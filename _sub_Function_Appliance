#!/bin/bash

### Package : _sub_Function_Appliance

### Comming from reference of pythonmodule jellyfish:
### with matching rating-codex of Infrastructure
### jellyfish.match_rating_codex(u'Infrastructure')
### give Infctr
### While same module to short Name like 
### General        ->  Gnrl
### Parser         ->  Prsr
### Infrastructure ->  Infctr
### To make this function called GnrlPrsrInfctr for a really 
### short Name which telling more... 
 
### function GeneralParserInfctr 
### Is not actually ready in design plan it only miss couple of verification
### before pushing it to version 0.0.2 . It's sure if you start LibLoader ( 
### with _sub_Function_Appliance inside the ArrayLib and adding to the command 
### line versionGPI=0.0.2 it will parse this but this function is not ready 
### to proove how pushing variable from command-prompt and Feeding the Parser with 
### GDITagFeeder help the Parser to parser variable from prompt and declaration 
### of relation of variable+__TAG__ to acheive a Generalistic Case of function
### wrapper to have a applied firter to a function to get a speciffic result. 
### 
### Missing, 
###  - Loging inside UUID, 
###  - Executing the Evaluation and inject the variable result inside current code
###  so we can be ready to use the Value . We do have GDIDpkgTpl for template-future
###  command line and StrCmd from GDITagParserResult, it evaluate the GDIDpkgTpl result
### but haven't specified where to execute it... Initially inside the function but all
### the returned event are simply displayed and not keeped. 
###  - Many more precautions and tests. 
### 

if [ ${versionGPI:=0.0.2} == "0.0.2" ] ; then 
 
 unset GnrlPrsrInfctr; 
 function GnrlPrsrInfctr()
 {
  ### This is a specialized Verbosis mode :
  ###  
  ###  All condition required to set VerbState=True 
  ###  All condition required to set a message with VerbMsg=STRING
  ###  
  ###  
  ### It can be used to :
  ###  - Echo result to be passed throught Value Result .
  ###  Required :
  ###  VerbEvalForm=True VerbFormated=False 
  ###  
  ###  VerbHeader Is ineffective
  ###  
  ### -Echo result can be append to file and not overwriting the content: 
  ###  Required ;
  ###  VerbFormated=False/True VerbAppendDev=True VerbDev=[ FILENAME | UUID ]
  ###  - Appending to file also required to be unique-file were no instance of 
  ###  Verbosis may point on same-file or loss of log will be CERTAIN.
  ###  -Pointing to Same-Destination require a lock Mechanism which is 
  ###  not implemented here
  ###  
  function Verbosis()
  {
   #eval $( CAFunctName=Verbosis CAIsAddParent=False __Call_Argument ) ; 
   local -a ArrayArg=( $* ) ; 
   local -a __call_locality=( Verb Verbosis )
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
        echo "${StrMsg}" ;  
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo "${StrMsg}" >> ${StrDevOut} ;
      else
       echo "${StrMsg}" > ${StrDevOut} ;
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
  
  if [ "${versionCA:=0.0.0}" == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( GPI GnrlPrsrInfctr ) ;
   local Arg0="${ArrayArg[0]}";  
   local StrStartMain=${GPIFuncStart:=__main_StartServices} ; 
   local StrParentApps=${__call_locality[1]} ; 
  elif [ "${versionCA:=0.0.0}" == "0.0.1" ] ; then 
   eval $( eval CAFunctName=GnrlPrsrInfctr CAIsAddParent=False __Call_Argument ) ; 
  elif [ "${versionCA:=0.0.0}" == "0.0.2" ] ; then 
   eval $( eval CAFunctName=GnrlPrsrInfctr CAIsAddParent=False CallArgument ) ; 
  fi
  ### This is an evaluation test GnrlPrsrInfctr, for having installing extras
  ### package toward Zenity-Dbus problem and after a reboot, the evaluation 
  ### start to flaw and solution like echo inside an eval is not quite acceptable:
  ### solution offert : write like an echo evaluation where it is already going
  ### out from an echo: eval $( echo "CAFunctName=GnrlPrsrInfctr 
  ### CAIsAddParent=False __Call_Argument" ) ; So I withdraw package from last 
  ### download and imply testing both version __Call_Argument versionGPI==0.0.1
  ### and CallArgument versionGPI==0.0.2, and may come to a conclusion function 
  ### starting with _Prefix or __Prefix may be blind to evaluation and report 
  ### being absent, which is probably a policy-kit altering the code.

  #local __call_locality=( GPI GnrlPrsrInfctr ) ;
  #local ArrayArg=( $* ) ;
  #local Arg0=( ${ArrayArg[0]} ) ; 
  
  ### General to GnrlPrsrInfctr Command Parser and depot. 
  local StrAppsTemplate=${GPITpl:=__APPS__ __APPS_OPT__ __PIPE__ __FILTER__ __FILTER_OPT__} ;
  local StrApps=${GPIApps:=/usr/bin/dpkg} ;
  local StrAppsOpt=${GPIAppsOpt:=--get-selections} ; 
  local StrFilterApps=${GPIFilterApps:=/usr/bin/gawk} ;
  local StrFileName=${GPIFileName:=None} ;
  local StrFilterOpt=${GPIFilterOpt:=-f __FILE__} ; 
  local StrParserTag=${GPITagParser:=StrDefaultPipe:__PIPE__,StrApps:__APPS__,StrAppsOpt:__APPS_OPT__,StrFilterApps:__FILTER__,StrFilterOpt:__FILTER_OPT__,StrFileName:__FILE__}
  local StrTagFeeder=${GPITagFeeder:=''} ;
  local StrParserResult=${GPITagParserResult:=StrCmd} ; 
  local StrUUIDTransmit=${GPITUUIDName:=UUID} ; 
  local StrDefaultPipe=${GPIPipeSig:=\|} ;
  local StrDefaultVerbose=${GPIVerboseDev:=/dev/stderr} ; 
  local IntFontSize=${GPIFontSize:=10} ; 
  local StrUUIDInstance ;
  local StrFileOutput=${GPIOutFile:=.GnrlPrsrInfctr} ; 
  local BoolDisplayDebug=${GPIDisplayDebug:=False} ; 
  local BoolEmitUUID=${GPIIsUUIDInstance:=False} ; 
  local BoolGenerateCode=${GPIIsGenerateCode:=False} ; 
  local BoolOutToZenity=${GPIIsZenityHandlerOut:=False} ;
  local BoolOutToFile=${GPIIsFileHandlerOut:=False} ; 
  local BoolExecuteEval=${GPIIsExecuteEval:=True} ; 

  ### General To RepositoryCreation
  local BoolRepoCreaEnabled=${GPIRepoCreatEnabled:=True} ; 
  local BoolDisplayParserDebug=${GPIParserDebug:=False} ;
  local BoolCreateRepository=${GPIRepositoryCreation:=False} ; 
  local StrTagRepoMkdir=${GPIParserMkdir:=StrAppsSudo:__SUDO__,StrAppsSudoOpt:__OPT__,StrAppsMkdir:__APPS__,StrRepositoryQuery:__PATH__,StrAppsMkdirOpt:__APPS_OPTS__} ;
  local StrTagRepoChmod=${GPIParserChmod:=StrAppsSudo:__SUDO__,StrAppsSudoOpt:__OPT__,StrAppsChmod:__APPS__,StrRepositoryQuery:__PATH__,StrDefaultPerm:__PERM__} ;
  local StrTagRepoChown=${GPIParserChown:=StrAppsSudo:__SUDO__,StrAppsSudoOpt:__OPT__,StrAppsChown:__APPS__,StrRepositoryQuery:__PATH__,StrDefaultUser:__OWNER__} ;
  local StrPrefixTagGroup=${GPIGroupParserPrefix:=StrTagRepo} ; 
  local -A ArrayTplAction ; 
  ### Fixed after reference : 472de1ad3899ab7a0aa52869a073c19c52178940
  ### Associative Array was declared with '-a' instead of '-A'
  local StrRepositoryQuery=${GPIQueryRepository:=/var/log/Fnct.D/GnrlPrsrInfctr} ;  
  local StrDefaultUser=${GPIRepoUser:=user.root} ;
  local StrDefaultPerm=${GPIRepoPerm:=775} ;  
  local StrAppsSudo=${GPIAppsSudo:=/usr/bin/sudo} ;
  local StrAppsSudoOpt=${GPIAppsSudoOpt:=-s -H} ;
  local StrAppsMkdir=${GPIAppsMkdir:=/bin/mkdir} ;
  local StrAppsMkdirOpt=${GPIAppsMkdirOpt:=-p} ;
  local StrAppsChown=${GPIChown:=/bin/chown} ;
  local StrAppsChmod=${GPIChmod:=/bin/chmod} ;
  #local StrParentApps=${__call_locality[1]} ;
  #local StrStartMain=${GPIFuncStart:=__main_StartServices} ;
  
  ### While GnrlPrsrInfctr is the only first Helper available, it provide a list of function
  ### where this provider have some internal action being usefull to re-use, example RepositoryCreation
  ### It's useless to export this variable it's mostly re-used by application Getter . 
  local UUIDHApps=${GPIAppsProvide:=RepositoryCreation} ; 
  
  
  ArrayMsg[0]="Prefixed Variable: __VAR__=__VALUE__\nThis is an assistant creating the Repository (location: __PATH__)\n.This is reserved to store your Query for future uses. Prepare to enter into\nCredential action to create the Repository. In case your haven't chooses Variable\n\tGPIRepoUser GPIRepoPerm\nto set your user(s)/Group accessing the repository or Permission to read and write,\nyou can stop the application and start over. If you haven't choose a Function Name\nfor this step it will pop-you a warning and stop the application." ;
  ArrayMsg[1]="Creation of PATH __PATH__, Right Attribution : __MODE__, Owner: __USER__" ;
  ArrayMsg[2]="__CMD__ " ;
  ArrayMsg[3]="Parsed CmdLine: __CMDLINE__" ;
  ArrayMsg[4]="Instance will use UUID reference: __UUID__"
  ArrayMsg[5]="Entry-Start : __FUNCT__"
  ArrayMsg[6]="__FUNCT__ version versionTP=__VER_TP__, versionCA=__VER_CA__, versionGPI=__VER_GPI__" ; 
  
  ArrayTplAction["Mkdir"]="__SUDO__ __OPT__ __APPS__ __APPS_OPTS__ __PATH__" ;  
  ArrayTplAction["Chmod"]="__SUDO__ __OPT__ __APPS__ __PERM__ __PATH__"   ;
  ArrayTplAction["Chown"]="__SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__"   ;
  local -a ArrayActionOrder=( "Mkdir" "Chmod" "Chown" ) ;
   
  local StrVarList="StrVarList,StrFileOutput,BoolOutToZenity,BoolOutToFile,StrTagFeeder,StrParentApps,BoolEmitUUID,StrParserResult,StrAwkScript,StrAppsTemplate,StrApps,StrAppsOpt,StrFilterApps,StrFilterOpt,StrParserTag,StrFileName,StrDefaultPipe,StrDefaultVerbose,StrTagRepoMkdir,StrTagRepoChmod,StrTagRepoChown,BoolRepoCreaEnabled,BoolDisplayParserDebug,StrRepositoryQuery,BoolCreateRepository,StrDefaultUser,StrDefaultPerm,StrAppsSudo,StrAppsSudoOpt,StrAppsMkdir,StrAppsChown,StrAppsChmod,StrStartMain,BoolExecuteEval,BoolGenerateCode,StrUUIDInstance,StrPrefixTagGroup,StrUUIDTransmit,IntFontSize" ; 
  
  ### Informations About uses of StrUUIDInstance vs. StrFileOutput  .
  ### 
  ### +---------------------------------------------------------------------------------------------------+ 
  ### |Specialized case, if it's UUID choice have been obtain from BoolEmitUUID                           |
  ### | we do storing inside {Repository}/{UUID} , if its not the case it's {GPIOutFile:=.GnrlPrsrInfctr} |
  ### | it can be everywhere                                                                              |
  ### +-+-------------------------------------------------------------------------------------------------+
  ###   |
  ### +-+----------------------------+
  ### | Box-Location-Of-Information  |
  ### |    < BoolEmitUUID >          |  is Reponsible to inform the application to :
  ### +-+-----|---|------------------+        
  ###   |     |   +TRUE -> Use the UUID Infrastructure and output on location {Repository}/{UUID} on need  
  ###   |     +FALSE    -> Use the local {GPIOutFile:=.GnrlPrsrInfctr} on need . 
  ###   | 
  ### +-+---------------------------------------------+ In case BoolExecuteEval==True ( same model is 
  ### |  Box-Output-The-Information                   | applied to BoolExecuteEval=False )
  ### | <BoolOutToZenity==True> <BoolOutToFile==True> |
  ### +--------+------------------+-------------------+   
  ###          |                  | 
  ###   <Attr:BoolEmitUUID>       +---<Attr:BoolEmitUUID>---For BoolEmitUUID==True
  ###      |   |                                 |          Information will be dumped inside
  ###      |   +For BoolEmitUUID==False          |          {Repository}/{UUID}
  ###      |    Zenity will look inside file     +---For BoolEmitUUID==False
  ###      |    {GPIOutFile:=.GnrlPrsrInfctr}        Information will be dumped inside
  ###      |                                         {GPIOutFile:=.GnrlPrsrInfctr}
  ###      +-----For BoolEmitUUID==True
  ###            Zenity will look inside file
  ###            {Repository}/{UUID} 
  ### 
  ### 
  ### 
  
  
  function RepositoryCreation()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( RC RepositoryCreation ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ;  
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=RepositoryCreation CAIsAddParent=True __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=RepositoryCreation CAIsAddParent=True CAIsChildBoot=False CallArgument ) ; 
   fi  
   #eval $( CAFunctName=RepositoryCreation CAIsAddParent=True __Call_Argument ) ; 
   #local __call_locality=( RC RepositoryCreation ${StrParentApps} ) ; 
   #local Arg0=${ArrayArg[0]} ; 
   #local ArrayArg=( $* ) ;
   local StrAction ; 
   if [ ! -d ${StrRepositoryQuery} ] ; then 
    StrMsg=$( ${StrParentApps} --get ArrayMsg[0] ) ;
    StrMsg=${StrMsg//__VALUE__/${BoolCreateRepository}} ; 
    StrMsg=${StrMsg//__VAR__/BoolCreateRepository} ; 
    StrMsg=${StrMsg//__PATH__/${StrRepositoryQuery}} ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
    
    StrMsg=$( ${StrParentApps} --get ArrayMsg[1] ) ;
    StrMsg=${StrMsg//__PATH__/${StrRepositoryQuery}} ;
    StrMsg=${StrMsg//__MODE__/${StrDefaultPerm}} ;
    StrMsg=${StrMsg//__USER__/${StrDefaultUser}} ;
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 

    ### The Array ArrayActionOrder is present to define an order . This order 
    ### result in getting numerical index from 1 .. N
    ### Getting information from ArrayActionOrder[@], provide 
    ### 3 differents index name, 
    ### 0 -> "Mkdir" 
    ### 1 -> "Chmod" 
    ### 2 -> "Chown"
    ### in Error observed inside error-fix.txt for reference : 472de1ad3899ab7a0aa52869a073c19c52178940
    ### is the StrAction is not changing at all after each loop and get only
    ### ArrayTplAction["Chown"] 
    ### 
    ### This mean : 
    ### calling application 
    ### GnrlPrsrInfctr --get ArrayTplAction['Mkdir']
    ###  --> __SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__
    ### GnrlPrsrInfctr --get ArrayTplAction['Chmod']
    ###  --> __SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__
    ### GnrlPrsrInfctr --get ArrayTplAction['Chown']
    ###  --> __SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__
    ### 
    ### Getting from First Application able to do this : ZenityBuildForm
    ### 
    ### ZenityBuildForm --get ArrayTplAction['Mkdir'] 
    ###  --> __SUDO__ __OPT__ __APPS__ __PATH__
    ### ZenityBuildForm --get ArrayTplAction['Chmod'] 
    ###  --> __SUDO__ __OPT__ __APPS__ __PERM__ __PATH__
    ### ZenityBuildForm --get ArrayTplAction['Chown']
    ###  --> __SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__
    ### 
    for IterActionName in $( ${StrParentApps} --get ArrayActionOrder[@] ) ; do 
     StrAction=$( ${StrParentApps} --get ArrayTplAction["${IterActionName}"] ) ; 
     StrArrayName="${StrPrefixTagGroup}" ;
     
     StrTagListVarName="${StrArrayName}${IterActionName}" ;
     eval "StrTagListVar=\${${StrTagListVarName}} ;" ; 
     StrMsg="Parser TAG-List Variable name : __TAGLIST__: Template:[ __ACTION__] : content: [ __CONTENT__ ]" ; 
     StrMsg=${StrMsg//__TAGLIST__/${StrTagListVarName}} ; 
     StrMsg=${StrMsg//__CONTENT__/${StrTagListVar}} ; 
     StrMsg=${StrMsg//__ACTION__/${StrAction}} ; 
     
     VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
     
     ### Double Evaluation of the command seem to work for TagParser. 
     ### I mean it worked for 2 days since I do to respawn it to 
     ### eval $( ... ) .
     eval  $( TPVarNameParsed="StrAction"                     \
             TPListTag=${StrTagListVar}                        \
             TPIsMatchRtoL=True                                \
             TPDisplayParserNotice=${BoolDisplayParserDebug}   \
             TPDisplayDebug=${BoolDisplayDebug}                \
             TPArrayName="Array${__call_locality[0]}Tag"       \
             TagParser ) ;
             
     StrMsg=$( ${StrParentApps} --get ArrayMsg[2] ) ;
     
     VerbMsg="${StrMsg//__CMD__/${StrAction}}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
     if [ "${BoolRepoCreaEnabled:=False}" == "True" ] ; then 
       eval """$( ${StrAction} )""" ;
     fi 
    done 

   fi 

  } 

  
  function ReportReference()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( RR ReportReference ${StrParentApps} ) ;
    local Arg0=${ArrayArg[0]} ;  
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=ReportReference CAIsAddParent=True __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=ReportReference CAIsAddParent=True CAIsChildBoot=False  CallArgument ) ; 
   fi   
   #eval $( CAFunctName=ReportReference CAIsAddParent=True __Call_Argument ) ; 
   #local __call_locality=( RR ReportReference ${StrParentApps} ) ;
   #local ArrayArg=( $* ) ;
   #local Arg0=${ArrayArg[0]};  
   local StrMsg ; 
   ### After moving the body of the if statement if if [ "${BoolExecuteEval}" == True...
   ### into a function. The query was tried again and confirm 
   ### BuildForm UUID:6e5b6d0c-890f-11e6-8b1d-001e4c8856d6 , was able to 
   ### publish the same information. 
   
   ### Execution Side
   ### Example : BuildForm UUID:6e5b6d0c-890f-11e6-8b1d-001e4c8856d6
   ### Should End here since this BuildForm imply  : refusing to generate code.
   ### don't dump it on file , on ZenityViewer like and also once executed it 
   ### transfert the content into na UUID into /var/log/GnrlPrsrInfctr/UUID because GPIIsUUIDInstance=TRue
   ### See path example/BuildForm/6e5b6d0c-890f-11e6-8b1d-001e4c8856d6 for parameter.
   ### Evaluation side to execte it inside called-funtion. 
   
   ### Default StrParserResult should Use variable name StrCmd to apply rules of parser to obtain
   ### 1. StrCmd=dpkg --get-selections | /usr/bin/gawk -f awk-script/dpkg-col-display.awk 
   ### 2 By calling ${StrCmd} it should execute itself and at least output the display on 
   ### screen . 
   
   ### We do have a limit to Pass StrUUIDTransmit, as long there is instance 
   ### in form UUID, or general file .GnrlPrsrInfctr i used. This is why the message
   ### is changing, and there is no evaluation in case BoolEmitUUID==False In the other
   ### case I  have neglected uses of UUID, it's not generated and ${StrFileOutput} 
   ### was probably assigned to .GnrlPrsrInfctr . 
   
   if [ "${BoolEmitUUID:=True}" == "True" ] ; then
    StrMsg="Query Executed, UUID-Variable Reference:[ __VAR_NAME__ ]" ;
    StrMsg=${StrMsg//__VAR_NAME__/${StrUUIDTransmit}} ; 
    eval ${StrUUIDTransmit}=${StrUUIDInstance} ;
   else
    StrMsg="Query Executed, No UUID used, Reference file:[ __FILE__ ]" ;
    StrMsg=${StrMsg//__FILE__/${StrFileOutput}} ;
   fi 
   VerbMsg="${StrMsg}"        \
   VerbDev=/dev/stderr        \
   VerbEvalForm=False         \
   VerbHeader="EXECUTE-${__call_locality[1]}" \
   VerbState=${BoolDisplayDebug}              \
   VerbFormated=True Verbosis ; 
   ### Allow the Command-prompt or after this function ending it's live to allow having 
   ### One way to recuperate the UUID-log. 
  
  }
    
  function ZenityHandlerOut()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( ZHO ZenityHandlerOut ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ;  
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=ZenityHandlerOut CAIsAddParent=True __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=ZenityHandlerOut CAIsAddParent=True CAIsChildBoot=False  CallArgument ) ; 
   fi   
   #eval $( CAFunctName=ZenityHandlerOut CAIsAddParent=True __Call_Argument ) ; 
   #local __call_locality=( ZHO ZenityHandlerOut ${StrParentApps} ) ;
   #local ArrayArg=( $* ) ;
   #local Arg0=${ArrayArg[0]};  
   local StrTplZenityTextInfo=${ZHOZenityTpl:="zenity --text-info --filename=__FILE__ --font=__FONT__ 2> /dev/null"} ; 
   
   ### After moving the body of the if statement if [ "${BoolOutToZenity:=False}" == "True"...
   ### into a function. The query was tried again and confirm 
   ### BuildForm UUID:bb7e1d60-899f-11e6-8b1d-001e4c8856d6 , was able to 
   ### publish the same information. 
   ### 
   ### Send-it to a file, Zenity will recuperate-it 
   ### Example : BuildForm UUID:bb7e1d60-899f-11e6-8b1d-001e4c8856d6
   ### Should End here since this BuildForm imply  : refusing to generate code.
   ### To view the result with Zenity Windows.
   ### Since Zenity can not really accept Stream from piped application action it
   ### requiert to dump it on file first. 
   ### Some extra Prefixed-Variable will be available to free-out the file after . 
   VerbMsg=$( eval eval "\${${StrParserResult}}" ) VerbDev=${StrDestinationResult} VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
   #VerbMsg="""\${${StrParserResult}}""" VerbDev=${StrDestinationResult} VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
   StrTplZenityTextInfo=${StrTplZenityTextInfo//__FILE__/${StrDestinationResult}} ; 
   StrTplZenityTextInfo=${StrTplZenityTextInfo//__FONT__/${IntFontSize}} ; 
   ### Should Lunch Zenity --text-info... 
   ${StrTplZenityTextInfo}  
  }  
  
  function ParserFunctionEval()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( PFE ParserFunctionEval ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ;  
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=ParserFunctionEval CAIsAddParent=True __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=ParserFunctionEval CAIsAddParent=True CAIsChildBoot=False  CallArgument ) ; 
   fi   
   ### Require Unusual Evaluation or evaluation not interpret this line like a 
   ### command line parsing . 
   #eval $( CAFunctName=ParserFunctionEval CAIsAddParent=True Call_Argument ) ; 
   #local __call_locality=( PFE ParserFunctionEval ${StrParentApps} ) ;
   #local ArrayArg=( $* ) ;
   #local Arg0=${ArrayArg[0]};  
   
   #eval $( CAFunctName=ParserFunctionEval CAIsAddParent=True __Call_Argument ) ; 
   
   
   ### This line does, Getting from Prefixed-Variable desired Variable to 
   ### to be generated like Variable=command
   ### and put the content of template and FeedParser .  
   eval "local ${StrParserResult}=\"${StrAppsTemplate} ${StrTagFeeder}\"" ;
   
   StrMsg="From variable __VAR__ Copy of StrAppsTemplate, named __VAR2__ will hold __CONTENT__" ; 
   StrMsg=${StrMsg//__VAR__/${StrParserResult}} ;
   eval """StrMsg=\${StrMsg//__CONTENT__/\${${StrParserResult}}}"""  ;
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbState=${BoolDisplayDebug} VerbFormated=True VerbDev=/dev/stderr Verbosis ; 
   
   eval $( eval \
     TPIsMatchRtoL=True                        \
     TPVarNameParsed="${StrParserResult}"      \
     TPDisplayDebug=${BoolDisplayDebug}        \
     TPDisplayParserNotice=${BoolDisplayParserDebug}  \
     TPArrayName=Array${__call_locality[0]}Tag \
     TPListTag="${StrParserTag}"               \
     TagParser ) ; 
   
   
   ### Notice if this line is called with ${StrParentApps} which suppose to 
   ### be the application GnrlPrsrInfctr --get ArrayMsg[3] <> ${StrParentApps} --get ArrayMsg[3] 
   ### it enter inside a loop and never end... the test consist to add before the StrMsg=...
   ### the echo line "Before getting ArrayMsg[3]" and right under to put an echo 
   ### line "After getting ArrayMsg[3]". On console you do never see the After getting ArrayMsg[3] !!!
   ### But this fixed with putting back the function name GnrlPrsrInfctr, work for versionCA=0.0.0 to 0.0.2
   ### but exceptionnally does it for versionCA=0.0.1 and versionCA=0.0.2 ???
   StrMsg=$( GnrlPrsrInfctr --get ArrayMsg[3] ) ;
   eval """StrMsg=\${StrMsg//__CMDLINE__/\${${StrParserResult}}}"""  ;
   VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbState=${BoolDisplayDebug} VerbFormated=True VerbHeader="${__call_locality[1]}-CMDLINE" Verbosis
   
   local StrFileResult="" ;
   local StrDestinationResult="" ; 
   if [ "${BoolEmitUUID:=True}" == "True" ] ; then
    StrFileResult="${StrUUIDInstance}" ; 
    StrDestinationResult="${StrRepositoryQuery}/${StrFileResult}" ;
   else 
    StrFileResult="${StrFileOutput}" ; 
    StrDestinationResult="${StrFileResult}"
   fi 
   
   
   
   ### Notice : Because we only allow One State at the time, Evualing the code or
   ### Executing the code the Prefixed-variable are ste by default to 
   ### GPIIsGenerateCode:=False + GPIIsExecuteEval:=True
   ### ---> This mean it prefer to execute the value and since all handler are all
   ### False There is more chance than It produce a stream of information on screen.
   ### Since GPIIsUUIDInstance is False by default it give twice the chance to have
   ### user decision having to read .GnrlPrsrInfctr for the content in case of 
   ### File-Handler is True. Idem for case of Window-Handler. The actual setup of
   ### if-elif give choice to Execute Eval to be the first test but case where 2 
   ### are false, there is nothing at the end and function should end without doing 
   ### something. it's probably important to set a Warning in case 2 Master decision 
   ### is false
   ### GPIIsGenerateCode ==False And GPIIsExecuteEval==False
   ### 
   ### In case where thoses 2 master variable are True, it's the BoolExecuteEval
   ### will be executed first because it's not a Select case where more than True
   ### value can flow across schema of Select. 
   
   if [ "${BoolExecuteEval:=True}" == "True" ] ; then
    eval $( eval VTVIsArrayStyleInsert=True \
             VTVValueEntry=${StrVarList},${StrParserResult},StrDestinationResult   \
             VTVIsValueReAssign=True       \
             VTVIsValueToConvert=False     \
             VTVIsQuotedValue=True         \
             VTVIsArrayStyleInsert=True    \
             ValueToVariable ) ReportReference ;    

    if [ "${BoolOutToZenity:=False}" == "True" ] ; then 
     eval $( eval VTVIsArrayStyleInsert=True \
              VTVValueEntry=${StrVarList},${StrParserResult},StrTplZenityTextInfo   \
              VTVIsValueReAssign=True       \
              VTVIsValueToConvert=False     \
              VTVIsQuotedValue=True         \
              VTVIsArrayStyleInsert=True    \
              ValueToVariable ) ZenityHandlerOut ;    
    elif [ "${BoolOutToFile:=False}" == "True" ] ; then 
     ### Send-it to a file. 
     ### No recuperation from tiers methods. 
     ### Scenario from BuildForm UUID:def9e256-8990-11e6-8b1d-001e4c8856d6
     ### At this stage, GPIIsExecuteEval=True 
     ###                GPIIsFileHandlerOut=True
     ### To avoid falling inside next elif-case where 2 Handler-Out( ToFile and ToZenity )
     ### to refuse collecting the result. 
     
     VerbMsg=$( eval eval "\${${StrParserResult}}" ) VerbDev=${StrDestinationResult} VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
     ### This case execute and send it to file which is different from it's brotherhood 
     ### of evaluating the code where the code should at least get out of the fuction and 
     ### logging is used on demand, where 2 method here exist to execute the code and 
     ### suggest to keep the code from elif BoolOutToFile == False AND BoolOutToZenity == False  
     
    elif [ "${BoolOutToFile:=False}" == "False" -a "${BoolOutToZenity:=False}" == "False" ]  ; then 
     eval eval "\${${StrParserResult}}"  
     ### This scenario from Executing only the query and not provide handler to see the content, 
     ### to have not Handler like file handler (.GnrlPrsrInfctr or UUID depot) is part of the query 
     ### BuildForm UUID:6e5b6d0c-890f-11e6-8b1d-001e4c8856d6

     ### Display the Evaluation on /dev/stderr 
     #VerbMsg="""\${${StrParserResult}}""" VerbDev=/dev/stderr VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
     #eval ${StrUUIDTransmit}=${StrUUIDInstance} ;
     #eval eval "\${${StrParserResult}}" > ${StrDestinationResult} ; 
       
    fi
     
   elif [ "${BoolGenerateCode:=False}" == "True" ] ; then 
    ### ReportReference Must display proper message where is the Specified file
    ### to hold the result. 
    ### Also Generate the Variable required to hold the query ready to execute. 
    eval $( eval VTVIsArrayStyleInsert=True \
          VTVValueEntry=${StrVarList},${StrParserResult},StrDestinationResult   \
          VTVIsValueReAssign=True       \
          VTVIsQuotedValue=True         \
          VTVIsValueToConvert=False     \
          VTVIsArrayStyleInsert=True    \
          ValueToVariable ) ReportReference ; 
    
    ### Does create ${StrCmd} uselessly .... 
    ### VerbMsg="""\${${StrParserResult}}""" VerbEvalForm=True VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
    
    ### I admit it's not a profit gain for log-repository to store volume of 
    ### informations,and it' probably once we do generated code we can asking 
    ### was generated and can we see back the information. So Test of the 
    ### handler-out are also important here. 
    ###   
    ###    Genration/Exec Tree Possibility . 
    ###    
    ###    
    ###                      Content of code generated 
    ###                   /+ will go in file
    ###    Output        /   
    ###    Generation-------+Both are False, it's not reported 
    ###                  \
    ###                   \+ Content of code generated  
    ###                      will go inside windows 
    ###                      called Zenity
    ###    
    ###                      Content of Execution
    ###                   /+ will go in file  
    ###    Output        /   
    ###    Execution ---------------------------------+Both are False, it's not reported ( and case neglected because 
    ###                  \                             if-elif-elif structure suggest if there is no variable handled 
    ###                   \+ Content of Execution      BoolOutToZenity & BoolOutToFile it won't fall in inapropritate choice. 
    ###                      will go inside windows 
    ###                      called Zenity
    ###    
    ###    
    ###    
    
    ### Responsible to Throw the command line on to launch it or display it 
    ### like an echo . The procedure include fall inside BoolGenerateCode ==True
    ### 1 - MUST generate code for evaluation ... 
    ### 2 - depending of a condition BoolOutToZenity==True or BoolOutToFile==True
    ### it dump the log confirmation of executed text in a zenity Windows or 
    ### File. 
    eval VerbMsg="\${${StrParserResult}}" VerbEvalForm=True VerbHeader="" VerbState=True VerbFormated=False VerbDev=/dev/stderr  Verbosis ; 
    
    if [ "${BoolOutToZenity:=False}" == "True" ] ; then
     local StrTplZenityTextInfo=${ZHOZenityTpl:="zenity --text-info --filename=__FILE__ --font=__FONT__ 2> /dev/null"} ; 
     eval VerbMsg="\${${StrParserResult}}" VerbDev=${StrDestinationResult} VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
     StrTplZenityTextInfo=${StrTplZenityTextInfo//__FILE__/${StrDestinationResult}} ; 
     StrTplZenityTextInfo=${StrTplZenityTextInfo//__FONT__/${IntFontSize}} ; 
     ### Should Lunch Zenity --text-info... 
     ${StrTplZenityTextInfo} ; 
     
     #VerbMsg=$( eval "\${${StrParserResult}}" ) VerbEvalForm=True VerbHeader="" VerbState=True VerbFormated=False Verbosis ;  
     #VerbDev=${StrDestinationResult} 
    elif [ "${BoolOutToFile:=False}" == "True" ] ; then 
     eval VerbMsg="\${${StrParserResult}}" VerbDev=${StrDestinationResult} VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False  Verbosis ; 
    
    ### Suggested to eliminate this case .  
    #elif [ "${BoolOutToFile:=False}" == "False" -a "${BoolOutToZenity:=False}" == "False" ]  ; then 
    # eval VerbMsg="\${${StrParserResult}}" VerbDev=/dev/stderr VerbEvalForm=True VerbHeader="" VerbState=${BoolDisplayDebug} VerbFormated=False  Verbosis ; 
     
    fi
   fi   
  }

  
  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}";  
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CAIsChildBoot=False  CallArgument ) ; 
   fi   
   #eval $( CAUsingSedTrim=False CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ; 
   #local __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
   #local ArrayArg=( $* ) ;
   #local Arg0=${ArrayArg[0]};  
   
   #local StrCmd=${StrAppsTemplate}
   
   
   ### Generic Infrastructure coming from ZenityBuildForm, have proof of it's success
   ### we do assume it's simlpe to port-it inside GnrlPrsrInfctr . 
   if [ ${BoolCreateRepository:=False} == "True" ] ; then
    if [ ! -d ${StrRepositoryQuery} ] ; then 
     eval $( eval VTVIsArrayStyleInsert=True \
         VTVValueEntry=${StrVarList}   \
         VTVIsQuotedValue=True         \
         VTVIsValueReAssign=True       \
         VTVIsValueToConvert=False     \
         VTVIsArrayStyleInsert=True    \
         ValueToVariable ) RepositoryCreation ;
    fi
   fi   
    
    eval $( eval VTVIsArrayStyleInsert=True \
        VTVValueEntry=${StrVarList},StrCmd   \
        VTVIsQuotedValue=True         \
        VTVIsValueReAssign=True       \
        VTVIsValueToConvert=False     \
        VTVIsArrayStyleInsert=True    \
        ValueToVariable ) ParserFunctionEval ;
   
   ### 
  
  } 
  
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  local StrNameHelper="GnrlPrsrInfctr\tStand for General-Parser-Infrastructure ; The Fnct.D Mechanism Parsing single function call or piped function and even multi-piped function with conjunction of TagParser. ";
  local StrSummary="This TagParser for single function, piped-function and Nth-piped function is coming with Repository to log result from GnrlPrsrInfctr and Parser engine is equiped of a ParserFeeder to append Variable And Tag to know GDITagParser. The main goal of this Function is to profit from Entry of variable from command-line entry and to use extra TAG binded to Variable-name added to let it parse the rest of the information and thus will be explained." ; 
  local StrSynopsis="Soon to fill it with lot of informations";
  local StrDescription="Having surdose of informations, skip this part..." ;
  
  
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GVRIsName=True GVRIsSynopsis=True GVRIsSummary=True GVRIsDesc=True GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( __GetVarReferenceList ) ;	
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
   StrMsg=${ArrayMsg[6]} ; 
   StrMsg=${StrMsg//__FUNCT__/${__call_locality[1]}} ; 
   StrMsg=${StrMsg//__VER_CA__/${versionCA}} ; 
   StrMsg=${StrMsg//__VER_TP__/${versionTP}} ; 
   StrMsg=${StrMsg//__VER_GPI__/${versionGPI}} ; 
   VerbMsg="${StrMsg}" VerbHeader="VERSION" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
   if [ "${BoolEmitUUID:=True}" == "True" ] ; then 
    StrUUIDInstance=$( GetUTimeBased=True GetUSeq=1 GetUIDRegister=True GetUAppsRegisterName=GnrlPrsrInfctr GetUUID ) ; 
    StrMsg=${ArrayMsg[4]} ; 
    StrMsg=${StrMsg//__UUID__/${StrUUIDInstance}} ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
   fi 
   StrMsg=${ArrayMsg[5]}; 
   StrMsg=${StrMsg//__FUNCT__/${StrStartMain}}
   VerbMsg="${StrMsg}" VerbEvalForm=False VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayDebug} VerbFormated=True VerbDevOut=/dev/stderr Verbosis ; 
   
   eval $( eval VTVIsArrayStyleInsert=True  \
                VTVValueEntry=${StrVarList} \
                VTVIsQuotedValue=True       \
                VTVIsValueReAssign=True     \
                VTVIsValueToConvert=False   \
                ValueToVariable ) ${StrStartMain}
  fi
 }


fi

### function LoopShellScript 

### Is not actually ready in design plan it only miss couple of function like 
### DataExtractionTool which requiert to extract compressed file and transcoded 
### in base64 to hold on the same line of SHA1SUM, before pushing it to version 
### 0.0.2

### In General:
### 
### This application is perfect for compiling kernel or package, it was designed
### by creating a shell-script holding the configure __OPT__ && make clean && make  
### where __OPT__ stand for all CFLAGS, LDFLAGS and option from configure with 
### ---enable-..., --with-... it run the file after you save it and if the compilation
### or the return statement is OK, it store Your file as-is inside a file-storage
### compressed where function like DataExtractionTool should revert the compressed 
### information into a working script, ready to repeat the operation before you
### have changed thing you did not have idea or did not note it. It's also perfect 
### for template compilation (C++ templating) who require severe ajustement from 
### compiler notice in bjam-file can be inserted in a script where the bjam-file 
### can be generated by the script and saving the script is a clever and 
### conventionnal way to save space and information at once. 
### 
### This script also comming with a --stopservices switche where after specifying 
### the UUID instance inside prefixed-variable LSSUUIDInstance or Unified UUID
### reserved prefixed-variable UUID, it will terminate the execution-loop  
### This method can also allow starting multiple instance at once . Later a 
### ZenityStopServices can be explain to filter application from same family
### and not using DoCtrlHandler / ActivatSeServerBuffer which depend from their
### own methodology .
### 
### example : 
### >>> To stop a running instance called 25d4a256-9c1a-11e6-8b1d-001e4c8856d6 
### you can call it like : 
### 
### UUID=25d4a256-9c1a-11e6-8b1d-001e4c8856d6 LoopShellScript --stopservices
### or 
### LSSUUIDInstance=25d4a256-9c1a-11e6-8b1d-001e4c8856d6 LoopShellScript --stopservices
### 


if [ ${versionLSS:=0.0.1} == "0.0.1" ] ; then 

 eval $( GFCFuncName=LSSServices GlobalFunctionCleaning ) ; 
 #unset LSSServices ; 
 
 function LSSServices()
 {
  function Verbosis()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Verb Verbosis ) ; 
   local Arg0=${ArrayArg[0]} ; 
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local IsExtendedOutput=${VerbExtendedOut:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
      if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" ;  
      else
        echo "${StrMsg}" ;  
      fi
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" >> ${StrDevOut} ;
       else
         echo "${StrMsg}" >> ${StrDevOut} ;
       fi
      else
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" > ${StrDevOut} ;
       else
        echo "${StrMsg}" > ${StrDevOut} ;
       fi 
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( LSSS LSSServices ) ;
   local Arg0="${ArrayArg[0]}" ; 
   local StrParentApps=${__call_locality[1]} ;
   local StrStartMain=${LSSFuncStart:=__main_StartServices} ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=LSSServices CAIsAddParent=False __Call_Argument ) ; 
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=LSSServices CAIsAddParent=False CallArgument ) ;
  fi  
     
  local StrPathLoopState=${LSSSInstancePath:=/var/cache/Fnct.D} ;  
  local StrDefaultShortName=${LSSShortNameFunc:=LSS} ; 
  local StrTextZenityEmpty="""<span font_family=\"monospace\" size=\"large\">List of LoopShellScript is empty</span>""" ;
  local StrTextZenityList="""Select UUID instance to Shutdown""" ; 
  local StrUUID="" ; 
  local StrVarList="StrPathLoopState,StrTextZenityEmpty,StrTextZenityList,StrDefaultShortName" ;
  
  local -a ArrayMsg ;
  
  ArrayMsg[0]="Entry in function" ;   
  
  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
   fi 
   StrMsg=$( LoopShellScript --get ArrayMsg[0] ) ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
   local IntGrepResult=$( find ${StrPathLoopState} -maxdepth 1 -type f -iname "Loop-${StrDefaultShortName}*" | egrep -ic "[a-fA-F0-9]*-[a-fA-F0-9]*-[a-fA-F0-9]*-[a-fA-F0-9]*-[a-fA-F0-9]*" ) ; 
   
   local StrZenityListUUID=$( find ${StrPathLoopState} -maxdepth 1 -type f -iname "Loop-${StrDefaultShortName}*" -printf "FALSE %f\n" | sed 's/-/ /g' | cut -d ' ' -f 1,4-8 | sed 's/ /-/g;s/FALSE-/FALSE /g' | tr '[:cntrl:]' ' '  ) ; 
   
   StrMsg="Element(s) inside StrZenityListUUID:( __STR__) Detected Item: __INT__" ;
   StrMsg=${StrMsg//__STR__/${StrZenityListUUID}} ;
   StrMsg=${StrMsg//__INT__/${IntGrepResult}} ;
   
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   local IntLenZenityList=${#StrZenityListUUID}
   ### IntLenZenityList is size of all UUID file, and minimal form is 
   ### "FALSE XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX" 43 chars long
   if [ ${IntGrepResult:=0} -gt 0 ] ; then 
    local ArrayServicesStop=( $( zenity --width=400 --height=400 --list --text="${StrTextZenityList}" --column="Selection" --column="UUID Instance" --separator=' ' --checklist --multiple  ${StrZenityListUUID} ) ) ; 
    local IntCountID=${#ArrayServicesStop[@]} ; 
    
    StrMsg="Nb Element inside ArrayServicesStop: __INT__" ;
    StrMsg=${StrMsg//__INT__/${#ArrayServicesStop[@]}} 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    if [ ${IntCountID:=0} -gt 0 ] ; then 
     for (( intx=0 ; intx <= ${IntCountID}-1 ; intx++ )) ; do 
      StrUUID=${ArrayServicesStop[${intx}]} ; 
      UUID=${StrUUID} LSSShortNameFunc=${StrDefaultShortName}  LoopShellScript --stopservices ;
     done 
    fi 
   else
    zenity --info --text="${StrTextZenityEmpty}" ; 
   fi 
  }
  function __main_StopServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StopServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
   fi 
   StrMsg="Entry in function" ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
  }
      
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  local StrNameHelper="${__call_locality[1]}\tAn application to manage LoopShellScript instance.";
  local StrSummary="This application does survey your LoopShellScript Instance By UUID, Selecting the UUID instance from Zenity List will terminate the application." ; 
  local StrSynopsis="This application is also perfect to clean residual instance from LoopShellScript terminated interrupted or aged.";
  local StrDescription="Not finished yet." ;
  
   
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GVRIsName=True     \
   GVRIsSummary=True  \
   GVRIsSynopsis=True \
   GVRIsDesc=True     \
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( __GetVarReferenceList ) ;	
  elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
   eval $( eval \
     VTVIsArrayStyleInsert=True  \
     VTVValueEntry=${StrVarList} \
     VTVIsValueReAssign=True     \
     VTVIsValueToConvert=False   \
     VTVIsWhiteList=True         \
     VTVWhiteListTransfert=UUID  \
     ValueToVariable ) __main_StopServices ; 
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
   # eval $( eval VersionApps ) ; 
   StrMsg=$( LoopShellScript --get ArrayMsg[0] ) ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   eval $( eval \
     VTVIsArrayStyleInsert=True  \
     VTVValueEntry=${StrVarList} \
     VTVIsValueReAssign=True     \
     VTVIsValueToConvert=False   \
     ValueToVariable ) ${StrStartMain}
  fi   
 }
 
 #unset Verbosis GetSha1Sum GetFileFormatCmd FileDeCapsulation DataExtractionTool SearchByFile SearchDate SearchId ListFile FileWriterSupport ShellControlServices VersionApps __main_StopServices __main_StartServices ; 
 
 eval $( GFCFuncName=LoopShellScript GlobalFunctionCleaning ) ; 

 function LoopShellScript()
 {
  function Verbosis()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Verb Verbosis ) ; 
   local Arg0=${ArrayArg[0]} ; 
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local IsExtendedOutput=${VerbExtendedOut:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
      if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" ;  
      else
        echo "${StrMsg}" ;  
      fi
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" >> ${StrDevOut} ;
       else
         echo "${StrMsg}" >> ${StrDevOut} ;
       fi
      else
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" > ${StrDevOut} ;
       else
        echo "${StrMsg}" > ${StrDevOut} ;
       fi 
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis

   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( LSS LoopShellScript ) ;
    local Arg0="${ArrayArg[0]}" ; 
    local StrParentApps=${__call_locality[1]} ;
    local StrStartMain=${LSSFuncStart:=__main_StartServices} ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=LoopShellScript CAIsAddParent=False __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=LoopShellScript CAIsAddParent=False CallArgument ) ;
   fi  
  
   local StrStartFile=${LSSFileName:=start-configure.sh} ; 
   local StrStoreResult=${LSSFileStorage:=.LoopShellScript} ; 
   local StrCertFileApps=${LSSFileCert:=/usr/bin/sha1sum} ; 
   local StrLockFileId=${LSSFileStorageLock:=/var/cache/Fnct.D/Lock-LSS} ;
   local StrDateFormat=${LSSDateFormat:='%Y%m%d-%H:%M:%S'} ; 
   local StrDefaultShortName=${LSSShortNameFunc:=LSS} ; 
   local StrPathLoopState=${LSSLoopFile:=/var/cache/Fnct.D/Loop-__SHORTFUNC__-__UUID__} ; 
   local StrUUIDInstance=${LSSUUIDInstance:=Last-instance-UUID};
   local StrDefaultFileFormat=${LSSFileFormat:=BZIP2+BASE64} ;
   local BoolIsScriptRun=${LSSIsScriptFile:=True} ; 
   local StrFileAlterateVrf=${LSSNonScriptValidator:=/usr/bin/file} ;
   local BoolLoopScriptOnState=${LSSIsLoopOnErrorType:=False} ;
   local IntDefaultErrorStateLoop=${LSSLoopOnError:=2} ; 
   local IntMaxLoopOnError=${LSSMaxLoopOnError:=5} 
   local BoolIsLockFile=${LSSIsLockFile:=False} ; 
   local BoolIsExtraction=${LSSIsExtraction:=False} ; 
   local BoolListFile=${LSSIsListID:=False} ;
   local BoolSearchId=${LSSIsSearchID:=False} ;  
   local BoolSearchDate=${LSSIsSearchDate:=False} ; 
   local BoolSearchFile=${LSSIsSearchFile:=False} ; 
   local BoolSortByDate=${LSSIsSortByDate:=False} ; 
   local StrSearchQuery=${LSSSearchQuery:=None} ;  
   local StrShaSumExtract=${LSSSHAIndexExtract:=None} ; 
   local BoolImportStoreResult=${LSSIsImportStoreResult:=False} ; 
   local BoolHideAppsDebug=${LSSIsHideScriptOutput:=False} ; 
   local BoolDisplayDebug=${LSSIsDisplayDebug:=False} ; 
   local BoolDisplayIf=${LSSIsDisplayIfDebug:=False} ; 
   
   local StrApps=${LSSApps:=bzip2} ;
   local StrAppsCmprOpt=${LSSAppsCmprOpt:='-9c'} ;
   local StrAppsDeCmprOpt=${LSSAppsDeCmprOpt:='-dc'} ;
   local StrFilter=${LSSFilter:=base64} ; 
   local StrFilterCmprOpt=${LSSFilterCmprOpt:='--wrap=0'} ;
   local StrFilterDeCmprOpt=${LSSFilterDeCmprOpt:=-d} ;
   local StrPipeCmd=${LSSDefaultPipe:='|'} ; 
   local StrTagParser=${LSSTagParserDef:=StrPipeCmd:__PIPE__,StrFilterDeCmprOpt:__FILTER_DECR_OPT__,StrApps:__APPS__,StrAppsCmprOpt:__APPS_CMPR_OPT__,StrAppsDeCmprOpt:__APPS_DECR_OPT__,StrFilter:__FILTER__,StrFilterCmprOpt:__FILTER_CMPR_OPT__} ; 
   local StrCompressionTpl=${LSSCmprTag:=__APPS__ __APPS_CMPR_OPT__ __PIPE__ __FILTER__ __FILTER_CMPR_OPT__} ;
   local StrDeCompressionTpl=${LSSDeCmprTag:=__FILTER__ __FILTER_DECR_OPT__ __PIPE__ __APPS__ __APPS_DECR_OPT__} ;

   ### Common to DataExtractionTool function
   local StrDetApps=${LSSDETApps:=/bin/egrep} ;
   local StrDetAppsOpt=${LSSDETFAppsOpt:=-i __FILE__ __QUERY__} ;
   local StrDetFilter=${LSSDETFilter:=/usr/bin/cut} ;
   local StrDetFilterOpt=${LSSDETFilterOpt:=-d \' \' -f __RANK__} ;
   local StrDetSort=${LSSDETSort:=/bin/sort} ;
   local StrDetSortOpt=${LSSDETSortOpt:=-k1} ;
   local StrDetRankDisplay=${LSSDETColDisplay:=1,2,3} ; 
      
   ### A short-cut to call uniformely an UUID used by this Application. 
   local UUID=${UUID:=${StrUUIDInstance}} ; 
   local StrTemplateShaStorage="__DATE__ __SHA__ __FILENAME__ __FORMAT__ __FILECONTENT__" ;
   
   local StrVarList="BoolSortByDate,BoolImportStoreResult,BoolLoopScriptOnState,IntDefaultErrorStateLoop,IntMaxLoopOnError,BoolIsScriptRun,StrFileAlterateVrf,BoolIsLockFile,StrLockFileId,BoolDisplayIf,BoolSearchId,BoolSearchDate,StrSearchQuery,BoolSearchFile,BoolListFile,BoolHideAppsDebug,StrVarList,StrStartFile,StrStoreResult,StrDateFormat,StrPathLoopState,StrUUIDInstance,StrTemplateShaStorage,StrDefaultFileFormat,StrShaSumExtract,BoolIsExtraction,StrApps,StrAppsCmprOpt,StrAppsDeCmprOpt,StrFilter,StrFilterCmprOpt,StrFilterDeCmprOpt,StrTagParser,StrCompressionTpl,StrDeCompressionTpl,StrDefaultShortName,StrDetApps,StrDetAppsOpt,StrDetFilter,StrDetFilterOpt,StrDetSort,StrDetSortOpt,StrDetRankDisplay,StrCertFileApps"

   local -a ArrayMsg=() ;
   ArrayMsg[0]="Entry in function" ; 
   ArrayMsg[1]="Codec Problem, current configured Codec:(__CODEC1__) is not stored Codec:(__CODEC2__), you must specify a correct codec to extract this file." ; 
   ArrayMsg[2]="Complete If Statement from __FUNCT__:__VAR__" ; 
   ArrayMsg[3]="De-Compression Codec: __CODEC__\nCommand : __CMD__\nSearching for SHA1SUM ID:__SHASUMID__ in file __FILE__" ; 
   ArrayMsg[4]="Add command-directive, SHA1SUM:__CURRSHA__, status: __STOREDSHA__" ; 
   ArrayMsg[5]="Shell-Script Item information:__CURRSHA__, __STOREDSHA__" ; 
   ArrayMsg[6]="Shell-Script returned state: __RET__" ; 
   ArrayMsg[7]="Shell-Script classified:__CURRSHA__,\n\tdon't required to start over." ; 
   ArrayMsg[8]="\nDate:__DATE__\nUUID-Instance:__UUID__\n" ; 
   ArrayMsg[9]="Shell-scripts directive result:" ; 
   ArrayMsg[10]="Shell-Script SHA1SUM:__CURRSHA__, result: __STOREDSHA__" ; 
   ArrayMsg[11]="\n------------------------------------------------------------------------\n\n" ; 
   ArrayMsg[12]="Stream Information: __TYPEACTION__" ; 
   ArrayMsg[13]="Template used: __TPL__" ; 
   ArrayMsg[14]="Value StrTagParser: __VAR__" ; 
   ArrayMsg[15]="Listing by FileName\nDate:\t\tSHA1SUM\t\t\t\t\tFileName\n" ; 
   ArrayMsg[16]="Searching by Date\nDate\t\t\tSHA1SUM\t\t\t\t\tFileName\n" ; 
   ArrayMsg[17]="Searching by ID\nDate:\t\tSHA1SUM\t\t\t\t\tFileName\n" ; 
   ArrayMsg[18]="Listing ID and FileName\nDate:\t\tSHA1SUM\t\t\t\t\tFileName\n\n" ; 
   ArrayMsg[19]="Compression Header:__VAR__" ; 
   ArrayMsg[20]="Compression :( cat __FILE__ | __STREAMCMD__ )" ; 
   ArrayMsg[21]="Execute Script Step __STEP__ of __STEPMAX__" ;
   ArrayMsg[22]="!!! Warning IsLoopOnErrorType is Activated And require to know the ErrorLevel or your script !!!\n\tIsLoopOnErrorType is Activated, and Will loop by detecting ErrorLevel=__INT__ and will loop __LOOP__ time(s) to certify this problem." ;
   ArrayMsg[23]="Evaluated Command: __CMD__" ; 
   
   function GetSha1Sum()
   {
    ${GS1SApps} ${GS1SFile} | /usr/bin/cut -d ' ' -f 1 ; 
   } 

   function GetFileFormatCmd( )
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( GFFC GetFileFormatCmd ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=GetFileFormatCmd CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=GetFileFormatCmd CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
    fi  
    StrMsg=$( LoopShellScript --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

    local StrEncapsulationMeth="" ;
    local StrFileFormatMeth="" ; 
    local StrTplTagParser="" ; 
    local StrMsg="" ; 
    local StrTypeAction="Compression" ; 
    if [ "${BoolIsExtraction:=False}" == "True" ] ; then 
     ### The application is in decompression mode
     ### I do retreive the encapsulation first 
     ### Working with String-Substitution , retreiving the 
     ### encapsulation from last-elements running 
     ### ${/#__METHOD_REGEXP____CSV__} will retreive
     ### the Encapsulation, reducing the string with the 
     ### answer should give us minimal condition. 
     StrTypeAction="De-Compression" ; 
     StrTplTagParser=${StrDeCompressionTpl} ;
     StrEncapsulationMeth=${StrDefaultFileFormat/#[A-Za-z0-9]*+} ;
     StrFileFormatMeth=${StrDefaultFileFormat/%+${StrEncapsulationMeth}} ; 
    else
     ### The application is in compression mode 
     ### I do retreive the Compression method first 
     ### allowing compression of the result and retreive 
     ### the encapsulation, so Parsing the StrDefaultFileFormat
     ### will start from the end to the beginning, 
     StrTplTagParser=${StrCompressionTpl} ;
     StrFileFormatMeth=${StrDefaultFileFormat/%+[A-Za-z0-9]*} ; 
     StrEncapsulationMeth=${StrDefaultFileFormat/#${StrFileFormatMeth}+} ;
    fi 

    StrMsg=$( LoopShellScript --get ArrayMsg[12] ) ;
    StrMsg="Stream Information: __TYPEACTION__" ; 
    VerbMsg="${StrMsg//__TYPEACTION__/${StrTypeAction}}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    StrMsg=$( LoopShellScript --get ArrayMsg[13] ) ;
    #StrMsg="Template used: __TPL__" ; 
    VerbMsg="${StrMsg//__TPL__/${StrTplTagParser}}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

    eval $( eval TPListTag=${StrTagParser}                 \
      TPArrayName=Array${__call_locality[0]}    \
      TPVarNameParsed="StrTplTagParser"         \
      TPDisplayDebug=${BoolDisplayDebug}        \
      TPDisplayParserNotice=${BoolDisplayDebug} \
      TagParser ) ; 
    
    StrMsg=$( LoopShellScript --get ArrayMsg[14] );
    #StrMsg="Value StrTagParser: __VAR__" ; 
    VerbMsg="${StrMsg//__VAR__/${StrTplTagParser}}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    ### This one display on common stdout the Parsing result. 
    VerbMsg="${StrTplTagParser}" VerbState=True VerbEvalForm=True VerbFormated=False Verbosis ;
   }
   
   function FileDeCapsulation()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( FDC FileDeCapsulation ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=FileDeCapsulation CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=FileDeCapsulation CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
    fi  
    StrMsg=$( LoopShellScript --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    StrCodec=$( cat ${StrStoreResult} | grep -i "${StrShaSumExtract}" | cut -d ' ' -f 4 ) ;
    StrFile=$( cat ${StrStoreResult} | grep -i "${StrShaSumExtract}" | cut -d ' ' -f 3 ) ;
    if [ "${StrCodec:=None}" == "${StrDefaultFileFormat}" ] ; then 
      StrMsg="Extracting File:__FILE__, with CODEC:__CODEC__,\nCMD: __CMD__,\npresent file will be overwritten." ;
      StrMsg=${StrMsg//__FILE__/${StrFile}} ;
      StrMsg=${StrMsg//__CODEC__/${StrCodec}} ;
      StrMsg=${StrMsg//__CMD__/${StrStreamCodec}} ;
      
      VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
      cat ${StrStoreResult} | grep -i "${StrShaSumExtract}" | cut -d ' ' -f 5 | eval ${StrStreamCodec} > ${StrFile} ; 
    else 
      StrMsg=${StrMsg//__CODEC1__/${StrDefaultFileFormat}} ; 
      StrMsg=${StrMsg//__CODEC2__/${StrCodec}} ; 
      VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    fi 

   }
   
   function DataExtractionTool()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( DET DataExtractionTool ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=DataExtractionTool CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=DataExtractionTool CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
    fi  
    StrMsg=$( LoopShellScript --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    local ArrayFunction=( ListFile:BoolListFile SearchByFile:BoolSearchFile SearchId:BoolSearchId SearchDate:BoolSearchDate ) ; 
    
    local StrStreamCodec=$( eval \
    $( eval \
      VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      VTVIsQuotedValue=True       \
      VTVIsWhiteList=True         \
      VTVWhiteListTransfert=UUID  \
      ValueToVariable ) GetFileFormatCmd ) ;     
   
    StrMsg=$( LoopShellScript --get ArrayMsg[3] ) ; 
    StrMsg=${StrMsg//__CODEC__/${StrDefaultFileFormat}} ;
    StrMsg=${StrMsg//__SHASUMID__/${StrShaSumExtract}} ;
    StrMsg=${StrMsg//__FILE__/${StrStoreResult}} ; 
    StrMsg=${StrMsg//__CMD__/${StrStreamCodec}} ; 
    
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

    #### This example require ArrayFunction in form 'FuctionName:VariableName' where 
    #### function are code allowed to search inside the StoreFile and Variable name
    #### are directly Binded Prefixed-Variable accessible from command line to specify
    #### one and only one of them, The advantage of if-elif statement, only first meet
    #### Variable test will execute the function and leave the if-elif bloc command . 
    #### Specifying more than one of these Pair Variable from Prefixed-variable relation
    #### will simply not execute the function and will requiert to remove the undesired 
    #### variable from the prompt. Cibled like unidirectional action it does fill requirement
    #### here function DataExtractionTool is multi tool pass-through where sub-function 
    #### directly do an action.
    #### 
    ####  This is acheive with a 2 type of BoolVartest if-elif + elif-fi BVTIdType=1,BVTIdType=2 ,
    ####  BVTIdType=6. This directive require inside a loop at index=0 it build a if-elif, where 
    #### it's mandatory concatenation quired to build a elif state because BoolVarTest manage 
    #### Preambule out of a condition and it's assertion from a test. While elif, else cannot use 
    #### the preambule it erase the ending-statement segment and provide only the assertion. 
    #### So looping after index 0 requiert BVTIdType=2 to build many elif and at loop index minus
    #### maximum, closing the if-elif with elif-fi where BVTIdType=6 and We can acheive a one loop
    #### building any elif clause for calling function from Boolean variable list associated with
    #### them in a Array declaration. 
    #### 
    
    local StrBoolConditionName="" ;
    local StrFunctionName="" ; 
    local StrPairFuncVar="" ;
    local StrIfElifBuild ; 
    ###eval $( eval BVTIsPreambule=False BVTIsValueToVarAssert=True BVTBoolVarName=\${BoolListFile:=False} BVTBoolCase=True  BVTVTVVarA=\${StrVarList} BVTVTFnctA=ListFile  BoolVarTest ) ;
    
    ### Following statement, if LSSSHAIndexExtract Is different than None, 
    ### it inform the application It did not choose the SHA1SUM Id to extract
    ### and either have to search for one or simply call the ListFile.
    ###StrMsg="Codec Problem, current configured Codec:(__CODEC1__) is not stored Codec:(__CODEC2__), you must specify a correct codec to extract this file." ;
    StrMsg=$( LoopShellScript --get ArrayMsg[1] ) ; 
    if [ "${StrShaSumExtract:=None}" != "None" ] ; then 
    $( eval \
      VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList},StrStreamCodec \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      VTVIsQuotedValue=True       \
      VTVIsWhiteList=True         \
      VTVWhiteListTransfert=UUID  \
      ValueToVariable ) FileDeCapsulation ;
    else 
    
     local IntIfType=6 ; 
     local IntMaxArrayIndex=$(( ${#ArrayFunction[@]}-1 )) ;
     for (( intx=0 ; intx <= ${IntMaxArrayIndex} ; intx++ )) ; do 
      StrPairFuncVar=${ArrayFunction[${intx}]} ; 
      ### Simple way to build a if-elif depending of a Array Of function 
      ### where One Boolean is require to select one of the required function
      ### and will be yield once with this if-elif structure. 
      if [ ${intx:=0} -eq 0 ] ; then 
       IntIfType=1 ;
      elif [ ${intx:=0} -gt 0 -a ${intx:=0} -lt ${IntMaxArrayIndex} ] ; then 
       IntIfType=2 ;
      elif [ ${intx:=0} -eq ${IntMaxArrayIndex} ] ; then 
       IntIfType=6 ;
      fi 
      StrBoolConditionName=${StrPairFuncVar/#[a-zA-Z0-9_]*:} ; 
      StrFunctionName=${StrPairFuncVar/%:${StrBoolConditionName/#[a-zA-Z0-9_]*:}} ; 
      ### 
      ###  Require some tuning of BoolVarTest, already changed and give good 
      ###  result.
      ### 
      StrIfBuildStatement=$( eval BVTDisplayIf=${BoolDisplayIf} BVTIdType=${IntIfType} BVTIsPreambule=False BVTIsValueToVarAssert=True BVTBoolVarName=\${${StrBoolConditionName}:=False} BVTBoolCase=True  BVTVTVVarA=${StrVarList} BVTVTFnctA=${StrFunctionName}  BoolVarTest  ) ; 
      StrIfElifBuild="${StrIfElifBuild}${StrIfBuildStatement}" ; 
     done 
     
     StrMsg=$( LoopShellScript --get ArrayMsg[2] ) ;  
     StrMsg="${StrMsg//__FUNCT__/${__call_locality[0]}}" ;
     StrMsg=${StrMsg//__VAR__/${StrIfElifBuild}}
     VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayIf} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
     eval ${StrIfElifBuild} ; 
     ###; BVTIdType=6 BVTIsPreambule=False BVTIsValueToVarAssert=True BVTBoolVarName=\${BoolSearchFile:=False} BVTBoolCase=True  BVTVTVVarA=\${StrVarList} BVTVTFnctA=SearchByFile BoolVarTest ; 
    fi    
   
   } 

   function SearchByFile()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( SBF SearchByFile ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=SearchByFile CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=SearchByFile CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
    fi
    StrMsg=$( LoopShellScript --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
      
    local StrCmdTpl="__APPS__ __APPS_OPT__ \"__QUERY__\" __FILE__ | __FILTER__ __FILTER_OPT__ " ; 
    
    if [ "${BoolSortByDate:=False}" == "True" ] ; then  
     StrCmdTpl="${StrCmdTpl} | __SORT__ __SORT_OPT__" ; 
    fi 
    StrCmdTpl=${StrCmdTpl//__APPS__/${StrDetApps}} ; 
    StrCmdTpl=${StrCmdTpl//__APPS_OPT__/${StrDetAppsOpt}} ; 
    StrCmdTpl=${StrCmdTpl//__QUERY__/${StrSearchQuery}} ; 
    StrCmdTpl=${StrCmdTpl//__FILE__/${StrStoreResult}} ; 
    StrCmdTpl=${StrCmdTpl//__FILTER__/${StrDetFilter}} ; 
    StrCmdTpl=${StrCmdTpl//__FILTER_OPT__/${StrDetFilterOpt}} ;
    StrCmdTpl=${StrCmdTpl//__RANK__/${StrDetRankDisplay}} ;
    StrCmdTpl=${StrCmdTpl//__SORT__/${StrDetSort}} ;
    StrCmdTpl=${StrCmdTpl//__SORT__OPT__/${StrDetSortOpt}} ;
     
    StrMsg=$( LoopShellScript --get ArrayMsg[23] ) ;
    StrMsg=${StrMsg//__CMD__/${StrCmdTpl}} ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    StrMsg=$( LoopShellScript --get ArrayMsg[15] ) ; 
    VerbMsg="${StrMsg}" VerbState=True VerbExtendedOut=True VerbEvalForm=False VerbFormated=False VerbDev=/dev/stderr  Verbosis ;

    eval ${StrCmdTpl} ; 
    ### egrep  "${StrSearchQuery}" ${StrStoreResult} | /usr/bin/cut -d ' ' -f 1,2,3 | /usr/bin/sort -k1 ; 
    
   } 


   function SearchDate()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( SD SearchDate ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=SearchDate CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=SearchDate CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
    fi  
    StrMsg=$( LoopShellScript --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    local StrCmdTpl="__APPS__ __APPS_OPT__ \"__QUERY__\" __FILE__ | __FILTER__ __FILTER_OPT__ " ; 
    
    if [ "${BoolSortByDate:=False}" == "True" ] ; then  
     StrCmdTpl="${StrCmdTpl} | __SORT__ __SORT_OPT__" ; 
    fi 
    StrCmdTpl=${StrCmdTpl//__APPS__/${StrDetApps}} ; 
    StrCmdTpl=${StrCmdTpl//__APPS_OPT__/${StrDetAppsOpt}} ; 
    StrCmdTpl=${StrCmdTpl//__QUERY__/${StrSearchQuery}} ; 
    StrCmdTpl=${StrCmdTpl//__FILE__/${StrStoreResult}} ; 
    StrCmdTpl=${StrCmdTpl//__FILTER__/${StrDetFilter}} ; 
    StrCmdTpl=${StrCmdTpl//__FILTER_OPT__/${StrDetFilterOpt}} ;
    StrCmdTpl=${StrCmdTpl//__RANK__/${StrDetRankDisplay}} ;
    StrCmdTpl=${StrCmdTpl//__SORT__/${StrDetSort}} ;
    StrCmdTpl=${StrCmdTpl//__SORT__OPT__/${StrDetSortOpt}} ;
    
    StrMsg=$( LoopShellScript --get ArrayMsg[23] ) ;
    StrMsg=${StrMsg//__CMD__/${StrCmdTpl}} ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

    StrMsg=$( LoopShellScript --get ArrayMsg[16] ) ; 
    VerbMsg="${StrMsg}" VerbState=True VerbExtendedOut=True VerbEvalForm=False VerbFormated=False VerbDev=/dev/stderr  Verbosis ;

    eval ${StrCmdTpl} ; 
    
   }

   
   function SearchId()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( SI SearchId ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=SearchId CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=SearchId CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
    fi  
    StrMsg=$( LoopShellScript --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    local StrCmdTpl="__APPS__ __APPS_OPT__ \"__QUERY__\" __FILE__ | __FILTER__ __FILTER_OPT__ " ; 
    
    if [ "${BoolSortByDate:=False}" == "True" ] ; then  
     StrCmdTpl="${StrCmdTpl} | __SORT__ __SORT_OPT__" ; 
    fi 
    StrCmdTpl=${StrCmdTpl//__APPS__/${StrDetApps}} ; 
    StrCmdTpl=${StrCmdTpl//__APPS_OPT__/${StrDetAppsOpt}} ; 
    StrCmdTpl=${StrCmdTpl//__QUERY__/${StrSearchQuery}} ; 
    StrCmdTpl=${StrCmdTpl//__FILE__/${StrStoreResult}} ; 
    StrCmdTpl=${StrCmdTpl//__FILTER__/${StrDetFilter}} ; 
    StrCmdTpl=${StrCmdTpl//__FILTER_OPT__/${StrDetFilterOpt}} ;
    StrCmdTpl=${StrCmdTpl//__RANK__/${StrDetRankDisplay}} ;
    StrCmdTpl=${StrCmdTpl//__SORT__/${StrDetSort}} ;
    StrCmdTpl=${StrCmdTpl//__SORT__OPT__/${StrDetSortOpt}} ;
    
    StrMsg=$( LoopShellScript --get ArrayMsg[23] ) ;
    StrMsg=${StrMsg//__CMD__/${StrCmdTpl}} ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    StrMsg=$( LoopShellScript --get ArrayMsg[17] ) ;
    VerbMsg="${StrMsg}" VerbState=True VerbExtendedOut=True VerbEvalForm=False VerbFormated=False VerbDev=/dev/stderr  Verbosis ;
    
    eval ${StrCmdTpl} ; 
   }
     
   function ListFile()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( LF ListFile ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=ListFile CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=ListFile CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
    fi  
    StrMsg=$( LoopShellScript --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    local StrCmdTpl="__FILTER__ __FILTER_OPT__ < __FILE__ " ; 
    if [ "${BoolSortByDate:=False}" == "True" ] ; then  
     StrCmdTpl="${StrCmdTpl} | __SORT__ __SORT_OPT__" ; 
    fi 

    StrCmdTpl=${StrCmdTpl//__FILE__/${StrStoreResult}} ; 
    StrCmdTpl=${StrCmdTpl//__FILTER__/${StrDetFilter}} ; 
    StrCmdTpl=${StrCmdTpl//__FILTER_OPT__/${StrDetFilterOpt}} ;
    StrCmdTpl=${StrCmdTpl//__SORT__/${StrDetSort}} ;
    StrCmdTpl=${StrCmdTpl//__SORT__OPT__/${StrDetSortOpt}} ;
    StrCmdTpl=${StrCmdTpl//__RANK__/${StrDetRankDisplay}} ;
    
    StrMsg=$( LoopShellScript --get ArrayMsg[23] ) ;
    StrMsg=${StrMsg//__CMD__/${StrCmdTpl}} ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    StrMsg=$( LoopShellScript --get ArrayMsg[18] ) ; 
    VerbMsg="${StrMsg}" VerbState=True VerbExtendedOut=True VerbEvalForm=False VerbFormated=False VerbDev=/dev/stderr  Verbosis ;
 
    eval ${StrCmdTpl} ; 
   }

   function FileWriterSupport()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( FWS FileWriterSupport ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=FileWriterSupport CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=FileWriterSupport CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
    fi  
    StrMsg=$( LoopShellScript --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

    local StrCompressionStream=$( eval \
    $( eval \
      VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      VTVIsQuotedValue=True       \
      VTVIsWhiteList=True         \
      VTVWhiteListTransfert=UUID  \
      ValueToVariable ) GetFileFormatCmd ) ; 
    
    StrMsg=$( LoopShellScript --get ArrayMsg[19] ) ; 
    #StrMsg="Compression Header:__VAR__";
    VerbMsg=${StrMsg//__VAR__/${StrCompressionStream}}"" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=True VerbEvalForm=False VerbFormated=True  VerbDev=/dev/stderr  Verbosis ;

    local IntLockInfo=0 ; 
    local StrLockHolder ; 
     
    StrMsg=$( LoopShellScript --get ArrayMsg[20] ) ; 
    #StrMsg="Compression :( cat __FILE__ | __STREAMCMD__ )";
    StrMsg=${StrMsg//__FILE__/${StrStartFile}} ;
    StrMsg=${StrMsg//__STREAMCMD__/${StrCompressionStream}} ;
    VerbMsg=${StrMsg}"" VerbHeader="${__call_locality[1]}-CMDLINE" VerbState=True VerbEvalForm=False VerbFormated=True  VerbDev=/dev/stderr  Verbosis ;

    StrScriptCpr=$( cat ${StrStartFile} | eval ${StrCompressionStream} ) ; 
    StrNewParserInfo=${StrTemplateShaStorage} ; 
    
    if [ "${versionGOD:=0.0.1}" == "0.0.1" ] ; then 
      StrDate=$( GODFormat="${StrDateFormat}" GetOtherDate ) ; 
    elif [ "${versionGOD:=0.0.1}" == "0.0.2" ] ; then 
      StrDate=$( GODFormat="${StrDateFormat}" GODShowVersion=False GetOtherDate ) ; 
    fi
     
    StrNewParserInfo=${StrNewParserInfo//__DATE__/${StrDate}}
    StrNewParserInfo=${StrNewParserInfo//__SHA__/${StrCurrentSha}}
    StrNewParserInfo=${StrNewParserInfo//__FILENAME__/${StrStartFile}}
    StrNewParserInfo=${StrNewParserInfo//__FORMAT__/${StrDefaultFileFormat}}
    StrNewParserInfo=${StrNewParserInfo//__FILECONTENT__/${StrScriptCpr}}
    if [ "${BoolIsLockFile:=False}" == "True" ] ; then 
    
     StrMsg="Lock holded by Instance-ID: __UUID__" ; 
     StrLockHolder="";
     IntLockInfo=0;
     
     while [ -f ${StrLockFileId} ] ; do  
      ### Required to sleep until LockFile is removed .
      if [ ${IntLockInfo:=0} -eq 0 -a -f ${StrLockFileId} ] ; then 
       StrLockHolder=$( cat ${StrLockFileId} ) ; 
       StrMsg=${StrMsg//__UUID__/${StrLockHolder}} ; 
       VerbMsg=${StrMsg} VerbHeader="${__call_locality[1]}-LOCK" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ;
       IntLockInfo=1 ; 
      fi 
      sleep 1 ; 
     done 
     ### If LockFile was removed or either never exist.
     ### Create a new LockFile
     VerbMsg=${StrUUID}  VerbExtendedOut=False VerbEvalForm=True VerbFormated=False VerbState=True VerbDev=${StrLockFileId}  Verbosis ;
     echo -ne "${StrNewParserInfo}\n" >> ${StrStoreResult} ;  
     rm -f ${StrLockFileId} ; 
    else
     ### Normal Writing without LockFile implementation . 
     echo -ne "${StrNewParserInfo}\n" >> ${StrStoreResult} ;  
    fi 
    
   }
   
   function ImportStoreResult()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( SCS ShellControlServices ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=ImportStoreResult CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=ImportStoreResult CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
    fi  
    StrMsg=$( LoopShellScript --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    local StrEvalCmd="""local StrMsgTpl=\"Importing previous SHA1SUM result:__SHA__\" ;
    local StrMsgDup=\"Existing Duplicate of SHA1SUM: __SHA__, not importing\" ; 
    local StrMsg ; 
    local ArrayShaImport=( \$( cat \${StrStoreResult} | cut -d ' ' -f 2  ) ) ;
    local StrTestTbl ;
    local IntSetNotAdd=0 ; 
    for StrShaSumPair in \${ArrayShaImport[@]} ; do 
     StrMsg=\${StrMsgTpl} ; 
     StrMsg=\${StrMsg//__SHA__/\${StrShaSumPair}} ;
     VerbMsg=\"\${StrMsg}\" VerbHeader=\"\${__call_locality[1]}-IMPORT\" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
     IntSetNotAdd=0 ; 
     for StrPairTest in \${!ArrayCompiler[@]} ; do 
      if [ \"\${StrPairTest:=None}\" == \"\${StrShaSumPair}\" ] ; then 
       IntSetNotAdd=1 ; 
      fi ; 
     done ;
     if [ \${IntSetNotAdd:=0} -ne 1 ] ; then 
      ArrayCompiler[\${StrShaSumPair}]=\"OK\" ;  
     else
      StrMsg=\${StrMsgDup} ;
      VerbMsg=\"\${StrMsg//__SHA__/\${StrShaSumPair}}\" VerbHeader=\"\${__call_locality[1]}-IMPORT\" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
     fi ;  
    done """ ; 
    
    local StrEvalTpl=$( LoopShellScript --get ArrayMsg[23] ) ; 
    StrMsg=${StrEvalTpl} ; 
    StrMsg=${StrMsg//__CMD__/${StrEvalCmd}} ;
    VerbMsg=${StrMsg} VerbHeader="${__call_locality[1]}-EVALCMD" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    VerbMsg=${StrEvalCmd} VerbState=True VerbEvalForm=True VerbFormated=False Verbosis ;
    #echo -ne  "${StrEvalCmd}" ; 
     
   }
   function ShellControlServices()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( SCS ShellControlServices ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=ShellControlServices CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=ShellControlServices CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
    fi  
    StrMsg=$( LoopShellScript --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    local StrUUID=$( GetUAppsRegisterName=${StrParentApps} GetUTimeBased=True GetULoop=False GetUUID ) ; 
    StrPathLoopState=${StrPathLoopState//__SHORTFUNC__/${StrDefaultShortName}} ; 
    StrPathLoopState=${StrPathLoopState//__UUID__/${StrUUID}}
    VerbMsg="Instance ID:${StrUUID}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ;
    touch ${StrPathLoopState} ; 

    local -A ArrayCompiler  ; 
    ### Load StrStoreResult, all Sha1Sum to avoid starting over some test. 
    ### Also dependend of BoolImportStoreResult, and wrapped with a BoolVarTest.
    eval $( BVTBoolVarName=\${BoolImportStoreResult:=False} \
      BVTIdType=0                   \
      BVTIsPreambule=False          \
      BVTIsValueToVarAssert=True    \
      BVTVTVVarA=${StrVarList}      \
      BVTBoolCase=True              \
      BVTVTFnctA=ImportStoreResult  \
      BVTVTVTPLA="eval __TES__ eval __FNCT_ASRT__ __TEE__ " \
      BoolVarTest                   ) ;  
    
    local StrCurrentSha ; 
    local IntCompileState=0 ; 
    local IntCompileAdd=0 ;  
    local IntReturn=0 ; 
    local IntFindCompiler ; 
    local StrScriptCpr ; 
    local StrDate ;
    local StrOperatorExec="." ; 
    local -a ArrayMsg=( ) ;
    
    ArrayMsg[0]=$( LoopShellScript --get ArrayMsg[4] ) ;  
    ArrayMsg[1]=$( LoopShellScript --get ArrayMsg[5] ) ;  
    ArrayMsg[2]=$( LoopShellScript --get ArrayMsg[5] ) ;  
    ArrayMsg[3]=$( LoopShellScript --get ArrayMsg[6] ) ;  
    ArrayMsg[4]=$( LoopShellScript --get ArrayMsg[7] ) ;  
    ArrayMsg[5]=$( LoopShellScript --get ArrayMsg[8] ) ;  
    ArrayMsg[6]=$( LoopShellScript --get ArrayMsg[9] ) ;  
    ArrayMsg[7]=$( LoopShellScript --get ArrayMsg[10] ) ;  
    ArrayMsg[8]=$( LoopShellScript --get ArrayMsg[11] ) ;  
    ArrayMsg[9]=$( LoopShellScript --get ArrayMsg[21] ) ;  
    ArrayMsg[10]=$( LoopShellScript --get ArrayMsg[22] ) ;  
    
    while [ -f ${StrPathLoopState} ] ; do 
     StrCurrentSha=$( GS1SApps=${StrCertFileApps} GS1SFile=${StrStartFile} GetSha1Sum ) ; 

     IntFindCompiler=0 ; 
     for Iter in ${!ArrayCompiler[@]} ; do 
       if [ "${Iter}" == "${StrCurrentSha}" ] ; then 
         IntFindCompiler=1 ; 
       fi ; 
     done 
    
     if [ ${IntFindCompiler:=0} -eq 0 ] ; then 
       ### Must add a sha1sum for specific change of compiler directive inside 
       ### start-configure.sh
       ArrayCompiler[${StrCurrentSha}]="UNKNOW" ; 
     fi 
     
     if [ "${ArrayCompiler[${StrCurrentSha}]}" == "UNKNOW" ] ; then 
      ### Do find a sha1sum compiler directive differ from previous version . 
      ### run the script and report it execution state, because the Compiler 
      ### directive are empty. 
      StrMsg=${ArrayMsg[0]};
      StrMsg=${StrMsg//__CURRSHA__/${StrCurrentSha}} ; 
      StrMsg=${StrMsg//__STOREDSHA__/${ArrayCompiler[${StrCurrentSha}]}} ;
      VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DISPLAY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
      IntCompileAdd=1 ;
      IntFindCompiler=0 ;
      sleep 5 ; 
     elif [ "${ArrayCompiler[${StrCurrentSha}]}" == "OK" ] ; then 
      ###echo -ne "Shell-Script SHA1SUM:__CURRSHA__, __STOREDSHA__" ;
      StrMsg=${ArrayMsg[1]}
      StrMsg=${StrMsg//__CURRSHA__/${StrCurrentSha}} ;
      StrMsg=${StrMsg//__STOREDSHA__/${ArrayCompiler[${StrCurrentSha}]}} ;
      VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DISPLAY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
      IntCompileAdd=0 ; 
      IntFindCompiler=0 ;
     elif [ "${ArrayCompiler[${StrCurrentSha}]}" == "FAILED" ] ; then 
      StrMsg=${ArrayMsg[2]}
      StrMsg=${StrMsg//__CURRSHA__/${ArrayCompiler[${StrCurrentSha}]}} ;
      StrMsg=${StrMsg//__STOREDSHA__/${StrCurrentSha}} ;
      VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DISPLAY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
      ###echo -ne "Shell-Script SHA1SUM:__CURRSHA__, __STOREDSHA__" ;
      IntCompileAdd=0 ; 
      IntFindCompiler=0 ;
     fi

     if [ ${IntCompileAdd:=0} -eq 1  ] ; then 
       ### The Executing action . Here I do specify the execution of a script
       ### file with dot operator '. SCRIPT', but changing the infrastructure 
       ### from Script to Observe a File do require at least to inspect-it,
       ### or to look at it, here I define /usr/bin/file to simply return
       ### a correct-statement if file can be readed and identified. 
       
       if [ "${BoolIsScriptRun:=True}" == "False" ] ; then 
        StrOperatorExec=${StrFileAlterateVrf} ; 
       fi 
       
       IntMaxLoop=1 ;
       IntStepScript=0 ; 
       if [ "${BoolLoopScriptOnState:=False}" == "True" ] ; then 
        IntMaxLoop=${IntMaxLoopOnError} ; 
        StrMsg=${ArrayMsg[10]}
        StrMsg=${StrMsg//__INT__/${IntDefaultErrorStateLoop}} ;
        StrMsg=${StrMsg//__LOOP__/${IntMaxLoop}} ;
        VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-EXECUTION" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
       fi
       while [ ${IntStepScript} -ne ${IntMaxLoop}  ] ; do  
        StrMsg=${ArrayMsg[9]}
        StrMsg=${StrMsg//__STEP__/${IntStepScript}} ; 
        StrMsg=${StrMsg//__STEPMAX__/$(( ${IntMaxLoop} - 1 ))} ; 
        VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-EXECUTION" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

        if [ "${BoolHideAppsDebug:=False}" == "True" ] ; then 
          eval ${StrOperatorExec} ${StrStartFile} 2>&1 > /dev/null  ;
          IntReturn=$? ;
        else
          eval ${StrOperatorExec} ${StrStartFile} ;
          IntReturn=$? ;
        fi
        StrMsg=${ArrayMsg[3]}
        StrMsg=${StrMsg//__RET__/${IntReturn}} ;
        VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DISPLAY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
        if [ ${IntReturn:=0} -eq ${IntDefaultErrorStateLoop} -a "${BoolLoopScriptOnState:=False}" == "True" ] ; then 
         ### while are sure to obtain N-time the error-type in  
         ### IntDefaultErrorStateLoop ( as example : return 
         ### statement of a make with segmentation fault==2)
         ### AND It support the loop on error-type loop
         ### it should pass here . 
         IntStepScript=$(( ${IntStepScript} + 1 )) ; 
        elif [ "${BoolLoopScriptOnState:=False}" == "False" ] ; then 
         ### If it not support the loop on error-type it should 
         ### directly increase the counter . 
         ### While default maximum is already set to one
         ### the only way to define it to more is to enable 
         ### BoolLoopScriptOnState=True 
         IntStepScript=$(( ${IntStepScript} + 1 )) ; 
        fi 
        #IntStepScript=$(( ${IntStepScript} + 1 )) ;
       done 
       ### echo -ne "Shell-Script returned state: __RET__" ; 
       StrMsg=${ArrayMsg[3]}
       StrMsg=${StrMsg//__RET__/${IntReturn}} ;
       VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DISPLAY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
       IntCompileState=1 ;  
       IntCompileAdd=0 ; 
     else
      if [ "${ArrayCompiler[${StrCurrentSha}]}" != "UNKNOW" ] ; then 
        StrMsg=${ArrayMsg[4]}
        StrMsg=${StrMsg//__CURRSHA__/${StrCurrentSha}} ;
        VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DISPLAY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
        ###echo -ne "Shell-Script classified:__CURRSHA__,\n\tdon't required to start over."
      fi 
      sleep 5; 
      ### StrDate=$( GODFormat="${StrDateFormat}" GetOtherDate ) ; 
      if [ "${versionGOD:=0.0.1}" == "0.0.1" ] ; then 
       StrDate=$( GODFormat="${StrDateFormat}" GetOtherDate ) ; 
      elif [ "${versionGOD:=0.0.1}" == "0.0.2" ] ; then 
       StrDate=$( GODFormat="${StrDateFormat}" GODShowVersion=False GetOtherDate ) ; 
      fi
      ###echo -ne "UUID-Instance:__UUID__\nDate:__DATE__"
      ###echo -ne "Shell-scripts directive result:" ;
      StrMsg=${ArrayMsg[5]}
      StrMsg=${StrMsg//__UUID__/${StrUUID}} ;
      StrMsg=${StrMsg//__DATE__/${StrDate}} ;
      StrMsg1=${ArrayMsg[6]}
      VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DISPLAY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
      VerbMsg="${StrMsg1}" VerbHeader="${__call_locality[1]}-DISPLAY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
      
      for StrDirective in ${!ArrayCompiler[@]} ; do
       if [ "${ArrayCompiler[${StrDirective}]}" != "UNKNOW" ] ; then 
         StrMsg=${ArrayMsg[7]} ;
         StrMsg=${StrMsg//__CURRSHA__/${StrDirective}} ;
         StrMsg=${StrMsg//__STOREDSHA__/${ArrayCompiler[${StrDirective}]}} ;
         VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DISPLAY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
         ###echo -ne "Shell-Script SHA1SUM:__CURRSHA__, result: __STOREDSHA__" ; 
       fi 
      done ;
      StrMsg=${ArrayMsg[8]} ;
      ### VerbExtendedOut=True
      VerbMsg="${StrMsg}" VerbFormated=False VerbState=True VerbEvalForm=False  VerbDev=/dev/stderr  Verbosis ;
     fi 
     
     if [ ${IntCompileState:=0} -eq 1  ] ; then 
      ### Time to analyse the result of shell-script 
      if [ ${IntReturn:=0} -eq 0  ] ; then 
       ArrayCompiler[${StrCurrentSha}]="OK"
       ### FileWriterSupport 
       $( eval \
       VTVIsArrayStyleInsert=True  \
       VTVValueEntry=${StrVarList},StrUUID,StrCompressionStream \
       VTVIsValueReAssign=True     \
       VTVIsValueToConvert=False   \
       VTVIsQuotedValue=True       \
       VTVIsWhiteList=True         \
       VTVWhiteListTransfert=UUID  \
       ValueToVariable ) FileWriterSupport ; 
       
      else 
       ### Many state can be returned, like script from configure will return :
       ### configure: error: C compiler cannot create executables, 
       ### and return code == 77 .
       ArrayCompiler[${StrCurrentSha}]="FAILED"
      fi 
      IntCompileState=0;
      IntReturn=0; 
     fi   
    done ; 
    
   }
   
   function VersionApps()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( VA VersionApps ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=VersionApps CAIsAddParent=True __Call_Argument ) ;
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=VersionApps CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
    fi     
    StrEvalCmd="""
    StrMsg=\"Application:__FUNCT__ , version:( versionTP:__VER_TP__ versionVTV:__VER_VTV__, versionCA:__VER_CA__, versionBVT:__VER_BVT__)\" ; 
    StrMsg=\${StrMsg//__VER_CA__/\${versionCA}} ;
    StrMsg=\${StrMsg//__VER_TP__/\${versionTP}} ;
    StrMsg=\${StrMsg//__VER_VTV__/\${versionVTV}} ;
    StrMsg=\${StrMsg//__VER_BVT__/\${versionBVT}} ;
    StrMsg=\${StrMsg//__FUNCT__/\${__call_locality[1]}} ;
    VerbMsg=\${StrMsg} VerbHeader=\"VERSION\" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
    """ ; 
    echo -ne "${StrEvalCmd}" ; 
   }
   
   function __main_StopServices()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( Main __main_StopServices ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True __Call_Argument ) ;
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
    fi 
    local StrMsg="Entry in function" ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    local StrCachePath=$( ServiceControllerHandler --get SCHSInstancePath ) ; 
    local StrCacheAction=$( ServiceControllerHandler --get SCHAction ) ; 
    local IntPathLength=${#StrPathLoopState} ; 
    local StrCacheFromSCH=${StrPathLoopState//${StrCachePath}/} ; 
    local BoolCacheFromSCH="False" ; 
    
    ### After creation of variable StrCacheFromSCH that do reduce 
    ### the StrPathLoopState by reducing what we found inside 
    ### 'ServiceControllerHandler --get SCHSInstancePath' ( usually
    ### /var/cache/Fnct.D, will be involved in BoolCacheFromSCH 
    ### to be set to true for following meanning ; Application is
    ### keeping UUID instance inside /var/cache/Fnct.D   
    if [ ${#StrCacheFromSCH} -lt ${IntPathLength} ] ; then 
     BoolCacheFromSCH="True" ;
    fi  
    
    ### Does apply couple of transformation to String StrPathLoopState
    ### due to compliance of ServiceControllerHandler and require 
    ### and Action, with Tag __ACTION__, and Path with tag __PATH__
    ### to be feeded/replaced to get all the UUID instance file. 
    ### By default Action from SCH 'ServiceControllerHandler --get SCHAction'
    ### is Loop, but some other information like Setting, Storage, Buffer, 
    ### and other semantic-file can be used since ServiceControllerHandler 
    ### is having more and more member to handler life-cycle of some UUID-
    ### instance, it may have future property like altering information, not 
    ### only deleting them.  
    
    if [ ${BoolCacheFromSCH:=False} == "True" ]  ; then 
     StrPathLoopState=${StrPathLoopState//__PATH__/${StrCachePath}} ; 
     StrPathLoopState=${StrPathLoopState//__ACTION__/${StrCacheAction}} ; 
    fi 

    local StrUUID=${UUID};
    if [ "${StrUUID:=None}" == "None" ] ; then 
     StrUUID=${StrUUIDInstance} ; 
    fi 
    
    local StrFSH=${StrDefaultShortName} ; 
    
    StrPathLoopState=${StrPathLoopState//__SHORTFUNC__/${StrFSH}} ; 
    StrPathLoopState=${StrPathLoopState//__UUID__/${StrUUID}} ; 
    
    
    VerbMsg="Shutdown Instance ID:${StrUUID}, file: ${StrPathLoopState}" VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ;
    if [ -f ${StrPathLoopState} ] ; then 
     rm -f ${StrPathLoopState} ; 
    fi 
   }
   
   function __main_StartServices()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( CFCD CurlFtpContentDownload ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
    fi 
    StrMsg=$( LoopShellScript --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
    local StrCmdAction=$( \
       BVTDisplayIf=${BoolDisplayIf}   \
       BVTIdType=4                     \
       BVTIsPreambule=False            \
       BVTIsValueToVarAssert=True      \
       BVTBoolVarName=\${BoolIsExtraction:=False} \
       BVTBoolCase=False               \
       BVTVTVVarA=${StrVarList}        \
       BVTVTFnctA=ShellControlServices \
       BoolVarTest                     ;
       BVTDisplayIf=${BoolDisplayIf}   \
       BVTIdType=5                     \
       BVTIsPreambule=False            \
       BVTIsValueToVarAssert=True      \
       BVTVTFnctA=DataExtractionTool   \
       BVTVTVVarA=${StrVarList}        \
       BoolVarTest                    ); 
    
    StrMsg="Complete If Statement from __FUNCT__:__VAR__" ; 
    StrMsg=${StrMsg//__VAR__/${StrCmdAction}}
    StrMsg=${StrMsg//__FUNCT__/${__call_locality[1]}}
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayIf} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    eval ${StrCmdAction} ; 
   }
   
   local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
   local StrNameHelper="LoopShellScript\t\tA Test-Unit to test command with many directive to test and report the working solution.";
   local StrSummary="This application does survey your script and run-it belong to a different SHA1SUM reported by the application and upon a result it store-it inside a File for working solution. " ; 
   local StrSynopsis="This application is also perfect for Shell-Script with TAG to replace or add directive. Coming with Start and Stop services, it expect to produce execution once and store the file inside file with SHA1SUM header from your script qualified of different from previous save or modification. Result is compressed and this application will deliver a method to extract the compressed file inside this SHA1SUM header. (END OF DRAFT INFORMATION)";
   local StrDescription="A common way to use it is to test your source package requiring to change the configure with multiples option some may fail and require to change the information inside. This application will wait until the file is changed and report you if it work or not. File Specified by the application is compressing the working result ready to extract the working solution. This Application can be shutdown from a command from same USER by using --stopservices function. It require to specify a Uniform Ressource Identifier specified inside prefixed-variable, LSSUUIDInstance. Also UUID variable can be used instead. By starting a new instance of this application it show you a UUID identifier and a new file inside  prefixed-variable LSSLoopFile will exist the time the loop is testing and compiling succesfull script. Stopping the services will only remove the file and stop the Loop.\n\nMaster Prefixed Variable\nLSSIsExtraction=False  ( by default )\nMaster Prefixed Variable\nLSSIsExtraction=False  ( by default )\nSwitch To ShellControlServices main function responsible of looping script and store working script inside file LSSFileStorage (by default .LoopShellScript)\n\n\nLSSIsExtraction=True\nSwitch To ,DataExtractionTool to access to your file LSSFileStorage (by default .LoopShellScript) by extracting script. Also access to the sub-function of DataExtractionTool, SearchByFile ,SearchDate ,SearchId ,ListFile. Only ListFile is not requiring a query to enter with prefixed variable LSSSearchQuery. Sub Function SearchByFile ,SearchDate ,SearchId require Prefixed-variable to allow a specific search and not working in same time than ListFile. Assuming ListFile can be accessed by using [ LSSIsListID=True, LSSIsExtraction=True ], sub-function SearchByFile ,SearchDate ,SearchId won't be accessible at same time. You do require to acces to them, just use [ LSSIsListID=True, LSSIsSearchID=True | LSSIsSearchDate=True | LSSIsSearchFile=True ] . Using the search facility, your query can be inserted inside Prefixed-Variable LSSSearchQuery=... . A Search engine only search it does not extract the information. \n\n\nLSSSHAIndexExtract=...\nIs the only one prefixed-parameter to use to extract the file under LoopShellScript. One full-length query to extract imply loading the DET ( DataExtractionTool ) by loading extraction:\n\n\nLSSIsExtraction=True LSSSHAIndexExtract=8fa097cd6652a6f3d106193a12ff4d5855e894a2.\n\nServices Engine Section :\nLoopShellScript can start many instance, and each instance information is stored inside /var/cache/Fnct.D/, where a file named Loop-LSS-UUID, where UUID is an UUID Identifier used to identify the active loop for your script detection. To stop a services running it's mandatory require to claim the shutdown by specifying the UUID on prompt with the switche '--stopservices' . \n\n\nex:\n$> UUID=938cc57c-9c73-11e6-8b1d-001e4c8856d6 LoopShellScript --stopservices\n\tOr\n$> LSSUUIDInstance=938cc57c-9c73-11e6-8b1d-001e4c8856d6 LoopShellScript --stopservices\n\n\nFollowing Prefixed-Variable can be used for the main-loop called ShellControlServices:\n\nLSSFileName\t\tSTRING The Script, image, the collected data in chunk used to analysed with this application.\nLSSFileStorageLock\tSTRING File location to control all Lock-ready Instance of LoopShellScript.\nLSSNonScriptValidator\tSTRING default to ('/usr/bin/file') replace Operator Dot [.] in file-script execution.\nLSSIsScriptFile\t\tSet To True/False Default to True, if LSSFileName is not a script but a file to monitor it's have to turn it to False.\nLSSIsLockFile\t\tSet To True/False Default to False, allow multiple instance to store in the same file. \nLSSFileStorage\t\tSTRING File The default file name to store all SHA1SUM + FILE, beware of multiples instance.\nLSSIsImportStoreResult\tSet To True/FalseLoad result from a FileStorage specified by LSSFileStorage it can be from local path, or any existing location. If this one is in use, suggested to add LSSIsLockFile=True.\nLSSLoopFile\t\tSTRING File Identifier to manage the instance, To create your own repository consult GnrlPrsrInfctr Creation of repository.\nLSSFileFormat\t\tSTRING Based on LSSApps LSSFilter prefixed-Var. it required to managed theses variable too to specify something else.\nLSSIsHideScriptOutput\tSet To True/False Hide from Stdout output of your script, does not affect the return statement.\nLSSIsDisplayDebug\tSet To True/False Display Debugging and verbose left inside.\nLSSIsDisplayIfDebug\tSet To True/False Display Debugging and verbose toward Generated-If clause from BoolVarTest.\nLSSDateFormat\t\tSTRING and Quoted STRING required use Standard POSIX-date format and can use also Unix-TimeStamp.\nLSSIsLoopOnErrorType\tSet To True/False Does Enable Script Looping. This Parameter are for OS or hardware problem\nLSSLoopOnError\t\tINT This is once a script does return alternatively no error and error, must specify the error to filter\nLSSMaxLoopOnError\tINT Number of Iteration the script should run to certify for error.\n\n\nComment over LSSIsLoopOnErrorType:\nThis is another section used to test and strength scritp, some script like configure loading Makefile and this one using the compiler, does sometimes return no error and the moment after it start to generate Segment-fault with or withour changes on your system, this facility is here to give a try on your night-build.\n\nComment over LSSLoopOnError:\nThis Prefixed-variable require you do know about recurrent error, like compiler like gcc give ErrorLevel of 2 and enabling suppose your script only loop after detecting Segmentation fault.\n\nData Extraction Tool Section :\nExtracting the file from specified Prefixed-variable LSSFileStorage does overwrite your current file-name if this one is present inside the path where you do require to extract it. Mostly if you do have done a Shutdown request you may already own a copy of the file inside the Storage file.\n\nPrefixed-Variable for DataExtractionTool or ( DET ).\n\nLSSIsExtraction\t\tSet To True/False Mandatory to use DataExtractionTool search or extraction\nLSSSHAIndexExtract\tSTRING The SHA1SUM Id information used to extract the file. \nLSSIsListID\t\tSet To True/False Only List all SHA1SUM Id and file \nLSSIsSearchID\t\tSet To True/False Actiave DET Search By ID\nLSSIsSearchDate\t\tSet To True/False Actiave DET Search By Date\nLSSIsSearchFile\t\tSet To True/False Actiave DET Search By File\nLSSSearchQuery\t\tSTRING The query string used to seach by Date, File, ID.\n\n\nAvanced Prefixed-Variable for Both DataExtractionTool and ShellControlServices.\n\nLSSApps\t\t\tSTRING Specify the active codec for compression, other suggestion can be gzip, lzma, 7z\nLSSAppsCmprOpt\t\tSTRING Specify the Compression Codec parameter for compression.\nLSSAppsDeCmprOpt\tSTRING Specify the De-Compression Codec parameter for de-compression.\nLSSFilter\t\tSTRING Specify the encapsulation layer of compressed file stored inside declaration of  LSSFileStorage. Should support storage in one line with no EOL.\nLSSFilterCmprOpt\tSTRING Specify the parameter to use the encapsulation to store inside the file declared by LSSFileStorage\nLSSFilterDeCmprOpt\tSTRING Specify the paramter to extract from encapulation the compressed file. \n\n\nParser & Advanced Prefixed-Variable for Both DataExtractionTool and ShellControlServices\n\nThis section does manage uniquely your encapsulation layer and compression tool if you do provide other parameter to the application and will manage your information.\nLSSFileFormat\t\tSTRING By Default its 'BZIP2+BASE64'\nLSSCmprTag\t\tSTRING Parse your LSSFileFormat into command line to Store your script or file analysed by this application. \nLSSDeCmprTag\t\tSTRING Parse your LSSFileFormat into command line to extract your script out of SHA1SUM Id out of the storage file. \nLSSTagParserDef\t\tSTRING Unless your are not a ParserTag Aware it does transform TAG from Variable definition inside the application.\nLSSFuncStart\t\tSTRING From Function member or existing function it's the function LoopShellScript.\n\nComment over LSSFileFormat:\nIn compression which is default, but internal function GetFileFormatCmd ( visible from Function Member section) callable from LSSFuncStart use the variable LSSIsExtraction and for one way compression the function read your LSSFileFormat into LSSCmprTag parameter from this STRING BZIP2+BASE64. Setting LSSIsExtraction=True the same function can revert this LSSFileFormat and apply BASE64+BZIP2 to getting your file out of storage file. This Parser will use LSSDeCmprTag and parsing your application BASE64+BZIP2 into a command line.\n\nComment over LSSTagParserDef:\nTouching-it play with the code and may not work, but quite usefull if you do have to add from Prefixed-Variable from prompt to One of internal function should specified with the affected tag.\n\nComment over LSSFuncStart:\nCan bypass the function design like GnrlPrsrInfctr function to implement the Repository Creation. To get familliar with use with GetFileFormatCmd and add prefixed-parameter LSSIsExtraction=[True/False] to test your compression design is throwing you correct parsing." ;
   
   
   if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    GVRIsName=True     \
    GVRIsSummary=True  \
    GVRIsSynopsis=True \
    GVRIsDesc=True     \
    GetVarReference ${__call_locality[1]} ; 
    echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ;
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    eval $( __GetVarReferenceList ) ;	
   elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
    eval $( eval \
      VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      VTVIsWhiteList=True         \
      VTVIsQuotedValue=True       \
      VTVWhiteListTransfert=UUID  \
      ValueToVariable ) __main_StopServices ; 
   elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
    #StrMsg="Application:${__call_locality[1]} , version:( versionTP:__VER_TP__ versionVTV:__VER_VTV__, versionCA:__VER_CA__, versionBVT:__VER_BVT__)" ; 
    #StrMsg=${StrMsg//__VER_CA__/${versionCA}} ;
    #StrMsg=${StrMsg//__VER_TP__/${versionTP}} ;
    #StrMsg=${StrMsg//__VER_VTV__/${versionVTV}} ;
    #StrMsg=${StrMsg//__VER_BVT__/${versionBVT}} ;
    #VerbMsg=${StrMsg} VerbHeader="VERSION" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
    eval $( eval VersionApps ) ; 
    StrMsg=$( LoopShellScript --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    eval $( eval \
      VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsQuotedValue=True       \
      VTVIsValueToConvert=False   \
      ValueToVariable ) ${StrStartMain}
   fi  
 }

### end-if versionLSS
fi 

if [ "${versionNM:=0.0.0}" == "0.0.0" ] ; then 
  
 unset NtpdMonitor ; 
 function NtpdMonitor()
 {
   local StrHeader=$( ntpq -pn | head -n 2 ) ; 
   local StrContent ; 
   while [ 1 ] ; do 
    StrContent=$( ntpq -pn | head -n 7 | tail -n 5 | sort -g -k 5 ) ; 
    echo -ne "${StrHeader}\n${StrContent}\n"  ; 
    sleep 5 ; 
    clear ; 
   done
 }
fi

if [ "${versionNM:=0.0.0}" == "0.0.1" ] ; then 
 
 IntIsFunc=$( declare -F | egrep -c "NtpdMonitor" ) ; 
 if [ ${IntIsFunc:=0} -gt 0 ] ; then 
  unset $( NtpdMonitor --list  ) ; 
  unset $( GetVarReference NtpdMonitor | egrep -i "Function Member:" -A1 | tail -n1 | sed -r 's/,/ /g;s/[\t\ ]+/ /g' ) ; 
 fi 
 unset IntIsFunc ;
 
 function NtpdMonitor()
 {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( NM NtpdMonitor ) ;
    local Arg0="${ArrayArg[0]}" ; 
    local StrParentApps=${__call_locality[1]} ;
    local StrStartMain=${NMFuncStart:=__main_StartServices} ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=NtpdMonitor CAIsAddParent=False __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=NtpdMonitor CAIsAddParent=False CallArgument ) ;
   fi 

  local StrVarList=""
  
  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
   fi 
   local StrHeader=$( ntpq -pn | head -n 2 ) ; 
   local StrContent ; 
   while [ 1 ] ; do 
    StrContent=$( ntpq -pn | head -n 7 | tail -n 5 | sort -g -k 5 ) ; 
    echo -ne "${StrHeader}\n${StrContent}\n"  ; 
    sleep 5 ; 
    clear ; 
   done
  
  }
    local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
    local StrNameHelper;
    local StrSummary;
    local StrSynopsis;
    local StrDescription;
    
    
    if [ "${Arg0:=--startservices}" == "--help"	] ; then 
     GVRIsName=False     \
     GVRIsSummary=False  \
     GVRIsSynopsis=False \
     GVRIsDesc=False     \
     GetVarReference ${__call_locality[1]} ; 
     VerbMsg="${StrSwitchMessages}" VerbExtendedOut=True VerbState=True VerbEvalForm=False VerbFormated=False VerbDev=/dev/stderr Verbosis ;
    elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
     eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
     echo -ne """${ArgGet}\n""" ;
    elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
     eval $( __GetVarReferenceList ) ;	
    elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
     VerbMsg=${ArrayMsg[0]} VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolShowEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr Verbosis ;
     eval $( eval \
       VTVIsQuotedValue=True       \
       VTVIsArrayStyleInsert=True  \
       VTVValueEntry=${StrVarList} \
       VTVIsValueReAssign=True     \
       VTVIsValueToConvert=False   \
       ValueToVariable ) ${StrStartMain} ; 
    fi  

 }
fi
if [ "${versionNM:=0.0.0}" == "0.0.2" ] ; then 
 
 IntIsFunc=$( declare -F | egrep -c "NtpdMonitor" ) ; 
 if [ ${IntIsFunc:=0} -gt 0 ] ; then 
  unset $( NtpdMonitor --list  ) ; 
  unset $( GetVarReference NtpdMonitor | egrep -i "Function Member:" -A1 | tail -n1 | sed -r 's/,/ /g;s/[\t\ ]+/ /g' ) ; 
 fi 
 unset IntIsFunc ;
  
 function NtpdMonitor()
 {
   function Verbosis()
   {
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Verb Verbosis ) ; 
    local Arg0=${ArrayArg[0]} ; 
    local StrMsg=${VerbMsg:=__TEXT__} ; 
    local StrDevOut=${VerbDev:=/dev/stderr} ; 
    local IsVerboseState=${VerbState:=False} ;
    local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
    local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
    local IsDisplayFormatted=${VerbFormated:=True} ;
    local IsAppendMode=${VerbAppendDev:=False} ; 
    local IsExtendedOutput=${VerbExtendedOut:=False} ; 
    local ArrayArg=( $* ) ; 
    if [ "${IsVerboseState:=False}" == "True" ] ; then 
     if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
        echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
      else  
        echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
      fi
     else
      if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" ;  
       else
         echo "${StrMsg}" ;  
       fi
      else
       if [ "${IsAppendMode:=False}" == "True" ] ; then 
        if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
          echo -ne "${StrMsg}" >> ${StrDevOut} ;
        else
          echo "${StrMsg}" >> ${StrDevOut} ;
        fi
       else
        if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" > ${StrDevOut} ;
        else
         echo "${StrMsg}" > ${StrDevOut} ;
        fi 
       fi
      fi 
     fi 
    fi
   } 
   ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
  
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( NM NtpdMonitor ) ;
    local Arg0="${ArrayArg[0]}" ; 
    local StrParentApps=${__call_locality[1]} ;
    local StrStartMain=${NMFuncStart:=__main_StartServices} ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=NtpdMonitor CAIsAddParent=False __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=NtpdMonitor CAIsAddParent=False CallArgument ) ;
   fi 
  
  local StrPathLoopState=${NMLoopFile:=/var/cache/Fnct.D/Loop-NM-__UUID__} ;
  local StrUUIDInstance=${NMUUIDInstance:=Last-instance-UUID};
  local IntDefaultSleep=${NMSleepTime:=5} ; 
  local BoolShowEntry=${NMShowEntry:=False} ; 
  local BoolDisplayDebug=${NMDisplayDebug:=False} ; 
  local BoolShowInstance=${NMShowInstance:=True} ; 
  local UUID=${UUID:=${StrUUIDInstance}} ; 
  local StrVarList="UUID,BoolShowInstance,BoolDisplayDebug,BoolShowEntry,IntDefaultSleep,StrUUIDInstance,UUID,StrPathLoopState" ; 
  
  local -a ArrayMsg ;
  ArrayMsg[0]="Entry in function" ;  
  ArrayMsg[1]="Shutdown Instance ID:__UUID__, file: __FILE__" ;
  ArrayMsg[2]="Instance ID:__UUID__" ;
  
  function __main_StopServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StopServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
   fi 
   StrMsg=$( NtpdMonitor --get ArrayMsg[0] )
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolShowEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

   local StrUUID=${UUID};
   if [ "${StrUUID:=None}" == "None" ] ; then 
    StrUUID=${StrUUIDInstance} ; 
   fi 
   local StrPathLoopState=${StrPathLoopState//__UUID__/${StrUUID}} ; 
   StrMsg=$( NtpdMonitor --get ArrayMsg[1] ) ; 
   StrMsg=${StrMsg//__UUID__/${StrUUID}} ; 
   StrMsg=${StrMsg//__FILE__/${StrPathLoopState}} ; 
    
   VerbMsg=${StrMsg} VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolShowInstance} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   if [ -f ${StrPathLoopState} ] ; then 
    rm -f ${StrPathLoopState} ; 
   fi 
  }
     
  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
   fi 
   StrMsg=$( NtpdMonitor --get ArrayMsg[0] ) ;
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolShowEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

   local StrUUID=$( GetUAppsRegisterName=${StrParentApps} GetUTimeBased=True GetULoop=False GetUUID ) ; 
   
   StrMsg=$( NtpdMonitor --get ArrayMsg[2] ) ; 
   StrMsg=${StrMsg//__UUID__/${StrUUID}} ; 
   VerbMsg=${StrMsg} VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ;
   
   StrPathLoopState=${StrPathLoopState//__UUID__/${StrUUID}}
   touch ${StrPathLoopState} ; 
   
  
   ### Draw The Header.  
   local StrHeader=$( /usr/bin/ntpq -pn | head -n 2 ) ; 
   local StrContent ; 
   local StrMsg ; 
   while [ -f ${StrPathLoopState} ] ; do 
    StrContent=$( /usr/bin/ntpq -pn | /usr/bin/head -n 7 | /usr/bin/tail -n 5 | /usr/bin/sort -g -k 5 ); 
    StrMsg="${StrHeader}\n${StrContent}\n" ; 
    VerbMsg=${StrMsg}  VerbEvalForm=False VerbFormated=False VerbState=True VerbDev=/dev/stderr  Verbosis ;
    sleep ${IntDefaultSleep} ; 
    clear ; 
   done 
  } 

    local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
    local StrNameHelper="NtpdMonitor\t\tUtility To loop collected information from ntp.conf server information fro Network Time Protocol deamon";
    local StrSummary="Display a All column sorted by the column When to seek for weak server or instable server reference. " ; 
    local StrSynopsis="This is only using ntpq and basic parameter, was also used to monitor a python application.";
    local StrDescription="NtpdMonitor is uniquely to test the name ntpdshm python's module. Standing for Ntpd shared-memory a swig port of C code compiled memory reference. This was also to monitor the \"Off by one second\" script. It does produce a reference time different than behavior. By example where code looped inside a Python application does reduce by 1000 ms (or 1 sec) your Ntpd server and does reflect with command ntpq -nm. Also project started in 2016-2017 to simulate virtual station with qemu application, it does simulate problems of multiple stations experiencing synchronisation problems with File mapping Deamon Protocol like Unix NFS, samba protocol and different alternative to minimize synchronisation. Therefore it require different IP (or virtual localhost) with projected delay/jitter an this application does report if a server cause a fallback and/or cause delay in synchronisation." ;
    
    
    if [ "${Arg0:=--startservices}" == "--help"	] ; then 
     GVRIsName=True     \
     GVRIsSummary=True  \
     GVRIsSynopsis=True \
     GVRIsDesc=True     \
     GetVarReference ${__call_locality[1]} ; 
     VerbMsg="${StrSwitchMessages}" VerbExtendedOut=True VerbState=True VerbEvalForm=False VerbFormated=False VerbDev=/dev/stderr Verbosis ;
    elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
     eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
     echo -ne """${ArgGet}\n""" ;
    elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
     eval $( __GetVarReferenceList ) ;	
    elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
     eval $( eval \
       VTVIsQuotedValue=True \
       VTVIsArrayStyleInsert=True  \
       VTVValueEntry=${StrVarList} \
       VTVIsValueReAssign=True     \
       VTVIsValueToConvert=False   \
       VTVIsWhiteList=True         \
       VTVWhiteListTransfert=UUID  \
       ValueToVariable ) __main_StopServices ; 
    elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
     VerbMsg=${ArrayMsg[0]} VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolShowEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr Verbosis ;
     eval $( eval \
       VTVIsQuotedValue=True       \
       VTVIsArrayStyleInsert=True  \
       VTVValueEntry=${StrVarList} \
       VTVIsValueReAssign=True     \
       VTVIsValueToConvert=False   \
       ValueToVariable ) ${StrStartMain} ; 
    fi  

 }

fi 
### end-if versionNM


#unset $( Bzip2DataTool --list  ) ; 
#unset $( GetVarReference Bzip2DataTool | egrep -i "Function Member:" -A1 | tail -n1 | sed -r 's/,/ /g;s/[\t\ ]+/ /g' ) ; 

if [ "${versionB2DT:=0.0.0}" == "0.0.0" ] ; then 
 echo -ne "\n\033[01;33m**************************************************\n\033[01;43mNo Bzip2DataTool / Bzip2DataTool in version 0.0.0\n\033[00m\033[01;33m**************************************************\033[00m\n" ; 
fi
if [ "${versionB2DT:=0.0.0}" == "0.0.1" ] ; then 
 echo -ne "\n\033[01;33m************************************************************\n\033[00m\033[00m \033[01;45mNo Regression of Bzip2DataTool available in version 0.0.1\033[00m\n\033[00m\033[00m\033[01;33m************************************************************\033[00m\n\033[00m\033[00m" ; 
fi
if [ "${versionB2DT:=0.0.0}" == "0.0.2" ] ; then 

 IntIsFunc=$( declare -F | egrep -c "Bzip2DataTool" ) ; 
 if [ ${IntIsFunc:=0} -gt 0 ] ; then 
  unset $( StrPrefix=$( GetStdPrefixName Bzip2DataTool ) ; GetVarReference Bzip2DataTool | egrep -i "^Variable" | sed 's/\(Variable \)\('${StrPrefix}'[a-zA-Z0-9]*\)\( ,\)/\2/g' | tr '[:cntrl:]' ' '  ) ; 
  unset $( GetVarReference Bzip2DataTool | egrep -i "Function Member:" -A1 | tail -n1 | sed -r 's/,/ /g;s/[\t\ ]+/ /g' ) ; 
 fi 
 unset IntIsFunc StrPrefix ;

 function Bzip2DataTool()
 {
   function Verbosis()
   {
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Verb Verbosis ) ; 
    local Arg0=${ArrayArg[0]} ; 
    local StrMsg=${VerbMsg:=__TEXT__} ; 
    local StrDevOut=${VerbDev:=/dev/stderr} ; 
    local IsVerboseState=${VerbState:=False} ;
    local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
    local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
    local IsDisplayFormatted=${VerbFormated:=True} ;
    local IsAppendMode=${VerbAppendDev:=False} ; 
    local IsExtendedOutput=${VerbExtendedOut:=False} ; 
    local ArrayArg=( $* ) ; 
    if [ "${IsVerboseState:=False}" == "True" ] ; then 
     if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
        echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
      else  
        echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
      fi
     else
      if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" ;  
       else
         echo "${StrMsg}" ;  
       fi
      else
       if [ "${IsAppendMode:=False}" == "True" ] ; then 
        if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
          echo -ne "${StrMsg}" >> ${StrDevOut} ;
        else
          echo "${StrMsg}" >> ${StrDevOut} ;
        fi
       else
        if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" > ${StrDevOut} ;
        else
         echo "${StrMsg}" > ${StrDevOut} ;
        fi 
       fi
      fi 
     fi 
    fi
   } 
   ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( B2DT Bzip2DataTool ) ;
    local Arg0="${ArrayArg[0]}" ; 
    local StrParentApps=${__call_locality[1]} ;
    local StrStartMain=${B2DTFuncStart:=__main_StartServices} ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=Bzip2DataTool CAIsAddParent=False __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=Bzip2DataTool CAIsAddParent=False CallArgument ) ;
   fi 

  ### Variable common to All.
  local -a ArraySpecialChar=( "\`" "'" "|" ) ; 
  local StrExecutiveChar=${B2DTExecutiveCharCmd:=${ArraySpecialChar[0]}} ; 
  local StrSingleQuote=${B2DTSingleQuoteCmd:=${ArraySpecialChar[1]}} ; 
  local StrPipeCmd=${B2DTPipeCmd:=${ArraySpecialChar[2]}} ;
  local StrSuffixFile=${B2DTBzip2Suffix:=.repair} ; 
 
  local StrRegXBlockFileContent=${B2DTRegXFile:='"^[\t\ ]*writing block [0-9]*"'} ;
  local StrRegXBlockHeader=${B2DTRegXHeader:='"^[\t\ ]*block [0-9]*"'} ;
  local StrSubRegExpFileContent=${B2DTSubRegXFile:='"block __INT__ to"'}
  local StrSubRegExpHeader=${B2DTSubRegXHeader:='"block __INT__ runs"'}
  local StrAppsHead=${B2DTAppsRangeStart:=/usr/bin/head} ;
  local StrAppsHeadOpt=${B2DTAppsRangeStartOpt:=-n 1} ;
  local StrAppsTail=${B2DTAppsRangeEnd:=/usr/bin/tail} ;
  local StrAppsTailOpt=${B2DTAppsRangeEndOpt:=-n 1} ;

  ### Variable Member for BlockFile,  BlockInformation
  local StrBlockFileRef=${B2DTFileCount:=block-count.txt} ; 
   
  ### Variable Member for BlockExtraction 
  local StrFilter2Apps=${B2DTFilter2:=/usr/bin/cut} ; 
  local StrFilter2AppsOpt=${B2DTFilter2Opt:=-d \' \' -f 3} ; 
  local StrAppsRange=${B2DTAppsRange:=/bin/grep} ;
  local StrFilter1Apps=${B2DTFilter1:=/bin/sed} ; 
  local StrFilter1AppsOpt=${B2DTFilter1Opt:=-r \'s/\ +/ /g\'} ; 
  
  ### Variable Member for BlockFile
  local StrFileRecover=${B2DTBzip2File:=PathDocuments/work-PathDocuments-maxiste.tar.bz2} ;
  local StrAppsRecover=${B2DTAppsRecovery:=/bin/bzip2recover} ; 
  local BoolMoveBlocToPath=${B2DTMoveBlockToPath:=False} ; 
  local StrBlockPath=${B2DTBlockLocation:=./} ; 
  
  ### Variable Member for BlockCreation
  local StrFileRepair=${StrFileRecover//.bz2/${StrSuffixFile}.bz2}

  ### Variable Member for BlockInformation 
  local StrFilter3Apps=${B2DTFilter3:=/usr/bin/cut} ; 
  local StrFilter3AppsOpt=${B2DTFilter3Opt:=-d \' \' -f 6,8} ; 
  local StrFilter4Apps=${B2DTFilter3:=/usr/bin/cut} ; 
  local StrFilter4AppsOpt=${B2DTFilter3Opt:=-d \' \' -f 6} ; 
  local StrFilter5Apps=${B2DTFilter5:=/bin/sed} ;
  local StrFilter5AppsOpt=${B2DTFilter5Opt:=\'s/^[\\__EXECCHR____SINGLQUT__\\__SINGLQUT____SINGLQUT__]//g;s/.[\\__EXECCHR____SINGLQUT__\\__SINGLQUT____SINGLQUT__]//g\'} ; 
  
  ### Pair Tpl/Parser for BlockCreation 
  ### other dd flag: status=none oflag=append seek=0
  
  local StrBCApps=${B2DTAppsBC:=/bin/dd} ;
  local StrBCAppsStatus=${B2DTBCStatus:='status=none'} ;
  local StrBCAppsOFlags=${B2DTBCOFlags:='oflag=append'} ;
  local StrBCAppsBSOpt=${B2DTBCOBS:='bs=__INTSIZE__'} ; 
  local StrBCAppsOptTpl=${B2DTBCOpt:='__APPSBC__ if=__BLOCK_FILE__ of=__FILE_REPAIR__ __APPSBCOPT__'}
  local StrBCAppsHdrOptTpl=${B2DTBCAppsHdrOpt:='__BLOCK_SIZE__ __STATUS__'}
  local StrBCAppsCntOptTpl=${B2DTBCAppsCntOpt:='__BLOCK_SIZE__ __OFLAGS__ seek=__SIZE__ __STATUS__'};
  local StrBCAppsParser=${B2DTBCAppsParser:=StrBCApps:__APPSBC__,StrFileRepair:__FILE_REPAIR__} ; 
  
  local -A ArrayFileCreation;
  ArrayFileCreation["header"]="StrBCAppsHdrOptTpl:__APPSBCOPT__,StrBCAppsBSOpt:__BLOCK_SIZE__,StrBCAppsStatus:__STATUS__" ; 
  ArrayFileCreation["content"]="StrBCAppsCntOptTpl:__APPSBCOPT__,StrBCAppsBSOpt:__BLOCK_SIZE__,StrBCAppsOFlags:__OFLAGS__,StrBCAppsStatus:__STATUS__" ; 
  ### End-Pair Tpl/Parser for BlockCreation
  
  ### Pair Tpl/Parser for BlockFile
  local StrRecoverParser=${B2DTAppsRecoverParser:=StrBlockFileRef:__BLOCK_FILE__,StrFileRecover:__FILE_RECOVER__,StrAppsRecover:__APPS_RECOVER__} ;
  local StrAppsRecoverTpl=${B2DTAppsRecoverTpl:='__APPS_RECOVER__ __FILE_RECOVER__'} ;
  
  ### Pair Tpl/Parser for BlockExtraction 
  local StrRangeParser=${B2DTRangeParser:=StrPipeCmd:__PIPE__,StrAppsRange:__APPS_RANGE__,StrRegXBlockHeader:__REGEXP__,StrBlockFileRef:__BLOCK_FILE__,StrFilter1Apps:__FILTER1__,StrFilter1AppsOpt:__FILTER1OPT__,StrFilter2Apps:__FILTER2__,StrFilter2AppsOpt:__FILTER2OPT__} ;
  local StrAppsRangeTpl=${B2DTAppsRangeTpl:=__APPS_RANGE__ __REGEXP__ __BLOCK_FILE__ __PIPE__ __RANGETYPEAPPS__ __RANGETYPEAPPSOPT__ __PIPE__ __FILTER1__ __FILTER1OPT__ __PIPE__ __FILTER2__ __FILTER2OPT__} ;
  
  ### Pair Tpl/Parser for BlockInformation
  local StrBlockInforParser=${B2DTInfoParser:=StrAppsRange:__APPS_RANGE__,StrBlockFileRef:__BLOCK_FILE__,StrFilter1Apps:__FILTER1__,StrFilter1AppsOpt:__FILTER1OPT__,StrFilter3Apps:__FILTER3__,StrFilter3AppsOpt:__FILTER3OPT__,StrFilter4Apps:__FILTER4__,StrFilter4AppsOpt:__FILTER4OPT__,StrFilter5Apps:__FILTER5__,StrFilter5AppsOpt:__FILTER5OPT__,StrExecutiveChar:__EXECCHR__,StrSingleQuote:__SINGLQUT__,StrPipeCmd:__PIPE__} ;
  local StrAppsBlockInfoTpl=${B2DTAppsBlockInfo:=__APPS_RANGE__ __REGEXP__ __BLOCK_FILE__ __PIPE__ __APPS_RANGE__ \"__REGEXP2__\" __PIPE__ __POST_FILTER__}
  local StrBlkInfoTplRank=${B2DTAppsBlkInfoRnkTpl:= __FILTER1__ __FILTER1OPT__ __PIPE__ __FILTER3__ __FILTER3OPT__}
  local StrBlkInfoTplHeader=${B2DTAppsBlkInfoHdrTpl:=__FILTER1__ __FILTER1OPT__ __PIPE__ __FILTER4__ __FILTER4OPT__ __PIPE__ __FILTER5__ __FILTER5OPT__}
  
  ### Bolean to change Event controlled inside __main_StartServices 
  local BoolGenerateBlockFile=${B2DTGenerateBlockFile:=False} ; 

  
  ### Common Boolean to allow display some debug content 
  local BoolDisplayDebug=${B2DTDisplayDebug:=False} ; 
  local BoolParserInfo=${B2DTParserDebug:=False}
  local BoolShowEntry=${B2DTShowEntryFunc:=True} ; 
  local BoolShowEvalCmd=${B2DTShowEvalCmd:=False}
  
  local StrVarList="StrBCApps,StrBCAppsStatus,StrBCAppsOFlags,StrBCAppsBSOpt,StrBCAppsOptTpl,StrBCAppsHdrOptTpl,StrBCAppsCntOptTpl,StrBCAppsParser,StrSuffixFile,StrFileRepair,StrBlockFileRef,StrFileRecover,StrRecoverParser,StrAppsRecoverTpl,StrAppsRecover,StrRegXBlockHeader,StrRegXBlockFileContent,StrAppsHead,StrAppsTail,StrAppsRange,StrRangeParser,BoolDisplayDebug,BoolShowEntry,BoolParserInfo,BoolGenerateBlockFile,BoolShowEvalCmd,StrAppsRangeTpl,StrPipeCmd,StrFilter2AppsOpt,StrFilter2Apps,StrFilter1AppsOpt,StrFilter1Apps,StrAppsTailOpt,StrAppsHeadOpt" ;
  
  local -a ArrayMsg ;
  ArrayMsg[0]="Entry in function" ;   
  ArrayMsg[1]="Remain Parser Extracted from : \n\tBEExtraction:__VALUE__\n\tcontent:__TAG__" ; 
  ArrayMsg[2]="CmdLine: __CMD__";
  ArrayMsg[3]="Remain Template from StrAppsRecoverTpl: content:__TAG__" ; 
  ArrayMsg[4]="Remain Template from __VARNAME__: content:__TAG__" ; 
  ArrayMsg[5]="Inspecting Variable:__VAR__, Value: __VALUE__" ; 
  ArrayMsg[6]="Test Array Extraction: ArrayName:__ARRAY__, Index:__INDEX__, PairName:__PAIR__, Value:__VALUE__" ; 
  ArrayMsg[7]="Source Code __SEGNAME__ at Line __LINE__" ; 
  
  local -A ArrayFileRank;
  ArrayFileRank["start"]="StrAppsHeadOpt:__RANGETYPEAPPSOPT__,StrAppsHead:__RANGETYPEAPPS__" ;
  ArrayFileRank["end"]="StrAppsTailOpt:__RANGETYPEAPPSOPT__,StrAppsTail:__RANGETYPEAPPS__" ;
  ArrayFileRank["Rank"]="StrBlkInfoTplRank:__POST_FILTER__,StrRegXBlockHeader:__REGEXP__,StrSubRegExpHeader:__REGEXP2__" ;
  ArrayFileRank["Header"]="StrBlkInfoTplHeader:__POST_FILTER__,StrRegXBlockFileContent:__REGEXP__,StrSubRegExpFileContent:__REGEXP2__" ; 

  
  

  ### Required to test the BlockInformation from Prefixed-variable Query 
  ### B2DTFuncStart=BlockInformation
  local -A ArrayFileHeader ; 
  
  
  ### function BlockCreation
  ### 
  ### This function does mapping The repaired file . It require to paste the Header from 
  ### the old file, and know the whole size of the file. After it append information
  ### block after block. 
  ### 
  ### Decription : Function work with two possibles modes :
  ###  - Mode Header-Creation 
  ###  - Mode Content-Creation 
  ### 
  ### Requirement : 
  ###  - Mode Header-Creation 
  ###   - Require the file-name 
  ###   - require block location of 1st rank . 
  ###   - Suffix Bzip2 to create the new file. 
  ### 
  ###  - Mode Content-Creation 
  ###   - Require the file-name 
  ###   - require all information of block location  
  ###   - require all information of file.
  ###   - Suffix Bzip2 to append to the new file. 
  ### 
  function BlockCreation()
  { 
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( BC BlockCreation ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=BlockCreation CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=BlockCreation CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
   fi 
   StrMsg=$( Bzip2DataTool --get ArrayMsg[0] ) ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolShowEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   local -A ArrayCmdEval ;
   local StrAction=${BCAction:=header} ; 
   local IntStartLineNo ; 
   
   local StrMsgTplCode=$( Bzip2DataTool --get ArrayMsg[7] ) ; 
   
   local StrLocalParser=$( Bzip2DataTool --get ArrayFileCreation[${StrAction}] ) ; 
   
   local StrTagParser="${StrLocalParser},${StrBCAppsParser},${StrFileBlock}" ;
   
   local StrVarNameP="StrParser${__call_locality[0]}" ;
   
   eval """local ${StrVarNameP}=\"${StrBCAppsOptTpl}\"""" ; 


   eval $( eval TPListTag=${StrTagParser}  \
       TPArrayName=Array${__call_locality[0]}  \
       TPVarNameParsed="${StrVarNameP}"     \
       TPDisplayDebug=${BoolParserInfo}     \
       TPDisplayParserNotice=${BoolParserInfo} \
       TagParser ) ; 
   
   StrMsg=$( Bzip2DataTool --get ArrayMsg[2] ) ;
   eval "StrMsg=\${StrMsg//__CMD__/\${${StrVarNameP}}}" ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;


   IntStartLineNo=${LINENO} ;    
   StrMsg=${StrMsgTplCode//__LINE__/${IntStartLineNo}} ; 
   StrMsg=${StrMsg//__SEGNAME__/Markup} ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-LINENO" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
   ArrayCmdEval["header"]="""
   \$( GAIVarName=StrFileBlock GAIArrayName=ArrayFileHeader GAIIndex=1 GAIPairName=file GetArrayItem ) ; 
   ${StrVarNameP}=\${${StrVarNameP}\/\/__BLOCK_FILE__\/\${StrFileBlock}} ; 
   \${${StrVarNameP}} ; 
   """ ; 
   
   ArrayCmdEval["content"]="""
   """ ; 

   IntStartLineNo=${LINENO} ;
   StrMsg=${StrMsgTplCode//__LINE__/${IntStartLineNo}} ; 
   StrMsg=${StrMsg//__SEGNAME__/Start} ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-LINENO" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
   StrMsg=$( Bzip2DataTool --get ArrayMsg[2] ) ; 
   StrMsg=${StrMsg/__CMD__/${ArrayCmdEval[${StrAction}]}} ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
   IntEndLineNo=${LINENO} ;    
   
   StrMsg=${StrMsgTplCode//__LINE__/${IntEndLineNo}} ; 
   StrMsg=${StrMsg//__SEGNAME__/End} ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-LINENO" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   #echo -ne "${ArrayCmdEval[${StrAction}]}" ; 
 
  }
  
  
  function GetArrayItem()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( GAI GetArrayItem ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=GetArrayItem CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=GetArrayItem CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
   fi 
   StrMsg=$( Bzip2DataTool --get ArrayMsg[0] ) ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolShowEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
   local StrArrayName=${GAIArrayName:=Array} ; 
   local StrIndexName=${GAIIndex:=None} ; 
   local StrPairName=${GAIPairName:=None} ; 
   local StrVarName=${GAIVarName:=StrItem} ; 
   ### -> 1 local StrMsg=\"Variable StrTmpPair Value:[__TMPVALUE__]\\\nVariable StrTmpTestPair Value:[__TEST_PAIR__]\" ;
   ### -> 2 StrMsg=\${StrMsg//__TMPVALUE__/\${StrTmpValue}} ;
   ###      StrMsg=\${StrMsg//__TEST_PAIR__/\${StrTmpTestPair}} ;
   ###      VerbMsg=\${StrMsg} VerbHeader=\"\${__call_locality[1]}-DEBUG\" VerbState=\${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
   local StrMsgTplCode=$( Bzip2DataTool --get ArrayMsg[7] ) ; 
   
   local IntStartLineNo=${LINENO} ;    
   
   #local StrEvalCmd="""
   #local StrTmpValue=\${${StrArrayName}[${StrIndexName}]};
   #local ArrayTmp=( \${StrTmpValue//;/ } ) ; 
   #local StrTmpPair;
   #local StrTmpTestPair ; 
   #local IntPairLen; 
   #local IntPairTestLen ;
   #local StrPairName ; 
   #local StrPairValue ; 
   #local IntC=0 ; 
   #local IntMaxCount=\${#ArrayTmp[@]} ;
   
   #for (( IntC=0 ; IntC <= \${IntMaxCount} - 1 ; IntC++ )) ; do 
    #StrTmpPair=\"\${ArrayTmp[\${IntC}]}\" ; 
    #StrTmpTestPair=\"\${StrTmpPair/#${StrPairName}:}\" ; 
    #IntPairLen=\${#StrTmpPair} ; 
    #IntPairTestLen=\${#StrTmpTestPair} ;
    #if [ \${IntPairLen:=0} -ne \${IntPairTestLen:=0} ] ; then
     #${StrVarName}=\"\${StrTmpTestPair}\" ;
    
    #fi  
   #done ;
   #echo -ne \"\${${StrVarName}}\"
   #""" ;
   local StrEvalCmd="""
   local StrTmpValue=\"\${${StrArrayName}[${StrIndexName}]}\";
   local ArrayTmp=( \${StrTmpValue//;/ } ) ; 
   local StrTmpPair;
   local StrTmpTestPair ; 
   local IntPairLen; 
   local IntPairTestLen ;
   local StrPairName ; 
   local StrPairValue ; 
   local IntC=0 ; 
   local IntMaxCount=\${#ArrayTmp[@]} ;
   local StrMsg=\"Variable StrTmpPair Value:(__TMPVALUE__)\\\nVariable StrTmpTestPair Value:(__TEST_PAIR__)\" ;
   for (( IntC=0 ; IntC <= \${IntMaxCount} - 1 ; IntC++ )) ; do 
    StrTmpPair=\"\${ArrayTmp[\${IntC}]}\" ; 
    StrTmpTestPair=\"\${StrTmpPair/#${StrPairName}:}\" ; 
    IntPairLen=\${#StrTmpPair} ; 
    IntPairTestLen=\${#StrTmpTestPair} ;
    if [ \${IntPairLen:=0} -ne \${IntPairTestLen:=0} ] ; then
     ${StrVarName}=\"\${StrTmpTestPair}\" ;
     StrMsg=\${StrMsg//__TMPVALUE__/\${StrTmpValue}} ;
     StrMsg=\${StrMsg//__TEST_PAIR__/\${StrTmpTestPair}} ;
     VerbMsg=\${StrMsg} VerbHeader=\"\${__call_locality[1]}-DEBUG\" VerbState=\${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    fi  
   done ;
   echo -ne \"\${${StrVarName}}\"
   """ ;
   local IntEndLineNo=${LINENO} ;    
   
   StrMsg=${StrMsgTplCode//__LINE__/${IntStartLineNo}} ; 
   StrMsg=${StrMsg//__SEGNAME__/Start} ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-LINENO" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
   ### Output the StrEvalCmd as Debug Display to STDERR. 
   StrMsg=$( Bzip2DataTool --get ArrayMsg[2] ) ; 
   VerbMsg="${StrMsg/__CMD__/${StrEvalCmd}}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
   ### Output the StrEvalCmd to STDOUT. 
   VerbMsg="${StrEvalCmd}" VerbState=True VerbEvalForm=True VerbFormated=False Verbosis ;
   
   StrMsg=${StrMsgTplCode//__LINE__/${IntEndLineNo}} ; 
   StrMsg=${StrMsg//__SEGNAME__/End} ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-LINENO" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
  }
  
  function BlockInformation()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( BI BlockInformation ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=BlockInformation CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=BlockInformation CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
   fi 
   StrMsg=$( Bzip2DataTool --get ArrayMsg[0] ) ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolShowEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   local IntStartBlock=${BIStartBlock:=0} ; 
   local IntEndBlock=${BIEndBlock:=0} ; 
   local StrArrayName=${BIArrayName:=ArrayFileHeader} ;
   
   ### StrIdName is under This name all paired information
   ### from Query inside StrBlockFileRef will be stored inside 
   ### StrArrayName. 
   ### like form ArrayFileHeader[BlockID]=${ArrayFileHeader[BlockID]};StrIdName:Value
   ### StrIdName can be either location / file 
   ### When StrIdName = location, value are Begin,End of a Block
   ### When StrIdName = file , value are FileName. 
   local StrIdName=${BIIndexStoreName:=location} ; 
     
   ### StrFieldLineExtr is a default index in an associative 
   ### array where some extra definition for TagParser 
   ### are stored. Depending of call of BlockInformation
   ### with BILineExtractionField=Rank or 
   ### BILineExtractionField=Hearder it extract 
   ### where is the HEADER goes inside a File ( Start location and End location of the date)
   ### while calling BILineExtractionField=Hearder will give the 
   ### file-namededicated to the block to place inside our 
   ### re-constructed Bzip2 file. 
   local StrFieldLineExtr=${BILineExtractionField:=Rank} ;
   
   local StrTagParser=$( Bzip2DataTool --get ArrayFileRank[${StrFieldLineExtr}] ) ; 
   StrTagParser="${StrTagParser},${StrBlockInforParser}" ;
   
   ### Value Inspection
   StrMsgTpl=$( Bzip2DataTool --get ArrayMsg[5] ) ;
   StrMsg=${StrMsgTpl//__VAR__/StrBlockInforParser} ;   
   StrMsg=${StrMsg//__VALUE__/${StrBlockInforParser}} ;   
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-Variable" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
   ### Value Inspection
   StrMsgTpl=$( Bzip2DataTool --get ArrayMsg[5] ) ;
   StrMsg=${StrMsgTpl//__VAR__/ArrayFileRank[${StrFieldLineExtr}]} ;   
   StrMsg=${StrMsg//__VALUE__/${StrTagParser}} ;   
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-Variable" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
   ### Require to Parse the Command Query to allow having one 
   ### The IntX to parse from __INT__ from sub-regular-expression 
   ### StrSubRegExpHeader or StrSubRegExpFileContent . 
   local StrVarNameP="StrParser${__call_locality[0]}" ;
   eval """local ${StrVarNameP}=\"${StrAppsBlockInfoTpl}\"""" ; 
   
   StrMsgTpl=$( Bzip2DataTool --get ArrayMsg[4] ) ;
   StrMsg=${StrMsgTpl//__VARNAME__/${StrVarNameP}} ;   
   eval "StrMsg=\${StrMsg//__TAG__/\${${StrVarNameP}}}" ;   
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-TPL" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

   StrMsg=${StrMsgTpl//__VARNAME__/StrTagParser} ;   
   StrMsg=${StrMsg//__TAG__/${StrTagParser}};
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-Parser" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
   eval $( eval TPListTag=${StrTagParser}  \
       TPArrayName=Array${__call_locality[0]}  \
       TPVarNameParsed="${StrVarNameP}"     \
       TPDisplayDebug=${BoolParserInfo}     \
       TPDisplayParserNotice=${BoolParserInfo} \
       TagParser ) ;   

   StrMsg=$( Bzip2DataTool --get ArrayMsg[2] ) ; 
   eval """StrMsg=\${StrMsg//__CMD__/\${${StrVarNameP}}}"""  ;
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
   local IntX=0 ; 
   local StrLoopParser ; 
   local StrValueFromCmd ; 
   local StrAllEvalCmd ; 
   local StrPartBodyEvalCmd ;
   local StrPartBodyEvalCmdTpl ;  
   local StrStartEvalCmd="local StrContentArray ; local IntLenCA ;" ; 
   local StrEndEval="unset StrContentArray IntLenCA ; " ;
   ### Suggested replacement:
   ### Not implemented yet but should give same result. 
   ### - This taking the advantage of Life-Cycle Termination of BVTVarName="StrContentArray" allowing 
   ### another variable to exist.
   ### Imply to Add BVTIsPrmblVarCylceEnd=True, 
   ### must require BVTNewVarAssertion=VariableName in this case \${StrArrayName}[\${IntX}] is 
   ### the Associative array with it's allocation. Index is in Int but should be about anything
   ### 
   ### Exceptionnally here the type of If-Test is based on Integer format rather than String ? 
   ###  - It's evaluation from code injection does not instantly evaluate Deep Variable field
   ### Inside the __main_StartServices, line to call the code for BlockInformation stipulate 
   ### eval $( eval $(
   ###        VTV
   ###        ...
   ###        ValueToVariable ) BI
   ###                          ...
   ###                          BlockInformation ) 
   ### A double evaluation with Double Executive brace which remove per evaluation a back-quoted 
   ### '\' Back-slash and from un-back-slashed variable it transform it's value and remain back-quoted, 
   ### back-slashed variable will lost their '\' or last evaluation or an error should pop-out... 
   ### So this case suggest working with variable without quote to let back-quoting with back-slash
   ### not interfering in evaluation. So it's important to prefer having default value exist in 
   ### in common uses of BVTBoolVarName and forget about possibility to replace a variable ${__VAR__}
   ### by $__VAR__ it's exclued from codeability and this code is entirely existing for full brace 
   ### the variable by their Expanser operator ( expanser are '{' and '}' ) .
   ### 
   ### suggestion for replacement :
   ### StrPartBodyEvalCmd=$( BVTIsPreambule=True BVTIdType=4 BVTVarName="StrContentArray" BVTIsPrmblVarCylceEnd=True BVTNewVarAssertion=\${StrArrayName}[\${IntX}] BVTVarHold=\${ArrayFileHeader[\${IntX}]} BVTBoolVarName=\\\"\\\\\${StrContentArray:=None}\\\" BVTIfType=Int BVTBoolCase=\\\"None\\\" BVTBoolAssertion="\"\${StrIdName}:\${StrValueFromCmd};\""  BoolVarTest ; \
   ### BVTIsPreambule=False BVTIdType=5 BVTVarName=\${StrArrayName}[\${IntX}] BVTVarHold=\${ArrayFileHeader[\${IntX}]}   BVTBoolAssertion="\\\";\${StrIdName}:\${StrValueFromCmd}\\\""  BoolVarTest ) ; 
   ### 
   ### And for the exam, of course removing the eval from StrPartBodyEvalCmd prevent parsing the 
   ### String uselessly and allow the generated list of code for adding Block locating inside the 
   ### Associative Array does display the code by removing the other eval from calling BlockInformation
   ### or leaving the eval does let exist the assciative array with the information. 
   ### 
   
   StrPartBodyEvalCmdTpl="""
   StrContentArray=\"\${${StrArrayName}[__INTX__]}\" ; 
   IntLenCA=\${#StrContentArray} ;
   if [ \${IntLenCA:=0} -eq 0 ] ; then
    ${StrArrayName}[__INTX__]=\"__PAIR_NAME__:__PAIR_VALUE__\" ;
   else
    ${StrArrayName}[__INTX__]=\"\${StrContentArray};__PAIR_NAME__:__PAIR_VALUE__\";
   fi ;
   """ ; 
        
   for (( IntX=${IntStartBlock} ; IntX <= ${IntEndBlock} ; IntX++ )) ; do 
     StrValueFromCmd="" ; 
     eval StrLoopParser=\${${StrVarNameP}} ; 
     StrLoopParser=${StrLoopParser//__INT__/${IntX}};
     eval "StrValueFromCmd=\$( ${StrLoopParser} )" ; 
     StrMsg="Variable StrValueFromCmd, value:[__VALUE__]" ; 
     VerbMsg="${StrMsg//__VALUE__/${StrValueFromCmd}}" VerbHeader="${__call_locality[1]}-CMDLINE-LOOP" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
     
     if [ "${StrIdName:=location}" == "location" ] ; then 
      ### in case StrIdName==location we do own 2 data, begin and end of a 
      ### block, this require to add a CSV to separate the information
      StrValueFromCmd=${StrValueFromCmd// /,} ; 
     fi 
     ### External part, this are echoed and evaluated by the calling 
     ### Member which is __main_StartServices or called by B2DTFuncStart which is 
     ### located at root level of the function. ( in this case another Associative 
     ### array must exist or information won't rely exist if BlockInformation is 
     ### calling nobody ) . 
     
     StrCpBodyTmp=${StrPartBodyEvalCmdTpl} ; 
     StrCpBodyTmp=${StrCpBodyTmp//__INTX__/${IntX}} ; 
     StrCpBodyTmp=${StrCpBodyTmp//__PAIR_NAME__/${StrIdName}} ; 
     StrCpBodyTmp=${StrCpBodyTmp//__PAIR_VALUE__/${StrValueFromCmd}} ; 


     StrBodyEvalCmd="${StrBodyEvalCmd} ${StrCpBodyTmp}" ; 
   done 
   StrAllEvalCmd="${StrStartEvalCmd} ${StrBodyEvalCmd} ${StrEndEval}" ; 
   StrMsg=$( Bzip2DataTool --get ArrayMsg[2] ) ; 
   StrMsg=${StrMsg//__CMD__/${StrAllEvalCmd}}  ;
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbState=${BoolShowEvalCmd} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
   echo -ne "${StrAllEvalCmd}" ; 
  }

  
  function BlockFile( )
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( BF BlockFile ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=BlockFile CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=BlockFile CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
   fi
   StrMsg=$( Bzip2DataTool --get ArrayMsg[0] ) ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolShowEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
   local StrVarNameP=StrParser${__call_locality[0]} ;
   eval """local ${StrVarNameP}=\"${StrAppsRecoverTpl}\"""" ; 
   
   StrMsg=$( Bzip2DataTool --get ArrayMsg[3] ) ;
   StrMsg=${StrMsg//__TAG__/${StrAppsRecoverTpl}} ;   
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-TPL" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
   eval $( eval TPListTag=${StrRecoverParser}   \
       TPArrayName=Array${__call_locality[0]}    \
       TPVarNameParsed="${StrVarNameP}" \
       TPDisplayDebug=${BoolParserInfo}        \
       TPDisplayParserNotice=${BoolParserInfo} \
       TagParser ) ;   
   
   StrMsg=$( Bzip2DataTool --get ArrayMsg[2] ) ; 
   eval """StrMsg=\${StrMsg//__CMD__/\${${StrVarNameP}}}"""  ;
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
   #eval "\${${StrVarNameP}}" ;    
   eval "\${${StrVarNameP}}" 2> ${StrBlockFileRef}  ; 
   
  
  }
  
  function BlockExtraction()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( BE BlockExtraction ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=BlockExtraction CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=BlockExtraction CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
   fi
   ###grep "^[\t\ ]*block [0-9]*" block-count.txt | head -n1  
   StrMsg=$( Bzip2DataTool --get ArrayMsg[0] ) ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolShowEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
   local StrParserBE=${StrAppsRangeTpl} ;
   
   local StrExtractionType=${BEExtraction:=start} ; 
   
   local StrTagParser=$( Bzip2DataTool --get ArrayFileRank[${StrExtractionType}] ) ; 
   StrTagParser="${StrRangeParser},${StrTagParser}" ;
   
   StrMsg=$( Bzip2DataTool --get ArrayMsg[1] ) ;
   StrMsg=${StrMsg//__VALUE__/${StrExtractionType}} ; 
   StrMsg=${StrMsg//__TAG__/${StrTagParser}} ; 
    
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
   eval $( eval \
       TPListTag=${StrTagParser}               \
       TPArrayName=Array${__call_locality[0]}  \
       TPVarNameParsed="StrParserBE"           \
       TPDisplayDebug=${BoolParserInfo}        \
       TPDisplayParserNotice=${BoolParserInfo} \
       TagParser ) ; 
   
   StrMsg=$( Bzip2DataTool --get ArrayMsg[2] ) ; 
   StrMsg=${StrMsg//__CMD__/${StrParserBE}} ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
       
   eval ${StrParserBE} ; 
  }
  
  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
   fi 
   StrMsg=$( Bzip2DataTool --get ArrayMsg[0] ) ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolShowEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

   ### This Associative array will store By Index :
   ### Index ---> referred to Block ID
   ### each index will hold, 
   ### 1-> block start-offset 
   ### 2-> end-offset
   ### 3-> corresponding segment 
   ### Required to test the BlockInformation from __main_StartServices function by
   ### not using  
   ### B2DTFuncStart=BlockInformation but B2DTFuncStart=__main_StartServices which is 
   ### the default case. 
   local -A ArrayFileHeader ;
   
   local -A ArrayGroupAssociate ;
   ArrayGroupAssociate["Rank"]="location"
   ArrayGroupAssociate["Header"]="file" ;  
   
   ### Used for Association in BlockExtraction function require
   ### BEExtraction Prefixed parameter for seeking in head or bottom
   ### of the file to search for first and last block information . 
   local -a ArrayIndex=( IntStartBlock:start IntEndBlock:end ) ; 
   local IntStartBlock ;
   local IntEndBlock ; 
   local StrLeftPair ; 
   local StrRightPair ;
   
   local StrVarBEList="StrAppsRangeTpl,StrExtractionType,StrRangeParser,BoolShowEntry,BoolParserInfo,BoolDisplayDebug,BoolShowEvalCmd" ; 
   local StrVarBFList="StrBlockFileRef,StrAppsRecoverTpl,StrRecoverParser,BoolDisplayDebug,BoolParserInfo,BoolShowEntry,BoolShowEvalCmd" ; 
   local StrVarBIList="StrBlockInforParser,StrAppsBlockInfoTpl,BoolDisplayDebug,BoolParserInfo,BoolShowEntry,BoolShowEvalCmd" ; 
   local StrVarBCList="StrBCApps,StrBCAppsStatus,StrBCAppsOFlags,StrBCAppsBSOpt,StrBCAppsOptTpl,StrBCAppsHdrOptTpl,StrBCAppsCntOptTpl,StrBCAppsParser,StrFileRepair,BoolDisplayDebug,BoolParserInfo,BoolShowEntry,BoolShowEvalCmd" ;
   
   ### In case Block-File don't exist or require to generate a new-one . 
   ### This is also controlled by B2DTGenerateBlockFile( BoolGenerateBlockFile )
   ### 
   eval $( eval                 \
     BVTIsPreambule=False       \
     BVTIsValueToVarAssert=True \
     BVTBoolVarName=\${BoolGenerateBlockFile:=False} \
     BVTBoolCase=True           \
     BVTVTFnctA=BlockFile       \
     BVTVTVVarA=${StrVarBFList} \
     BVTIdType=0                \
     BoolVarTest                ) ; 
   
   ###
   ### This section will extract 
   ### - first instance the Location information where to put the 
   ### Block-file information
   ### - second instance the file-name of the block-file. 
   ### 
   for StrIndexIter in ${ArrayIndex[@]} ; do 
     StrLeftPair=${StrIndexIter/%:[a-zA-Z0-9]*} ; 
     StrRightPair=${StrIndexIter/#${StrLeftPair}:} ;
     eval ${StrLeftPair}=$( eval $( eval \
       VTVIsQuotedValue=True \
       VTVIsArrayStyleInsert=True  \
       VTVValueEntry=${StrVarBEList}  \
       VTVIsValueReAssign=True     \
       VTVIsValueToConvert=False   \
       VTVIsWhiteList=True         \
       VTVWhiteListTransfert=UUID  \
       ValueToVariable ) BEExtraction="${StrRightPair}" BlockExtraction ) ; 
   done 

                       
   StrMsg="Block List:[ Start:__INTSTART__, End:__INTEND__ ]" ; 
   StrMsg=${StrMsg//__INTSTART__/${IntStartBlock}} ; 
   StrMsg=${StrMsg//__INTEND__/${IntEndBlock}} ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
  
   ### Section to load Location and File-chunk from BlockInformation
   for StrIndexBlock in ${!ArrayGroupAssociate[@]} ; do 
    eval $( eval $( 
            VTVIsQuotedValue=True          \
            VTVIsArrayStyleInsert=True     \
            VTVValueEntry=${StrVarBEList}  \
            VTVIsValueReAssign=True        \
            VTVIsValueToConvert=False      \
            VTVIsQuotedValue=True          \
            ValueToVariable ) BIStartBlock=${IntStartBlock}  \
                              BIEndBlock=50      \
                              BILineExtractionField=${StrIndexBlock}  \
                              BIIndexStoreName=${ArrayGroupAssociate[${StrIndexBlock}]} \
                              BIArrayName=ArrayFileHeader    \
                              BlockInformation ) ; 
  done 
  ### replace BIEndBlock=${IntEndBlock} by BIEndBlock=5
   
  ### 
  ### This test purposes is present to test BlockInformation Correct work.
  ### It does generate enough line in reason of 1 per Assignation to the 
  ### ArrayFileHeader and the braced if surrounding the way it store the informaion
  ### ( by possibility to call BILineExtractionField=Rank BlockInformation & 
  ### BILineExtractionField=Header BlockInformation ) in different order and 
  ### Shall have correct syntax to allow a CSV-filter to extract either location
  ### or filename without having empty csv definied to ';' semicolon due to presence
  ### of ',' for value, ':' for pair of value ( Name for this storage and it's value)
  ### where name will differ if it's Rank or Header to be stored . 

  StrMsg="Validating ArrayFileHeader information, browsing across __INT__ Index(es)." ; 
  StrMsg=${StrMsg//__INT__/${#ArrayFileHeader[@]}} ; 
  VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

  for StrIndex in ${!ArrayFileHeader[@]} ; do 
   echo -ne "ArrayFileHeader[${StrIndex}]=${ArrayFileHeader[${StrIndex}]}\n" ; 
  done 

  eval $( eval $( 
            VTVIsQuotedValue=True          \
            VTVIsArrayStyleInsert=True     \
            VTVValueEntry=${StrVarBCList}  \
            VTVIsValueReAssign=True        \
            VTVIsValueToConvert=False      \
            VTVIsQuotedValue=True          \
            ValueToVariable ) BCAction=header BlockCreation ) ;

  
  }
  
  function __main_StopServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StopServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
   fi 
   StrMsg=$( Bzip2DataTool --get ArrayMsg[0] ) ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolShowEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
  
  }

   local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
   local StrNameHelper="Bzip2DataTool\n\tAn Application that recover from Bzip2 encapsulation problem or corruption. ";
   local StrSummary="This application does using Recovery application to generated external header information and use mechanical application to recombine the file." ; 
   local StrSynopsis="This application does also try to save Tar file and archive under tar file-format to analyse the file with bzip2recover or any application that do wor on same method then bzip2recover and generate an output of part-header and file allocation of part-content and recombine, assumming this application does remove the corrupted information.";
   local StrDescription="more to come..." ;
    
    
    if [ "${Arg0:=--startservices}" == "--help"	] ; then 
     GVRIsName=True     \
     GVRIsSummary=True  \
     GVRIsSynopsis=True \
     GVRIsDesc=True     \
     GetVarReference ${__call_locality[1]} ; 
     echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
    elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
     eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
     echo -ne """${ArgGet}\n""" ;
    elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
     eval $( __GetVarReferenceList ) ;	
    elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
     eval $( eval \
       VTVIsQuotedValue=True \
       VTVIsArrayStyleInsert=True  \
       VTVValueEntry=${StrVarList} \
       VTVIsValueReAssign=True     \
       VTVIsValueToConvert=False   \
       VTVIsWhiteList=True         \
       VTVWhiteListTransfert=UUID  \
       ValueToVariable ) __main_StopServices ; 
    elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
     #eval $( eval VersionApps ) ; 
     StrMsg=$( Bzip2DataTool --get ArrayMsg[0] ) ; 
     VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolShowEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
     eval $( eval \
       VTVIsQuotedValue=True \
       VTVIsArrayStyleInsert=True  \
       VTVValueEntry=${StrVarList} \
       VTVIsValueReAssign=True     \
       VTVIsValueToConvert=False   \
       ValueToVariable ) ${StrStartMain}
    fi  
 }
fi
### End of versionB2DT

if [ "${versionLSP:=0.0.0}" == "0.0.0" ] ; then 
 eval $( GFCFuncName=LoopSetupProperty GlobalFunctionCleaning ) ;

 function LoopSetupProperty()
 {
  #echo -ne "Entry in Function LoopSetupProperty\n" ; 
  if [ "${versionCA:=0.0.0}" == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( LSP LoopSetupProperty ) ;
   local Arg0="${ArrayArg[0]}" ;  
   local StrParentApps=${__call_locality[1]} ; 
   local StrStartMain=${LSPFuncStart:=__main_StartServices} ; 
  elif [ "${versionCA:=0.0.0}" == "0.0.2" ] ; then 
   eval $( eval CAFunctName=LoopSetupProperty CAIsAddParent=False CallArgument ) ;
  fi 
  
  local StrArrayName=${LSPArrayDrive:=None} ; 
  local StrIndexLoop=${LSPIndexLoop:=loop} ; 
  local StrIndexImage=${LSPIndexImage:=image} ; 
  local StrIndexMount=${LSPIndexMount:=mount} ;
  local StrIndexMntOpt=${LSPIndexMountOpt:=mount-opt} ;
  local BoolIsVerbose=${LSPIsVerbose:=False} ; 
  local StrAppsLosetup=${LSPAppsLosetup:=/sbin/losetup} ;
  local StrAppsMount=${LSPAppsMount:=/bin/mount} ;
  local BoolIsDryRun=${LSPDryRun:=False} ; 
  local StrNewLoopSet=${LSPLosetupTpl:=__APPS__ __LOOP__ __IMAGE__} ; 
  local StrNewMountSet=${LSPMountTpl:=__APPS__ -t __FS__ __LOOP__ __MOUNT__ -o__OPT__}
  
  function ArrayGetter( )
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( AG ArrayGetter ) ;
   local Arg0="${ArrayArg[0]}" ;  
   local StrIndexName=${AGIndexName:=None} ; 
   local StrArrayName=${AGArray:=None} ; 
   local BoolIsVerbose=${AGIsVerbose:=False} ; 
   local StrCmd="""local StrReturn=\${${StrArrayName}[${StrIndexName}]}""" ;
   eval ${StrCmd} ; 
   if [ ${BoolIsVerbose:=False} == "True" ] ; then 
    echo -ne "from ${__call_locality[1]}\nCmd:${StrCmd}\nShould return:${StrReturn}\n" > /dev/stderr ; 
   fi 
   
   echo -ne "${StrReturn}" ; 
  }
  
  function ArraySetter( )
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( AS ArraySetter ) ;
   local Arg0="${ArrayArg[0]}" ;  
   local StrIndexName=${ASIndexName:=None} ; 
   local StrArrayName=${ASArray:=None} ; 
   local StrValue=${ASValue:=None} ; 
   local BoolIsVerbose=${ASIsVerbose:=False} ; 
   local StrCmd="${StrArrayName}[${StrIndexName}]=${StrValue}" ;
   if [ ${BoolIsVerbose:=False} == "True" ] ; then 
    echo -ne "from ${__call_locality[1]}\n${StrCmd}\n" > /dev/stderr ; 
   fi
   eval """${StrCmd}""" ; 
  }
  
  function GetAllFileSystem()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( LSP LoopSetupProperty ) ;
   local Arg0="${ArrayArg[0]}" ;  
   /usr/bin/cut -f 2 < /proc/filesystems | tr '[:cntrl:]' ' '
  }
  
  function GetFreeLoop( )
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( GFL GetFreeLoop ${StrParentApps} ) ;
   local Arg0="${ArrayArg[0]}" ;
   local StrOptFree=${GFLAppsLoFree:=-f} ;  
   echo -ne $( eval ${StrAppsLosetup} ${StrOptFree} ) ; 
  }
  
  function GetFileFsType()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( GFFT GetFileFsType ${StrParentApps} ) ;
   local Arg0="${ArrayArg[0]}" ; 
   local BoolIsVerbose=${GFFTIsVerbose:=False} ; 
   local StrFileInfoApps=${GFFTFileInfoApps:=/usr/bin/file} ;
   local -a ArrayFS=( $( GetAllFileSystem ) ) ; 
   local StrFileInfo=$( eval ${StrFileInfoApps} \${${StrArrayName}[${StrIndexImage}]} )
   IntFileInfoLen=${#StrFileInfo} ; 
   local StrImageFS="None" ; 
   if [ ${BoolIsVerbose:=False} == "True" ] ; then 
    echo -ne "Answer from file-information: ${StrFileInfo}\n" > /dev/stderr ; 
    echo -ne "All filesystem detected: ${ArrayFS[@]}\n" > /dev/stderr ; 
   fi 
   for(( intx=0 ; intx <= ${#ArrayFS[@]}-1 ; intx++ )) ; do 
    StrFSInspect=${ArrayFS[${intx}]} ; 
    if [ ${BoolIsVerbose:=False} == "True" ] ; then 
     echo -ne "Parsing FS: ${StrFSInspect}\n" > /dev/stderr ; 
    fi 
    StrFilterFileInfo=${StrFileInfo//${StrFSInspect}/} ; 
    IntFilterLen=${#StrFilterFileInfo} ; 
    if [ "${StrImageFS:=None}" == "None" ] ; then 
     if [ ${IntFileInfoLen} -gt ${IntFilterLen:=0} ] ; then 
      StrImageFS=${StrFSInspect} ;
     fi 
    fi 
   done 
   echo -ne "${StrImageFS}" ; 
  }
  
  function __main_StartServices()
  {
   #echo -ne "Entry in Function __main_StartServices\n" ; 
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CAIsChildBoot=False CallArgument  ) ;
   fi
   
   echo -ne "Inspecting Array Name:${StrArrayName}\n" > /dev/stderr ; 
   
   local StrFsName=$( eval GFFTIsVerbose=${BoolIsVerbose} StrArrayName=${StrArrayName} StrIndexImage=${StrIndexImage} GetFileFsType )  ; 
   local StrFreeLoop=$( eval GFLIsVerbose=${BoolIsVerbose} StrAppsLosetup=${StrAppsLosetup} GetFreeLoop )  ; 
   
   echo -ne "FsName detected: ${StrFsName}\nNext free loop:${StrFreeLoop}\n" > /dev/stderr ;
   
   local -a ArrayCmd ; 
   
   
   local StrImageName=$( eval AGIsVerbose=${BoolIsVerbose} AGIndexName=${StrIndexImage} AGArray=${StrArrayName} ArrayGetter )  ;
   local StrMountAInfo=$( eval AGIsVerbose=${BoolIsVerbose} AGIndexName=${StrIndexMount} AGArray=${StrArrayName} ArrayGetter )  ;
   local StrMntOptAInfo=$( eval AGIsVerbose=${BoolIsVerbose} AGIndexName=${StrIndexMntOpt} AGArray=${StrArrayName} ArrayGetter )  ;
   local StrLoopAInfo=$( eval AGIsVerbose=${BoolIsVerbose} AGIndexName=${StrIndexLoop} AGArray=${StrArrayName} ArrayGetter )  ;
   
   local IntIndexCmd ; 
   local StrCmd=${StrNewLoopSet}
   
   StrCmd=${StrCmd//__APPS__/${StrAppsLosetup}} ; 
   StrCmd=${StrCmd//__LOOP__/${StrFreeLoop}} ; 
   StrCmd=${StrCmd//__IMAGE__/${StrImageName}} ; 
     
   IntIndexCmd=${#ArrayCmd[@]} ; 
   ArrayCmd[${IntIndexCmd}]=${StrCmd} ; 
   
   echo -ne "CMD:${ArrayCmd[0]}\n" > /dev/stderr ; 
   if [ ${BoolIsDryRun:=False} != "True" ] ; then 
    echo -ne "BoolIsDryRun: ${BoolIsDryRun}\n" > /dev/stderr ; 
    eval $( eval ${ArrayCmd[0]} ) ;  
   fi 
   
   if [ ${StrLoopAInfo:=None} == "None" ] ; then 
    ### In case Array not holding information about
    ### free-loop device, StrLoopAInfo will get 
    ### directly from StrFreeLoop . 
    StrLoopAInfo=${StrFreeLoop} ; 
   fi 
   StrCmd=${StrNewMountSet}; 
   StrCmd=${StrCmd//__APPS__/${StrAppsMount}} ; 
   StrCmd=${StrCmd//__FS__/${StrFsName}} ; 
   StrCmd=${StrCmd//__LOOP__/${StrLoopAInfo}} ; 
   StrCmd=${StrCmd//__MOUNT__/${StrMountAInfo}} ; 
   StrCmd=${StrCmd//__OPT__/${StrMntOptAInfo}} ; 

   IntIndexCmd=${#ArrayCmd[@]} ; 
   ArrayCmd[${IntIndexCmd}]=${StrCmd} ; 
   
   echo -ne "CMD:${ArrayCmd[${IntIndexCmd}]}\n" > /dev/stderr ; 
   if [ ${BoolIsDryRun:=False} != "True" ] ; then 
    echo -ne "BoolIsDryRun: ${BoolIsDryRun}\n" > /dev/stderr ; 
    eval $( eval ${ArrayCmd[${IntIndexCmd}]} ) ;  
    
   fi 
   
  
  }

   local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
   local StrNameHelper="${__call_locality[1]}\n\tA Tool to link several images Files into /dev/loopN \n";
   local StrSynopsis="\n\tThis application does  work with an Array with textual-index and do\n\trequire to specify the name of the array and all the required index-key\n\tto extract information and Active a loop and a mount of this loop.\n\tSuch Array in bash are Associative array. Basic example are declared\n\twith 'declare -A' in global variable scope, and in local scope will\n\tuse 'local -A'> In Exception to local scope, the function\n\t${__call_locality[1]} should be inside your function or will not acces\n\tto it due to scopability...\n\n\tThe other method, do require Fnct.D having UUID persistent-cache usually\n\tDoCtrlHandler should exist and should work.\n\tIt's possible to use VlcServicesLayer since this application does own\n\tinitial design and do have it's security signature which make it \n\taffordable to use.\n\tA Dry-run action is an application that pretend doing the action. In\n\tthis situation, our application only ouput the command to stdout. So\n\tkeep an eyes on DryRun action .\n\tA single way to call it after configuring your declarative Array, \n\twill look like :\n\n\tLSPIndexLoop=loop LSPIndexImage=image LSPIndexMount=mount \\ \n\tLSPIndexMountOpt=mount-opt LSPDryRun=False \\ \n\tLSPArrayDrive=ArrayDriveChroot \\ \n\tLoopSetupProperty \n\n\tTo simply see the command generated you can change the prefixed-variable\n\tLSPDryRun to True, and will only display the command.\n";
   local StrSummary="\n\t\tSince it's a problems managing Loop device and do not have priority,\n\tthe day it missing a link in a script mounting, all drive can be drift \n\tto another Loop index where mounting may not work. Coding loop-device \n\tfrom /etc/fstab can be problemati. A Services state to Start Attachment\n\tof loop to file or device may help, and some addition to this services \n\tmay help like adding encryption support. \n" ; 
   local StrDescription="\n\tThis application is used to attach an image or device to a loop device\n\tand mount-it too. It allow using an array to ready information from\n\tin. The allowed type of array is an associative array. As example It\n\twill be ArrayDriveChroot. This is important to configure your array\n\tto hold severals informations:\n\n\tthis array using following index-key name :\n\tkey loop . . . . . Hold a present loop or even hold \$( losetup -f )\n\t\t\t to make easier to extract a free device.It Can be\n\t\t\t  empty and the application will feed this key to \n\t\t\t  updated value and your application will have to\n\t\t\t  acces to ArrayDriveChroot[loop] to read latest\n\t\t\t  information\n\tkey image     ---> \t  Should hold the information of Formatted image.\n\tkey mount     --->  \t  Will have to hold path-location of the mount.\n\tkey mount-opt --->  Being serious with Mount option, all the \n\t\t\t information goes here and should remain comma\n\t\t\t    ',' seprated format.\n\n\t This application will require to Set Prefixed-variable as:\n\n\tLSPArrayDrive=ArrayDriveChroot \\ \n\tLSPIndexLoop=loop \\ \n\tLSPIndexImage=image \\ \n\tLSPIndexMount=mount \\ \n\tLSPIndexMountOpt=mount-opt \\ \n\tLoopSetupProperty\n\n\tWill attach it to a /dev/loop[N] and \n\tmount-it." ;

   ### Section : Switches-Statememt 
   
   #echo -ne "In Function LoopSetupProperty, Switches statement.\n" ; 
   if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    ### GVRIsName set to True is the Variable handled StrNameHelper by GetVarReference and 
    ### provide a Name-Helper inside the live-documentation if we call StartSlewAnalysis --help.
    ### Extending the help by turning other variable to True will increae help. Variable are
    ### declared previously. 
    GVRIsName=True \
    GVRIsSummary=True \
    GVRIsSynopsis=True \
    GVRIsDesc=True \
    GetVarReference ${__call_locality[1]} ; 
    #VerbMsg="${StrSwitchMessages}" VerbState=True       VerbEvalForm=False   VerbFormated=False    VerbExtendedOut=True VerbDev=/dev/stderr  Verbosis ;
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ;
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    eval $( __GetVarReferenceList ) ;	
   elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
    $( eval StrArrayName="${StrArrayName}"      \
                 StrIndexLoop="${StrIndexLoop}"      \
                 StrIndexImage="${StrIndexImage}"    \
                 StrStartMain="${StrStartMain}"      \
                 StrIndexMount="${StrIndexMount}"    \
                 StrIndexMntOpt="${StrIndexMntOpt}"  \
                 StrAppsLosetup="${StrAppsLosetup}"  \
                 StrAppsMount="${StrAppsMount}"      \
                 StrNewLoopSet="${StrNewLoopSet}"    \
                 BoolIsDryRun="${BoolIsDryRun}"      \
                 StrNewMountSet="${StrNewMountSet}"  ) __main_StopServices ; 
   elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
    #StrMsg=$( LoopSetupProperty --get ArrayMsg[0] ) ; 
    #VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    #echo -ne "In Function LoopSetupProperty, Switches statement, 'startservices' options.\n\tWill process function from StrStartMain:${StrStartMain}\n" ; 
    eval $( StrArrayName="${StrArrayName}"      \
            StrIndexLoop="${StrIndexLoop}"      \
            StrIndexImage="${StrIndexImage}"    \
            StrIndexMount="${StrIndexMount}"    \
            StrIndexMntOpt="${StrIndexMntOpt}"  \
            StrStartMain="${StrStartMain}"      \
            StrAppsLosetup="${StrAppsLosetup}"  \
            StrAppsMount="${StrAppsMount}"      \
            StrNewLoopSet="${StrNewLoopSet}"    \
            StrNewMountSet="${StrNewMountSet}"  \
            BoolIsDryRun="${BoolIsDryRun}" ${StrStartMain}  )  ;
    #echo -ne "In Function LoopSetupProperty, Switches statement, end of 'startservices'\n" ; 
   fi 
   
   
 }
fi #End-if versionLSP==0.0.0 


