#!/bin/bash

### Package : _sub_Function_Appliance

### Comming from reference of pythonmodule jellyfish:
### with matching rating-codex of Infrastructure
### jellyfish.match_rating_codex(u'Infrastructure')
### give Infctr
### While same module to short Name like 
### General        ->  Gnrl
### Parser         ->  Prsr
### Infrastructure ->  Infctr
### To make this function called GnrlPrsrInfctr for a really 
### short Name which telling more... 
 
### function GeneralParserInfctr 
### Is not actually ready in design plan it only miss couple of verification
### before pushing it to version 0.0.2 . It's sure if you start LibLoader ( 
### with _sub_Function_Appliance inside the ArrayLib and adding to the command 
### line versionGPI=0.0.2 it will parse this but this function is not ready 
### to proove how pushing variable from command-prompt and Feeding the Parser with 
### GDITagFeeder help the Parser to parser variable from prompt and declaration 
### of relation of variable+__TAG__ to acheive a Generalistic Case of function
### wrapper to have a applied firter to a function to get a speciffic result. 
### 
### Missing, 
###  - Loging inside UUID, 
###  - Executing the Evaluation and inject the variable result inside current code
###  so we can be ready to use the Value . We do have GDIDpkgTpl for template-future
###  command line and StrCmd from GDITagParserResult, it evaluate the GDIDpkgTpl result
### but haven't specified where to execute it... Initially inside the function but all
### the returned event are simply displayed and not keeped. 
###  - Many more precautions and tests. 
### 

if [ ${versionGPI:=0.0.2} == "0.0.2" ] ; then 
 
 unset GnrlPrsrInfctr; 
 function GnrlPrsrInfctr()
 {
  ### This is a specialized Verbosis mode :
  ###  
  ###  All condition required to set VerbState=True 
  ###  All condition required to set a message with VerbMsg=STRING
  ###  
  ###  
  ### It can be used to :
  ###  - Echo result to be passed throught Value Result .
  ###  Required :
  ###  VerbEvalForm=True VerbFormated=False 
  ###  
  ###  VerbHeader Is ineffective
  ###  
  ### -Echo result can be append to file and not overwriting the content: 
  ###  Required ;
  ###  VerbFormated=False/True VerbAppendDev=True VerbDev=[ FILENAME | UUID ]
  ###  - Appending to file also required to be unique-file were no instance of 
  ###  Verbosis may point on same-file or loss of log will be CERTAIN.
  ###  -Pointing to Same-Destination require a lock Mechanism which is 
  ###  not implemented here
  ###  
  function Verbosis()
  {
   #eval $( CAFunctName=Verbosis CAIsAddParent=False __Call_Argument ) ; 
   local -a ArrayArg=( $* ) ; 
   local -a __call_locality=( Verb Verbosis )
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
        echo "${StrMsg}" ;  
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo "${StrMsg}" >> ${StrDevOut} ;
      else
       echo "${StrMsg}" > ${StrDevOut} ;
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
  
  if [ "${versionCA:=0.0.0}" == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( GPI GnrlPrsrInfctr ) ;
   local Arg0="${ArrayArg[0]}";  
   local StrStartMain=${GPIFuncStart:=__main_StartServices} ; 
   local StrParentApps=${__call_locality[1]} ; 
  elif [ "${versionCA:=0.0.0}" == "0.0.1" ] ; then 
   eval $( eval CAFunctName=GnrlPrsrInfctr CAIsAddParent=False __Call_Argument ) ; 
  elif [ "${versionCA:=0.0.0}" == "0.0.2" ] ; then 
   eval $( eval CAFunctName=GnrlPrsrInfctr CAIsAddParent=False CallArgument ) ; 
  fi
  ### This is an evaluation test GnrlPrsrInfctr, for having installing extras
  ### package toward Zenity-Dbus problem and after a reboot, the evaluation 
  ### start to flaw and solution like echo inside an eval is not quite acceptable:
  ### solution offert : write like an echo evaluation where it is already going
  ### out from an echo: eval $( echo "CAFunctName=GnrlPrsrInfctr 
  ### CAIsAddParent=False __Call_Argument" ) ; So I withdraw package from last 
  ### download and imply testing both version __Call_Argument versionGPI==0.0.1
  ### and CallArgument versionGPI==0.0.2, and may come to a conclusion function 
  ### starting with _Prefix or __Prefix may be blind to evaluation and report 
  ### being absent, which is probably a policy-kit altering the code.

  #local __call_locality=( GPI GnrlPrsrInfctr ) ;
  #local ArrayArg=( $* ) ;
  #local Arg0=( ${ArrayArg[0]} ) ; 
  
  ### General to GnrlPrsrInfctr Command Parser and depot. 
  local StrAppsTemplate=${GPITpl:=__APPS__ __APPS_OPT__ __PIPE__ __FILTER__ __FILTER_OPT__} ;
  local StrApps=${GPIApps:=/usr/bin/dpkg} ;
  local StrAppsOpt=${GPIAppsOpt:=--get-selections} ; 
  local StrFilterApps=${GPIFilterApps:=/usr/bin/gawk} ;
  local StrFileName=${GPIFileName:=None} ;
  local StrFilterOpt=${GPIFilterOpt:=-f __FILE__} ; 
  local StrParserTag=${GPITagParser:=StrDefaultPipe:__PIPE__,StrApps:__APPS__,StrAppsOpt:__APPS_OPT__,StrFilterApps:__FILTER__,StrFilterOpt:__FILTER_OPT__,StrFileName:__FILE__}
  local StrTagFeeder=${GPITagFeeder:=''} ;
  local StrParserResult=${GPITagParserResult:=StrCmd} ; 
  local StrUUIDTransmit=${GPITUUIDName:=UUID} ; 
  local StrDefaultPipe=${GPIPipeSig:=\|} ;
  local StrDefaultVerbose=${GPIVerboseDev:=/dev/stderr} ; 
  local IntFontSize=${GPIFontSize:=10} ; 
  local StrUUIDInstance ;
  local StrFileOutput=${GPIOutFile:=.GnrlPrsrInfctr} ; 
  local BoolDisplayDebug=${GPIDisplayDebug:=False} ; 
  local BoolEmitUUID=${GPIIsUUIDInstance:=False} ; 
  local BoolGenerateCode=${GPIIsGenerateCode:=False} ; 
  local BoolOutToZenity=${GPIIsZenityHandlerOut:=False} ;
  local BoolOutToFile=${GPIIsFileHandlerOut:=False} ; 
  local BoolExecuteEval=${GPIIsExecuteEval:=True} ; 

  ### General To RepositoryCreation
  local BoolRepoCreaEnabled=${GPIRepoCreatEnabled:=True} ; 
  local BoolDisplayParserDebug=${GPIParserDebug:=False} ;
  local BoolCreateRepository=${GPIRepositoryCreation:=False} ; 
  local StrTagRepoMkdir=${GPIParserMkdir:=StrAppsSudo:__SUDO__,StrAppsSudoOpt:__OPT__,StrAppsMkdir:__APPS__,StrRepositoryQuery:__PATH__,StrAppsMkdirOpt:__APPS_OPTS__} ;
  local StrTagRepoChmod=${GPIParserChmod:=StrAppsSudo:__SUDO__,StrAppsSudoOpt:__OPT__,StrAppsChmod:__APPS__,StrRepositoryQuery:__PATH__,StrDefaultPerm:__PERM__} ;
  local StrTagRepoChown=${GPIParserChown:=StrAppsSudo:__SUDO__,StrAppsSudoOpt:__OPT__,StrAppsChown:__APPS__,StrRepositoryQuery:__PATH__,StrDefaultUser:__OWNER__} ;
  local StrPrefixTagGroup=${GPIGroupParserPrefix:=StrTagRepo} ; 
  local -A ArrayTplAction ; 
  ### Fixed after reference : 472de1ad3899ab7a0aa52869a073c19c52178940
  ### Associative Array was declared with '-a' instead of '-A'
  local StrRepositoryQuery=${GPIQueryRepository:=/var/log/Fnct.D/GnrlPrsrInfctr} ;  
  local StrDefaultUser=${GPIRepoUser:=user.root} ;
  local StrDefaultPerm=${GPIRepoPerm:=775} ;  
  local StrAppsSudo=${GPIAppsSudo:=/usr/bin/sudo} ;
  local StrAppsSudoOpt=${GPIAppsSudoOpt:=-s -H} ;
  local StrAppsMkdir=${GPIAppsMkdir:=/bin/mkdir} ;
  local StrAppsMkdirOpt=${GPIAppsMkdirOpt:=-p} ;
  local StrAppsChown=${GPIChown:=/bin/chown} ;
  local StrAppsChmod=${GPIChmod:=/bin/chmod} ;
  #local StrParentApps=${__call_locality[1]} ;
  #local StrStartMain=${GPIFuncStart:=__main_StartServices} ;
  
  ### While GnrlPrsrInfctr is the only first Helper available, it provide a list of function
  ### where this provider have some internal action being usefull to re-use, example RepositoryCreation
  ### It's useless to export this variable it's mostly re-used by application Getter . 
  local UUIDHApps=${GPIAppsProvide:=RepositoryCreation} ; 
  
  
  ArrayMsg[0]="Prefixed Variable: __VAR__=__VALUE__\nThis is an assistant creating the Repository (location: __PATH__)\n.This is reserved to store your Query for future uses. Prepare to enter into\nCredential action to create the Repository. In case your haven't chooses Variable\n\tGPIRepoUser GPIRepoPerm\nto set your user(s)/Group accessing the repository or Permission to read and write,\nyou can stop the application and start over. If you haven't choose a Function Name\nfor this step it will pop-you a warning and stop the application." ;
  ArrayMsg[1]="Creation of PATH __PATH__, Right Attribution : __MODE__, Owner: __USER__" ;
  ArrayMsg[2]="__CMD__ " ;
  ArrayMsg[3]="Parsed CmdLine: __CMDLINE__" ;
  ArrayMsg[4]="Instance will use UUID reference: __UUID__"
  ArrayMsg[5]="Entry-Start : __FUNCT__"
  ArrayMsg[6]="__FUNCT__ version versionTP=__VER_TP__, versionCA=__VER_CA__, versionGPI=__VER_GPI__" ; 
  
  ArrayTplAction["Mkdir"]="__SUDO__ __OPT__ __APPS__ __APPS_OPTS__ __PATH__" ;  
  ArrayTplAction["Chmod"]="__SUDO__ __OPT__ __APPS__ __PERM__ __PATH__"   ;
  ArrayTplAction["Chown"]="__SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__"   ;
  local -a ArrayActionOrder=( "Mkdir" "Chmod" "Chown" ) ;
   
  local StrVarList="StrVarList,StrFileOutput,BoolOutToZenity,BoolOutToFile,StrTagFeeder,StrParentApps,BoolEmitUUID,StrParserResult,StrAwkScript,StrAppsTemplate,StrApps,StrAppsOpt,StrFilterApps,StrFilterOpt,StrParserTag,StrFileName,StrDefaultPipe,StrDefaultVerbose,StrTagRepoMkdir,StrTagRepoChmod,StrTagRepoChown,BoolRepoCreaEnabled,BoolDisplayParserDebug,StrRepositoryQuery,BoolCreateRepository,StrDefaultUser,StrDefaultPerm,StrAppsSudo,StrAppsSudoOpt,StrAppsMkdir,StrAppsChown,StrAppsChmod,StrStartMain,BoolExecuteEval,BoolGenerateCode,StrUUIDInstance,StrPrefixTagGroup,StrUUIDTransmit,IntFontSize" ; 
  
  ### Informations About uses of StrUUIDInstance vs. StrFileOutput  .
  ### 
  ### +---------------------------------------------------------------------------------------------------+ 
  ### |Specialized case, if it's UUID choice have been obtain from BoolEmitUUID                           |
  ### | we do storing inside {Repository}/{UUID} , if its not the case it's {GPIOutFile:=.GnrlPrsrInfctr} |
  ### | it can be everywhere                                                                              |
  ### +-+-------------------------------------------------------------------------------------------------+
  ###   |
  ### +-+----------------------------+
  ### | Box-Location-Of-Information  |
  ### |    < BoolEmitUUID >          |  is Reponsible to inform the application to :
  ### +-+-----|---|------------------+        
  ###   |     |   +TRUE -> Use the UUID Infrastructure and output on location {Repository}/{UUID} on need  
  ###   |     +FALSE    -> Use the local {GPIOutFile:=.GnrlPrsrInfctr} on need . 
  ###   | 
  ### +-+---------------------------------------------+ In case BoolExecuteEval==True ( same model is 
  ### |  Box-Output-The-Information                   | applied to BoolExecuteEval=False )
  ### | <BoolOutToZenity==True> <BoolOutToFile==True> |
  ### +--------+------------------+-------------------+   
  ###          |                  | 
  ###   <Attr:BoolEmitUUID>       +---<Attr:BoolEmitUUID>---For BoolEmitUUID==True
  ###      |   |                                 |          Information will be dumped inside
  ###      |   +For BoolEmitUUID==False          |          {Repository}/{UUID}
  ###      |    Zenity will look inside file     +---For BoolEmitUUID==False
  ###      |    {GPIOutFile:=.GnrlPrsrInfctr}        Information will be dumped inside
  ###      |                                         {GPIOutFile:=.GnrlPrsrInfctr}
  ###      +-----For BoolEmitUUID==True
  ###            Zenity will look inside file
  ###            {Repository}/{UUID} 
  ### 
  ### 
  ### 
  
  
  function RepositoryCreation()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( RC RepositoryCreation ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ;  
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=RepositoryCreation CAIsAddParent=True __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=RepositoryCreation CAIsAddParent=True CallArgument ) ; 
   fi  
   #eval $( CAFunctName=RepositoryCreation CAIsAddParent=True __Call_Argument ) ; 
   #local __call_locality=( RC RepositoryCreation ${StrParentApps} ) ; 
   #local Arg0=${ArrayArg[0]} ; 
   #local ArrayArg=( $* ) ;
   local StrAction ; 
   if [ ! -d ${StrRepositoryQuery} ] ; then 
    StrMsg=$( ${StrParentApps} --get ArrayMsg[0] ) ;
    StrMsg=${StrMsg//__VALUE__/${BoolCreateRepository}} ; 
    StrMsg=${StrMsg//__VAR__/BoolCreateRepository} ; 
    StrMsg=${StrMsg//__PATH__/${StrRepositoryQuery}} ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
    
    StrMsg=$( ${StrParentApps} --get ArrayMsg[1] ) ;
    StrMsg=${StrMsg//__PATH__/${StrRepositoryQuery}} ;
    StrMsg=${StrMsg//__MODE__/${StrDefaultPerm}} ;
    StrMsg=${StrMsg//__USER__/${StrDefaultUser}} ;
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 

    ### The Array ArrayActionOrder is present to define an order . This order 
    ### result in getting numerical index from 1 .. N
    ### Getting information from ArrayActionOrder[@], provide 
    ### 3 differents index name, 
    ### 0 -> "Mkdir" 
    ### 1 -> "Chmod" 
    ### 2 -> "Chown"
    ### in Error observed inside error-fix.txt for reference : 472de1ad3899ab7a0aa52869a073c19c52178940
    ### is the StrAction is not changing at all after each loop and get only
    ### ArrayTplAction["Chown"] 
    ### 
    ### This mean : 
    ### calling application 
    ### GnrlPrsrInfctr --get ArrayTplAction['Mkdir']
    ###  --> __SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__
    ### GnrlPrsrInfctr --get ArrayTplAction['Chmod']
    ###  --> __SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__
    ### GnrlPrsrInfctr --get ArrayTplAction['Chown']
    ###  --> __SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__
    ### 
    ### Getting from First Application able to do this : ZenityBuildForm
    ### 
    ### ZenityBuildForm --get ArrayTplAction['Mkdir'] 
    ###  --> __SUDO__ __OPT__ __APPS__ __PATH__
    ### ZenityBuildForm --get ArrayTplAction['Chmod'] 
    ###  --> __SUDO__ __OPT__ __APPS__ __PERM__ __PATH__
    ### ZenityBuildForm --get ArrayTplAction['Chown']
    ###  --> __SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__
    ### 
    for IterActionName in $( ${StrParentApps} --get ArrayActionOrder[@] ) ; do 
     StrAction=$( ${StrParentApps} --get ArrayTplAction["${IterActionName}"] ) ; 
     StrArrayName="${StrPrefixTagGroup}" ;
     
     StrTagListVarName="${StrArrayName}${IterActionName}" ;
     eval "StrTagListVar=\${${StrTagListVarName}} ;" ; 
     StrMsg="Parser TAG-List Variable name : __TAGLIST__: Template:[ __ACTION__] : content: [ __CONTENT__ ]" ; 
     StrMsg=${StrMsg//__TAGLIST__/${StrTagListVarName}} ; 
     StrMsg=${StrMsg//__CONTENT__/${StrTagListVar}} ; 
     StrMsg=${StrMsg//__ACTION__/${StrAction}} ; 
     
     VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
     
     ### Double Evaluation of the command seem to work for TagParser. 
     ### I mean it worked for 2 days since I do to respawn it to 
     ### eval $( ... ) .
     eval  $( TPVarNameParsed="StrAction"                     \
             TPListTag=${StrTagListVar}                        \
             TPIsMatchRtoL=True                                \
             TPDisplayParserNotice=${BoolDisplayParserDebug}   \
             TPDisplayDebug=${BoolDisplayDebug}                \
             TPArrayName="Array${__call_locality[0]}Tag"       \
             TagParser ) ;
             
     StrMsg=$( ${StrParentApps} --get ArrayMsg[2] ) ;
     
     VerbMsg="${StrMsg//__CMD__/${StrAction}}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
     if [ "${BoolRepoCreaEnabled:=False}" == "True" ] ; then 
       eval """$( ${StrAction} )""" ;
     fi 
    done 

   fi 

  } 

  
  function ReportReference()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( RR ReportReference ${StrParentApps} ) ;
    local Arg0=${ArrayArg[0]} ;  
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=ReportReference CAIsAddParent=True __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=ReportReference CAIsAddParent=True CallArgument ) ; 
   fi   
   #eval $( CAFunctName=ReportReference CAIsAddParent=True __Call_Argument ) ; 
   #local __call_locality=( RR ReportReference ${StrParentApps} ) ;
   #local ArrayArg=( $* ) ;
   #local Arg0=${ArrayArg[0]};  
   local StrMsg ; 
   ### After moving the body of the if statement if if [ "${BoolExecuteEval}" == True...
   ### into a function. The query was tried again and confirm 
   ### BuildForm UUID:6e5b6d0c-890f-11e6-8b1d-001e4c8856d6 , was able to 
   ### publish the same information. 
   
   ### Execution Side
   ### Example : BuildForm UUID:6e5b6d0c-890f-11e6-8b1d-001e4c8856d6
   ### Should End here since this BuildForm imply  : refusing to generate code.
   ### don't dump it on file , on ZenityViewer like and also once executed it 
   ### transfert the content into na UUID into /var/log/GnrlPrsrInfctr/UUID because GPIIsUUIDInstance=TRue
   ### See path example/BuildForm/6e5b6d0c-890f-11e6-8b1d-001e4c8856d6 for parameter.
   ### Evaluation side to execte it inside called-funtion. 
   
   ### Default StrParserResult should Use variable name StrCmd to apply rules of parser to obtain
   ### 1. StrCmd=dpkg --get-selections | /usr/bin/gawk -f awk-script/dpkg-col-display.awk 
   ### 2 By calling ${StrCmd} it should execute itself and at least output the display on 
   ### screen . 
   
   ### We do have a limit to Pass StrUUIDTransmit, as long there is instance 
   ### in form UUID, or general file .GnrlPrsrInfctr i used. This is why the message
   ### is changing, and there is no evaluation in case BoolEmitUUID==False In the other
   ### case I  have neglected uses of UUID, it's not generated and ${StrFileOutput} 
   ### was probably assigned to .GnrlPrsrInfctr . 
   
   if [ "${BoolEmitUUID:=True}" == "True" ] ; then
    StrMsg="Query Executed, UUID-Variable Reference:[ __VAR_NAME__ ]" ;
    StrMsg=${StrMsg//__VAR_NAME__/${StrUUIDTransmit}} ; 
    eval ${StrUUIDTransmit}=${StrUUIDInstance} ;
   else
    StrMsg="Query Executed, No UUID used, Reference file:[ __FILE__ ]" ;
    StrMsg=${StrMsg//__FILE__/${StrFileOutput}} ;
   fi 
   VerbMsg="${StrMsg}"        \
   VerbDev=/dev/stderr        \
   VerbEvalForm=False         \
   VerbHeader="EXECUTE-${__call_locality[1]}" \
   VerbState=${BoolDisplayDebug}              \
   VerbFormated=True Verbosis ; 
   ### Allow the Command-prompt or after this function ending it's live to allow having 
   ### One way to recuperate the UUID-log. 
  
  }
    
  function ZenityHandlerOut()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( ZHO ZenityHandlerOut ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ;  
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=ZenityHandlerOut CAIsAddParent=True __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=ZenityHandlerOut CAIsAddParent=True CallArgument ) ; 
   fi   
   #eval $( CAFunctName=ZenityHandlerOut CAIsAddParent=True __Call_Argument ) ; 
   #local __call_locality=( ZHO ZenityHandlerOut ${StrParentApps} ) ;
   #local ArrayArg=( $* ) ;
   #local Arg0=${ArrayArg[0]};  
   local StrTplZenityTextInfo=${ZHOZenityTpl:="zenity --text-info --filename=__FILE__ --font=__FONT__ 2> /dev/null"} ; 
   
   ### After moving the body of the if statement if [ "${BoolOutToZenity:=False}" == "True"...
   ### into a function. The query was tried again and confirm 
   ### BuildForm UUID:bb7e1d60-899f-11e6-8b1d-001e4c8856d6 , was able to 
   ### publish the same information. 
   ### 
   ### Send-it to a file, Zenity will recuperate-it 
   ### Example : BuildForm UUID:bb7e1d60-899f-11e6-8b1d-001e4c8856d6
   ### Should End here since this BuildForm imply  : refusing to generate code.
   ### To view the result with Zenity Windows.
   ### Since Zenity can not really accept Stream from piped application action it
   ### requiert to dump it on file first. 
   ### Some extra Prefixed-Variable will be available to free-out the file after . 
   VerbMsg=$( eval eval "\${${StrParserResult}}" ) VerbDev=${StrDestinationResult} VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
   #VerbMsg="""\${${StrParserResult}}""" VerbDev=${StrDestinationResult} VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
   StrTplZenityTextInfo=${StrTplZenityTextInfo//__FILE__/${StrDestinationResult}} ; 
   StrTplZenityTextInfo=${StrTplZenityTextInfo//__FONT__/${IntFontSize}} ; 
   ### Should Lunch Zenity --text-info... 
   ${StrTplZenityTextInfo}  
  }  
  
  function ParserFunctionEval()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( PFE ParserFunctionEval ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ;  
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=ParserFunctionEval CAIsAddParent=True __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=ParserFunctionEval CAIsAddParent=True CallArgument ) ; 
   fi   
   ### Require Unusual Evaluation or evaluation not interpret this line like a 
   ### command line parsing . 
   #eval $( CAFunctName=ParserFunctionEval CAIsAddParent=True Call_Argument ) ; 
   #local __call_locality=( PFE ParserFunctionEval ${StrParentApps} ) ;
   #local ArrayArg=( $* ) ;
   #local Arg0=${ArrayArg[0]};  
   
   #eval $( CAFunctName=ParserFunctionEval CAIsAddParent=True __Call_Argument ) ; 
   
   
   ### This line does, Getting from Prefixed-Variable desired Variable to 
   ### to be generated like Variable=command
   ### and put the content of template and FeedParser .  
   eval "local ${StrParserResult}=\"${StrAppsTemplate} ${StrTagFeeder}\"" ;
   
   StrMsg="From variable __VAR__ Copy of StrAppsTemplate, named __VAR2__ will hold __CONTENT__" ; 
   StrMsg=${StrMsg//__VAR__/${StrParserResult}} ;
   eval """StrMsg=\${StrMsg//__CONTENT__/\${${StrParserResult}}}"""  ;
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbState=${BoolDisplayDebug} VerbFormated=True VerbDev=/dev/stderr Verbosis ; 
   
   eval $( eval \
     TPIsMatchRtoL=True                        \
     TPVarNameParsed="${StrParserResult}"      \
     TPDisplayDebug=${BoolDisplayDebug}        \
     TPDisplayParserNotice=${BoolDisplayParserDebug}  \
     TPArrayName=Array${__call_locality[0]}Tag \
     TPListTag="${StrParserTag}"               \
     TagParser ) ; 
   
   
   ### Notice if this line is called with ${StrParentApps} which suppose to 
   ### be the application GnrlPrsrInfctr --get ArrayMsg[3] <> ${StrParentApps} --get ArrayMsg[3] 
   ### it enter inside a loop and never end... the test consist to add before the StrMsg=...
   ### the echo line "Before getting ArrayMsg[3]" and right under to put an echo 
   ### line "After getting ArrayMsg[3]". On console you do never see the After getting ArrayMsg[3] !!!
   ### But this fixed with putting back the function name GnrlPrsrInfctr, work for versionCA=0.0.0 to 0.0.2
   ### but exceptionnally does it for versionCA=0.0.1 and versionCA=0.0.2 ???
   StrMsg=$( GnrlPrsrInfctr --get ArrayMsg[3] ) ;
   eval """StrMsg=\${StrMsg//__CMDLINE__/\${${StrParserResult}}}"""  ;
   VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbState=${BoolDisplayDebug} VerbFormated=True VerbHeader="${__call_locality[1]}-CMDLINE" Verbosis
   
   local StrFileResult="" ;
   local StrDestinationResult="" ; 
   if [ "${BoolEmitUUID:=True}" == "True" ] ; then
    StrFileResult="${StrUUIDInstance}" ; 
    StrDestinationResult="${StrRepositoryQuery}/${StrFileResult}" ;
   else 
    StrFileResult="${StrFileOutput}" ; 
    StrDestinationResult="${StrFileResult}"
   fi 
   
   
   
   ### Notice : Because we only allow One State at the time, Evualing the code or
   ### Executing the code the Prefixed-variable are ste by default to 
   ### GPIIsGenerateCode:=False + GPIIsExecuteEval:=True
   ### ---> This mean it prefer to execute the value and since all handler are all
   ### False There is more chance than It produce a stream of information on screen.
   ### Since GPIIsUUIDInstance is False by default it give twice the chance to have
   ### user decision having to read .GnrlPrsrInfctr for the content in case of 
   ### File-Handler is True. Idem for case of Window-Handler. The actual setup of
   ### if-elif give choice to Execute Eval to be the first test but case where 2 
   ### are false, there is nothing at the end and function should end without doing 
   ### something. it's probably important to set a Warning in case 2 Master decision 
   ### is false
   ### GPIIsGenerateCode ==False And GPIIsExecuteEval==False
   ### 
   ### In case where thoses 2 master variable are True, it's the BoolExecuteEval
   ### will be executed first because it's not a Select case where more than True
   ### value can flow across schema of Select. 
   
   if [ "${BoolExecuteEval:=True}" == "True" ] ; then
    eval $( eval VTVIsArrayStyleInsert=True \
             VTVValueEntry=${StrVarList},${StrParserResult},StrDestinationResult   \
             VTVIsValueReAssign=True       \
             VTVIsValueToConvert=False     \
             VTVIsQuotedValue=True         \
             VTVIsArrayStyleInsert=True    \
             ValueToVariable ) ReportReference ;    

    if [ "${BoolOutToZenity:=False}" == "True" ] ; then 
     eval $( eval VTVIsArrayStyleInsert=True \
              VTVValueEntry=${StrVarList},${StrParserResult},StrTplZenityTextInfo   \
              VTVIsValueReAssign=True       \
              VTVIsValueToConvert=False     \
              VTVIsQuotedValue=True         \
              VTVIsArrayStyleInsert=True    \
              ValueToVariable ) ZenityHandlerOut ;    
    elif [ "${BoolOutToFile:=False}" == "True" ] ; then 
     ### Send-it to a file. 
     ### No recuperation from tiers methods. 
     ### Scenario from BuildForm UUID:def9e256-8990-11e6-8b1d-001e4c8856d6
     ### At this stage, GPIIsExecuteEval=True 
     ###                GPIIsFileHandlerOut=True
     ### To avoid falling inside next elif-case where 2 Handler-Out( ToFile and ToZenity )
     ### to refuse collecting the result. 
     
     VerbMsg=$( eval eval "\${${StrParserResult}}" ) VerbDev=${StrDestinationResult} VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
     ### This case execute and send it to file which is different from it's brotherhood 
     ### of evaluating the code where the code should at least get out of the fuction and 
     ### logging is used on demand, where 2 method here exist to execute the code and 
     ### suggest to keep the code from elif BoolOutToFile == False AND BoolOutToZenity == False  
     
    elif [ "${BoolOutToFile:=False}" == "False" -a "${BoolOutToZenity:=False}" == "False" ]  ; then 
     eval eval "\${${StrParserResult}}"  
     ### This scenario from Executing only the query and not provide handler to see the content, 
     ### to have not Handler like file handler (.GnrlPrsrInfctr or UUID depot) is part of the query 
     ### BuildForm UUID:6e5b6d0c-890f-11e6-8b1d-001e4c8856d6

     ### Display the Evaluation on /dev/stderr 
     #VerbMsg="""\${${StrParserResult}}""" VerbDev=/dev/stderr VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
     #eval ${StrUUIDTransmit}=${StrUUIDInstance} ;
     #eval eval "\${${StrParserResult}}" > ${StrDestinationResult} ; 
       
    fi
     
   elif [ "${BoolGenerateCode:=False}" == "True" ] ; then 
    ### ReportReference Must display proper message where is the Specified file
    ### to hold the result. 
    ### Also Generate the Variable required to hold the query ready to execute. 
    eval $( eval VTVIsArrayStyleInsert=True \
          VTVValueEntry=${StrVarList},${StrParserResult},StrDestinationResult   \
          VTVIsValueReAssign=True       \
          VTVIsQuotedValue=True         \
          VTVIsValueToConvert=False     \
          VTVIsArrayStyleInsert=True    \
          ValueToVariable ) ReportReference ; 
    
    ### Does create ${StrCmd} uselessly .... 
    ### VerbMsg="""\${${StrParserResult}}""" VerbEvalForm=True VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
    
    ### I admit it's not a profit gain for log-repository to store volume of 
    ### informations,and it' probably once we do generated code we can asking 
    ### was generated and can we see back the information. So Test of the 
    ### handler-out are also important here. 
    ###   
    ###    Genration/Exec Tree Possibility . 
    ###    
    ###    
    ###                      Content of code generated 
    ###                   /+ will go in file
    ###    Output        /   
    ###    Generation-------+Both are False, it's not reported 
    ###                  \
    ###                   \+ Content of code generated  
    ###                      will go inside windows 
    ###                      called Zenity
    ###    
    ###                      Content of Execution
    ###                   /+ will go in file  
    ###    Output        /   
    ###    Execution ---------------------------------+Both are False, it's not reported ( and case neglected because 
    ###                  \                             if-elif-elif structure suggest if there is no variable handled 
    ###                   \+ Content of Execution      BoolOutToZenity & BoolOutToFile it won't fall in inapropritate choice. 
    ###                      will go inside windows 
    ###                      called Zenity
    ###    
    ###    
    ###    
    
    ### Responsible to Throw the command line on to launch it or display it 
    ### like an echo . The procedure include fall inside BoolGenerateCode ==True
    ### 1 - MUST generate code for evaluation ... 
    ### 2 - depending of a condition BoolOutToZenity==True or BoolOutToFile==True
    ### it dump the log confirmation of executed text in a zenity Windows or 
    ### File. 
    eval VerbMsg="\${${StrParserResult}}" VerbEvalForm=True VerbHeader="" VerbState=True VerbFormated=False VerbDev=/dev/stderr  Verbosis ; 
    
    if [ "${BoolOutToZenity:=False}" == "True" ] ; then
     local StrTplZenityTextInfo=${ZHOZenityTpl:="zenity --text-info --filename=__FILE__ --font=__FONT__ 2> /dev/null"} ; 
     eval VerbMsg="\${${StrParserResult}}" VerbDev=${StrDestinationResult} VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
     StrTplZenityTextInfo=${StrTplZenityTextInfo//__FILE__/${StrDestinationResult}} ; 
     StrTplZenityTextInfo=${StrTplZenityTextInfo//__FONT__/${IntFontSize}} ; 
     ### Should Lunch Zenity --text-info... 
     ${StrTplZenityTextInfo} ; 
     
     #VerbMsg=$( eval "\${${StrParserResult}}" ) VerbEvalForm=True VerbHeader="" VerbState=True VerbFormated=False Verbosis ;  
     #VerbDev=${StrDestinationResult} 
    elif [ "${BoolOutToFile:=False}" == "True" ] ; then 
     eval VerbMsg="\${${StrParserResult}}" VerbDev=${StrDestinationResult} VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False  Verbosis ; 
    
    ### Suggested to eliminate this case .  
    #elif [ "${BoolOutToFile:=False}" == "False" -a "${BoolOutToZenity:=False}" == "False" ]  ; then 
    # eval VerbMsg="\${${StrParserResult}}" VerbDev=/dev/stderr VerbEvalForm=True VerbHeader="" VerbState=${BoolDisplayDebug} VerbFormated=False  Verbosis ; 
     
    fi
   fi   
  }

  
  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}";  
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ; 
   fi   
   #eval $( CAUsingSedTrim=False CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ; 
   #local __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
   #local ArrayArg=( $* ) ;
   #local Arg0=${ArrayArg[0]};  
   
   #local StrCmd=${StrAppsTemplate}
   
   
   ### Generic Infrastructure coming from ZenityBuildForm, have proof of it's success
   ### we do assume it's simlpe to port-it inside GnrlPrsrInfctr . 
   if [ ${BoolCreateRepository:=False} == "True" ] ; then
    if [ ! -d ${StrRepositoryQuery} ] ; then 
     eval $( eval VTVIsArrayStyleInsert=True \
         VTVValueEntry=${StrVarList}   \
         VTVIsQuotedValue=True         \
         VTVIsValueReAssign=True       \
         VTVIsValueToConvert=False     \
         VTVIsArrayStyleInsert=True    \
         ValueToVariable ) RepositoryCreation ;
    fi
   fi   
    
    eval $( eval VTVIsArrayStyleInsert=True \
        VTVValueEntry=${StrVarList},StrCmd   \
        VTVIsQuotedValue=True         \
        VTVIsValueReAssign=True       \
        VTVIsValueToConvert=False     \
        VTVIsArrayStyleInsert=True    \
        ValueToVariable ) ParserFunctionEval ;
   
   ### 
  
  } 
  
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  local StrNameHelper="GnrlPrsrInfctr\tStand for General-Parser-Infrastructure ; The Fnct.D Mechanism Parsing single function call or piped function and even multi-piped function with conjunction of TagParser. ";
  local StrSummary="This TagParser for single function, piped-function and Nth-piped function is coming with Repository to log result from GnrlPrsrInfctr and Parser engine is equiped of a ParserFeeder to append Variable And Tag to know GDITagParser. The main goal of this Function is to profit from Entry of variable from command-line entry and to use extra TAG binded to Variable-name added to let it parse the rest of the information and thus will be explained." ; 
  local StrSynopsis="Soon to fill it with lot of informations";
  local StrDescription="Having surdose of informations, skip this part..." ;
  
  
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GVRIsName=True GVRIsSynopsis=True GVRIsSummary=True GVRIsDesc=True GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( __GetVarReferenceList ) ;	
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
   StrMsg=${ArrayMsg[6]} ; 
   StrMsg=${StrMsg//__FUNCT__/${__call_locality[1]}} ; 
   StrMsg=${StrMsg//__VER_CA__/${versionCA}} ; 
   StrMsg=${StrMsg//__VER_TP__/${versionTP}} ; 
   StrMsg=${StrMsg//__VER_GPI__/${versionGPI}} ; 
   VerbMsg="${StrMsg}" VerbHeader="VERSION" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
   if [ "${BoolEmitUUID:=True}" == "True" ] ; then 
    StrUUIDInstance=$( GetUTimeBased=True GetUSeq=1 GetUIDRegister=True GetUAppsRegisterName=GnrlPrsrInfctr GetUUID ) ; 
    StrMsg=${ArrayMsg[4]} ; 
    StrMsg=${StrMsg//__UUID__/${StrUUIDInstance}} ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
   fi 
   StrMsg=${ArrayMsg[5]}; 
   StrMsg=${StrMsg//__FUNCT__/${StrStartMain}}
   VerbMsg="${StrMsg}" VerbEvalForm=False VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayDebug} VerbFormated=True VerbDevOut=/dev/stderr Verbosis ; 
   
   eval $( eval VTVIsArrayStyleInsert=True  \
                VTVValueEntry=${StrVarList} \
                VTVIsQuotedValue=True       \
                VTVIsValueReAssign=True     \
                VTVIsValueToConvert=False   \
                ValueToVariable ) ${StrStartMain}
  fi
 }


fi

### function LoopShellScript 

### Is not actually ready in design plan it only miss couple of function like 
### DataExtractionTool which requiert to extract compressed file and transcoded 
### in base64 to hold on the same line of SHA1SUM, before pushing it to version 
### 0.0.2

### In General:
### 
### This application is perfect for compiling kernel or package, it was designed
### by creating a shell-script holding the configure __OPT__ && make clean && make  
### where __OPT__ stand for all CFLAGS, LDFLAGS and option from configure with 
### ---enable-..., --with-... it run the file after you save it and if the compilation
### or the return statement is OK, it store Your file as-is inside a file-storage
### compressed where function like DataExtractionTool should revert the compressed 
### information into a working script, ready to repeat the operation before you
### have changed thing you did not have idea or did not note it. It's also perfect 
### for template compilation (C++ templating) who require severe ajustement from 
### compiler notice in bjam-file can be inserted in a script where the bjam-file 
### can be generated by the script and saving the script is a clever and 
### conventionnal way to save space and information at once. 
### 
### This script also comming with a --stopservices switche where after specifying 
### the UUID instance inside prefixed-variable LSSUUIDInstance or Unified UUID
### reserved prefixed-variable UUID, it will terminate the execution-loop  
### This method can also allow starting multiple instance at once . Later a 
### ZenityStopServices can be explain to filter application from same family
### and not using DoCtrlHandler / ActivatSeServerBuffer which depend from their
### own methodology .
### 
### example : 
### >>> To stop a running instance called 25d4a256-9c1a-11e6-8b1d-001e4c8856d6 
### you can call it like : 
### 
### UUID=25d4a256-9c1a-11e6-8b1d-001e4c8856d6 LoopShellScript --stopservices
### or 
### LSSUUIDInstance=25d4a256-9c1a-11e6-8b1d-001e4c8856d6 LoopShellScript --stopservices
### 


if [ ${versionLSS:=0.0.1} == "0.0.1" ] ; then 
 
 unset LoopShellScript GetSha1Sum ; 
 function LoopShellScript()
 {
   function Verbosis()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Verb Verbosis ) ; 
   local Arg0=${ArrayArg[0]} ; 
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local IsExtendedOutput=${VerbExtendedOut:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
      if [ "${IsExtendedOutput:False}" == "True" ] ; then 
        echo -ne "${StrMsg}" ;  
      else
        echo "${StrMsg}" ;  
      fi
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:False}" == "True" ] ; then 
         echo -ne "${StrMsg}" >> ${StrDevOut} ;
       else
         echo "${StrMsg}" >> ${StrDevOut} ;
       fi
      else
       if [ "${IsExtendedOutput:False}" == "True" ] ; then 
        echo -ne "${StrMsg}" > ${StrDevOut} ;
       else
        echo "${StrMsg}" > ${StrDevOut} ;
       fi 
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis

   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( LSS LoopShellScript ) ;
    local Arg0="${ArrayArg[0]}" ; 
    local StrParentApps=${__call_locality[1]} ;
    local StrStartMain=${LSSFuncStart:=__main_StartServices} ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=LoopShellScript CAIsAddParent=False __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=LoopShellScript CAIsAddParent=False CallArgument ) ;
   fi  
  
   local StrStartFile=${LSSFileName:=start-configure.sh} ; 
   local StrStoreResult=${LSSFileStorage:=.LoopShellScript} ; 
   local StrLockFileId=${LSSFileStorageLock:=/var/cache/Fnct.D/Lock-LSS} ;
   local StrDateFormat=${LSSDateFormat:='%Y%m%d-%H:%M:%S'} ; 
   local StrPathLoopState=${LSSLoopFile:=/var/cache/Fnct.D/Loop-LSS-__UUID__} ; 
   local StrUUIDInstance=${LSSUUIDInstance:=Last-instance-UUID};
   local StrShaSumExtract=${LSSSHAIndexExtract:=None} ; 
   local StrDefaultFileFormat=${LSSFileFormat:=BZIP2+BASE64} ;
   local BoolIsScriptRun=${LSSIsScriptFile:=True} ; 
   local StrFileAlterateVrf=${LSSNonScriptValidator:=/usr/bin/file} ; 
   local BoolIsLockFile=${LSSIsLockFile:=False} ; 
   local BoolIsExtraction=${LSSIsExtraction:=False} ; 
   local BoolListFile=${LSSIsListID:=False} ;
   local BoolSearchId=${LSSIsSearchID:=False} ;  
   local BoolSearchDate=${LSSIsSearchDate:=False} ; 
   local BoolSearchFile=${LSSIsSearchFile:=False} ; 
   local StrSearchQuery=${LSSSearchQuery:=None} ;  
   local BoolHideAppsDebug=${LSSIsHideScriptOutput:=False} ; 
   local BoolDisplayDebug=${LSSIsDisplayDebug:=False} ; 
   local BoolDisplayIf=${LSSIsDisplayIfDebug:=False} ; 
   
   local StrApps=${LSSApps:=bzip2} ;
   local StrAppsCmprOpt=${LSSAppsCmprOpt:='-9c'} ;
   local StrAppsDeCmprOpt=${LSSAppsDeCmprOpt:='-dc'} ;
   local StrFilter=${LSSFilter:=base64} ; 
   local StrFilterCmprOpt=${LSSFilterCmprOpt:='--wrap=0'} ;
   local StrFilterDeCmprOpt=${LSSFilterDeCmprOpt:=-d} ;
   local StrPipeCmd=${LSSDefaultPipe:='|'} ; 
   local StrTagParser=${LSSTagParserDef:=StrPipeCmd:__PIPE__,StrFilterDeCmprOpt:__FILTER_DECR_OPT__,StrApps:__APPS__,StrAppsCmprOpt:__APPS_CMPR_OPT__,StrAppsDeCmprOpt:__APPS_DECR_OPT__,StrFilter:__FILTER__,StrFilterCmprOpt:__FILTER_CMPR_OPT__} ; 
   local StrCompressionTpl=${LSSCmprTag:=__APPS__ __APPS_CMPR_OPT__ __PIPE__ __FILTER__ __FILTER_CMPR_OPT__} ;
   local StrDeCompressionTpl=${LSSDeCmprTag:=__FILTER__ __FILTER_DECR_OPT__ __PIPE__ __APPS__ __APPS_DECR_OPT__} ;
  
   ### A short-cut to call uniformely an UUID used by this Application. 
   local UUID=${UUID:=${StrUUIDInstance}} ; 
   local StrTemplateShaStorage="__DATE__ __SHA__ __FILENAME__ __FORMAT__ __FILECONTENT__" ;
   
   local StrVarList="BoolIsScriptRun,StrFileAlterateVrf,BoolIsLockFile,StrLockFileId,BoolDisplayIf,BoolSearchId,BoolSearchDate,StrSearchQuery,BoolSearchFile,BoolListFile,BoolHideAppsDebug,StrVarList,StrStartFile,StrStoreResult,StrDateFormat,StrPathLoopState,StrUUIDInstance,StrTemplateShaStorage,StrDefaultFileFormat,StrShaSumExtract,BoolIsExtraction,StrApps,StrAppsCmprOpt,StrAppsDeCmprOpt,StrFilter,StrFilterCmprOpt,StrFilterDeCmprOpt,StrTagParser,StrCompressionTpl,StrDeCompressionTpl"
   
   function GetSha1Sum()
   {
    sha1sum ${GSSFileName} | cut -d ' ' -f 1 ; 
   } 

   function GetFileFormatCmd( )
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( GFFC GetFileFormatCmd ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=GetFileFormatCmd CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=GetFileFormatCmd CAIsAddParent=True CallArgument ) ;
    fi  
    StrMsg="Entry in function" ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

    local StrEncapsulationMeth="" ;
    local StrFileFormatMeth="" ; 
    local StrTplTagParser="" ; 
    local StrMsg="" ; 
    local StrTypeAction="Compression" ; 
    if [ "${BoolIsExtraction:=False}" == "True" ] ; then 
     ### The application is in decompression mode
     ### I do retreive the encapsulation first 
     ### Working with String-Substitution , retreiving the 
     ### encapsulation from last-elements running 
     ### ${/#__METHOD_REGEXP____CSV__} will retreive
     ### the Encapsulation, reducing the string with the 
     ### answer should give us minimal condition. 
     StrTypeAction="De-Compression" ; 
     StrTplTagParser=${StrDeCompressionTpl} ;
     StrEncapsulationMeth=${StrDefaultFileFormat/#[A-Za-z0-9]*+} ;
     StrFileFormatMeth=${StrDefaultFileFormat/%+${StrEncapsulationMeth}} ; 
    else
     ### The application is in compression mode 
     ### I do retreive the Compression method first 
     ### allowing compression of the result and retreive 
     ### the encapsulation, so Parsing the StrDefaultFileFormat
     ### will start from the end to the beginning, 
     StrTplTagParser=${StrCompressionTpl} ;
     StrFileFormatMeth=${StrDefaultFileFormat/%+[A-Za-z0-9]*} ; 
     StrEncapsulationMeth=${StrDefaultFileFormat/#${StrFileFormatMeth}+} ;
    fi 

    StrMsg="Stream Information: __TYPEACTION__" ; 
    VerbMsg="${StrMsg//__TYPEACTION__/${StrTypeAction}}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    StrMsg="Template used: __TPL__" ; 
    VerbMsg="${StrMsg//__TPL__/${StrTplTagParser}}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

    eval $( eval TPListTag=${StrTagParser}                 \
      TPArrayName=Array${__call_locality[0]}    \
      TPVarNameParsed="StrTplTagParser"         \
      TPDisplayDebug=${BoolDisplayDebug}        \
      TPDisplayParserNotice=${BoolDisplayDebug} \
      TagParser ) ; 
    
      
    StrMsg="Value StrTagParser: __VAR__" ; 
    VerbMsg="${StrMsg//__VAR__/${StrTplTagParser}}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    ### This one display on common stdout the Parsing result. 
    VerbMsg="${StrTplTagParser}" VerbState=True VerbEvalForm=True VerbFormated=False Verbosis ;
   }
   
   function FileDeCapsulation()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( FDC FileDeCapsulation ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=FileDeCapsulation CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=FileDeCapsulation CAIsAddParent=True CallArgument ) ;
    fi  
    StrMsg="Entry in function" ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    StrCodec=$( cat ${StrStoreResult} | grep -i "${StrShaSumExtract}" | cut -d ' ' -f 4 ) ;
    StrFile=$( cat ${StrStoreResult} | grep -i "${StrShaSumExtract}" | cut -d ' ' -f 3 ) ;
    if [ "${StrCodec:=None}" == "${StrDefaultFileFormat}" ] ; then 
      StrMsg="Extracting File:__FILE__, with CODEC:__CODEC__,\nCMD: __CMD__,\npresent file will be overwritten." ;
      StrMsg=${StrMsg//__FILE__/${StrFile}} ;
      StrMsg=${StrMsg//__CODEC__/${StrCodec}} ;
      StrMsg=${StrMsg//__CMD__/${StrStreamCodec}} ;
      
      VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
      cat ${StrStoreResult} | grep -i "${StrShaSumExtract}" | cut -d ' ' -f 5 | eval ${StrStreamCodec} > ${StrFile} ; 
    else 
      StrMsg=${StrMsg//__CODEC1__/${StrDefaultFileFormat}} ; 
      StrMsg=${StrMsg//__CODEC2__/${StrCodec}} ; 
      VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    fi 
    
    
   }
   
   function DataExtractionTool()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( DET DataExtractionTool ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=DataExtractionTool CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=DataExtractionTool CAIsAddParent=True CallArgument ) ;
    fi  
    StrMsg="Entry in function" ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    local ArrayFunction=( ListFile:BoolListFile SearchByFile:BoolSearchFile SearchId:BoolSearchId SearchDate:BoolSearchDate ) ; 
    
    ### Extraction Tool not ready....
    local StrStreamCodec=$( eval \
    $( eval \
      VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      VTVIsQuotedValue=True       \
      VTVIsWhiteList=True         \
      VTVWhiteListTransfert=UUID  \
      ValueToVariable ) GetFileFormatCmd ) ;     
   
    StrMsg="De-Compression Codec: __CODEC__\nCommand : __CMD__\nSearching for SHA1SUM ID:__SHASUMID__ in file __FILE__" ; 
    StrMsg=${StrMsg//__CODEC__/${StrDefaultFileFormat}} ;
    StrMsg=${StrMsg//__SHASUMID__/${StrShaSumExtract}} ;
    StrMsg=${StrMsg//__FILE__/${StrStoreResult}} ; 
    StrMsg=${StrMsg//__CMD__/${StrStreamCodec}} ; 
    
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

    #### This example require ArrayFunction in form 'FuctionName:VariableName' where 
    #### function are code allowed to search inside the StoreFile and Variable name
    #### are directly Binded Prefixed-Variable accessible from command line to specify
    #### one and only one of them, The advantage of if-elif statement, only first meet
    #### Variable test will execute the function and leave the if-elif bloc command . 
    #### Specifying more than one of these Pair Variable from Prefixed-variable relation
    #### will simply not execute the function and will requiert to remove the undesired 
    #### variable from the prompt. Cibled like unidirectional action it does fill requirement
    #### here function DataExtractionTool is multi tool pass-through where sub-function 
    #### directly do an action.
    #### 
    ####  This is acheive with a 2 type of BoolVartest if-elif + elif-fi BVTIdType=1,BVTIdType=2 ,
    ####  BVTIdType=6. This directive require inside a loop at index=0 it build a if-elif, where 
    #### it's mandatory concatenation quired to build a elif state because BoolVarTest manage 
    #### Preambule out of a condition and it's assertion from a test. While elif, else cannot use 
    #### the preambule it erase the ending-statement segment and provide only the assertion. 
    #### So looping after index 0 requiert BVTIdType=2 to build many elif and at loop index minus
    #### maximum, closing the if-elif with elif-fi where BVTIdType=6 and We can acheive a one loop
    #### building any elif clause for calling function from Boolean variable list associated with
    #### them in a Array declaration. 
    #### 
    
    local StrBoolConditionName="" ;
    local StrFunctionName="" ; 
    local StrPairFuncVar="" ;
    local StrIfElifBuild ; 
    ###eval $( eval BVTIsPreambule=False BVTIsValueToVarAssert=True BVTBoolVarName=\${BoolListFile:=False} BVTBoolCase=True  BVTVTVVarA=\${StrVarList} BVTVTFnctA=ListFile  BoolVarTest ) ;
    
    ### Following statement, if LSSSHAIndexExtract Is different than None, 
    ### it inform the application It did not choose the SHA1SUM Id to extract
    ### and either have to search for one or simply call the ListFile.
    StrMsg="Codec Problem, current configured Codec:(__CODEC1__) is not stored Codec:(__CODEC2__), you must specify a correct codec to extract this file." ;
    if [ "${StrShaSumExtract:=None}" != "None" ] ; then 
    $( eval \
      VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList},StrStreamCodec \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      VTVIsQuotedValue=True       \
      VTVIsWhiteList=True         \
      VTVWhiteListTransfert=UUID  \
      ValueToVariable ) FileDeCapsulation ;
    else 
    
     local IntIfType=6 ; 
     local IntMaxArrayIndex=$(( ${#ArrayFunction[@]}-1 )) ;
     for (( intx=0 ; intx <= ${IntMaxArrayIndex} ; intx++ )) ; do 
      StrPairFuncVar=${ArrayFunction[${intx}]} ; 
      ### Simple way to build a if-elif depending of a Array Of function 
      ### where One Boolean is require to select one of the required function
      ### and will be yield once with this if-elif structure. 
      if [ ${intx:=0} -eq 0 ] ; then 
       IntIfType=1 ;
      elif [ ${intx:=0} -gt 0 -a ${intx:=0} -lt ${IntMaxArrayIndex} ] ; then 
       IntIfType=2 ;
      elif [ ${intx:=0} -eq ${IntMaxArrayIndex} ] ; then 
       IntIfType=6 ;
      fi 
      StrBoolConditionName=${StrPairFuncVar/#[a-zA-Z0-9_]*:} ; 
      StrFunctionName=${StrPairFuncVar/%:${StrBoolConditionName/#[a-zA-Z0-9_]*:}} ; 
      ### 
      ###  Require some tuning of BoolVarTest, already changed and give good 
      ###  result.
      ### 
      StrIfBuildStatement=$( eval BVTDisplayIf=${BoolDisplayIf} BVTIdType=${IntIfType} BVTIsPreambule=False BVTIsValueToVarAssert=True BVTBoolVarName=\${${StrBoolConditionName}:=False} BVTBoolCase=True  BVTVTVVarA=${StrVarList} BVTVTFnctA=${StrFunctionName}  BoolVarTest  ) ; 
      StrIfElifBuild="${StrIfElifBuild}${StrIfBuildStatement}" ; 
     done 
     
     StrMsg="Complete If Statement from __FUNCT__:__VAR__" ; 
     StrMsg="${StrMsg//__FUNCT__/${__call_locality[0]}}" ;
     StrMsg=${StrMsg//__VAR__/${StrIfElifBuild}}
     VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayIf} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
     eval ${StrIfElifBuild} ; 
     ###; BVTIdType=6 BVTIsPreambule=False BVTIsValueToVarAssert=True BVTBoolVarName=\${BoolSearchFile:=False} BVTBoolCase=True  BVTVTVVarA=\${StrVarList} BVTVTFnctA=SearchByFile BoolVarTest ; 
    fi    
   
   } 

   function SearchByFile()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( SBF SearchByFile ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=SearchByFile CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=SearchByFile CAIsAddParent=True CallArgument ) ;
    fi
    StrMsg="Entry in function" ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
      
    StrMsg="Listing By FileName \nSHA1SUM\t\t\t\t\tFileName\n" ; 
    VerbMsg="${StrMsg}" VerbState=True VerbExtendedOut=True VerbEvalForm=False VerbFormated=False VerbDev=/dev/stderr  Verbosis ;
    cat ${StrStoreResult} | egrep -i "${StrSearchQuery}" | cut -d ' ' -f 2,3 ; 
    
   } 

   function SearchDate()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( SD SearchDate ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=SearchDate CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=SearchDate CAIsAddParent=True CallArgument ) ;
    fi  
    StrMsg="Entry in function" ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    StrMsg="Searching By Date\nDate\t\t\tSHA1SUM\t\t\t\t\tFileName\n" ; 
    VerbMsg="${StrMsg}" VerbState=True VerbExtendedOut=True VerbEvalForm=False VerbFormated=False VerbDev=/dev/stderr  Verbosis ;
    cat ${StrStoreResult} | egrep -i "${StrSearchQuery}" | cut -d ' ' -f 1,2,3 ; 
    
   }

   
   function SearchId()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( SI SearchId ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=SearchId CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=SearchId CAIsAddParent=True CallArgument ) ;
    fi  
    StrMsg="Entry in function" ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    StrMsg="Searching By ID\n\nSHA1SUM\t\t\t\t\tFileName\n" ; 
    VerbMsg="${StrMsg}" VerbState=True VerbExtendedOut=True VerbEvalForm=False VerbFormated=False VerbDev=/dev/stderr  Verbosis ;
    cat ${StrStoreResult} | egrep -i "${StrSearchQuery}" | cut -d ' ' -f 2,3 ; 
    
   }
     
   function ListFile()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( LF ListFile ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=ListFile CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=ListFile CAIsAddParent=True CallArgument ) ;
    fi  
    StrMsg="Entry in function" ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    StrMsg="Listing ID and FileName\nSHA1SUM\t\t\t\t\tFileName\n" ; 
    VerbMsg="${StrMsg}" VerbState=True VerbExtendedOut=True VerbEvalForm=False VerbFormated=False VerbDev=/dev/stderr  Verbosis ;
    cat ${StrStoreResult} | cut -d ' ' -f 2,3 ; 
    
   }

   function FileWriterSupport()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( FWS FileWriterSupport ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=FileWriterSupport CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=FileWriterSupport CAIsAddParent=True CallArgument ) ;
    fi  
    StrMsg="Entry in function" ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

    local StrCompressionStream=$( eval \
    $( eval \
      VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      VTVIsQuotedValue=True       \
      VTVIsWhiteList=True         \
      VTVWhiteListTransfert=UUID  \
      ValueToVariable ) GetFileFormatCmd ) ; 
    
    StrMsg="Compression Header:__VAR__";
    VerbMsg=${StrMsg//__VAR__/${StrCompressionStream}}"" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=True VerbEvalForm=False VerbFormated=True  VerbDev=/dev/stderr  Verbosis ;


    local IntLockInfo=0 ; 
    local StrLockHolder ; 

    StrMsg="Compression :( cat ${StrStartFile} | ${StrCompressionStream} )";
    VerbMsg=${StrMsg}"" VerbHeader="${__call_locality[1]}-CMDLINE" VerbState=True VerbEvalForm=False VerbFormated=True  VerbDev=/dev/stderr  Verbosis ;

    StrScriptCpr=$( cat ${StrStartFile} | eval ${StrCompressionStream} ) ; 
    StrNewParserInfo=${StrTemplateShaStorage} ; 
    
    StrDate=$( GODFormat="${StrDateFormat}" GetOtherDate ) ; 
       
    StrNewParserInfo=${StrNewParserInfo//__DATE__/${StrDate}}
    StrNewParserInfo=${StrNewParserInfo//__SHA__/${StrCurrentSha}}
    StrNewParserInfo=${StrNewParserInfo//__FILENAME__/${StrStartFile}}
    StrNewParserInfo=${StrNewParserInfo//__FORMAT__/${StrDefaultFileFormat}}
    StrNewParserInfo=${StrNewParserInfo//__FILECONTENT__/${StrScriptCpr}}
    if [ "${BoolIsLockFile:=False}" == "True" ] ; then 
    
     StrMsg="Lock holded by Instance-ID: __UUID__" ; 
     StrLockHolder="";
     IntLockInfo=0;
     
     while [ -f ${StrLockFileId} ] ; do  
      ### Required to sleep until LockFile is removed .
      if [ ${IntLockInfo:=0} -eq 0 -a -f ${StrLockFileId} ] ; then 
       StrLockHolder=$( cat ${StrLockFileId} ) ; 
       StrMsg=${StrMsg//__UUID__/${StrLockHolder}} ; 
       VerbMsg=${StrMsg} VerbHeader="${__call_locality[1]}-LOCK" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ;
       IntLockInfo=1 ; 
      fi 
      sleep 1 ; 
     done 
     ### If LockFile was removed or either never exist.
     ### Create a new LockFile
     VerbMsg=${StrUUID}  VerbExtendedOut=False VerbEvalForm=True VerbFormated=False VerbState=True VerbDev=${StrLockFileId}  Verbosis ;
     echo -ne "${StrNewParserInfo}\n" >> ${StrStoreResult} ;  
     rm -f ${StrLockFileId} ; 
    else
     ### Normal Writing without LockFile implementation . 
     echo -ne "${StrNewParserInfo}\n" >> ${StrStoreResult} ;  
    fi 
    
   }
   
   function ShellControlServices()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( SCS ShellControlServices ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=LoopShellScript CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=LoopShellScript CAIsAddParent=True CallArgument ) ;
    fi  
    StrMsg="Entry in function" ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    local StrUUID=$( GetUAppsRegisterName=LoopShellScript GetUTimeBased=True GetULoop=False GetUUID ) ; 
    StrPathLoopState=${StrPathLoopState//__UUID__/${StrUUID}}
    VerbMsg="Instance ID:${StrUUID}" VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ;
    touch ${StrPathLoopState} ; 

    local -A ArrayCompiler  ; 
    local StrCurrentSha ; 
    local IntCompileState=0 ; 
    local IntCompileAdd=0 ;  
    local IntReturn=0 ; 
    local IntFindCompiler ; 
    local StrScriptCpr ; 
    local StrDate ;
    local StrOperatorExec="." ; 
    
    while [ -f ${StrPathLoopState} ] ; do 
     StrCurrentSha=$( GSSFileName=${StrStartFile} GetSha1Sum ) ; 

     IntFindCompiler=0 ; 
     for Iter in ${!ArrayCompiler[@]} ; do 
       if [ "${Iter}" == "${StrCurrentSha}" ] ; then 
         IntFindCompiler=1 ; 
       fi ; 
     done 
    
     if [ ${IntFindCompiler:=0} -eq 0 ] ; then 
       ### Must add a sha1sum for specific change of compiler directive inside 
       ### start-configure.sh
       ArrayCompiler[${StrCurrentSha}]="UNKNOW" ; 
     fi 
     
     if [ "${ArrayCompiler[${StrCurrentSha}]}" == "UNKNOW" ] ; then 
      ### Do find a sha1sum compiler directive differ from previous version . 
      ### run the script and report it execution state, because the Compiler 
      ### directive are empty. 
      echo -ne "Add command-directive, SHA1SUM:${StrCurrentSha}, status: ${ArrayCompiler[${StrCurrentSha}]}\n"  ; 
      IntCompileAdd=1 ;
      IntFindCompiler=0 ;
      sleep 5 ; 
     elif [ "${ArrayCompiler[${StrCurrentSha}]}" == "OK" ] ; then 
      echo -ne "Shell-Script SHA1SUM:${StrCurrentSha}, ${ArrayCompiler[${StrCurrentSha}]}\n" ;
      IntCompileAdd=0 ; 
      IntFindCompiler=0 ;
     elif [ "${ArrayCompiler[${StrCurrentSha}]}" == "FAILED" ] ; then 
      echo -ne "Shell-Script SHA1SUM:${StrCurrentSha}, ${ArrayCompiler[${StrCurrentSha}]}\n" ;
      IntCompileAdd=0 ; 
      IntFindCompiler=0 ;
     fi

     if [ ${IntCompileAdd:=0} -eq 1  ] ; then 
       ### The Executing action . Here I do specify the execution of a script
       ### file with dot operator '. SCRIPT', but changing the infrastructure 
       ### from Script to Observe a File do require at least to inspect-it,
       ### or to look at it, here I define /usr/bin/file to simply return
       ### a correct-statement if file can be readed and identified. 
       
       if [ "${BoolIsScriptRun:=True}" == "False" ] ; then 
        StrOperatorExec=${StrFileAlterateVrf} ; 
       fi 
       if [ "${BoolHideAppsDebug:=False}" == "True" ] ; then 
         eval ${StrOperatorExec} ${StrStartFile} 2>&1 > /dev/null  ;
         IntReturn=$? ;
       else
         eval ${StrOperatorExec} ${StrStartFile} ;
         IntReturn=$? ;
       fi
       
       echo -ne "Shell-Script returned state: ${IntReturn}\n" ; 
       IntCompileState=1 ;  
       IntCompileAdd = 0 ; 
     else
      if [ "${ArrayCompiler[${StrCurrentSha}]}" != "UNKNOW" ] ; then 
        echo -ne "Shell-Script classified:${StrCurrentSha},\n\tdon't required to start over.\n"
      fi 
      sleep 5; 
      StrDate=$( GODFormat="${StrDateFormat}" GetOtherDate ) ; 
      echo -ne "UUID-Instance:${StrUUID}\nDate:${StrDate}\n"
      echo -ne "Shell-scripts directive result:\n" ;
      for StrDirective in ${!ArrayCompiler[@]} ; do
       if [ "${ArrayCompiler[${StrDirective}]}" != "UNKNOW" ] ; then 
         echo -ne "Shell-Script SHA1SUM:${StrDirective}, result: ${ArrayCompiler[${StrDirective}]}\n" ; 
       fi 
      done ;
      echo -ne "------------------------------------------------------------------------\n\n" ; 
     fi 
     
     if [ ${IntCompileState:=0} -eq 1  ] ; then 
      ### Time to analyse the result of shell-script 
      if [ ${IntReturn:=0} -eq 0  ] ; then 
       ArrayCompiler[${StrCurrentSha}]="OK"
       ### FileWriterSupport 
       $( eval \
       VTVIsArrayStyleInsert=True  \
       VTVValueEntry=${StrVarList},StrUUID,StrCompressionStream \
       VTVIsValueReAssign=True     \
       VTVIsValueToConvert=False   \
       VTVIsQuotedValue=True       \
       VTVIsWhiteList=True         \
       VTVWhiteListTransfert=UUID  \
       ValueToVariable ) FileWriterSupport ; 
       
      else 
       ### Many state can be returned, like script from configure will return :
       ### configure: error: C compiler cannot create executables, 
       ### and return code == 77 .
       ArrayCompiler[${StrCurrentSha}]="FAILED"
      fi 
      IntCompileState=0;
      IntReturn=0; 
     fi   
    done ; 
    
   }

   function __main_StopServices()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( Main __main_StopServices ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True __Call_Argument ) ;
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True CallArgument ) ;
    fi 
    StrMsg="Entry in function" ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

    local StrUUID=${UUID};
    if [ "${StrUUID:=None}" == "None" ] ; then 
     StrUUID=${StrUUIDInstance} ; 
    fi 
    local StrPathLoopState=${StrPathLoopState//__UUID__/${StrUUID}} ; 
    VerbMsg="Shutdown Instance ID:${StrUUID}, file: ${StrPathLoopState}" VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ;
    if [ -f ${StrPathLoopState} ] ; then 
     rm -f ${StrPathLoopState} ; 
    fi 
   }
   
   function __main_StartServices()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( CFCD CurlFtpContentDownload ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ;
    fi 
    StrMsg="Entry in function" ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
    local StrCmdAction=$( \
       BVTDisplayIf=${BoolDisplayIf}   \
       BVTIdType=4                     \
       BVTIsPreambule=False            \
       BVTIsValueToVarAssert=True      \
       BVTBoolVarName=\${BoolIsExtraction:=False} \
       BVTBoolCase=False               \
       BVTVTVVarA=${StrVarList}        \
       BVTVTFnctA=ShellControlServices \
       BoolVarTest                     ;
       BVTDisplayIf=${BoolDisplayIf}   \
       BVTIdType=5                     \
       BVTIsPreambule=False            \
       BVTIsValueToVarAssert=True      \
       BVTVTFnctA=DataExtractionTool   \
       BVTVTVVarA=${StrVarList}        \
       BoolVarTest                    ); 
    
    StrMsg="Complete If Statement from __FUNCT__:__VAR__" ; 
    StrMsg=${StrMsg//__VAR__/${StrCmdAction}}
    StrMsg=${StrMsg//__FUNCT__/${__call_locality[1]}}
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayIf} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    eval ${StrCmdAction} ; 
   }
   
   local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
   local StrNameHelper="LoopShellScript\t\tA Test-Unit to test command with many directive to test and report the working solution.";
   local StrSummary="This application does survey your script and run-it belong to a different SHA1SUM reported by the application and upon a result it store-it inside a File for working solution. " ; 
   local StrSynopsis="This application is also perfect for Shell-Script with TAG to replace or add directive. Coming with Start and Stop services, it expect to produce execution once and store the file inside file with SHA1SUM header from your script qualified of different from previous save or modification. Result is compressed and this application will deliver a method to extract the compressed file inside this SHA1SUM header. (END OF DRAFT INFORMATION)";
   local StrDescription="A common way to use it is to test your source package requiring to change the configure with multiples option some may fail and require to change the information inside. This application will wait until the file is changed and report you if it work or not. File Specified by the application is compressing the working result ready to extract the working solution. This Application can be shutdown from a command from same USER by using --stopservices function. It require to specify a Uniform Ressource Identifier specified inside prefixed-variable, LSSUUIDInstance. Also UUID variable can be used instead. By starting a new instance of this application it show you a UUID identifier and a new file inside  prefixed-variable LSSLoopFile will exist the time the loop is testing and compiling succesfull script. Stopping the services will only remove the file and stop the Loop.\n\nMaster Prefixed Variable\nLSSIsExtraction=False  ( by default )\nMaster Prefixed Variable\nLSSIsExtraction=False  ( by default )\nSwitch To ShellControlServices main function responsible of looping script and store working script inside file LSSFileStorage (by default .LoopShellScript)\n\n\nLSSIsExtraction=True\nSwitch To ,DataExtractionTool to access to your file LSSFileStorage (by default .LoopShellScript) by extracting script. Also access to the sub-function of DataExtractionTool, SearchByFile ,SearchDate ,SearchId ,ListFile. Only ListFile is not requiring a query to enter with prefixed variable LSSSearchQuery. Sub Function SearchByFile ,SearchDate ,SearchId require Prefixed-variable to allow a specific search and not working in same time than ListFile. Assuming ListFile can be accessed by using [ LSSIsListID=True, LSSIsExtraction=True ], sub-function SearchByFile ,SearchDate ,SearchId won't be accessible at same time. You do require to acces to them, just use [ LSSIsListID=True, LSSIsSearchID=True | LSSIsSearchDate=True | LSSIsSearchFile=True ] . Using the search facility, your query can be inserted inside Prefixed-Variable LSSSearchQuery=... . A Search engine only search it does not extract the information. \n\n\nLSSSHAIndexExtract=...\nIs the only one prefixed-parameter to use to extract the file under LoopShellScript. One full-length query to extract imply loading the DET ( DataExtractionTool ) by loading extraction:\n\n\nLSSIsExtraction=True LSSSHAIndexExtract=8fa097cd6652a6f3d106193a12ff4d5855e894a2.\n\nServices Engine Section :\nLoopShellScript can start many instance, and each instance information is stored inside /var/cache/Fnct.D/, where a file named Loop-LSS-UUID, where UUID is an UUID Identifier used to identify the active loop for your script detection. To stop a services running it's mandatory require to claim the shutdown by specifying the UUID on prompt with the switche '--stopservices' . \n\n\nex:\n$> UUID=938cc57c-9c73-11e6-8b1d-001e4c8856d6 LoopShellScript --stopservices\n\tOr\n$> LSSUUIDInstance=938cc57c-9c73-11e6-8b1d-001e4c8856d6 LoopShellScript --stopservices\n\n\nFollowing Prefixed-Variable can be used for the main-loop called ShellControlServices:\n\nLSSFileName\t\tString The Script, image, the collected data in chunk used to analysed with this application.\nLSSFileStorageLock\tString File location to control all Lock-ready Instance of LoopShellScript.\nLSSNonScriptValidator\tString default to ('/usr/bin/file') replace Operator Dot [.] in file-script execution.\nLSSIsScriptFile\t\tSet To True/False Default to True, if LSSFileName is not a script but a file to monitor it's have to turn it to False.\nLSSIsLockFile\t\tSet To True/False Default to False, allow multiple instance to store in the same file. \nLSSFileStorage\t\tString File The default file name to store all SHA1SUM + FILE, beware of multiples instance \nLSSLoopFile\t\tString File Identifier to manage the instance, To create your own repository consult GnrlPrsrInfctr Creation of repository.\nLSSFileFormat\t\tString Based on LSSApps LSSFilter prefixed-Var. it required to managed theses variable too to specify something else.\nLSSIsHideScriptOutput\tSet To True/False Hide from Stdout output of your script, does not affect the return statement.\nLSSIsDisplayDebug\tSet To True/False Display Debugging and verbose left inside.\nLSSIsDisplayIfDebug\tSet To True/False Display Debugging and verbose toward Generated-If clause from BoolVarTest.\nLSSDateFormat\t\tString and Quoted String required use Standard POSIX-date format and can use also Unix-TimeStamp.\n\n\nData Extraction Tool Section :\nExtracting the file from specified Prefixed-variable LSSFileStorage does overwrite your current file-name if this one is present inside the path where you do require to extract it. Mostly if you do have done a Shutdown request you may already own a copy of the file inside the Storage file.\n\n\nPrefixed-Variable for DataExtractionTool or ( DET ).\n\nLSSIsExtraction\t\tSet To True/False Mandatory to use DataExtractionTool search or extraction\nLSSSHAIndexExtract\tString The SHA1SUM Id information used to extract the file. \nLSSIsListID\t\tSet To True/False Only List all SHA1SUM Id and file \nLSSIsSearchID\t\tSet To True/False Actiave DET Search By ID\nLSSIsSearchDate\t\tSet To True/False Actiave DET Search By Date\nLSSIsSearchFile\t\tSet To True/False Actiave DET Search By File\nLSSSearchQuery\t\tString The query string used to seach by Date, File, ID.\n\n\nAvanced Prefixed-Variable for Both DataExtractionTool and ShellControlServices.\n\nLSSApps\t\t\tString Specify the active codec for compression, other suggestion can be gzip, lzma, 7z\nLSSAppsCmprOpt\t\tString Specify the Compression Codec parameter for compression.\nLSSAppsDeCmprOpt\tString Specify the De-Compression Codec parameter for de-compression.\nLSSFilter\t\tString Specify the encapsulation layer of compressed file stored inside declaration of  LSSFileStorage. Should support storage in one line with no EOL.\nLSSFilterCmprOpt\tString Specify the parameter to use the encapsulation to store inside the file declared by LSSFileStorage\nLSSFilterDeCmprOpt\tString Specify the paramter to extract from encapulation the compressed file. \n\n\nParser & Advanced Prefixed-Variable for Both DataExtractionTool and ShellControlServices\n\nThis section does manage uniquely your encapsulation layer and compression tool if you do provide other parameter to the application and will manage your information.\nLSSFileFormat\t\tString By Default its 'BZIP2+BASE64'\n\nLSSCmprTag\t\tString Parse your LSSFileFormat into command line to Store your script or file analysed by this application. \nLSSDeCmprTag\t\tString Parse your LSSFileFormat into command line to extract your script out of SHA1SUM Id out of the storage file. \nLSSTagParserDef\t\tString Unless your are not a ParserTag Aware it does transform TAG from Variable definition inside the application.\nLSSFuncStart\t\tString From Function member or existing function it's the function LoopShellScript.\n\nComment over LSSFileFormat:\nIn compression which is default, but internal function GetFileFormatCmd ( visible from Function Member section) callable from LSSFuncStart use the variable LSSIsExtraction and for one way compression the function read your LSSFileFormat into LSSCmprTag parameter from this String BZIP2+BASE64. Setting LSSIsExtraction=True the same function can revert this LSSFileFormat and apply BASE64+BZIP2 to getting your file out of storage file. This Parser will use LSSDeCmprTag and parsing your application BASE64+BZIP2 into a command line.\n\nComment over LSSTagParserDef:\nTouching-it play with the code and may not work, but quite usefull if you do have to add from Prefixed-Variable from prompt to One of internal function should specified with the affected tag.\n\nComment over LSSFuncStart:\nCan bypass the function design like GnrlPrsrInfctr function to implement the Repository Creation. To get familliar with use with GetFileFormatCmd and add prefixed-parameter LSSIsExtraction=[True/False] to test your compression design is throwing you correct parsing." ;
   
   
   if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    GVRIsName=True     \
    GVRIsSummary=True  \
    GVRIsSynopsis=True \
    GVRIsDesc=True     \
    GetVarReference ${__call_locality[1]} ; 
    echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ;
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    eval $( __GetVarReferenceList ) ;	
   elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
    eval $( eval \
      VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      VTVIsWhiteList=True         \
      VTVWhiteListTransfert=UUID  \
      ValueToVariable ) __main_StopServices ; 
   elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
    StrMsg="Application:${__call_locality[1]} , version:( versionTP:__VER_TP__ versionVTV:__VER_VTV__, versionCA:__VER_CA__, versionBVT:__VER_BVT__)" ; 
    StrMsg=${StrMsg//__VER_CA__/${versionCA}} ;
    StrMsg=${StrMsg//__VER_TP__/${versionTP}} ;
    StrMsg=${StrMsg//__VER_VTV__/${versionVTV}} ;
    StrMsg=${StrMsg//__VER_BVT__/${versionBVT}} ;
    VerbMsg=${StrMsg} VerbHeader="VERSION" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
    VerbMsg="Entry in function ${StrStartMain}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
    eval $( eval \
      VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      ValueToVariable ) ${StrStartMain}
   fi  
 }

### end-if versionLSS
fi 

