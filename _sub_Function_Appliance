
### Package : _sub_Function_Appliance

### Comming from reference of pythonmodule jellyfish:
### with matching rating-codex of Infrastructure
### jellyfish.match_rating_codex(u'Infrastructure')
### give Infctr
### While same module to short Name like 
### General        ->  Gnrl
### Parser         ->  Prsr
### Infrastructure ->  Infctr
### To make this function called GnrlPrsrInfctr for a really 
### short Name which telling more... 
 
### function GeneralParserInfctr 
### Is not actually ready in design plan it only miss couple of verification
### before pushing it to version 0.0.2 . It's sure if you start LibLoader ( 
### with _sub_Function_Appliance inside the ArrayLib and adding to the command 
### line versionGPI=0.0.2 it will parse this but this function is not ready 
### to proove how pushing variable from command-prompt and Feeding the Parser with 
### GDITagFeeder help the Parser to parser variable from prompt and declaration 
### of relation of variable+__TAG__ to acheive a Generalistic Case of function
### wrapper to have a applied firter to a function to get a speciffic result. 
### 
### Missing, 
###  - Loging inside UUID, 
###  - Executing the Evaluation and inject the variable result inside current code
###  so we can be ready to use the Value . We do have GDIDpkgTpl for template-future
###  command line and StrCmd from GDITagParserResult, it evaluate the GDIDpkgTpl result
### but haven't specified where to execute it... Initially inside the function but all
### the returned event are simply displayed and not keeped. 
###  - Many more precautions and tests. 
### 

if [ ${versionGPI:=0.0.2} == "0.0.1" ] ; then 
 unset GnrlPrsrInfctr; 
 function GnrlPrsrInfctr()
 {
  local __call_locality=( GPI GnrlPrsrInfctr ) ;
  local ArrayArg=( $* ) ;
  local Arg0=( ${ArrayArg[0]} ) ; 
  
  ### General to GnrlPrsrInfctr Command Parser and depot. 
  local StrAppsTemplate=${GPIDpkgTpl:=__APPS__ __APPS_OPT__ __PIPE__ __FILTER__ __FILTER_OPT__ } ;
  local StrApps=${GPIDpkgApps:=/usr/bin/dpkg} ;
  local StrAppsOpt=${GPIDpkgAppsOpt:=--get-selections} ; 
  local StrFilterApps=${GPIFilterApps:=/usr/bin/gawk} ;
  local StrFileName=${GPIFileName:=None} ;
  local StrFilterOpt=${GPIFilterOpt:=-f __FILE__} ; 
  local StrParserTag=${GPITagParser:=StrDefaultPipe:__PIPE__,StrApps:__APPS__,StrAppsOpt:__APPS_OPT__,StrFilterApps:__FILTER__,StrFilterOpt:__FILTER_OPT__,StrFileName:__FILE__}
  local StrTagFeeder=${GPITagFeeder:=''} ;
  local StrParserResult=${GPITagParserResult:=StrCmd} ; 
  local StrDefaultPipe=${GPIPipeSig:=\|} ;
  local StrDefaultVerbose=${GPIVerboseDev:=/dev/stderr} ; 
  local StrUUIDInstance ;
  local StrFileOutput=${GPIOutFile:=.GnrlPrsrInfctr} ; 
  local BoolDisplayDebug=${GPIDisplayDebug:=False} ; 
  local BoolEmitUUID=${GPIIsUUIDInstance:=False} ; 
  local BoolGenerateCode=${GPIIsGenerateCode:=False} ; 
  local BoolOutToZenity=${GPIIsZenityHandlerOut:=False} ;
  local BoolOutToFile=${GPIIsFileHandlerOut:=False} ; 
  local BoolExecuteEval=${GPIIsExecuteEval:=True} ; 

  ### General To RepositoryCreation
  local BoolRepoCreaEnabled=${GPIRepoCreatEnabled:=True} ; 
  local BoolDisplayParserDebug=${GPIParserDebug:=False} ;
  local BoolCreateRepository=${GPIRepositoryCreation:=False} ; 
  local StrTagRepoMkdir=${GPIParserMkdir:=StrAppsSudo:__SUDO__,StrAppsSudoOpt:__OPT__,StrAppsMkdir:__APPS__,StrRepositoryQuery:__PATH__,StrAppsMkdirOpt:__APPS_OPTS__} ;
  local StrTagRepoChmod=${GPIParserChmod:=StrAppsSudo:__SUDO__,StrAppsSudoOpt:__OPT__,StrAppsChmod:__APPS__,StrRepositoryQuery:__PATH__,StrDefaultPerm:__PERM__} ;
  local StrTagRepoChown=${GPIParserChown:=StrAppsSudo:__SUDO__,StrAppsSudoOpt:__OPT__,StrAppsChown:__APPS__,StrRepositoryQuery:__PATH__,StrDefaultUser:__OWNER__} ;
  local StrPrefixTagGroup=${GPIGroupParserPrefix:=StrTagRepo} ; 
  local -A ArrayTplAction ; 
  ### Fixed after reference : 472de1ad3899ab7a0aa52869a073c19c52178940
  ### Associative Array was declared with '-a' instead of '-A'
  local StrRepositoryQuery=${GPIQueryRepository:=/var/log/Fnct.D/GnrlPrsrInfctr} ;  
  local StrDefaultUser=${GPIRepoUser:=user.root} ;
  local StrDefaultPerm=${GPIRepoPerm:=775} ;  
  local StrAppsSudo=${GPIAppsSudo:=/usr/bin/sudo} ;
  local StrAppsSudoOpt=${GPIAppsSudoOpt:=-s -H} ;
  local StrAppsMkdir=${GPIAppsMkdir:=/bin/mkdir} ;
  local StrAppsMkdirOpt=${GPIAppsMkdirOpt:=-p} ;
  local StrAppsChown=${GPIChown:=/bin/chown} ;
  local StrAppsChmod=${GPIChmod:=/bin/chmod} ;
  local StrParentApps=${__call_locality[1]} ;
  local StrStartMain=${GPIFuncStart:=__main_StartServices} ;
  
  ArrayMsg[0]="Prefixed Variable: __VAR__=__VALUE__\nThis is an assistant creating the Repository (location: __PATH__)\n.This is reserved to store your Query for future uses. Prepare to enter into\nCredential action to create the Repository. In case your haven't chooses Variable\n\tGPIRepoUser GPIRepoPerm\nto set your user(s)/Group accessing the repository or Permission to read and write,\nyou can stop the application and start over. If you haven't choose a Function Name\nfor this step it will pop-you a warning and stop the application." ;
  ArrayMsg[1]="Creation of PATH __PATH__, Right Attribution : __MODE__, Owner: __USER__" ;
  ArrayMsg[2]="__CMD__ " ;
  ArrayMsg[3]="Parsed CmdLine: __CMDLINE__" ;
  ArrayMsg[4]="Instance will use UUID reference: __UUID__"
  ArrayMsg[5]="Entry-Start : __FUNCT__"
  
  ArrayTplAction["Mkdir"]="__SUDO__ __OPT__ __APPS__ __APPS_OPTS__ __PATH__" ;  
  ArrayTplAction["Chmod"]="__SUDO__ __OPT__ __APPS__ __PERM__ __PATH__"   ;
  ArrayTplAction["Chown"]="__SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__"   ;
  local ArrayActionOrder=( "Mkdir" "Chmod" "Chown" ) ;
   
  local StrVarList="StrVarList,BoolOutToZenity,BoolOutToFile,StrTagFeeder,StrParentApps,BoolEmitUUID,StrParserResult,StrAwkScript,StrAppsTemplate,StrApps,StrAppsOpt,StrFilterApps,StrFilterOpt,StrParserTag,StrFileName,StrDefaultPipe,StrDefaultVerbose,StrTagRepoMkdir,StrTagRepoChmod,StrTagRepoChown,BoolRepoCreaEnabled,BoolDisplayParserDebug,StrRepositoryQuery,BoolCreateRepository,StrDefaultUser,StrDefaultPerm,StrAppsSudo,StrAppsSudoOpt,StrAppsMkdir,StrAppsChown,StrAppsChmod,StrStartMain,BoolExecuteEval,BoolGenerateCode,StrUUIDInstance,StrPrefixTagGroup" ; 
  
  ### Informations About uses of StrUUIDInstance vs. StrFileOutput  .
  ### 
  ### +---------------------------------------------------------------------------------------------------+ 
  ### |Specialized case, if it's UUID choice have been obtain from BoolEmitUUID                           |
  ### | we do storing inside {Repository}/{UUID} , if its not the case it's {GPIOutFile:=.GnrlPrsrInfctr} |
  ### | it can be everywhere                                                                              |
  ### +-+-------------------------------------------------------------------------------------------------+
  ###   |
  ### +-+----------------------------+
  ### | Box-Location-Of-Information  |
  ### |    < BoolEmitUUID >          |  is Reponsible to inform the application to :
  ### +-+-----|---|------------------+        
  ###   |     |   +TRUE -> Use the UUID Infrastructure and output on location {Repository}/{UUID} on need  
  ###   |     +FALSE    -> Use the local {GPIOutFile:=.GnrlPrsrInfctr} on need . 
  ###   | 
  ### +-+---------------------------------------------+ In case BoolExecuteEval==True ( same model is 
  ### |  Box-Output-The-Information                   | applied to BoolExecuteEval=False )
  ### | <BoolOutToZenity==True> <BoolOutToFile==True> |
  ### +--------+------------------+-------------------+   
  ###          |                  | 
  ###   <Attr:BoolEmitUUID>       +---<Attr:BoolEmitUUID>---For BoolEmitUUID==True
  ###      |   |                                 |          Information will be dumped inside
  ###      |   +For BoolEmitUUID==False          |          {Repository}/{UUID}
  ###      |    Zenity will look inside file     +---For BoolEmitUUID==False
  ###      |    {GPIOutFile:=.GnrlPrsrInfctr}        Information will be dumped inside
  ###      |                                         {GPIOutFile:=.GnrlPrsrInfctr}
  ###      +-----For BoolEmitUUID==True
  ###            Zenity will look inside file
  ###            {Repository}/{UUID} 
  ### 
  ### 
  ### 
  
  

  ### This is a specialized Verbosis mode :
  ###  
  ###  All condition required to set VerbState=True 
  ###  All condition required to set a message with VerbMsg=STRING
  ###  
  ###  
  ### It can be used to :
  ###  - Echo result to be passed throught Value Result .
  ###  Required :
  ###  VerbEvalForm=True VerbFormated=False 
  ###  
  ###  VerbHeader Is ineffective
  ###  
  ### -Echo result can be append to file and not overwriting the content: 
  ###  Required ;
  ###  VerbFormated=False/True VerbAppendDev=True VerbDev=[ FILENAME | UUID ]
  ###  - Appending to file also required to be unique-file were no instance of 
  ###  Verbosis may point on same-file or loss of log will be CERTAIN.
  ###  -Pointing to Same-Destination require a lock Mechanism which is 
  ###  not implemented here
  ###  
  function Verbosis()
  {
   local __call_locality=( Verbosis Verb );
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
        echo "${StrMsg}" ;  
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo "${StrMsg}" >> ${StrDevOut} ;
      else
       echo "${StrMsg}" > ${StrDevOut} ;
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis
  
  function RepositoryCreation()
  {
   local __call_locality=( RC RepositoryCreation ${StrParentApps} ) ; 
   local Arg0=${ArrayArg[0]} ; 
   local ArrayArg=( $* ) ;
   local StrAction ; 
   if [ ! -d ${StrRepositoryQuery} ] ; then 
    StrMsg=$( ${StrParentApps} --get ArrayMsg[0] ) ;
    StrMsg=${StrMsg//__VALUE__/${BoolCreateRepository}} ; 
    StrMsg=${StrMsg//__VAR__/BoolCreateRepository} ; 
    StrMsg=${StrMsg//__PATH__/${StrRepositoryQuery}} ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis ; 
    
    StrMsg=$( ${StrParentApps} --get ArrayMsg[1] ) ;
    StrMsg=${StrMsg//__PATH__/${StrRepositoryQuery}} ;
    StrMsg=${StrMsg//__MODE__/${StrDefaultPerm}} ;
    StrMsg=${StrMsg//__USER__/${StrDefaultUser}} ;
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis ; 

    ### The Array ArrayActionOrder is present to define an order . This order 
    ### result in getting numerical index from 1 .. N
    ### Getting information from ArrayActionOrder[@], provide 
    ### 3 differents index name, 
    ### 0 -> "Mkdir" 
    ### 1 -> "Chmod" 
    ### 2 -> "Chown"
    ### in Error observed inside error-fix.txt for reference : 472de1ad3899ab7a0aa52869a073c19c52178940
    ### is the StrAction is not changing at all after each loop and get only
    ### ArrayTplAction["Chown"] 
    ### 
    ### This mean : 
    ### calling application 
    ### GnrlPrsrInfctr --get ArrayTplAction['Mkdir']
    ###  --> __SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__
    ### GnrlPrsrInfctr --get ArrayTplAction['Chmod']
    ###  --> __SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__
    ### GnrlPrsrInfctr --get ArrayTplAction['Chown']
    ###  --> __SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__
    ### 
    ### Getting from First Application able to do this : ZenityBuildForm
    ### 
    ### ZenityBuildForm --get ArrayTplAction['Mkdir'] 
    ###  --> __SUDO__ __OPT__ __APPS__ __PATH__
    ### ZenityBuildForm --get ArrayTplAction['Chmod'] 
    ###  --> __SUDO__ __OPT__ __APPS__ __PERM__ __PATH__
    ### ZenityBuildForm --get ArrayTplAction['Chown']
    ###  --> __SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__
    ### 
    for IterActionName in $( ${StrParentApps} --get ArrayActionOrder[@] ) ; do 
     StrAction=$( ${StrParentApps} --get ArrayTplAction["${IterActionName}"] ) ; 
     StrArrayName="${StrPrefixTagGroup}" ;
     
     StrTagListVarName="${StrArrayName}${IterActionName}" ;
     eval "StrTagListVar=\${${StrTagListVarName}} ;" ; 
     StrMsg="Parser TAG-List Variable name : __TAGLIST__: Template:[ __ACTION__] : content: [ __CONTENT__ ]" ; 
     StrMsg=${StrMsg//__TAGLIST__/${StrTagListVarName}} ; 
     StrMsg=${StrMsg//__CONTENT__/${StrTagListVar}} ; 
     StrMsg=${StrMsg//__ACTION__/${StrAction}} ; 
     
     VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
     eval $( TPVarNameParsed="StrAction"                       \
             TPListTag=${StrTagListVar}                        \
             TPIsMatchRtoL=True                                \
             TPDisplayParserNotice=\${BoolDisplayParserDebug}  \
             TPDisplayDebug=${BoolDisplayDebug}                \
             TPArrayName="Array${__call_locality[0]}Tag"       \
             TagParser 2> /dev/null ) ;
     StrMsg=$( ${StrParentApps} --get ArrayMsg[2] ) ;
     
     VerbMsg="${StrMsg//__CMD__/${StrAction}}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis ; 
     if [ "${BoolRepoCreaEnabled:=False}" == "True" ] ; then 
       eval """$( ${StrAction} )""" ;
     fi 
    done 

   fi 

  } 
  
  function ParserFunctionEval()
  {
   local __call_locality=( PFE ParserFunctionEval ${StrParentApps} ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]};  
   
   eval ${StrParserResult}=${StrAppsTemplate} ;
   
   StrMsg="Copy of StrAppsTemplate, named __VAR__ will hold __CONTENT__" ; 
   StrMsg=${StrMsg//__VAR__/${StrParserResult}} ;
   eval """StrMsg=\${StrMsg//__CONTENT__/\${${StrParserResult}}}"""  ;
   VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbState=${BoolDisplayDebug} VerbFormated=True VerbHeader="${__call_locality[1]}-CMDLINE" Verbosis
   
   eval $( TPIsMatchRtoL=True                        \
           TPVarNameParsed="${StrParserResult}"      \
           TPDisplayDebug=${BoolDisplayDebug}        \
           TPDisplayParserNotice=${BoolDisplayParserDebug}  \
           TPArrayName=Array${__call_locality[0]}Tag \
           TPListTag="${StrParserTag}"               \
           TagParser ) ; 
   
   StrMsg=$( ${StrParentApps} --get ArrayMsg[3] ) ;
   eval """StrMsg=\${StrMsg//__CMDLINE__/\${${StrParserResult}}}"""  ;
   VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbState=${BoolDisplayDebug} VerbFormated=True VerbHeader="${__call_locality[1]}-CMDLINE" Verbosis
   
   local StrFileResult="" ;
   local StrDestinationResult="" ; 
   if [ "${BoolEmitUUID:=True}" == "True" ] ; then
    StrFileResult="${StrUUIDInstance}" ; 
    StrDestinationResult="${StrRepositoryQuery}/${StrFileResult}" ;
   else 
    StrFileResult="${StrFileOutput}" ; 
    StrDestinationResult="${StrFileResult}"
   fi 
   
   local StrTplZenityTextInfo="zenity --text-info --filename=__FILE__ --font=10" ; 
   if [ ${BoolExecuteEval:=True} == "True" ] ; then
    ### Execution Side 
    eval """\${${StrParserResult}}""" ; 
    if [ "${BoolOutToZenity:=False}" == "True" ] ; then 
     ### Send-it to a file, Zenity will recuperate-it 
     VerbMsg="""\${${StrParserResult}}""" VerbDev=${StrDestinationResult} VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
     StrTplZenityTextInfo=${StrTplZenityTextInfo//__FILE__/${StrDestinationResult}} ; 
     ### Should Lunch Zenity --text-info... 
     ${StrTplZenityTextInfo}
    elif [ "${BoolOutToFile:=False}" == "True" ] ; then 
     ### Send-it to a file. 
     ### No recuperation from tiers methods. 
     VerbMsg="""\${${StrParserResult}}""" VerbDev=${StrDestinationResult} VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
    elif [ "${BoolOutToFile:=False}" == "False" -a "${BoolOutToZenity:=False}" == "False" ]  ; then 
     ### Display the Evaluation on /dev/stderr 
     VerbMsg="""\${${StrParserResult}}""" VerbDev=/dev/stderr VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
           
    fi
     
   elif [ "${BoolGenerateCode:=False}" == "True" ] ; then 
    ### Evaluation side to execte it inside called-funtion. 
    VerbMsg="""\${${StrParserResult}}""" VerbEvalForm=True VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
        
   fi   
  }

  function __main_StartServices()
  {
   local __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]};  
   local StrCmd=${StrAppsTemplate}
   ### dpkg --get-selections | awk -f ${StrAwkScript}
   
   ### Generic Infrastructure coming from ZenityBuildForm, have proof of it's success
   ### we do assume it's simlpe to port-it inside GnrlPrsrInfctr . 
   if [ ${BoolCreateRepository:=False} == "True" ] ; then
    if [ ! -d ${StrRepositoryQuery} ] ; then 
     eval $( VTVIsArrayStyleInsert=True \
         VTVValueEntry=${StrVarList}   \
         VTVIsValueReAssign=True       \
         VTVIsValueToConvert=False     \
         VTVIsArrayStyleInsert=True    \
         ValueToVariable ) RepositoryCreation ;
    fi
   fi   
    
    eval $( VTVIsArrayStyleInsert=True \
        VTVValueEntry=${StrVarList}   \
        VTVIsValueReAssign=True       \
        VTVIsValueToConvert=False     \
        VTVIsArrayStyleInsert=True    \
        ValueToVariable ) ParserFunctionEval ;
   
   ### 
  
  } 
  
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  local StrNameHelper="GnrlPrsrInfctr\tStand for General-Parser-Infrastructure ; The Fnct.D Mechanism Parsing single function call or piped function and even multi-piped function with conjunction of TagParser. ";
  local StrSummary="This TagParser for single function, piped-function and Nth-piped function is coming with Repository to log result from GnrlPrsrInfctr and Parser engine is equiped of a ParserFeeder to append Variable And Tag to know GDITagParser. The main goal of this Function is to profit from Entry of variable from command-line entry and to use extra TAG binded to Variable-name added to let it parse the rest of the information and thus will be explained." ; 
  local StrSynopsis="Soon to fill it with lot of informations";
  local StrDescription="Having surdose of informations, skip this part..." ;
  
  
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GVRIsName=True GVRIsSynopsis=True GVRIsSummary=True GVRIsDesc=True GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( __GetVarReferenceList ) ;	
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
   if [ "${BoolEmitUUID:=True}" == "True" ] ; then 
    StrUUIDInstance=$( GetUTimeBased=True GetUSeq=1 GetUIDRegister=True GetUAppsRegisterName=GnrlPrsrInfctr GetUUID ) ; 
    VerbMsg="${ArrayMsg[4]//__UUID__/${StrUUIDInstance}}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
   
   fi 
   StrMsg=${ArrayMsg[5]}; 
   VerbMsg="${StrMsg//__FUNCT__/${StrStartMain}}" VerbEvalForm=True VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
   eval $( VTVIsArrayStyleInsert=True \
        VTVValueEntry=${StrVarList}   \
        VTVIsValueReAssign=True       \
        VTVIsValueToConvert=False     \
        VTVIsArrayStyleInsert=True    \
        ValueToVariable ) ${StrStartMain}
  fi
 }


fi
