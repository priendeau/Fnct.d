
### Package : _sub_Function_Appliance

### Comming from reference of pythonmodule jellyfish:
### with matching rating-codex of Infrastructure
### jellyfish.match_rating_codex(u'Infrastructure')
### give Infctr
### While same module to short Name like 
### General        ->  Gnrl
### Parser         ->  Prsr
### Infrastructure ->  Infctr
### To make this function called GnrlPrsrInfctr for a really 
### short Name which telling more... 
 
### function GeneralParserInfctr 
### Is not actually ready in design plan it only miss couple of verification
### before pushing it to version 0.0.2 . It's sure if you start LibLoader ( 
### with _sub_Function_Appliance inside the ArrayLib and adding to the command 
### line versionGPI=0.0.2 it will parse this but this function is not ready 
### to proove how pushing variable from command-prompt and Feeding the Parser with 
### GDITagFeeder help the Parser to parser variable from prompt and declaration 
### of relation of variable+__TAG__ to acheive a Generalistic Case of function
### wrapper to have a applied firter to a function to get a speciffic result. 
### 
### Missing, 
###  - Loging inside UUID, 
###  - Executing the Evaluation and inject the variable result inside current code
###  so we can be ready to use the Value . We do have GDIDpkgTpl for template-future
###  command line and StrCmd from GDITagParserResult, it evaluate the GDIDpkgTpl result
### but haven't specified where to execute it... Initially inside the function but all
### the returned event are simply displayed and not keeped. 
###  - Many more precautions and tests. 
### 

if [ ${versionGPI:=0.0.2} == "0.0.1" ] ; then 
 unset GnrlPrsrInfctr; 
 function GnrlPrsrInfctr()
 {
  eval $( CAFunctName=GnrlPrsrInfctr CAIsAddParent=False __Call_Argument ) ; 
  #local __call_locality=( GPI GnrlPrsrInfctr ) ;
  #local ArrayArg=( $* ) ;
  #local Arg0=( ${ArrayArg[0]} ) ; 
  
  ### General to GnrlPrsrInfctr Command Parser and depot. 
  local StrAppsTemplate=${GPITpl:=__APPS__ __APPS_OPT__ __PIPE__ __FILTER__ __FILTER_OPT__} ;
  local StrApps=${GPIApps:=/usr/bin/dpkg} ;
  local StrAppsOpt=${GPIAppsOpt:=--get-selections} ; 
  local StrFilterApps=${GPIFilterApps:=/usr/bin/gawk} ;
  local StrFileName=${GPIFileName:=None} ;
  local StrFilterOpt=${GPIFilterOpt:=-f __FILE__} ; 
  local StrParserTag=${GPITagParser:=StrDefaultPipe:__PIPE__,StrApps:__APPS__,StrAppsOpt:__APPS_OPT__,StrFilterApps:__FILTER__,StrFilterOpt:__FILTER_OPT__,StrFileName:__FILE__}
  local StrTagFeeder=${GPITagFeeder:=''} ;
  local StrParserResult=${GPITagParserResult:=StrCmd} ; 
  local StrUUIDTransmit=${GPITUUIDName:=UUID} ; 
  local StrDefaultPipe=${GPIPipeSig:=\|} ;
  local StrDefaultVerbose=${GPIVerboseDev:=/dev/stderr} ; 
  local IntFontSize=${GPIFontSize:=10} ; 
  local StrUUIDInstance ;
  local StrFileOutput=${GPIOutFile:=.GnrlPrsrInfctr} ; 
  local BoolDisplayDebug=${GPIDisplayDebug:=False} ; 
  local BoolEmitUUID=${GPIIsUUIDInstance:=False} ; 
  local BoolGenerateCode=${GPIIsGenerateCode:=False} ; 
  local BoolOutToZenity=${GPIIsZenityHandlerOut:=False} ;
  local BoolOutToFile=${GPIIsFileHandlerOut:=False} ; 
  local BoolExecuteEval=${GPIIsExecuteEval:=True} ; 

  ### General To RepositoryCreation
  local BoolRepoCreaEnabled=${GPIRepoCreatEnabled:=True} ; 
  local BoolDisplayParserDebug=${GPIParserDebug:=False} ;
  local BoolCreateRepository=${GPIRepositoryCreation:=False} ; 
  local StrTagRepoMkdir=${GPIParserMkdir:=StrAppsSudo:__SUDO__,StrAppsSudoOpt:__OPT__,StrAppsMkdir:__APPS__,StrRepositoryQuery:__PATH__,StrAppsMkdirOpt:__APPS_OPTS__} ;
  local StrTagRepoChmod=${GPIParserChmod:=StrAppsSudo:__SUDO__,StrAppsSudoOpt:__OPT__,StrAppsChmod:__APPS__,StrRepositoryQuery:__PATH__,StrDefaultPerm:__PERM__} ;
  local StrTagRepoChown=${GPIParserChown:=StrAppsSudo:__SUDO__,StrAppsSudoOpt:__OPT__,StrAppsChown:__APPS__,StrRepositoryQuery:__PATH__,StrDefaultUser:__OWNER__} ;
  local StrPrefixTagGroup=${GPIGroupParserPrefix:=StrTagRepo} ; 
  local -A ArrayTplAction ; 
  ### Fixed after reference : 472de1ad3899ab7a0aa52869a073c19c52178940
  ### Associative Array was declared with '-a' instead of '-A'
  local StrRepositoryQuery=${GPIQueryRepository:=/var/log/Fnct.D/GnrlPrsrInfctr} ;  
  local StrDefaultUser=${GPIRepoUser:=user.root} ;
  local StrDefaultPerm=${GPIRepoPerm:=775} ;  
  local StrAppsSudo=${GPIAppsSudo:=/usr/bin/sudo} ;
  local StrAppsSudoOpt=${GPIAppsSudoOpt:=-s -H} ;
  local StrAppsMkdir=${GPIAppsMkdir:=/bin/mkdir} ;
  local StrAppsMkdirOpt=${GPIAppsMkdirOpt:=-p} ;
  local StrAppsChown=${GPIChown:=/bin/chown} ;
  local StrAppsChmod=${GPIChmod:=/bin/chmod} ;
  #local StrParentApps=${__call_locality[1]} ;
  #local StrStartMain=${GPIFuncStart:=__main_StartServices} ;
  
  ArrayMsg[0]="Prefixed Variable: __VAR__=__VALUE__\nThis is an assistant creating the Repository (location: __PATH__)\n.This is reserved to store your Query for future uses. Prepare to enter into\nCredential action to create the Repository. In case your haven't chooses Variable\n\tGPIRepoUser GPIRepoPerm\nto set your user(s)/Group accessing the repository or Permission to read and write,\nyou can stop the application and start over. If you haven't choose a Function Name\nfor this step it will pop-you a warning and stop the application." ;
  ArrayMsg[1]="Creation of PATH __PATH__, Right Attribution : __MODE__, Owner: __USER__" ;
  ArrayMsg[2]="__CMD__ " ;
  ArrayMsg[3]="Parsed CmdLine: __CMDLINE__" ;
  ArrayMsg[4]="Instance will use UUID reference: __UUID__"
  ArrayMsg[5]="Entry-Start : __FUNCT__"
  
  ArrayTplAction["Mkdir"]="__SUDO__ __OPT__ __APPS__ __APPS_OPTS__ __PATH__" ;  
  ArrayTplAction["Chmod"]="__SUDO__ __OPT__ __APPS__ __PERM__ __PATH__"   ;
  ArrayTplAction["Chown"]="__SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__"   ;
  local ArrayActionOrder=( "Mkdir" "Chmod" "Chown" ) ;
   
  local StrVarList="StrVarList,StrFileOutput,BoolOutToZenity,BoolOutToFile,StrTagFeeder,StrParentApps,BoolEmitUUID,StrParserResult,StrAwkScript,StrAppsTemplate,StrApps,StrAppsOpt,StrFilterApps,StrFilterOpt,StrParserTag,StrFileName,StrDefaultPipe,StrDefaultVerbose,StrTagRepoMkdir,StrTagRepoChmod,StrTagRepoChown,BoolRepoCreaEnabled,BoolDisplayParserDebug,StrRepositoryQuery,BoolCreateRepository,StrDefaultUser,StrDefaultPerm,StrAppsSudo,StrAppsSudoOpt,StrAppsMkdir,StrAppsChown,StrAppsChmod,StrStartMain,BoolExecuteEval,BoolGenerateCode,StrUUIDInstance,StrPrefixTagGroup,StrUUIDTransmit,IntFontSize" ; 
  
  ### Informations About uses of StrUUIDInstance vs. StrFileOutput  .
  ### 
  ### +---------------------------------------------------------------------------------------------------+ 
  ### |Specialized case, if it's UUID choice have been obtain from BoolEmitUUID                           |
  ### | we do storing inside {Repository}/{UUID} , if its not the case it's {GPIOutFile:=.GnrlPrsrInfctr} |
  ### | it can be everywhere                                                                              |
  ### +-+-------------------------------------------------------------------------------------------------+
  ###   |
  ### +-+----------------------------+
  ### | Box-Location-Of-Information  |
  ### |    < BoolEmitUUID >          |  is Reponsible to inform the application to :
  ### +-+-----|---|------------------+        
  ###   |     |   +TRUE -> Use the UUID Infrastructure and output on location {Repository}/{UUID} on need  
  ###   |     +FALSE    -> Use the local {GPIOutFile:=.GnrlPrsrInfctr} on need . 
  ###   | 
  ### +-+---------------------------------------------+ In case BoolExecuteEval==True ( same model is 
  ### |  Box-Output-The-Information                   | applied to BoolExecuteEval=False )
  ### | <BoolOutToZenity==True> <BoolOutToFile==True> |
  ### +--------+------------------+-------------------+   
  ###          |                  | 
  ###   <Attr:BoolEmitUUID>       +---<Attr:BoolEmitUUID>---For BoolEmitUUID==True
  ###      |   |                                 |          Information will be dumped inside
  ###      |   +For BoolEmitUUID==False          |          {Repository}/{UUID}
  ###      |    Zenity will look inside file     +---For BoolEmitUUID==False
  ###      |    {GPIOutFile:=.GnrlPrsrInfctr}        Information will be dumped inside
  ###      |                                         {GPIOutFile:=.GnrlPrsrInfctr}
  ###      +-----For BoolEmitUUID==True
  ###            Zenity will look inside file
  ###            {Repository}/{UUID} 
  ### 
  ### 
  ### 
  
  

  ### This is a specialized Verbosis mode :
  ###  
  ###  All condition required to set VerbState=True 
  ###  All condition required to set a message with VerbMsg=STRING
  ###  
  ###  
  ### It can be used to :
  ###  - Echo result to be passed throught Value Result .
  ###  Required :
  ###  VerbEvalForm=True VerbFormated=False 
  ###  
  ###  VerbHeader Is ineffective
  ###  
  ### -Echo result can be append to file and not overwriting the content: 
  ###  Required ;
  ###  VerbFormated=False/True VerbAppendDev=True VerbDev=[ FILENAME | UUID ]
  ###  - Appending to file also required to be unique-file were no instance of 
  ###  Verbosis may point on same-file or loss of log will be CERTAIN.
  ###  -Pointing to Same-Destination require a lock Mechanism which is 
  ###  not implemented here
  ###  
  function Verbosis()
  {
   eval $( CAFunctName=Verbosis CAIsAddParent=False __Call_Argument ) ; 
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
        echo "${StrMsg}" ;  
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo "${StrMsg}" >> ${StrDevOut} ;
      else
       echo "${StrMsg}" > ${StrDevOut} ;
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis
  
  function RepositoryCreation()
  {
   eval $( "CAFunctName=RepositoryCreation CAIsAddParent=True __Call_Argument" ) ; 
   #local __call_locality=( RC RepositoryCreation ${StrParentApps} ) ; 
   #local Arg0=${ArrayArg[0]} ; 
   #local ArrayArg=( $* ) ;
   local StrAction ; 
   if [ ! -d ${StrRepositoryQuery} ] ; then 
    StrMsg=$( ${StrParentApps} --get ArrayMsg[0] ) ;
    StrMsg=${StrMsg//__VALUE__/${BoolCreateRepository}} ; 
    StrMsg=${StrMsg//__VAR__/BoolCreateRepository} ; 
    StrMsg=${StrMsg//__PATH__/${StrRepositoryQuery}} ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis ; 
    
    StrMsg=$( ${StrParentApps} --get ArrayMsg[1] ) ;
    StrMsg=${StrMsg//__PATH__/${StrRepositoryQuery}} ;
    StrMsg=${StrMsg//__MODE__/${StrDefaultPerm}} ;
    StrMsg=${StrMsg//__USER__/${StrDefaultUser}} ;
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis ; 

    ### The Array ArrayActionOrder is present to define an order . This order 
    ### result in getting numerical index from 1 .. N
    ### Getting information from ArrayActionOrder[@], provide 
    ### 3 differents index name, 
    ### 0 -> "Mkdir" 
    ### 1 -> "Chmod" 
    ### 2 -> "Chown"
    ### in Error observed inside error-fix.txt for reference : 472de1ad3899ab7a0aa52869a073c19c52178940
    ### is the StrAction is not changing at all after each loop and get only
    ### ArrayTplAction["Chown"] 
    ### 
    ### This mean : 
    ### calling application 
    ### GnrlPrsrInfctr --get ArrayTplAction['Mkdir']
    ###  --> __SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__
    ### GnrlPrsrInfctr --get ArrayTplAction['Chmod']
    ###  --> __SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__
    ### GnrlPrsrInfctr --get ArrayTplAction['Chown']
    ###  --> __SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__
    ### 
    ### Getting from First Application able to do this : ZenityBuildForm
    ### 
    ### ZenityBuildForm --get ArrayTplAction['Mkdir'] 
    ###  --> __SUDO__ __OPT__ __APPS__ __PATH__
    ### ZenityBuildForm --get ArrayTplAction['Chmod'] 
    ###  --> __SUDO__ __OPT__ __APPS__ __PERM__ __PATH__
    ### ZenityBuildForm --get ArrayTplAction['Chown']
    ###  --> __SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__
    ### 
    for IterActionName in $( ${StrParentApps} --get ArrayActionOrder[@] ) ; do 
     StrAction=$( ${StrParentApps} --get ArrayTplAction["${IterActionName}"] ) ; 
     StrArrayName="${StrPrefixTagGroup}" ;
     
     StrTagListVarName="${StrArrayName}${IterActionName}" ;
     eval "StrTagListVar=\${${StrTagListVarName}} ;" ; 
     StrMsg="Parser TAG-List Variable name : __TAGLIST__: Template:[ __ACTION__] : content: [ __CONTENT__ ]" ; 
     StrMsg=${StrMsg//__TAGLIST__/${StrTagListVarName}} ; 
     StrMsg=${StrMsg//__CONTENT__/${StrTagListVar}} ; 
     StrMsg=${StrMsg//__ACTION__/${StrAction}} ; 
     
     VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
     
     ### Double Evaluation of the command seem to work for TagParser. 
     eval eval TPVarNameParsed="StrAction"                     \
             TPListTag=${StrTagListVar}                        \
             TPIsMatchRtoL=True                                \
             TPDisplayParserNotice=\${BoolDisplayParserDebug}  \
             TPDisplayDebug=${BoolDisplayDebug}                \
             TPArrayName="Array${__call_locality[0]}Tag"       \
             TagParser ;
             # 2> /dev/null )  
     StrMsg=$( ${StrParentApps} --get ArrayMsg[2] ) ;
     
     VerbMsg="${StrMsg//__CMD__/${StrAction}}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis ; 
     if [ "${BoolRepoCreaEnabled:=False}" == "True" ] ; then 
       eval """$( ${StrAction} )""" ;
     fi 
    done 

   fi 

  } 
  
  function ReportReference()
  {
   eval $( CAFunctName=ReportReference CAIsAddParent=True __Call_Argument ) ; 
   #local __call_locality=( RR ReportReference ${StrParentApps} ) ;
   #local ArrayArg=( $* ) ;
   #local Arg0=${ArrayArg[0]};  
   local StrMsg ; 
   ### After moving the body of the if statement if if [ "${BoolExecuteEval}" == True...
   ### into a function. The query was tried again and confirm 
   ### BuildForm UUID:6e5b6d0c-890f-11e6-8b1d-001e4c8856d6 , was able to 
   ### publish the same information. 
   
   ### Execution Side
   ### Example : BuildForm UUID:6e5b6d0c-890f-11e6-8b1d-001e4c8856d6
   ### Should End here since this BuildForm imply  : refusing to generate code.
   ### don't dump it on file , on ZenityViewer like and also once executed it 
   ### transfert the content into na UUID into /var/log/GnrlPrsrInfctr/UUID because GPIIsUUIDInstance=TRue
   ### See path example/BuildForm/6e5b6d0c-890f-11e6-8b1d-001e4c8856d6 for parameter.
   ### Evaluation side to execte it inside called-funtion. 
   
   ### Default StrParserResult should Use variable name StrCmd to apply rules of parser to obtain
   ### 1. StrCmd=dpkg --get-selections | /usr/bin/gawk -f awk-script/dpkg-col-display.awk 
   ### 2 By calling ${StrCmd} it should execute itself and at least output the display on 
   ### screen . 
   
   ### We do have a limit to Pass StrUUIDTransmit, as long there is instance 
   ### in form UUID, or general file .GnrlPrsrInfctr i used. This is why the message
   ### is changing, and there is no evaluation in case BoolEmitUUID==False In the other
   ### case I  have neglected uses of UUID, it's not generated and ${StrFileOutput} 
   ### was probably assigned to .GnrlPrsrInfctr . 
   
   if [ "${BoolEmitUUID:=True}" == "True" ] ; then
    StrMsg="Query Executed, UUID-Variable Reference:[ __VAR_NAME__ ]" ;
    StrMsg=${StrMsg//__VAR_NAME__/${StrUUIDTransmit}} ; 
    eval ${StrUUIDTransmit}=${StrUUIDInstance} ;
   else
    StrMsg="Query Executed, No UUID used, Reference file:[ __FILE__ ]" ;
    StrMsg=${StrMsg//__FILE__/${StrFileOutput}} ;
   fi 
   VerbMsg=${StrMsg}          \
   VerbDev=/dev/stderr        \
   VerbEvalForm=False         \
   VerbHeader="EXECUTE-${__call_locality[1]}" \
   VerbState=${BoolDisplayDebug}              \
   VerbFormated=True Verbosis ; 
   ### Allow the Command-prompt or after this function ending it's live to allow having 
   ### One way to recuperate the UUID-log. 
  
  }
    
  function ZenityHandlerOut()
  {
   eval $( CAFunctName=ZenityHandlerOut CAIsAddParent=True __Call_Argument ) ; 
   #local __call_locality=( ZHO ZenityHandlerOut ${StrParentApps} ) ;
   #local ArrayArg=( $* ) ;
   #local Arg0=${ArrayArg[0]};  
   local StrTplZenityTextInfo=${ZHOZenityTpl:="zenity --text-info --filename=__FILE__ --font=__FONT__ 2> /dev/null"} ; 
   
   ### After moving the body of the if statement if [ "${BoolOutToZenity:=False}" == "True"...
   ### into a function. The query was tried again and confirm 
   ### BuildForm UUID:bb7e1d60-899f-11e6-8b1d-001e4c8856d6 , was able to 
   ### publish the same information. 
   ### 
   ### Send-it to a file, Zenity will recuperate-it 
   ### Example : BuildForm UUID:bb7e1d60-899f-11e6-8b1d-001e4c8856d6
   ### Should End here since this BuildForm imply  : refusing to generate code.
   ### To view the result with Zenity Windows.
   ### Since Zenity can not really accept Stream from piped application action it
   ### requiert to dump it on file first. 
   ### Some extra Prefixed-Variable will be available to free-out the file after . 
   VerbMsg=$( eval eval "\${${StrParserResult}}" ) \
   VerbDev=${StrDestinationResult} \
   VerbEvalForm=False              \
   VerbHeader=""                   \
   VerbState=True                  \
   VerbFormated=False Verbosis ; 
   #VerbMsg="""\${${StrParserResult}}""" VerbDev=${StrDestinationResult} VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
   StrTplZenityTextInfo=${StrTplZenityTextInfo//__FILE__/${StrDestinationResult}} ; 
   StrTplZenityTextInfo=${StrTplZenityTextInfo//__FONT__/${IntFontSize}} ; 
   ### Should Lunch Zenity --text-info... 
   ${StrTplZenityTextInfo}  
  }  
  
  function ParserFunctionEval()
  {
   ### Require Unusual Evaluation or evaluation not interpret this line like a 
   ### command line parsing . 
   eval $( "CAFunctName=ParserFunctionEval CAIsAddParent=True __Call_Argument" ) ; 
   #local __call_locality=( PFE ParserFunctionEval ${StrParentApps} ) ;
   #local ArrayArg=( $* ) ;
   #local Arg0=${ArrayArg[0]};  
   
   #eval $( CAFunctName=ParserFunctionEval CAIsAddParent=True __Call_Argument ) ; 
   
   
   ### This line does, Getting from Prefixed-Variable desired Variable to 
   ### to be generated like Variable=command
   ### and put the content of template and FeedParser .  
   eval "local ${StrParserResult}=\"${StrAppsTemplate} ${StrTagFeeder}\"" ;
   
   StrMsg="Copy of StrAppsTemplate, named __VAR__ will hold __CONTENT__" ; 
   StrMsg=${StrMsg//__VAR__/${StrParserResult}} ;
   eval """StrMsg=\${StrMsg//__CONTENT__/\${${StrParserResult}}}"""  ;
   VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbState=${BoolDisplayDebug} VerbFormated=True VerbHeader="${__call_locality[1]}-CMDLINE" Verbosis
   
   eval $( TPIsMatchRtoL=True                        \
           TPVarNameParsed="${StrParserResult}"      \
           TPDisplayDebug=${BoolDisplayDebug}        \
           TPDisplayParserNotice=${BoolDisplayParserDebug}  \
           TPArrayName=Array${__call_locality[0]}Tag \
           TPListTag="${StrParserTag}"               \
           TagParser ) ; 
   
   StrMsg=$( ${StrParentApps} --get ArrayMsg[3] ) ;
   eval """StrMsg=\${StrMsg//__CMDLINE__/\${${StrParserResult}}}"""  ;
   VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbState=${BoolDisplayDebug} VerbFormated=True VerbHeader="${__call_locality[1]}-CMDLINE" Verbosis
   
   local StrFileResult="" ;
   local StrDestinationResult="" ; 
   if [ "${BoolEmitUUID:=True}" == "True" ] ; then
    StrFileResult="${StrUUIDInstance}" ; 
    StrDestinationResult="${StrRepositoryQuery}/${StrFileResult}" ;
   else 
    StrFileResult="${StrFileOutput}" ; 
    StrDestinationResult="${StrFileResult}"
   fi 
   
   
   
   ### Notice : Because we only allow One State at the time, Evualing the code or
   ### Executing the code the Prefixed-variable are ste by default to 
   ### GPIIsGenerateCode:=False + GPIIsExecuteEval:=True
   ### ---> This mean it prefer to execute the value and since all handler are all
   ### False There is more chance than It produce a stream of information on screen.
   ### Since GPIIsUUIDInstance is False by default it give twice the chance to have
   ### user decision having to read .GnrlPrsrInfctr for the content in case of 
   ### File-Handler is True. Idem for case of Window-Handler. The actual setup of
   ### if-elif give choice to Execute Eval to be the first test but case where 2 
   ### are false, there is nothing at the end and function should end without doing 
   ### something. it's probably important to set a Warning in case 2 Master decision 
   ### is false
   ### GPIIsGenerateCode ==False And GPIIsExecuteEval==False
   ### 
   ### In case where thoses 2 master variable are True, it's the BoolExecuteEval
   ### will be executed first because it's not a Select case where more than True
   ### value can flow across schema of Select. 
   
   if [ "${BoolExecuteEval:=True}" == "True" ] ; then
    eval $( VTVIsArrayStyleInsert=True \
             VTVValueEntry=${StrVarList},${StrParserResult},StrDestinationResult   \
             VTVIsValueReAssign=True       \
             VTVIsValueToConvert=False     \
             VTVIsArrayStyleInsert=True    \
             ValueToVariable ) ReportReference ;    

    if [ "${BoolOutToZenity:=False}" == "True" ] ; then 
     eval $( VTVIsArrayStyleInsert=True \
              VTVValueEntry=${StrVarList},${StrParserResult},StrTplZenityTextInfo   \
              VTVIsValueReAssign=True       \
              VTVIsValueToConvert=False     \
              VTVIsArrayStyleInsert=True    \
              ValueToVariable ) ZenityHandlerOut ;    
    elif [ "${BoolOutToFile:=False}" == "True" ] ; then 
     ### Send-it to a file. 
     ### No recuperation from tiers methods. 
     ### Scenario from BuildForm UUID:def9e256-8990-11e6-8b1d-001e4c8856d6
     ### At this stage, GPIIsExecuteEval=True 
     ###                GPIIsFileHandlerOut=True
     ### To avoid falling inside next elif-case where 2 Handler-Out( ToFile and ToZenity )
     ### to refuse collecting the result. 
     
     VerbMsg=$( eval eval "\${${StrParserResult}}" ) VerbDev=${StrDestinationResult} VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
     ### This case execute and send it to file which is different from it's brotherhood 
     ### of evaluating the code where the code should at least get out of the fuction and 
     ### logging is used on demand, where 2 method here exist to execute the code and 
     ### suggest to keep the code from elif BoolOutToFile == False AND BoolOutToZenity == False  
     
    elif [ "${BoolOutToFile:=False}" == "False" -a "${BoolOutToZenity:=False}" == "False" ]  ; then 
     eval eval "\${${StrParserResult}}"  
     ### This scenario from Executing only the query and not provide handler to see the content, 
     ### to have not Handler like file handler (.GnrlPrsrInfctr or UUID depot) is part of the query 
     ### BuildForm UUID:6e5b6d0c-890f-11e6-8b1d-001e4c8856d6

     ### Display the Evaluation on /dev/stderr 
     #VerbMsg="""\${${StrParserResult}}""" VerbDev=/dev/stderr VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
     #eval ${StrUUIDTransmit}=${StrUUIDInstance} ;
     #eval eval "\${${StrParserResult}}" > ${StrDestinationResult} ; 
       
    fi
     
   elif [ "${BoolGenerateCode:=False}" == "True" ] ; then 
    ### ReportReference Must display proper mesage where is the Specified file
    ### to hold the result. 
    ### Also Generate the Variable required to hold the query ready to execute. 
    eval $( VTVIsArrayStyleInsert=True \
          VTVValueEntry=${StrVarList},${StrParserResult},StrDestinationResult   \
          VTVIsValueReAssign=True       \
          VTVIsValueToConvert=False     \
          VTVIsArrayStyleInsert=True    \
          ValueToVariable ) ReportReference ; 
    
    ### Does create ${StrCmd} uselessly .... 
    ### VerbMsg="""\${${StrParserResult}}""" VerbEvalForm=True VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
    
    ### I admit it's not a profit gain for log-repository to store volume of 
    ### informations,and it' probably once we do generated code we can asking 
    ### was generated and can we see back the information. So Test of the 
    ### handler-out are also important here. 
    ###   
    ###    Genration/Exec Tree Possibility . 
    ###    
    ###    
    ###                      Content of code generated 
    ###                   /+ will go in file
    ###    Output        /   
    ###    Generation-------+Both are False, it's not reported 
    ###                  \
    ###                   \+ Content of code generated  
    ###                      will go inside windows 
    ###                      called Zenity
    ###    
    ###                      Content of Execution
    ###                   /+ will go in file  
    ###    Output        /   
    ###    Execution ---------------------------------+Both are False, it's not reported ( and case neglected because 
    ###                  \                             if-elif-elif structure suggest if there is no variable handled 
    ###                   \+ Content of Execution      BoolOutToZenity & BoolOutToFile it won't fall in inapropritate choice. 
    ###                      will go inside windows 
    ###                      called Zenity
    ###    
    ###    
    ###    
    
    ### Responsible to Throw the command line on to launch it or display it 
    ### like an echo . The procedure include fall inside BoolGenerateCode ==True
    ### 1 - MUST generate code for evaluation ... 
    ### 2 - depending of a condition BoolOutToZenity==True or BoolOutToFile==True
    ### it dump the log confirmation of executed text in a zenity Windows or 
    ### File. 
    eval VerbMsg="\${${StrParserResult}}" \
    VerbDev=/dev/stderr  \
    VerbEvalForm=True    \
    VerbHeader=""        \
    VerbState=True       \
    VerbFormated=False  Verbosis ; 
    
    if [ "${BoolOutToZenity:=False}" == "True" ] ; then
     local StrTplZenityTextInfo=${ZHOZenityTpl:="zenity --text-info --filename=__FILE__ --font=__FONT__ 2> /dev/null"} ; 
     eval VerbMsg="\${${StrParserResult}}" VerbDev=${StrDestinationResult} VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False Verbosis ; 
     StrTplZenityTextInfo=${StrTplZenityTextInfo//__FILE__/${StrDestinationResult}} ; 
     StrTplZenityTextInfo=${StrTplZenityTextInfo//__FONT__/${IntFontSize}} ; 
     ### Should Lunch Zenity --text-info... 
     ${StrTplZenityTextInfo}  
     
     #VerbMsg=$( eval "\${${StrParserResult}}" ) VerbEvalForm=True VerbHeader="" VerbState=True VerbFormated=False Verbosis ;  
     #VerbDev=${StrDestinationResult} 
    elif [ "${BoolOutToFile:=False}" == "True" ] ; then 
     eval VerbMsg="\${${StrParserResult}}" VerbDev=${StrDestinationResult} VerbEvalForm=False VerbHeader="" VerbState=True VerbFormated=False  Verbosis ; 
    
    ### Suggested to eliminate this case .  
    #elif [ "${BoolOutToFile:=False}" == "False" -a "${BoolOutToZenity:=False}" == "False" ]  ; then 
    # eval VerbMsg="\${${StrParserResult}}" VerbDev=/dev/stderr VerbEvalForm=True VerbHeader="" VerbState=${BoolDisplayDebug} VerbFormated=False  Verbosis ; 
     
    fi
   fi   
  }

  
  function __main_StartServices()
  {
   eval $( "CAUsingSedTrim=False CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument" ) ; 
   #local __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
   #local ArrayArg=( $* ) ;
   #local Arg0=${ArrayArg[0]};  
   
   #local StrCmd=${StrAppsTemplate}
   
   
   ### Generic Infrastructure coming from ZenityBuildForm, have proof of it's success
   ### we do assume it's simlpe to port-it inside GnrlPrsrInfctr . 
   if [ ${BoolCreateRepository:=False} == "True" ] ; then
    if [ ! -d ${StrRepositoryQuery} ] ; then 
     eval $( VTVIsArrayStyleInsert=True \
         VTVValueEntry=${StrVarList}   \
         VTVIsValueReAssign=True       \
         VTVIsValueToConvert=False     \
         VTVIsArrayStyleInsert=True    \
         ValueToVariable ) RepositoryCreation ;
    fi
   fi   
    
    eval $( VTVIsArrayStyleInsert=True \
        VTVValueEntry=${StrVarList},StrCmd   \
        VTVIsValueReAssign=True       \
        VTVIsValueToConvert=False     \
        VTVIsArrayStyleInsert=True    \
        ValueToVariable ) ParserFunctionEval ;
   
   ### 
  
  } 
  
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  local StrNameHelper="GnrlPrsrInfctr\tStand for General-Parser-Infrastructure ; The Fnct.D Mechanism Parsing single function call or piped function and even multi-piped function with conjunction of TagParser. ";
  local StrSummary="This TagParser for single function, piped-function and Nth-piped function is coming with Repository to log result from GnrlPrsrInfctr and Parser engine is equiped of a ParserFeeder to append Variable And Tag to know GDITagParser. The main goal of this Function is to profit from Entry of variable from command-line entry and to use extra TAG binded to Variable-name added to let it parse the rest of the information and thus will be explained." ; 
  local StrSynopsis="Soon to fill it with lot of informations";
  local StrDescription="Having surdose of informations, skip this part..." ;
  
  
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GVRIsName=True GVRIsSynopsis=True GVRIsSummary=True GVRIsDesc=True GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( __GetVarReferenceList ) ;	
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
   if [ "${BoolEmitUUID:=True}" == "True" ] ; then 
    StrUUIDInstance=$( GetUTimeBased=True GetUSeq=1 GetUIDRegister=True GetUAppsRegisterName=GnrlPrsrInfctr GetUUID ) ; 
    VerbMsg="${ArrayMsg[4]//__UUID__/${StrUUIDInstance}}" \
    VerbHeader="${__call_locality[1]}-DEBUG" \
    VerbEvalForm=False                       \
    VerbFormated=True                        \
    VerbState=${BoolDisplayDebug}            \
    StrDevOut=/dev/stderr  Verbosis ; 
   
   fi 
   StrMsg=${ArrayMsg[5]}; 
   VerbMsg="${StrMsg//__FUNCT__/${StrStartMain}}" \
   VerbEvalForm=False VerbHeader="${__call_locality[1]}-DEBUG" \
   VerbState=${BoolDisplayDebug} \
   VerbFormated=False \
   VerbDevOut=/dev/stderr Verbosis ; 
   
   eval $( VTVIsArrayStyleInsert=True \
        VTVValueEntry=${StrVarList}   \
        VTVIsValueReAssign=True       \
        VTVIsValueToConvert=False     \
        VTVIsArrayStyleInsert=True    \
        ValueToVariable ) ${StrStartMain}
  fi
 }


fi
