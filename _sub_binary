#!/bin/bash

### Package : _sub_binary



if [ "${versionGFL:=0.0.1}" == "0.0.0" ] ; then 
 ### GlobalFunctionCleaning not compatible for version versionGFL==0.0.0
 ###eval $( GFCFuncName=GetFibLevel GlobalFunctionCleaning ) ; 
 unset GetFibLevel ; 
 function GetFibLevel()
 {
  local -a ArrayArg=( $* ) ;
  local -a __call_locality=( GFL GetFibLevel ) ;
  local Arg0=${ArrayArg[0]} ;   
  local StrApps=${GFLApps:=/usr/local/bin/fib} ; 
  local StrAppsOpt=${GFLAppsOpt:='fReadOnlyNumber=True'} ; 
  local BoolUsingAwkApps=${GFLUsingAwkApps:=True} ; 
  local StrFilterApps=${GFLFilterApps:=/usr/bin/gawk} ;
  local StrAwkScript=${GFLAwkScript:=/etc/init.d/Fnct.D/awk-script/Fibonacci.awk} ; 
  local StrASFibMeth=${GFLAwkFibEngine:=LT} ; 
  local BoolDisplayCmd=${GFLDisplayCmd:=False} ; 
  local IntFibLevel=${GFLIntLevel:=1} ;
  local StrCSVSep=${GFLIntLevelSep:=','} ;
  local IntFibSubStr ;
  local IntNbFib ; 
  
  if [ "${BoolUsingAwkApps:=True}" == "True" ] ; then 
    StrCmd="""echo ${IntFibLevel} | ${StrFilterApps} -vOutputFibOnly=True -vFuncType=${StrASFibMeth} -F '${StrCSVSep}' -f ${StrAwkScript}""" ; 
  else
    IntFibLevel="${IntFibLevel}${StrCSVSep}" ; 
    IntFibSubStr=${IntFibLevel//${StrCSVSep}/} ; 
    IntNbFib=$(( ${#IntFibLevel} - ${#IntFibSubStr} ))
    StrCmd="""${StrAppsOpt} ${StrApps} __INT__ """;
  fi
  
  if [ "${BoolDisplayCmd:=False}" == "True" ] ; then 
   echo -ne "${StrCmd}\n" > /dev/stderr ; 
  fi
  
  local StrNbParser=${IntFibLevel} ; 
  local StrItemLevel ; 
  local -a ArrayResult ;
  if [ "${BoolUsingAwkApps:=True}" == "True" ] ; then 
   ### In case Awk-script is used and more than one number is specified inside 
   ### the IntFibLevel. Awk-script can handle it
   eval "${StrCmd}" ; 
  else 
   ###  In case Application fib is use, it does not support more than one 
   ###  number from to compute by launch. It require to loop the application
   ###  and extract the value . 
   for(( intx=0 ; intx <= ${IntNbFib}-1 ; intx++)) ; do 
    StrItemLevel=${StrNbParser%*${StrNbParser#*${StrCSVSep}}} ;
    StrNbParser=${StrNbParser:${#StrItemLevel}:$(( ${#StrNbParser} - ${#StrItemLevel}))} ;
    if [ "${BoolDisplayCmd:=False}" == "True" ] ; then 
     echo -ne "CMD:${StrCmd//__INT__/${StrItemLevel//${StrCSVSep}/}}\n" > /dev/stderr ; 
    fi
    ArrayResult[${#ArrayResult[@]}]=$( eval "${StrCmd//__INT__/${StrItemLevel//${StrCSVSep}/}}" ); 
   done 
   echo "${ArrayResult[@]}" ; 
  fi 
  
  
 }
fi 

if [ "${versionGFL:=0.0.1}" == "0.0.1" ] ; then 
 eval $( GFCFuncName=GetFibLevel GlobalFunctionCleaning ) ; 
 #unset GetFibLevel ; 
 function GetFibLevel()
 {
  function Verbosis()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Verb Verbosis ) ; 
   local Arg0=${ArrayArg[0]} ; 
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local IsExtendedOutput=${VerbExtendedOut:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
      if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" ;  
      else
        echo "${StrMsg}" ;  
      fi
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" >> ${StrDevOut} ;
       else
         echo "${StrMsg}" >> ${StrDevOut} ;
       fi
      else
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" > ${StrDevOut} ;
       else
        echo "${StrMsg}" > ${StrDevOut} ;
       fi 
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( GFL GetFibLevel ) ;
   local Arg0="${ArrayArg[0]}" ; 
   local StrParentApps=${__call_locality[1]} ;
   local StrStartMain=${GFLFuncStart:=__main_StartServices} ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=GetFibLevel CAIsAddParent=False __Call_Argument ) ; 
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=GetFibLevel CAIsAddParent=False CallArgument ) ;
  fi  
  
  local StrApps=${GFLApps:=/usr/local/bin/fib} ; 
  local StrAppsOpt=${GFLAppsOpt:='fReadOnlyNumber=True'} ; 
  local BoolUsingAwkApps=${GFLUsingAwkApps:=True} ; 
  local StrFilterApps=${GFLFilterApps:=/usr/bin/gawk} ;
  local StrAwkScript=${GFLAwkScript:=/etc/init.d/Fnct.D/awk-script/Fibonacci.awk} ; 
  local StrASFibMeth=${GFLAwkFibEngine:=LT} ; 
  local BoolDisplayCmd=${GFLDisplayCmd:=False} ; 
  local BoolDisplayEntry=${GFLDisplayEntry:=False} ; 
  local IntFibLevel=${GFLIntLevel:=1} ;
  local StrCSVSep=${GFLIntLevelSep:=','} ;

  
  local StrVarList="StrApps,StrAppsOpt,BoolUsingAwkApps,StrFilterApps,StrFilterApps,StrAwkScript,StrASFibMeth,BoolDisplayCmd,IntFibLevel,StrCSVSep,BoolDisplayEntry" ; 
  
  local -a ArrayMsg=() ;
  ArrayMsg[0]="Entry in function, __VAR__:__VER__" ; 
  
  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ;
   fi 
   
   StrMsg=$( GetFibLevel --get ArrayMsg[0] ) ; 
   StrMsg=${StrMsg//__VAR__/versionGFL} ; 
   StrMsg=${StrMsg//__VER__/${versionGFL}} ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolDisplayEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
   local StrCmd ; 
   local IntFibSubStr ;
   local IntNbFib ; 
  
  if [ "${BoolUsingAwkApps:=True}" == "True" ] ; then 
    StrCmd="""echo ${IntFibLevel} | ${StrFilterApps} -vOutputFibOnly=True -vFuncType=${StrASFibMeth} -F '${StrCSVSep}' -f ${StrAwkScript}""" ; 
  else
    IntFibLevel="${IntFibLevel}${StrCSVSep}" ; 
    IntFibSubStr=${IntFibLevel//${StrCSVSep}/} ; 
    IntNbFib=$(( ${#IntFibLevel} - ${#IntFibSubStr} ))
    StrCmd="""${StrAppsOpt} ${StrApps} __INT__ """;
  fi
  
  VerbMsg="${StrCmd}" VerbHeader="${__call_locality[1]}-CMD" VerbState=${BoolDisplayCmd} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
  
  local StrNbParser=${IntFibLevel} ; 
  local StrItemLevel ; 
  local -a ArrayResult ;
  if [ "${BoolUsingAwkApps:=True}" == "True" ] ; then 
   ### In case Awk-script is used and more than one number is specified inside 
   ### the IntFibLevel. Awk-script can handle it
   eval "${StrCmd}" ; 
  else 
   ###  In case Application fib is use, it does not support more than one 
   ###  number from to compute by launch. It require to loop the application
   ###  and extract the value . 
   for(( intx=0 ; intx <= ${IntNbFib}-1 ; intx++)) ; do 
    StrItemLevel=${StrNbParser%*${StrNbParser#*${StrCSVSep}}} ;
    StrNbParser=${StrNbParser:${#StrItemLevel}:$(( ${#StrNbParser} - ${#StrItemLevel}))} ;
    
    StrParsedCmd="${StrCmd//__INT__/${StrItemLevel//${StrCSVSep}/}}" ;
    VerbMsg="${StrParsedCmd}" VerbHeader="${__call_locality[1]}-CMD" VerbState=${BoolDisplayCmd} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    ArrayResult[${#ArrayResult[@]}]=$( eval "${StrParsedCmd}" ); 
   done 
   
   VerbMsg="${ArrayResult[@]}" VerbHeader="${__call_locality[1]}-CMD" VerbState=True VerbEvalForm=False VerbFormated=False Verbosis ;

  fi 

    
  
  }  
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  local StrNameHelper="${__call_locality[1]}\n\t[ Compiled / Scripted ] Fibonnacci Number generation by Level.";
  local StrSummary="\n\tSimplest use is to call it with One parameter. This application support \n\talso many Integer as parameter. \n\n\tGFLIntLevel=70 GetFibLevel \n\n\tor multiple interger at once :\n\n\tGFLIntLevel=\"1,2,3,4,5,6,7,8,9,10\" GFLIntLevelSep=',' GetFibLevel \n\t  This one require uses of CSV to separate and was specified in\n\t  GFLIntLevelSep=','\n\n\t  Or it require you do pas the interger in '\"' quoted if you want to \n\t  use space :\n\tGFLIntLevel=\"1 2 3 4 5 6 7 8 9 10\" GetFibLevel \n\n\tRequire to witch to application fib from compiled version available in\n\tbranch MakeFileInstaller. \n\n\tSuggestion time it with time from bash:\n\n\ttime GFLUsingAwkApps=False GFLIntLevel=0 GetFibLevel \n\n\tHaving fib application compiled somewhere else :\n\n\tGFLApps=/path/to/fib GFLUsingAwkApps=False GFLIntLevel=0 GetFibLevel  \n\n" ;
  local StrSynopsis="This application rely on fib application compiled by branch \n\tMakeFileInstaller from Fnct.D and does use the awk-script Fibonacci.awk\n\tfrom Fnct.D repository. The awk-script seems suitable to perform on higher\n \tlevel since Level 70 can compute the number 190392490709135 in less than\n \t0.007 seconds on Dual X2 @ 1900 Mhz processor, it's accurate to perform\n \tcalculation to level 1476. or it indicate 'inf'. Further treatment can be\n \tpossible to extend the script but basically it's quite enought to report\n \tdesired information.\n" ; 
  local StrDescription="Function Prefixed-Variable Helper:\n\n  Main Prefixed-Variable:\nGFLIntLevel\t\t[Integer / CSV List] May accept one value or a List separeted by\n \t\t\tCommas Separated value. If 'Space' is used, double or single quote should\n\t\t\tWrap your information.\nGFLIntLevelSep\t\t[Char] Accept value by preference in single quoted value like \n\t\t\t' ', for space, ',' for Virgule, ':' Double-dot.\n  Related to Fibonacci application compiled :\nGFLFilterApps\t\t[String] the Awk interpreter to use.\nGFLAwkScript\t\t[String] Default Fibonacciscript or your-improved version\nGFLAwkFibEngine\t[String] Choice between LT or NB for Loop-Technique or\n\t\t\tNaive Binary Recursion. \n  Related to Fibonacci application compiled :\nGFLUsingAwkApps\tSet [True/False] Is required to et to True to enable the \n\t\t\tapplication layer to take over the awk-script. \nGFLApps\t\t[String] Quoted is mandatory and is used to specifiy some parameter\n\t\t\tto the application. Default parameter is 'fReadOnlyNumber=True' and it's\n\t\t\tinternal variable GFLAppsOpt\t\n\n\nRelated to Debugging purposes :\nGFLDisplayCmd\tSet [True/False] Display the command on every call. Uses of \n\t\t\tapplication will launch as many time held Interger inside GFLIntLevel\nGFLDisplayEntry\t Set [True/False]  Will display function entry.\n\n\nNotice to Debugging Prefixed-variable, it does output all the information inside\n/dev/stderr and will not interfer with variable assignation. \n" ; 
        
        
   
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GVRIsName=True     \
   GVRIsSummary=True  \
   GVRIsSynopsis=True \
   GVRIsDesc=True     \
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( __GetVarReferenceList ) ;	
  elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
   $( VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      VTVIsWhiteList=True         \
      VTVWhiteListTransfert=UUID  \
      ValueToVariable ) __main_StopServices ; 
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
   # eval $( eval VersionApps ) ; 
   StrMsg=$( GetFibLevel --get ArrayMsg[0] ) ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolDisplayEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   $( VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      ValueToVariable ) ${StrStartMain}
  fi   
 }  

fi 


if [ "${versionGHFH:=0.0.0}" == "0.0.0" ] ; then 
 
 #eval $( GFCFuncName=GetHighestFibHarmonic GlobalFunctionCleaning ) ; 
 unset GetHighestFibHarmonic ; 
 function GetHighestFibHarmonic()    
 { 
  function Verbosis()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Verb Verbosis ) ; 
   local Arg0=${ArrayArg[0]} ; 
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local IsExtendedOutput=${VerbExtendedOut:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
      if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" ;  
      else
        echo "${StrMsg}" ;  
      fi
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" >> ${StrDevOut} ;
       else
         echo "${StrMsg}" >> ${StrDevOut} ;
       fi
      else
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" > ${StrDevOut} ;
       else
        echo "${StrMsg}" > ${StrDevOut} ;
       fi 
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
  local -a ArrayArg=( $* ) ;
  local -a __call_locality=( GHFH GetHighestFibHarmonic ) ;
  local Arg0=${ArrayArg[0]} ; 
  
  local IntModSeek=${GHFHIntNumber:=20} ; 
  local BoolDisplayDebug=${GHFHIsDisplayDebug:=False} ; 
  local BoolDisplayEntry=${GHFHIsDisplayEntry:=False} ; 
  local BoolDisplayCmd=${GHFHIsDisplayCmd:=False} ; 
  
  local -a ArrayMsg ;
  
  ArrayMsg[0]="Entry in function, __VAR__:__VER__" ;
  ArrayMsg[1]="Level fib:__INT__, Fibonacci:__FIB__, targeted modulo:__MOD__, previous remain:__PREMAIN__ remain:__REMAIN__" ;
  ArrayMsg[2]="Modulus __MOD__\n\thaving lowest Fibonacci level __LEVEL__\n\tnumber __INT__\n\tremain __REMAIN__\n" ;
  ArrayMsg[3]="__INTA__,__INTB__" ; 
  ArrayMsg[4]="Status of \n\tBoolDisplayDebug: __DisplayDebug__\n\tBoolDisplayEntry: __DisplayEntry__\n\tBoolDisplayCmd: __DisplayCmd__\n" ; 

  StrMsg=${ArrayMsg[4]} ; 
  StrMsg=${StrMsg//__DisplayDebug__/${BoolDisplayDebug}} ; 
  StrMsg=${StrMsg//__DisplayEntry__/${BoolDisplayEntry}} ; 
  StrMsg=${StrMsg//__DisplayCmd__/${BoolDisplayCmd}} ; 
  VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
  
  #local IntModSeek=${Arg0} ; 
  local IntResFib=0 ; 
  local IntX=1 ;
  local IntRemain=-1 ;  
  local IntOldRemain=0 ; 
  local IntOldLevel=0
  local IntRestFibOld=0;
  local BoolEndTest=False  ;
  local IntDisplayLevel ;
  local IntDisplayRemain ;
  StrMsg=${ArrayMsg[0]} ;
  
  StrMsg=${StrMsg//__VAR__/versionGHFH} ; 
  StrMsg=${StrMsg//__VER__/${versionGHFH}} ; 
  VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolDisplayEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
  #echo -ne "${StrMsg}\n" > /dev/stderr ; 
  while [ "${BoolEndTest}" == "False" ] ; do  
   IntResFib=$( GFLDisplayCmd=${BoolDisplayCmd} GFLDisplayEntry=${BoolDisplayEntry} GFLIntLevel=${IntX} GetFibLevel ) ; 
   IntRemain=$(( ${IntResFib} - ${IntModSeek} )); 
   StrMsg=${ArrayMsg[1]} ; 
   StrMsg=${StrMsg//__INT__/${IntX}} ; 
   StrMsg=${StrMsg//__FIB__/${IntResFib}} ; 
   StrMsg=${StrMsg//__MOD__/${IntModSeek}} ; 
   StrMsg=${StrMsg//__PREMAIN__/${IntOldRemain}} ; 
   StrMsg=${StrMsg//__REMAIN__/${IntRemain}} ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   #echo -ne "${StrMsg}\n" > /dev/stderr ; 

   if [ ${IntRemain} -eq 0 ] ; then 
    BoolEndTest=True ;
    IntDisplayLevel=${IntX};
    IntDisplayRemain=${IntRemain} ; 
   fi 
   if [ ${IntRemain} -lt 0 ] ; then 
    IntOldRemain=${IntRemain} ;
    IntOldLevel=${IntX} ;
    IntRestFibOld=${IntResFib} ; 
    let IntX=IntX+1 ; 
   fi
   if [ ${IntOldRemain} -lt 0 -a ${IntRemain} -gt 0 ] ; then 
    BoolEndTest=True ;
    IntDisplayLevel=${IntOldLevel};
    IntDisplayRemain=${IntOldRemain} ; 
   fi 
   
  done  ; 
      
  StrMsg=${ArrayMsg[2]} ; 
  StrMsg=${StrMsg//__MOD__/${IntModSeek}} ; 
  StrMsg=${StrMsg//__LEVEL__/${IntOldLevel}} ; 
  StrMsg=${StrMsg//__INT__/${IntRestFibOld}} ; 
  StrMsg=${StrMsg//__REMAIN__/${IntOldRemain}} ; 
  VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
  #echo -ne "${StrMsg}\n" > /dev/stderr ; 
  
  StrMsg=${ArrayMsg[3]} ; 
  StrMsg=${StrMsg//__INTA__/${IntDisplayLevel}} ; 
  StrMsg=${StrMsg//__INTB__/${IntDisplayRemain//-/}} ; 
  VerbMsg="${StrMsg}" VerbState=True VerbEvalForm=False VerbFormated=False VerbDev=/dev/stdout  Verbosis ;
  #echo -ne "${StrMsg}\n" > /dev/stderr ; 

 }

fi

if [ "${versionGHFH:=0.0.0}" == "0.0.1" ] ; then 
 
 eval $( GFCFuncName=GetHighestFibHarmonic GlobalFunctionCleaning ) ; 
 #unset GetHighestFibHarmonic ; 
 function GetHighestFibHarmonic()    
 { 
  function Verbosis()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Verb Verbosis ) ; 
   local Arg0=${ArrayArg[0]} ; 
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local IsExtendedOutput=${VerbExtendedOut:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
      if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" ;  
      else
        echo "${StrMsg}" ;  
      fi
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" >> ${StrDevOut} ;
       else
         echo "${StrMsg}" >> ${StrDevOut} ;
       fi
      else
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" > ${StrDevOut} ;
       else
        echo "${StrMsg}" > ${StrDevOut} ;
       fi 
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( GHFH GetHighestFibHarmonic ) ;
   local Arg0="${ArrayArg[0]}" ; 
   local StrParentApps=${__call_locality[1]} ;
   local StrStartMain=${GHFHFuncStart:=__main_StartServices} ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=GetHighestFibHarmonic CAIsAddParent=False __Call_Argument ) ; 
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=GetHighestFibHarmonic CAIsAddParent=False CallArgument ) ;
  fi  

  local IntModSeek=${GHFHIntNumber:=20} ; 
  local BoolDisplayDebug=${GHFHIsDisplayDebug:=False} ; 
  local BoolDisplayEntry=${GHFHIsDisplayEntry:=False} ; 
  local BoolDisplayCmd=${GHFHIsDisplayCmd:=False} ; 
  local StrVarList="IntModSeek,BoolDisplayDebug,BoolDisplayEntry"
  
  local -a ArrayMsg=() ;
  
  ArrayMsg[0]="Entry in function, version __VER__" ; 
  ArrayMsg[1]="Modulus __IntModSeek__\n\thaving lowest Fibonacci level __IntOldLevel__\n\tnumber __IntRestFibOld__\n\tremain __IntOldRemain__\n" ;
  ArrayMsg[2]="__INT1__,__INT2__" ; 

  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ;
   fi 
   StrMsg=$( GetHighestFibHarmonic --get ArrayMsg[0] ) ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

   local IntResFib=0 ; 
   local IntX=1 ;
   local IntRemain=-1 ;  
   local IntOldRemain=0 ; 
   local IntOldLevel=0
   local IntRestFibOld=0;
   # ${resfib:=0} -lt ${IntModSeek} 
   local BoolEndTest=False  ;
   local IntDisplayLevel ;
   local IntDisplayRemain ;
   while [ "${BoolEndTest}" == "False" ] ; do  
    IntResFib=$( GFLDisplayCmd=${BoolDisplayCmd} GFLDisplayEntry=${BoolDisplayEntry} GFLIntLevel=${IntX} GetFibLevel ) ; 
    IntRemain=$(( ${IntResFib} - ${IntModSeek} )); 
    #echo -ne "Level fib:${IntX}, Fibonacci:${IntResFib}, targeted modulo:${IntModSeek}, previous remain:${IntOldRemain} remain:${IntRemain}\n" ; 
    if [ ${IntRemain} -eq 0 ] ; then 
     BoolEndTest=True ;
     IntDisplayLevel=${IntX};
     IntDisplayRemain=${IntRemain} ; 
    fi 
    if [ ${IntRemain} -lt 0 ] ; then 
     IntOldRemain=${IntRemain} ;
     IntOldLevel=${IntX} ;
     IntRestFibOld=${IntResFib} ; 
     let IntX=IntX+1 ; 
    fi
    if [ ${IntOldRemain} -lt 0 -a ${IntRemain} -gt 0 ] ; then 
     BoolEndTest=True ;
     IntDisplayLevel=${IntOldLevel};
     IntDisplayRemain=${IntOldRemain} ; 
    fi 
    
   done  ; 
   StrMsg=$( GetHighestFibHarmonic --get ArrayMsg[1] ) ; 
   StrMsg=${StrMsg//__IntModSeek__/${IntModSeek}} ; 
   StrMsg=${StrMsg//__IntOldLevel__/${IntOldLevel}} ; 
   StrMsg=${StrMsg//__IntRestFibOld__/${IntRestFibOld}} ; 
   StrMsg=${StrMsg//__IntOldRemain__/${IntOldRemain}} ; 
   VerbMsg=${StrMsg} VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
   
   StrMsg=$( GetHighestFibHarmonic --get ArrayMsg[2] ) ;
   StrMsg=${StrMsg//__INT1__/${IntDisplayLevel}} ; 
   StrMsg=${StrMsg//__INT2__/${IntDisplayRemain//-/}} ; 
   VerbMsg=${StrMsg} VerbEvalForm=False VerbFormated=False VerbState=True VerbDev=/dev/stdout  Verbosis ; 
    
  }
  
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  local StrNameHelper="${__call_locality[1]}\n\tHighest Fibonnacci Level reacheable by submitted number without excedding it.";
  local StrSummary="\n\tThis application does return the highest Fibonnacci level possible\n\twithout overflowing the value and does return a comma separated\n\tvalue a remainder. In case 0 is returned it give the comma and 0." ; 
  local StrSynopsis="\n\tAs example following example are giving remainder not equal to 0.\n\t$> GetHighestFibHarmonic 53668\n\t24,7300\n\t$> GetHighestFibHarmonic 40014\n\t23,11357\n\t$> GetHighestFibHarmonic 12211\n\t21,1265\n\t$> GetHighestFibHarmonic 2147483563\n\t46,311171660.";
  local StrDescription="\n\tThis application does come with _sub_binary bundle of application\n\tGetFibLevel, GetHighestFibHarmonic , GetValueScaledFibHarmonic,\n\tFibBinaryLevelRepr. And this application will be re-used in\n\tGetValueScaledFibHarmonic to extend de decompisition of a number.\n\tAs observed, it does produce a remainder lower than the Fibonnacci\n\tlevel. Accorded to this it should remain another possible\n\tdecomposition of the remainder until it get 0 remainder." ;
  
   
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GVRIsName=True     \
   GVRIsSummary=True  \
   GVRIsSynopsis=True \
   GVRIsDesc=True     \
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( __GetVarReferenceList ) ;	
  elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
   $( VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      VTVIsWhiteList=True         \
      VTVWhiteListTransfert=UUID  \
      ValueToVariable ) __main_StopServices ; 
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
   # eval $( eval VersionApps ) ; 
   StrMsg=${ArrayMsg[0]} ;
   StrMsg=${StrMsg//__VER__/${versionGHFH}} ;  
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolDisplayEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   $( VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      ValueToVariable ) ${StrStartMain}
  fi   
 
 }

fi



if [ "${versionGVSFH:=0.0.0}" == "0.0.0" ] ; then 
 
 #eval $( GFCFuncName=GetValueScaledFibHarmonic GlobalFunctionCleaning ) ; 
 unset GetValueScaledFibHarmonic ;
 function GetValueScaledFibHarmonic()
 {
  local -a ArrayArg=( $* ) ;
  local -a __call_locality=( GVSFH GetValueScaledFibHarmonic ) ;
  local Arg0=${ArrayArg[0]} ;   
  local IntRemain=0 ; 
  local -a ArrayScaledHarmonic=( ) ; 
  local -a ArrayGF ;
  local IntHarmonic=${GVSFHIntValue:=2147483563} ; 
  local BoolDisplayDebug=${GVSFHDisplayDebug:=True} ; 
  local BoolDisplayEntry=${GVSFHDisplayEntry:=False} ; 
  local BoolDisplayProof=${GVSFHDisplayProof:=True} ; 
  
  while [ ${IntHarmonic} -gt 0 ] ; do
   StrFibFilter=$( GHFHIntNumber=${IntHarmonic}           \
                   GHFHIsDisplayDebug=${BoolDisplayDebug} \
                   GHFHIsDisplayEntry=${BoolDisplayEntry} \
                   GetHighestFibHarmonic  ) ;
   ArrayGF=( ${StrFibFilter//,/ } ) ; 
   ArrayScaledHarmonic[${#ArrayScaledHarmonic[@]}]=${ArrayGF[0]} ; 
   IntHarmonic=${ArrayGF[1]} ; 
   
  done
  if [ ${BoolDisplayDebug:=False} == "True" ] ; then 
    echo -ne "Scaled Harmonic of ${Arg0}:[${ArrayScaledHarmonic[@]// /|}]\n" > /dev/stderr  ;
  fi
  
  if [ "${BoolDisplayProof:=True}" == "True"  ] ; then 
   local StrTplNumber="\$( GFLIntLevel=__X__  GFLDisplayEntry=${BoolDisplayEntry} GetFibLevel)"; 
   local StrParseTpl="" ; 
   local StrAddNumber="" ;
   
   for (( intx=${#ArrayScaledHarmonic[@]}-1 ; intx >= 0 ; intx-- )) ; do 
    IntHarmonic=${ArrayScaledHarmonic[${intx}]} ; 
    StrParseTpl="${StrTplNumber//__X__/${IntHarmonic}}" ; 
    eval "IntEvalRes=${StrParseTpl}" ;
    StrAddNumber="${IntEvalRes} + ${StrAddNumber}" ; 
    if [ ${intx} -eq 0 ] ; then 
     StrAddNumber=${StrAddNumber:0:$((${#StrAddNumber}-2))}
    fi 
    
   done 
   IntFibSum=$(( ${StrAddNumber} )) ; 
   if [ ${BoolDisplayDebug:=False} == "True" ] ; then 
    echo -ne "Proof:${StrAddNumber} = ${IntFibSum}\n" > /dev/stderr ; 
   fi 
  fi 
  echo -ne "${ArrayScaledHarmonic[@]}\n" > /dev/stdout ; 
 }
fi

if [ "${versionGVSFH:=0.0.0}" == "0.0.1" ] ; then 
 
 eval $( GFCFuncName=GetValueScaledFibHarmonic GlobalFunctionCleaning ) ; 

 function GetValueScaledFibHarmonic()
 {
  function Verbosis()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Verb Verbosis ) ; 
   local Arg0=${ArrayArg[0]} ; 
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local IsExtendedOutput=${VerbExtendedOut:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
      if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" ;  
      else
        echo "${StrMsg}" ;  
      fi
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" >> ${StrDevOut} ;
       else
         echo "${StrMsg}" >> ${StrDevOut} ;
       fi
      else
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" > ${StrDevOut} ;
       else
        echo "${StrMsg}" > ${StrDevOut} ;
       fi 
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( GVSFH GetValueScaledFibHarmonic ) ;
   local Arg0="${ArrayArg[0]}" ; 
   local StrParentApps=${__call_locality[1]} ;
   local StrStartMain=${GVSFHFuncStart:=__main_StartServices} ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=GetValueScaledFibHarmonic CAIsAddParent=False __Call_Argument ) ; 
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=GetValueScaledFibHarmonic CAIsAddParent=False CallArgument ) ;
  fi  
  
  local IntHarmonic=${GVSFHIntValue:=2147483563} ; 
  local BoolDisplayDebug=${GVSFHDisplayDebug:=True} ; 
  local BoolDisplayEntry=${GVSFHDisplayEntry:=False} ; 
  local BoolDisplayProof=${GVSFHDisplayProof:=True} ; 
  local StrVarList="IntHarmonic,BoolDisplayDebug,BoolDisplayEntry,BoolDisplayProof" ;
  
  local -a ArrayMsg=() ;
  
  ArrayMsg[0]="Entry in function" ; 
  ArrayMsg[1]="Proof:__LIST_ADD__ = __FIB__\n" ;
  ArrayMsg[2]="Scaled Harmonic of __INT__:[__LIST__]\n" ; 
  ArrayMsg[3]="__LIST__\n" ; 
  ArrayMsg[4]="" ; 
  ArrayMsg[5]="" ; 
  ArrayMsg[6]="" ; 

  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ;
   fi 
   StrMsg=$( GetValueScaledFibHarmonic --get ArrayMsg[0] ) ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolDisplayEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

    
  
  }  
  
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  local StrNameHelper="${__call_locality[1]}\n\t";
  local StrSummary="\n\t" ; 
  local StrSynopsis="\n\t";
  local StrDescription="\n\t" ;
  
   
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GVRIsName=True     \
   GVRIsSummary=True  \
   GVRIsSynopsis=True \
   GVRIsDesc=True     \
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( __GetVarReferenceList ) ;	
  elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
   $( VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      VTVIsWhiteList=True         \
      VTVWhiteListTransfert=UUID  \
      ValueToVariable ) __main_StopServices ; 
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
   # eval $( eval VersionApps ) ; 
   StrMsg=$( GetValueScaledFibHarmonic --get ArrayMsg[0] ) ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolDisplayEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   $( VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      ValueToVariable ) ${StrStartMain}
  fi   
 }

fi

if [ "${versionFBLR:=0.0.0}" == "0.0.0" ] ; then 
 
 unset FibBinaryLevelRepr ; 
 #eval $( GFCFuncName=FibBinaryLevelRepr GlobalFunctionCleaning ) ; 

 function FibBinaryLevelRepr()
 {
  local -a ArrayArg=( $* ) ;
  local -a __call_locality=( FBLR FibBinaryLevelRepr ) ;
  local Arg0=${ArrayArg[0]} ;   
  
  local StrReprFibLevel ;
  local IntOldLevel=0 ;
  local -a ArrayFibHarmonic=( $( GVSFHDisplayDebug=False GetValueScaledFibHarmonic ${Arg0} ) ) ; 
  
  IntLevelNb=$(( ${#ArrayFibHarmonic[@]} )) ;  
  IntLevel=$(( ${IntLevelNb} - 1 )) ;
  echo -ne "Representation over ${ArrayFibHarmonic[0]} binary-position, of number ${Arg0}\n" > /dev/stderr ;
  for (( intx=1 ; intx <= ${ArrayFibHarmonic[0]} ; intx++ )) ; do 
   IntLimitFix=${ArrayFibHarmonic[${IntLevel}]} ;
   #echo -ne "Actual Limit:${IntLimitFix}, cursor at ${intx}\n" ; 
   if [ ${intx} -eq ${IntLimitFix} ] ; then 
    #echo -ne "Adding to parity for representing value ${intx}\n" ;
    StrReprFibLevel="1${StrReprFibLevel}" ; 
    IntLevel=$(( ${IntLevel} - 1 )) ; 
   else
    StrReprFibLevel="0${StrReprFibLevel}" ;
   fi 
  done 
  echo -ne "Number: ${Arg0}\nFib Harmonic: [${ArrayFibHarmonic[@]}]\nBinary Level Repr:[${StrReprFibLevel}]\n" ; 
 }
fi

if [ "${versionFBLR:=0.0.1}" == "0.0.1" ] ; then 
 eval $( GFCFuncName=FibBinaryLevelRepr GlobalFunctionCleaning ) ; 
 function FibBinaryLevelRepr()
 {
  function Verbosis()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Verb Verbosis ) ; 
   local Arg0=${ArrayArg[0]} ; 
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local IsExtendedOutput=${VerbExtendedOut:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
      if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" ;  
      else
        echo "${StrMsg}" ;  
      fi
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" >> ${StrDevOut} ;
       else
         echo "${StrMsg}" >> ${StrDevOut} ;
       fi
      else
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" > ${StrDevOut} ;
       else
        echo "${StrMsg}" > ${StrDevOut} ;
       fi 
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( FBLR FibBinaryLevelRepr ) ;
   local Arg0="${ArrayArg[0]}" ; 
   local StrParentApps=${__call_locality[1]} ;
   local StrStartMain=${FBLRFuncStart:=__main_StartServices} ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=FibBinaryLevelRepr CAIsAddParent=False __Call_Argument ) ; 
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=FibBinaryLevelRepr CAIsAddParent=False CallArgument ) ;
  fi  
  
  local IntHarmonic=${GVSFHIntValue:=2147483563} ; 
  local BoolDisplayDebug=${FBLRDisplayDebug:=True} ; 
  local BoolDisplayEntry=${FBLRDisplayEntry:=False} ; 
  local StrVarList="" ;
  
  local -a ArrayMsg=() ;
  
  ArrayMsg[0]="Entry in function" ; 
  ArrayMsg[1]="" ;
  ArrayMsg[2]="" ; 
  ArrayMsg[3]="" ; 
  ArrayMsg[4]="" ; 
  ArrayMsg[5]="" ; 
  ArrayMsg[6]="" ; 

  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ;
   fi 
   StrMsg=$( FibBinaryLevelRepr --get ArrayMsg[0] ) ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolDisplayEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

   local StrReprFibLevel ;
   local IntOldLevel=0 ;
   local -a ArrayFibHarmonic=( $( GVSFHDisplayDebug=False GetValueScaledFibHarmonic ${Arg0} ) ) ; 
   
   IntLevelNb=$(( ${#ArrayFibHarmonic[@]} )) ;  
   IntLevel=$(( ${IntLevelNb} - 1 )) ;
   echo -ne "Representation over ${ArrayFibHarmonic[0]} binary-position, of number ${Arg0}\n" > /dev/stderr ;
   for (( intx=1 ; intx <= ${ArrayFibHarmonic[0]} ; intx++ )) ; do 
    IntLimitFix=${ArrayFibHarmonic[${IntLevel}]} ;
    #echo -ne "Actual Limit:${IntLimitFix}, cursor at ${intx}\n" ; 
    if [ ${intx} -eq ${IntLimitFix} ] ; then 
     #echo -ne "Adding to parity for representing value ${intx}\n" ;
     StrReprFibLevel="1${StrReprFibLevel}" ; 
     IntLevel=$(( ${IntLevel} - 1 )) ; 
    else
     StrReprFibLevel="0${StrReprFibLevel}" ;
    fi 
   done 
   echo -ne "Number: ${Arg0}\nFib Harmonic: [${ArrayFibHarmonic[@]}]\nBinary Level Repr:[${StrReprFibLevel}]\n" ; 
    
  
  }  
  
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  local StrNameHelper="${__call_locality[1]}\n\t";
  local StrSummary="\n\t" ; 
  local StrSynopsis="\n\t";
  local StrDescription="\n\t" ;
  
   
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GVRIsName=True     \
   GVRIsSummary=True  \
   GVRIsSynopsis=True \
   GVRIsDesc=True     \
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( __GetVarReferenceList ) ;	
  elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
   $( VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      VTVIsWhiteList=True         \
      VTVWhiteListTransfert=UUID  \
      ValueToVariable ) __main_StopServices ; 
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
   # eval $( eval VersionApps ) ; 
   StrMsg=$( FibBinaryLevelRepr --get ArrayMsg[0] ) ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolDisplayEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   $( VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      ValueToVariable ) ${StrStartMain}
  fi   
 }

fi

# Generate a List of Fibonnacci Level used to sum a Submitted number.
# only generating this list, using neighborhood application like GetFibLevel 

#unset MakeHuffmanPair ; 
eval $( GFCFuncName=MakeHuffmanPair GlobalFunctionCleaning ) ; 

function MakeHuffmanPair()
{
 local __call_locality=( MHP MakeHuffmanPair ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ; 
 local IntNbHuffmanPair=${MHPNumberOfPair:=64} ;
 local BoolDisplayDebug=${MHPIsDisplayDebug:=False} ; 
 local BoolDisplayStartup=${MHPIsDisplayStartup:=True} ;
 local BoolSHowAddedPair=${MHPIsDisplayAddedPair:=False} ; 
 local StrFileStoreResult=${MHPStoreResult:=file-sort.txt} ; 
 local StrBasedTreeBranch=${MHPBaseTreeMemeber:=0__A__,__A__0,1__A__,__A__1}
 local StrParent="${__call_locality[1]}" ;
 local StrUUID=$( GetUUID ) ; 
 local -a ArrayMsg=( ) ; 

 ArrayMsg[0]="We should discover __INT__ number(s) of pair." ;
 ArrayMsg[1]="Starting Analysis to Pair «__PAIR__», CountingPair : __INT__" ;
 ArrayMsg[2]="We haven't hit Maximum number or Huffmann pair, __CURR__ / __MAX__" ;
 ArrayMsg[3]="Working with template __TPL__" ;
 ArrayMsg[4]="Testing Pair: __PAIR__" ;
 ArrayMsg[5]="Reducing temporary Pair «__PARSE__» with Pair Huffman : «__PAIR__»: , giving __RESULT__" ;
 ArrayMsg[6]="Added Pair: __PAIR__, Member no.__INT__" ;
 local IntArrayMsg=${#ArrayMsg[@]} ;
 local StrValList="IntArrayMsg,BoolSHowAddedPair,StrParent,IntNbHuffmanPair,BoolDisplayDebug,BoolDisplayStarup,StrFileStoreResult,StrUUID" ; 
 
 function Verbosis()
 {
  local __call_locality=( Verbosis Verb );
  local StrMsg=${VerbMsg:=__TEXT__} ; 
  local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsDisplayFormatted=${VerbFormated:=True} ;
  local ArrayArg=( $* ) ; 
  if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
     echo -ne "${StrMsg}\n" > ${StrDevOut} ;
   fi 
  fi
 } 
 ### Model : VerbHeader="DEBUG" VerbMsg=${StrMsg} VerbFormated=True VerbState=True Verbosis
   
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ${StrParent} ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  local -A ArrayHuffman ;
  local StrBranchMember=$( ${StrParent} --get StrBasedTreeBranch ) ; 
  local ArrayTypeExpansion=( ${StrBranchMember//,/ } ) ; 
  
  local ArrayMsg=( ) ; 
  for (( intx=0 ; intx <= $( ${StrParent} --get IntArrayMsg ) ; intx++ )) ; do 
   ArrayMsg[${intx}]=$( ${StrParent} --get ArrayMsg[${intx}] );
  done 
  
  local StrPairStart="10" ; 
  ArrayHuffman[${StrPairStart}]="00001" ;   
  local ApairList=( ) ;
  local StrMsg="" ; 
  #StrMsg=$( ${StrParent} --get ArrayMsg[0] ) ; 
  StrMsg=${ArrayMsg[0]} ; 
  VerbHeader="DEBUG" VerbMsg=${StrMsg//__INT__/${IntNbHuffmanPair}} VerbFormated=True VerbState=${BoolDisplayStartup} Verbosis
  intx=1 ;
  while [ ${intx:=1} -ne ${IntNbHuffmanPair}  ] ; do 
  
   SkipLevel=0 ; 
   ### APair is used to start inspection inside three from lowest to highest.
   ### By Pair we will use form in ArrayTypeExpansion to inject 0 on right and 
   ### left side to inspect reduction to nill by usinf operator ${name//[01]+Apair[01]+}
   ### and evaluating the size to 0 -> found it similar, to Len-N make different 
   ### and still higher than Analysed pair. 
   ### 
   #sleep 1 ; 
   for Apair in ${!ArrayHuffman[@]} ; do 
    ### Ennoncing all Know pair elligible to test theirs branching ability
    ### So, inside a pure binary tree where each concatenation of 1 or 0
    ### can generate 4 branches by question, we are getting  a result 
    ### so This result will by filtered by reducing the predicated pair to
    ### not reduce to nil the previous accepted pair inside the huffman-code 
    ### prefix
    ### 
    ###       ex:              10  ( Start )
    ###                   +------+------+
    ###                  /      / \      \
    ###                 /      /   \      \
    ###                /      |     |      \
    ###               /       /     \       \
    ###              / *1    /*2     \*3     \*4
    ###           1?(101)  1?(110) 0?(010)-+  0?(100)
    ###         +---+---+   ->Forming 9-12 +   +-------Forming 17-20
    ###        /   /\    \            [[[[ +---> Forming 13-16
    ###   *5  /   /  \    \           [[
    ###  1?(1101) |   \    |     <----[[ Forced to Add One more char inside 
    ###        *6 |    \   | *8       [[ ArrayTypeExpansion to form 
    ###         1?(1011)\  0?(1010)   [[ "00__A__" "__A__00" "11__A__" "__A__11"
    ###                  \*7          [[   to find out about branch 5 forming 21-24 
    ###                  0?(0101)     [[[[   +==> where it should like this *21,111101 *22,110111 *23,001101 *24,110100
    ###                                    to find out about branch 6 forming 25-28
    ###                                    to find out about branch 7 forming 29-32
    ###                                    to find out about branch 8 forming 33-36 
    ###   So at the step we are reducing number 5,6,7 or 8, we know 
    ###   only few way to make it fast, or simply re-filter the discovered pair in DPair and 
    ###   if they are present, we exclude the add of this example.
    #StrMsg=$( ${StrParent} --get ArrayMsg[1] ) ; 
    StrMsg=${ArrayMsg[1]} ; 
    StrMsg=${StrMsg//__PAIR__/${Apair}} ; 
    StrMsg=${StrMsg//__INT__/${intx}} ; 
    VerbHeader="DEBUG" VerbMsg=${StrMsg} VerbFormated=True VerbState=${BoolDisplayDebug} Verbosis

    if [ ${intx:=1} -lt ${IntNbHuffmanPair} ] ; then 
     #StrMsg=$( ${StrParent} --get ArrayMsg[2] ) ; 
     StrMsg=${ArrayMsg[2]} ; 
     StrMsg=${StrMsg//__CURR__/${intx}} ; 
     StrMsg=${StrMsg//__MAX__/${IntNbHuffmanPair}} ; 
     
     VerbHeader="DEBUG" VerbMsg=${StrMsg} VerbFormated=True VerbState=${BoolDisplayDebug} Verbosis
     IntFamilyPair=0 ;
     for Bpair in ${ArrayTypeExpansion[@]} ; do 
      
      #StrMsg=$( ${StrParent} --get ArrayMsg[3] ) ; 
      StrMsg=${ArrayMsg[3]} ;
      VerbHeader="DEBUG" VerbMsg=${StrMsg//__TPL__/${Bpair}} VerbFormated=True VerbState=${BoolDisplayDebug} Verbosis
      
      TempPair=${Bpair//__A__/${Apair}} ; 
      #StrMsg=$( ${StrParent} --get ArrayMsg[4] ) ; 
      StrMsg=${ArrayMsg[4]} ;
      StrMsg=${StrMsg//__PAIR__/${TempPair}} ;
      
      VerbHeader="DEBUG" VerbMsg="${StrMsg}" VerbFormated=True VerbState=${BoolDisplayDebug} Verbosis
      for CPair in  ${!ArrayHuffman[@]} ; do 

       IntCpairSize=${#CPair} ;
       IntTmpPairSize=${#TempPair} ;
       if [ ${IntTmpPairSize} -ge ${IntCpairSize}  ] ; then 
        StrReduce=${TempPair//${CPair}/} ;
        ### remaining to add Does the StrReduce or remainder is found inside the list.
        ### if it's true, we do had problem, by founding one item from the tree inside 
        ### bunch of coded data and llok for the wrong code we loosing the whole integrity . 
        IntIntegrity=0 ; 
        for IPair in ${!ArrayHuffman[@]} ; do 
         if [ "${IPair}" == "${StrReduce}" ] ; then 
          IntIntegrity=1 ; 
         fi
        done 
        
        #StrMsg=$( ${StrParent} --get ArrayMsg[5] ) ; 
        StrMsg=${ArrayMsg[5]} ; 
        StrMsg=${StrMsg//__PAIR__/${CPair}} ;
        StrMsg=${StrMsg//__PARSE__/${TempPair}} ;
        StrMsg=${StrMsg//__RESULT__/${StrReduce}} ;
        VerbHeader="DEBUG" VerbMsg=${StrMsg} VerbFormated=True VerbState=${BoolDisplayDebug} Verbosis ;
        IntSizeP=${#StrReduce} ; 
        if [ ${intx:=1} -lt ${IntNbHuffmanPair} ] ; then 
         if [ ${IntSizeP:=0} -gt 0  ] ; then
          if [ ${IntIntegrity:=0} -ne 1  ] ; then 
            InspectPair=0 ; 
            ### can we found this pair inside the list.
            for DPair in ${!ArrayHuffman[@]} ; do
             if [ "${TempPair}" == "${DPair}" ] ; then InspectPair=1 ; fi 
            done 
            if [ ${InspectPair:=1} -eq 0  ] ; then 
             intx=$(( ${intx} + 1 )) ;
             StrStoreX="" ;
             if [ ${intx:=1} -lt 10000 -a ${intx:=1} -ge 1000 ] ; then
              StrStoreX="0${intx}" ; 
             elif [ ${intx:=1} -lt 1000 -a ${intx:=1} -ge 100 ] ; then 
              StrStoreX="00${intx}" ; 
             elif [ ${intx:=1} -lt 100 -a ${intx:=1} -ge 10 ] ; then 
              StrStoreX="000${intx}" ; 
             elif [ ${intx:=1} -lt 10 ] ; then 
              StrStoreX="0000${intx}" ; 
             else
              StrStoreX="${intx}"
             fi
             ArrayHuffman[${TempPair}]=${StrStoreX} ;
             #StrMsg=$( ${StrParent} --get ArrayMsg[6] ) ; 
             StrMsg=${ArrayMsg[6]} ; 

             StrMsg=${StrMsg//__PAIR__/${TempPair}} ;
             StrMsg=${StrMsg//__INT__/${intx}} ;
             VerbHeader="DEBUG" VerbMsg=${StrMsg} VerbFormated=True VerbState=${BoolDisplayDebug} Verbosis
            fi 
          fi 
         fi 
        fi 
       fi
      done 
      IntFamilyPair=$(( ${IntFamilyPair} + 1 )) ; 
      OddPair=${TempPair} ; 
      done 
    fi
    done  
  done 
  #local ArrayPairOrder=( ) ; 
  #intx=1;
  #while [ ${intx:=0} -ne ${IntNbHuffmanPair}  ] ; do 
  # for SPair in in ${!ArrayHuffman[@]} ; do 
  #  IntCurRank=${ArrayHuffman[${SPair}]} ;
  #  if [ "${IntCurRank}" == "${intx}" ] ; then
  #   ArrayPairOrder[${#ArrayPairOrder[@]}]=${SPair} ; 
  #   intx=$(( ${intx} + 1 )) ; 
  #  fi 
  # done 
  #done 
  #StrMsg="All Pair Listed: __PAIR__" ; 
  #StrMsg=${StrMsg//__PAIR__/${ArrayPairOrder[@]}} ; 
  LngMsg="" ; 
  for SPair in in ${!ArrayHuffman[@]} ; do 
   StrMsg="${ArrayHuffman[${SPair}]} ${SPair}" ;
   LngMsg="${LngMsg}\n${StrMsg}" ; 
  done ;
  VerbHeader="" VerbMsg="${LngMsg}\n" VerbFormated=False VerbDev=${StrUUID} VerbState=True Verbosis ; 
  cat ${StrUUID} | egrep -i "^[0-9]+" | sort -k1 > ${StrFileStoreResult} ;
  test -f ${StrUUID} && rm -f ${StrUUID} ;
  cat ${StrFileStoreResult}   ; 
 }

 local StrSynopsis="This is a simple N-Based Branch genertor, helpped to created Binary, Trinary or N-based Tree to help generating example in storing ability of log thru indexed refenrence. "
 local StrDescription="This application using artefact of Associative Array, it store inside Array index the binary result. Made it simply and Getter are yield at the beginning of the loop of main function __main_StartServices to prevent to slow he application in both Debugging or not. It using the parameter MHPBaseTreeMemeber to visit any accepted entry inside the associative Array to visit any Pre-fixed Code. Prefixed code stand for mechanical N-Base operation of concatenating member from this parameter. See parameter expect to create 4 branches for 4 mechanicals position where 1 or 0 will be concatenating before and after. Making 4 branch. Developping Equivalent algorithm, with possibly uses of MHPBaseTreeMemeber=0__A__,__A__0,1__A__,__A__1,2__A__,__A__2 will use 3 states possible and inflate the Tree to 6 branches by level. Branches are nominated inside the Associative array by discovery and depend of an algorithm. Using the replacement of a Parent pair it remove itself the parent pair inside the resultat concatenating and does a test accross already founded pair and anaylyse the result to ensure the remaning substartedfrom string reduction of the Parent pair there is no know result or this pair is not selected. It's more similar to LZW pair creationg except it does not come with assocition of data to be passed inside the Associative Array. Coming out of Shanon expression where it's global appelation, this Tree help building log of registered event if this tree is correct." ;
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GVRIsSynopsis=True GVRIsDesc=True GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;	
	elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVValueEntry=${StrValList}, \ 
          VTVIsArrayStyleInsert=True   \
          VTVIsValueReAssign=True      \
          VTVIsValueToConvert=False    \
          ValueToVariable              ) __main_StartServices ; 
	fi 
 
}
