#!/bin/bash


# Package _sub_ssh_handler 


function ZenityPassPhrase()
{
 local StrReturn=$( zenity --entry --text="Please insert the SSH Passphrase" --hide-text ) ; 
 echo "${StrReturn}" ; 
 return 0; 
 
}

export SSH_ENV="$HOME/.ssh/environment"
export SSH_ASKPASS="ZenityPassPhrase" 

if [ "${SubSSHAgentLoader:=False}" == "True" ] ; then 

unset StartAgentSSH ; 
function StartAgentSSH()
{
	local __call_locality=( SASSH StartAgentSSH ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ; 
 local StrAgentEnvFile=${SASSHEvFile:=environment} ; 
 local IsHomeUser=${SASSHIsUserBasedHome:=True};
 local StrPathBase=${SASSHRootPathNoneUser:=/root} ; 
 local StrAgentPathFile=${SASSHPathStorage:=.ssh};
 local IntDefaultSSHEnvChmod=${SASSHDefaultChmod:=600} ;
 local IsSetSSHENV=${SASSHIsSetSSHENV:=False};
 local IsDeregSSHENV=${SASSHUnregisterSSHENV:=False};
 local StrChmodApps=${SASSHChmodApps:=/bin/chmod}
 local StrSSHAddApps=${SASSHSSHADDApp:=/usr/bin/ssh-add} ; 
 local StrSSHAddAppsOpt=${SASSHSSHADDOpt:=} ; 
 local StrSSHAgentApps=${SASSHSSHAgentApp:=/usr/bin/ssh-agent} ; 
 local StrSSHAgentAppsOpt=${SASSHSSHAgentOpt:=} ; 
 local StrProcMemory=${SASSHProcessLink:=/proc} ;
 local StrStartServicesName=${SASSHStartServices:=__main_StartServices} ;
 local StrStopServicesName=${SASSHStopServices:=__main_StopServices} ;
 local IsVerbosis=${SASSHVerbosis:=False} ;

	function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local VerboseState=${VerbState:=False} ;
		local ArrayArg=( $* ) ; 
		if [ "${VerboseState:=False}" == "True" ] ; then 
			echo -ne "VERBOSE:[ ${StrMsg} ]\n" > ${StrDevOut} ;
		fi
	}
 
 
 ### Create StrPathSSH and if IsHomeUser==False, StrPathSSH will own
 ### the StrPathBase value (default set to /root )
 local StrEvalCmdUserHome=$( BVTVarName="StrPathSSH" \
       BVTDisplayIf=${IsVerbosis} \
       BVTVarHold=${HOME} \
       BVTBoolVarName=\${IsHomeUser} \
       BVTBoolAssertion=\${StrPathBase} \
       BVTConclude=' ' BoolVarTest ) ; 
 StrDbgMsg="In Funct:${__call_locality[1]}\n\t\tContent of StrEvalCmdUserHome:[${StrEvalCmdUserHome}]" ;
 VerbMsg=${StrDbgMsg} VerbState=${IsVerbosis} Verbosis ; 
 eval ${StrEvalCmdUserHome} ; 
 
 ### Appending to StrPathSSH , the .ssh path.
 StrPathSSH=${StrPathSSH}/${StrAgentPathFile} 
 
 function __main_StopServices()
 {
		local __call_locality=( Stop __main_StopServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ;   
  echo -ne "\n\t\033[01;31mDe-Register SSH agent...\033[00m\n\n" ; 
  test -f ${StrPathSSH}/${StrAgentEnvFile} && rm -f ${StrPathSSH}/${StrAgentEnvFile} ; 
  if [ "${IsDeregSSHENV:=False}" == "True" ] ; then 
   echo -ne "\n\t\033[01;31mDe-Register SSH_ENV...\033[00m\n\n" ; 
   unset SSH_ENV ; 
  fi 
  local IntPidAgent=${SSH_AGENT_PID:=-1}
  if [ ${IntPidAgent} -ne -1 ] ; then 
   echo -ne "\n\t\033[01;31mKilling SSH-Agent on PID:${IntPidAgent}\033[00m\n\n" ; 
   sudo kill -11 ${IntPidAgent} ; 
   test ! -d ${StrProcMemory}/${IntPidAgent} && unset SSH_AGENT_PID
  fi 
 }
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
 
  if [ "${IsSetSSHENV:=False}" == "True" ] ; then 
   if [ "${IsDeregSSHENV:=False}" == "True" ] ; then 
    echo -ne "\n\tDe-Register SSH_ENV...\n\n" ; 
    unset SSH_ENV ; 
   else
    echo -ne "\n\tRegistering SSH_ENV to file : ${StrPathSSH}/${StrAgentEnvFile}\n\n" ; 
    export SSH_ENV=${StrPathSSH}/${StrAgentEnvFile} ; 
   fi 
  fi
  
  if [ "${IsSetSSHENV:=False}" == "False" ] ; then 
   echo -ne "\n\t\033[01;33mInitializing new SSH agent...\033[00m\n\n"
   test -f ${StrPathSSH}/${StrAgentEnvFile} && rm -f ${StrPathSSH}/${StrAgentEnvFile}
   echo -ne "\n\t\033[01;33mLoading ${StrSSHAgentApps}...\033[00m\n\n"
   eval ${StrSSHAgentApps} ${StrSSHAgentAppsOpt} | sed 's/^echo/#echo/' > "${SSH_ENV}"
   echo -ne "SSHAgent\t\t\t\t\033[01;32m[ succeeded ]\033[00m\n" ; 
   eval ${StrChmodApps} ${IntDefaultSSHEnvChmod} "${SSH_ENV}"
   . "${SSH_ENV}" > /dev/null
   echo -ne "\n\t\033[01;33mLoading ${StrSSHAddApps}...\033[00m\n\n"
   local CmdLine="${StrSSHAddApps}" ; 
   eval ${CmdLine} ; 
  fi
 }
 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n" ;
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
 eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrAgentEnvFile,IsHomeUser,StrPathBase,StrAgentPathFile,IsSetSSHENV,IsDeregSSHENV,StrSSHAddApps,StrSSHAddAppsOpt,StrSSHAgentApps,StrSSHAgentAppsOpt \
  VTVIsValueReAssign=True    \
  VTVIsValueToConvert=False  \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) ${StrStopServicesName} ; 
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrAgentEnvFile,IsHomeUser,StrPathBase,StrAgentPathFile,IsSetSSHENV,IsDeregSSHENV,IntDefaultSSHEnvChmod,StrChmodApps,StrSSHAddApps,StrSSHAddAppsOpt,StrSSHAgentApps,StrSSHAgentAppsOpt,StrProcMemory \
  VTVIsValueReAssign=True    \
  VTVIsValueToConvert=False  \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) ${StrStartServicesName}
 fi
 unset __main_StopServices __main_StopServices ;
 ### Discover StartAgentSSH function did leave it's sub-function out and living.
 ### While StartAgentSSH did not own Brace after function declaration its better
 ### to unset internal function and/or rewriting 
 ### function StartAgentSSH
 ### into 
 ### function StartAgentSSH() 
 
}

unset StubStartAgent ;
function StubStartAgent()
{
	local __call_locality=( SSA StubStartAgent ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ; 
 
 local ArrayArg=( $* ) ;
 StartAgentSSH;
}

unset SSHAgentMemoryInfo ;
function SSHAgentMemoryInfo()
{
	local __call_locality=( SSHAMI SSHAgentMemoryInfo ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ; 
 
 ps -ef | egrep ${SSH_AGENT_PID} | egrep 'ssh-agent$' | egrep -v "<defunct>" > /dev/null ;
}

### Notice : 208d465e-f6d4-11e5-98a2-001e4c8856d6 
### Uses of Prefixed-Variable in AgentLoader Might work.
### 
### Belong to topology, all prefixed-variable are by default assigned to 
### a candidate value if there is no representation of it in Higher level 
### like command line: 
### 
### Explicitly mean : following command will output all 
### virtual test being handled by BoolVarTest if there is not 
### explicitly assigned value to is original command line, IsDisplayIfStatement
### is the Verbosis example following the output inside BoolVarTest. 
### 
### But subject line fully working in date of 2016-03-30 belong to notice 
### 208d465e-f6d4-11e5-98a2-001e4c8856d6 and after token notice, example :
### 
### BVTDisplayIf=True AgentLoader --stopservices
### BVTDisplayIf=True AgentLoader --startservices 
### will display the current BoolVarTest listing of if-fi statement.
### 
### reference : 
### 
### BVTDisplayIf=True AgentLoader --stopservices 
### VERBOSE:[ 
### Function BoolVarTest, Display Result:
### local StrAppsAction="${StrAppsAction}" ;
###  if [ "${IsValueSimpleConvert}" == "True" ]  ; then 
###   StrAppsAction=${StrDefaultSedScript} 
###   ; fi ;
###  ]
### VERBOSE:[ 
### Function BoolVarTest, Display Result:
###  local StrAppsAction="${StrAppsAction}" ;
###  if [ "${IsValueToAssignSame}" == "True" ]  ; then 
###   StrAppsAction=${StrDefaultAssignScript} 
###   ; fi ;
###  ]
### VERBOSE:[ 
### Function BoolVarTest, Display Result:
###  local StrAppsAction="${StrAppsAction}" ;
###  if [ "${IsValueTransScript}" == "True" ]  ; then 
###   StrAppsAction=${StrDefaultTransform} 
###   ; fi ;
###  ]
### VERBOSE:[ 
### Function BoolVarTest, Display Result:
###  local StrParsedVar="${StrValueParser}" ;
###  if [ "${IsEntryInComaSep}" == "True" ]  ; then 
###   StrParsedVar=${StrValueParser//,/ } 
###   ; fi ;
###  ]
### 
### 


 unset AgentLoader;
 function AgentLoader()
 {
  local __call_locality=( AL AgentLoader ) ;
  local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ;  
  local StrStartServicesName=${ALStartServices:=__main_StartServices} ;
  local StrStopServicesName=${ALStopServices:=__main_StopServices} ;
  
  
  function __main_StopServices()
  {
   local __call_locality=( Stop __main_StopServices ) ;
   local Arg0=${ArrayArg[0]} ;
   local ArrayArg=( $* ) ;  
   SASSHSSHAgentApp=${SASSHSSHAgentApp} SASSHSSHADDApp=${SASSHSSHADDApp} SASSHUnregisterSSHENV=True SASSHIsSetSSHENV=True StartAgentSSH --stopservices 
   unset SSH_AGENT_PID SSH_ENV ; 
  }
  
  function __main_StartServices()
  {
   local __call_locality=( Main __main_StartServices ) ;
   local Arg0=${ArrayArg[0]} ;
   local ArrayArg=( $* ) ; 
   ### Create environment for SSH_ENV 
   SASSHSSHAgentApp=${SASSHSSHAgentApp} SASSHSSHADDApp=${SASSHSSHADDApp} SASSHIsSetSSHENV=True StartAgentSSH ; 
   
   # Source SSH settings, if applicable
   if [ -f "${SSH_ENV}" ]; then
     . "${SSH_ENV}" > /dev/null
     #ps ${SSH_AGENT_PID} doesn't work under cygwin
     SSHAgentMemoryInfo || { StartAgentSSH ; } ;
   else
     StartAgentSSH ;
   fi 
  }
  function Verbosis()
  {
   local __call_locality=( Verbosis Verb );
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local VerboseState=${VerbState:=False} ;
   local ArrayArg=( $* ) ; 
   if [ "${VerbState:=False}" == "True" ] ; then 
    echo -ne "VERBOSE:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   fi
  }
  
  local StrNameHelper="AgentLoader\t\tThe Fnct.D SSH-Key manager, A Stub Function being StartAgentSSH";
  local StrSynopsis="Application allow to enter your SSH-Key from ASKPASS or from Shell and does wrap the key entry with user permission to Kill Actual-key and renew the PID instead of loosing the key-realm after definition of Key-Duration limit with git.";
  local StrSummary="By Starting the services AgentLoader does itself the PID registration and does keep it later to terminate the services with --stop-services switches. Make it easy to handle stopping the services it may ask you the password of the username and does terminate the session. Leaving you making changes in you key or yelding another key ans starting the services once. To manage the property of the SSH-Realm connection you must pass Pre-fixed variable to StartAgentSSH. This one is another function making the management of the services loaded by AgentLoader." ; 

  StrSwitchMessages="""${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n""" ; 
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    GVRIsName=True GVRIsSynopsis=True GVRIsSummary=True GetVarReference ${__call_locality[1]} ; 
    echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
		 eval $( __GetVarReferenceCompWord ) ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( __GetVarReferenceList ) ;
  elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
   # __main_StopServices ; ### replaced 
   eval "${StrStopServicesName}" ;
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
   # __main_StartServices ; ### replaced
   eval "${StrStartServicesName}" ; 
  fi

  unset __main_StartServices __main_StopServices ; 
 }
fi 

unset GetGitHubKey ; 
function GetGitHubKey()
{
 ### List of Key:
 ### GetGitHubKeyPassphraseHook
 ### GetGitHubKeyIndex
 ### GetGitHubKeyDecoder
 ### 
 ### --- > see Fnct_GetSSHKey.py from https://github.com/priendeau/Technical-PorteFolio/
 ### This will replace the function with safer storage thru sqlobject and sqlite backend
 ### it using the same Zenity interface with PyZenity . 

 local __call_locality=( GetGitHubKey ) 
 local ArrayArg=( $* ) ;
 local StrPassphraseHook=${GetGitHubKeyPassphraseHook:=${IntDefaultSSHKey}} ;
 local DefaultKeylevelExist=$( declare -i | egrep -c "${StrPassphraseHook}" ); 
 local SSHPassKey ; 
 local StrDecodeBase=${GetGitHubKeyDecoder:=base64 --decode}

 function LowLevelDecoder( )
 {
    local __call_locality=( LowLevelDecoder ) 
    local ArrayArg=( $* ) ;
    ${LowLevelDecoderCmd:=base64 --decode} ;
 }

 if [ ${DefaultKeylevelExist:=0} -eq 0 ] ; then 
    SSHPassKey=${GetGitHubKeyIndex:=0} ;
 else
    eval SSHPassKey=\${${StrPassphraseHook}} ;
 fi

 local DisplayKeyName=${ArrayGitHubKeyName[${SSHPassKey}]} ;
 local KeyOutput=$( echo ${ArrayGitHubKey[${SSHPassKey}]} | LowLevelDecoderCmd=${StrDecodeBase} LowLevelDecoder ) ; 
 echo -ne "Key from ${DisplayKeyName}:\n[${KeyOutput}]\n"  > /dev/stderr ; 
}

unset GetKeyChoice ; 
function GetKeyChoice()
{

### Pre Variable List 
### GetKeyChoiceDisplayKey                  -> ( True | False )
###  - Inhibit custom passphrase beign displayed on screen while 
###    invoking ssh-add . 
### GetKeyChoiceEval                        -> ( True | False )
###  - Creating extra line of shell used to add some update to your current 
###    shell once the Application end it's task. In this case updating var 
###    IntDefaultSSHKey to reflect current key selection. 
###    ( usefull when re-calling GetGitHubKey ) 
### GetKeyChoiceAppsKeyProvider             -> ( default : GetGitHubKey ) 
###    Is the application responsible to provide you the passphrase in case
###    you haven't noticed... Assuming your working on your sysetem and this 
###    one is not lethal to your life. 
###    Note : Involving this setting mean you have to call the Function like 
###    this to let it work : eval $( GetKeyChoiceEval=True GetKeyChoice ) 
###    next time By calling GetGitHubKey it will give you actual Passphrase. 
### GetKeyChoicePassphraseHook              -> ( default : IntDefaultSSHKey )
###    Allow GetGitHubKey to refer to this key to seek for actual Passphrase.
###
### !!! Paranoid Level !!!
###
### GetKeyChoiceDecoderLevel                -> ( default : base64 --decode)
###    Allow safer decoding but need your hand and may interfer with stdout and
###    stderr , using GetKeyChoiceEval may interfer and not working while asking
###    you to enter another passphrase like using :
###    openssl enc -d -cast5-cbc -k <PASSWORD> 
###     - This <PASSWORD> must be somewhere like on stdin ( on screen ) if you forget
###     option -k in openssl or using file as password holder, but it store the password 
###    on the .bash_history.... why it's paranoid level. 
### GetKeyChoiceStorageSuffix               -> ( default : GitHubKey )
###    Allow to Store Key, name of the key and corresponding key-file from Another
###    Array usually having ArrayGitHubKey, ArrayGitHubKeyName ArrayGitHubKeyFile
###    it using suffix GitHubKey see -> 
###         Array : Array[GitHubKey], Array[GitHubKey]Name Array[GitHubKey]File 
###     this can serve managing different Array of Key and may store other type of 
###    key, like passphrase for pem-file in apache like ... 
###
### !!! patented - talent !!! 
### AppsRootName                           -> ( default : GetKeyChoice )
###     Wrapping this Function another one you can call the application differently
###     by doing sed and evoluated reg-exp, like using python module and re. 
###     using declare -f GetKeyChoice give you the full body and may serve as template.
###     using AppsRootName prevent ovewriting of the new function in memory by avoiding
###     overwriting all already prefixed variable from this sedding or replacing action. 
###     It's a patented - talent ... << Sam on radio ; patented - talent ... 
###     Who know friend... >> ...


    local ArrayArg=( $* ) ;
    local __call_locality=( GetKeyChoice ) ;
    local StrPassphraseHook=${GetKeyChoicePassphraseHook:=IntDefaultSSHKey} ;
    local StrDecoder=${GetKeyChoiceDecoderLevel:=base64 --decode}
    local StrStoreSuffix=${GetKeyChoiceStorageSuffix:=GitHubKey} ;
    eval unset ${StrPassphraseHook} ; 
	function TransformArray()
	{
	    local ArrayArg=( $* ) ;
	    local __call_locality=( TransformArray ) ;
		local StrScopeType="declare -a" ;
		if [ "${TransformArrayScope:=local}" == "local" ] ; then 
			StrScopeType="local" ;
		fi
		if [ "${TransformArrayScope:=global}" == "local" ] ; then 
			StrScopeType="declare -a"

		fi 
		local StrSed="""'s/__SCOPE__ //g;s/^[a-zA-Z0-9\-\_]*=/__NEW_ARRAY__=/g'""" ;
		StrSed=${StrSed//__SCOPE__/${StrScopeType}}
		StrSed=${StrSed//__NEW_ARRAY__/${ArrayArg[0]}}
		StrSed=${StrSed//\ /\\\ } ;
		StrSed=${StrSed//\-/\\\-} ;
		echo -ne "Sed: sed ${StrSed}\n" > /dev/stderr ;
		local StrArrayTransform=$( ${StrScopeType} | egrep "${StrScopeType} ${ArrayArg[0]}"  | $( eval sed ${StrSed} )  ) 
		echo -ne """${TransformArrayDecl:=local} ${StrArrayTransform} ;"""  
	}
    function ZenityMenuKey()
    {
        ### List of Key:
        local ArrayArg=( $* ) ;
        local __call_locality=( ZenityMenuKey )
        zenity --width=300 --height=300 --list --radiolist --text="Choose your Key to add inside AgentLoader" --column "Selection" --column "Key Name" 
    }
    function ReduceTagInSed()
    {
        local ArrayArg=( $* ) ;
        local __call_locality=( ReduceTagInSed ) ;
        sed -e 's/\([\\\/\$\}\{a-z]\)//g;s/\(([A-Z0-9]*:)\)/\1;/g;s/[\)\(\}\{\}]//g' | cut -d ";" -f 1 ;
    }
    function ListKeyName()
    {
        ### List of Key:
        local ArrayArg=( $* ) ;
        local __call_locality=( ListKeyName ) ;
		eval $( TransformArrayDecl=local TransformArrayScope=global TransformArray Array${ListKeyNameStorageSuffix:=GitHubKey}Name _EArrayName ) 
		#eval "local _EArray=( \${Array${ListKeyNameStorageSuffix:=GitHubKey}Name[@]//\"/\\\"} ) ;" 
		for (( intx=0 ; intx <= ${#_EArrayName[@]}-1 ; intx++ )) ; do 
			echo -ne "FALSE\n${_EArray[${intx}]}\n" ; 
		done 
    }
    function ExchangeKeyPair( ) 
    {
        ### List of Key:
        local ArrayArg=( $* ) ;
        local __call_locality=( ExchangeKeyPair )       
        local PathSSH=${HOME}/.ssh ; 
        
        if [ "${USER}" == "root" ] ; then 
            PathSSH=/root/.ssh ;
        fi
        cp ${PathSSH}/${ArrayGitHubKeyFile[${KeyId}]} ${PathSSH}/id_rsa
        cp ${PathSSH}/${ArrayGitHubKeyFile[${KeyId}]}.pub ${PathSSH}/id_rsa.pub
        if [ "${IsDisplaySavedKey:=False}" == "True" ] ; then 
            echo -ne "Add this key inside the required field:\n" > /dev/stderr ;
            GetGitHubKeyDecoder=${StrDecoder} GetGitHubKeyIndex=${KeyId} ${GetKeyChoiceAppsKeyProvider:=GetGitHubKey} > /dev/stderr ;
        fi
        test -e ${PathSSH}/environment && rm -f ${PathSSH}/environment 
        ssh-add > /dev/stderr ;         
    }
    local IsDisplaySavedKey=${GetKeyChoiceDisplayKey:=True} ;
    local IsArrayCreated=$( declare -a | egrep -c "ArrayGitHubKey" ) ;
    local KeyName=$( ListKeyName | ZenityMenuKey ) ;

    if [ "${KeyName:=None}" != "None" ] ; then 
        echo -ne "Key Name selected: ${KeyName}\n" > /dev/stderr ; 
        local KeyId=None ;
        if [ ${IsArrayCreated:=0} -gt 0 ] ; then 
            if [ "${KeyName:=None}" != "None" ] ; then 
                for (( x=0 ; x <= ${#ArrayGitHubKeyName[@]}-1 ; x++ )) ; do 
                    local ItemKey="${ArrayGitHubKeyName[${x}]}" ;
                    if [ "${KeyName}" == "${ItemKey:=None}" ] ; then 
                        KeyId=${x} ;
                    fi
                done 
                KeyId=${KeyId} IsDisplaySavedKey=${IsDisplaySavedKey} ExchangeKeyPair

            fi    
        else
            echo -ne "Function ${__call_locality[0]} Need At least those Array being declared : \n" > /dev/stderr ; 
            echo -ne "ArrayGitHubKey To Hold The PassPhrase in base64 format ( with no wrap line.) \n" > /dev/stderr ; 
            echo -ne "ArrayGitHubKeyName To Hold The Zenity List Menu showing you wich key to use \n" > /dev/stderr ; 
            echo -ne "ArrayGitHubKeyFile to hold file inside ${HOME} or .ssh path from user ${USER} to copy both KEYNAME-id_rsa KEYNAME-id_rsa.pub into id_rsa and id_rsa.pub \n" > /dev/stderr ; 
            echo -ne "Being Afraid to display a passphrase on the screen, set this function has GetKeyChoiceDisplayKey=False GetKeyChoice on prompt or your .bashrc to prevent to be display.\n" > /dev/stderr ; 
        fi
    else
        echo -ne "User Cancel the Action.\n" > /dev/stderr
    fi 
    if [ "${GetKeyChoiceEval:=False}" == "True" ] ; then 
        echo -ne "declare -i ${StrPassphraseHook}=\"${KeyId}\"\n" ;
    fi 
}
### An example of what to add inside your /root/.bashrc 
### 
### declare -a ArrayGitHubKey=( Tm9uZQo= Tm9uZQo= Tm9uZQo= ) ; -> Assuming both 3 passphrase are : "None", "None" and "None".
### declare -a ArrayGitHubKeyName=( "None" "GitHub Key" "PyPi SSH Key" ) ;
### declare -a ArrayGitHubKeyFile=( None github-id_rsa pypi-id_rsa ) ;
### 
### Using GetKeyChoice will display you all 3 choice and ( cancel button is not yet designe, but None choice work )
### 
### 


### yet Another Password generator.
if [ "${SubSSHGetPasswd:=False}" == "True" ] ; then 

 unset GetPasswd ;
 function GetPasswd()    
 { 
  local ArrayArg=( $* ) ; 
  local __call_locality=( GP GetPasswd ) ; 
  local Arg0=${ArrayArg[0]} ; 
  
  local StrAppsPwdGenerator=${GPAppsGen:="/usr/bin/pwgen"} ;
  local IntDefaultPwdSize=${GPSize:=16} ;
  local IntDefaultFactor=${GPFactor:=1000} ; 
  local IntRandomSeedFactor=${GPRandomSeed:=10} ; 
  local StrPasswordTypeForm=${GPArgType:=cnsB1,cysB1,cnsyB1} ; 
  local IntPasswordType=${GPGenFormType:=0} ;
  local BoolEvalCmdExit=${GPShowCmdEvalAndExit:=False} ;
  local BoolFormatOuput=${GPShowOutputFormated:=True} ;
  local BoolDisplayFnctD=${GPShowFnctDCall:=False} ; 
  local IsAutoInstallPwgen=${GPAutoInstallDependency:=False} ; 
  local StrUrlManager=${GPDownloadManager:=/usr/bin/wget};
  local StrDebInstallMethod=${GPDebianMethodInst:=apt,gdebi}
  local IntDebianInstallerType=${GPPwGenPackager:=0}
  local StrAptLineCmd=${GPPwgenAptCmd:=sudo apt-get install pwgen};
  local StrGdebiLineCmd=${GPPwgenGdebiCmd:=sudo gdebi __OPTION__ __PACKAGE__}
  local StrGdebiLineOpt=${GPPwgenGdebiOpt:="""--option=Get::Assume-Yes=\"true\""""} ; 
  local StrGdebiPackageName=${GPPwgenPackaName:=pwgen_2.06-1ubuntu4_amd64.deb} ; 
  local StrGdebiDownloadPack=${GPPwgenPackageURL:=http://launchpadlibrarian.net/124865523/__PACKAGE__} ;
  local StrFnctDSvrBVTVC=${GPBVTVCName:=BoolVarTest} ;  
  local StrVarListTransfert="BoolDisplayFnctD,StrUrlGetter,BoolEvalCmdExit,StrAppsPwdGenerator,IntDefaultPwdSize,IntDefaultFactor,IntRandomSeedFactor,StrPasswordTypeForm,IntPasswordType,IsAutoInstallPwgen,StrDebInstallMethod,StrDebianInstallerType,StrAptLineCmd,StrGdebiPackageName,StrGdebiDownloadPack,StrFnctDSvrBVTVC" ;
  local ArrayInstalChoice=( "apt:StrAptLineCmd" "gdebi:StrGdebiLineCmd" ) ;
  local ArrayMsg=( ) 
  ArrayMsg[0]="executing following line: __CMD__"
  ArrayMsg[1]="Installtion with __MANAGER__ cmdline:[ __CMD__ ]." ; 
  ArrayMsg[2]="Installtion with __MANAGER__ require Downloading the package." ;
  ArrayMsg[3]="Crunching for a factor of __FACTOR__ password. " ;
  ArrayMsg[4]="Eval:[ __EVAL__ ]" ;
  ArrayMsg[5]="Application __APPS__ still not present."  ;
  
  ### Notice: c064ce9e-6e4e-11e6-abb3-001e4c8856d6, August 29 2016 , 21:12 pm. 
  ### For those beleiving adding the Function Execution inside ArrayInstalChoice like :
  ### apt:AutoInstallPackage:StrAptLineCmd, gdebi:DownloadFilePackage:StrGdebiLineCmd and 
  ### providing a Getter for AutoInstallPackage for only parse or getting few things out of 
  ### a single command that does not need to download the package, i'm still thinking hard
  ### about it, even for 13 years of thinking... It's because apt-get install can issues out 
  ### problems like end-of term and sometimes even archives.ubuntu.org does not respond while
  ### some effort are made actually to find a place to download it and make it installable. 
  ### Also, make it clear to see it and simply provide good-waty to make it visible. 
   
 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsDisplayFormatted=${VerbFormated:=True} ;
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
     echo -ne "${StrMsg}\n" > ${StrDevOut} ;
   fi 
		fi
	}
 ### Model : VerbHeader="DEBUG" VerbMsg=${StrMsg}  VerbDev=/dev/stderr VerbState=True Verbosis
 

  unset DownloadFilePackage ;
  function DownloadFilePackage()
  {
   local __call_locality=( AutoInstallPackage API  ) ;
   local ArrayArg=( $* ) ; 
   local Arg0=${ArrayArg[0]} ;   
   local StrMsg="" ; 
   local StrUrl=$( GetPasswd --get StrGdebiDownloadPack )   ;
   local StrPackage=$( GetPasswd --get StrGdebiPackageName )  ;
   local StrDownloadManager=$( GetPasswd --get StrUrlManager )
   local StrURLDownload="""${StrDownloadManager} \"${StrUrl}\"""" ;
   StrURLDownload=${StrURLDownload//__PACKAGE__/${StrPackage}} ;
   StrMsg=$( GetPasswd --get ArrayMsg[0] );
   VerbHeader="DOWNLOAD" VerbMsg=${StrMsg//__CMD__/${StrURLDownload}}  VerbDev=/dev/stderr VerbState=True Verbosis ;
   eval ${StrURLDownload} ; 
  
  }
  
  unset AutoInstallPackage
  function AutoInstallPackage()
  {
   local __call_locality=( AutoInstallPackage API  ) ;
   local ArrayArg=( $* ) ; 
   local Arg0=${ArrayArg[0]} ;
   local StrChoiceRank=$( GetPasswd --get StrDebInstallMethod ) ;
   local ArrayInstForm=( ${StrChoiceRank//,/ } ) ;
   local StrMsg="" ; 
   local IntChoiceInstaller=$( GetPasswd --get IntDebianInstallerType ) ;
   local CmdParserOpt=$( GetPasswd --get ArrayInstalChoice[${IntDebianInstallerType}] ) ;
   local StrPairLeft=${CmdParserOpt/%:[a-zA-Z0-9]*} ;
   local StrPairRight=${CmdParserOpt/#[a-zA-Z0-9]*:} ; 
   local StrParserCmd=$( GetPasswd --get ${StrPairRight} )  ; 
      
   if [ "${StrPairLeft}" == "${ArrayInstForm[${IntChoiceInstaller}]}" ] ; then 
    StrMsg="Installing using ${StrPairLeft} method." ; 
    VerbHeader="INSTALL" VerbMsg=${StrMsg}  VerbDev=/dev/stderr VerbState=True Verbosis ; 
    
    if [ "${StrPairLeft}" == ${ArrayInstForm[0]} ] ; then 
     StrMsg=$( GetPasswd --get ArrayMsg[1] );
     StrMsg=${StrMsg//__MANAGER__/${StrPairLeft}} ;
     StrMsg=${StrMsg//__CMD__/${StrParserCmd}} ;
     VerbHeader="INSTALL" VerbMsg=${StrMsg}  VerbDev=/dev/stderr VerbState=True Verbosis ;
     eval "${StrParserCmd}" ; 
    elif [ "${StrPairLeft}" == ${ArrayInstForm[1]} ] ; then 
     StrMsg=$( GetPasswd --get ArrayMsg[2] );
     StrMsg=${StrMsg//__MANAGER__/${StrPairLeft}} ;
     VerbHeader="INSTALL" VerbMsg=${StrMsg}  VerbDev=/dev/stderr VerbState=True Verbosis ;
     DownloadFilePackage ;
     StrParserCmd=${StrParserCmd//__OPTION__/$( GetPasswd --get StrGdebiLineOpt )} ; 
     StrParserCmd=${StrParserCmd//__PACKAGE__/$( GetPasswd --get StrGdebiPackageName )} ; 
     
     StrMsg=$( GetPasswd --get ArrayMsg[1] );
     StrMsg=${StrMsg//__MANAGER__/${StrPairLeft}} ;
     StrMsg=${StrMsg//__CMD__/${StrParserCmd}} ;
     VerbHeader="INSTALL" VerbMsg=${StrMsg}  VerbDev=/dev/stderr VerbState=True Verbosis ;
     eval ${StrParserCmd}
    fi 
   
   fi 
  }
  

  unset __Loop ;
  function __Loop( )
  {
   local __call_locality=( _L __Loop  ) ;
   local ArrayArg=( $* ) ; 
   local Arg0=${ArrayArg[0]} ;
   local StrMsg ;
   StrMsg=$( GetPasswd --get ArrayMsg[3] ) ;
   StrMsg=${StrMsg//__FACTOR__/${factor}} ; 
   VerbHeader="GetPasswd" VerbMsg=${StrMsg}  VerbDev=/dev/stderr VerbState=True Verbosis ;
   local value ; 
   local intx=0;
   while [ ${intx} -ne ${factor} ] ; do 
    value=$( ${StrAppsPwdGenerator} ${StrPwGenFormPassword} ${IntDefaultPwdSize} );
    intx=$(( ${intx} + 1 )) ; 
   done ; 
   StrMsg="${value}" ; 
   if [ "${BoolFormatOuput:=False}" == "True" ] ; then 
    VerbHeader="" VerbMsg="${StrMsg}"  VerbDev=/dev/stderr VerbState=True Verbosis ;
   else
    VerbHeader="GetPasswd" VerbMsg="${StrMsg}"  VerbDev=/dev/stderr VerbState=True VerbFormated=False Verbosis ;
   fi 
   

  }
  
  unset __Display ;
  function __Display()
  {
   local __call_locality=( _D __Display  ) ;
   local ArrayArg=( $* ) ; 
   local Arg0=${ArrayArg[0]} ;
   eval "local value=\"${StrAppsPwdGenerator} ${StrPwGenFormPassword} ${IntDefaultPwdSize}\"" ;
   StrMsg=$( GetPasswd --get ArrayMsg[4] ) ;
   StrMsg=${StrMsg//__EVAL__/${value}} ; 
   VerbHeader="CMDLINE" VerbMsg=${StrMsg}  VerbDev=/dev/stderr VerbState=True Verbosis ;
   
  }
  unset __main_StartServices ;
  function __main_StartServices()
  {
   local __call_locality=( Main __main_StartServices ) ;
   local ArrayArg=( $* ) ; 
   local Arg0=${ArrayArg[0]} ;
   local StrMsg="" ; 
   local StrPrefixFuncD=$( ${StrFnctDSvrBVTVC} --get __call_locality[0] ) ; 
   ### In Case we do require to install the package :
   if [ ! -e ${StrAppsPwdGenerator} ] ; then 
     ParserCmd="""${StrPrefixFuncD}VarHold='' ${StrPrefixFuncD}BoolVarName=\"\${IsAutoInstallPwgen:=False}\" ${StrPrefixFuncD}BoolCase=True ${StrPrefixFuncD}BoolAssertion='' ${StrPrefixFuncD}IsPreambule=False ${StrPrefixFuncD}ScopeTest=local ${StrPrefixFuncD}VTVVarA=${StrListVar} ${StrPrefixFuncD}VTFnctA=AutoInstallPackage ${StrPrefixFuncD}IsValueToVar=True ${StrPrefixFuncD}IsValueToVarAssert=True ${StrPrefixFuncD}DisplayIf=${BoolDisplayFnctD} ${StrFnctDSvrBVTVC}""" ;
     VerbHeader="DEBUG-CMDLINE" VerbMsg=${ParserCmd}  VerbDev=/dev/stderr VerbState=${BoolDisplayFnctD} Verbosis ;
     eval $( ${ParserCmd} ) ;
   fi  
   
   if [ ! -e ${StrAppsPwdGenerator} ] ; then 
    StrMsg=$( GetPasswd --get ArrayMsg[5] );
    StrMsg=${StrMsg//__APPS__/${StrAppsPwdGenerator}} ; 
    VerbHeader="PWGEN" VerbMsg=${StrMsg}  VerbDev=/dev/stderr VerbState=True Verbosis
   else 
    local ArrayFormPassword=( ${StrPasswordTypeForm//,/ } ) ;
    local StrPwGenFormPassword="-${ArrayFormPassword[${IntPasswordType}]}" ;
    local end=${IntDefaultFactor} ; 
    local factor=$(( ${end} * $(( ( ${RANDOM} % ${IntRandomSeedFactor} ) + 1 )) )) ; 
    
    local value="" ;
    ### 
    ### Password Line execution ( needed both in display and Loop command. )
    ### 
    local StrCmdPwdEval="""StrAppsPwdGenerator=${StrAppsPwdGenerator} StrPwGenFormPassword=${StrPwGenFormPassword} IntDefaultPwdSize=${IntDefaultPwdSize}""" ; 
    local StrLoopCmd="""${StrCmdPwdEval} factor=\${factor}""" ; 
    local StrDisplayCmd="""${StrCmdPwdEval}""" ; 
    
    ### Decide to display the command-line and exit or do the work. 
    ParserCmd="""${StrPrefixFuncD}VarHold='' ${StrPrefixFuncD}VTVVar=${StrVarListTransfert} ${StrPrefixFuncD}VTFnct=__Display ${StrPrefixFuncD}BoolVarName=\"\${BoolEvalCmdExit:=False}\" ${StrPrefixFuncD}BoolCase=False ${StrPrefixFuncD}oolAssertion='' ${StrPrefixFuncD}IsPreambule=True ${StrPrefixFuncD}ScopeTest=local ${StrPrefixFuncD}VTVVarA=${StrVarListTransfert} ${StrPrefixFuncD}VTFnctA=__Loop ${StrPrefixFuncD}IsValueToVar=True ${StrPrefixFuncD}IsValueToVarAssert=True ${StrPrefixFuncD}DisplayIf=${BoolDisplayFnctD} ${StrFnctDSvrBVTVC}""" ;
    VerbHeader="DEBUG-CMDLINE" VerbMsg=${ParserCmd}  VerbDev=/dev/stderr VerbState=True Verbosis ;
    $( eval ${ParserCmd} ) ;
   fi
     
  }

  local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    GetVarReference ${__call_locality[1]} ; 
    echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( __GetVarReferenceList ) ;
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVValueEntry=${StrVarListTransfert} VTVIsValueReAssign=True VTVIsValueToConvert=False VTVIsArrayStyleInsert=True ValueToVariable ) __main_StartServices
  fi	 
  

 }
fi

###     Not Needed anymore, see GetKeyChoice for a clever choice... Must be with XWindows or any Kde, gtk, gnome, Mate interface. 
#if [ -e "${HOME}/.ssh/environment" ] ; then 
# AgentLoader ;
#fi 

