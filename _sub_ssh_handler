
#. /etc/init.d/Fnct.d/fnct_debian_lib 

function ZenityPassPhrase()
{
 local StrReturn=$( zenity --entry --text="Please insert the SSH Passphrase" --hide-text ) ; 
 echo "${StrReturn}" ; 
 return 0; 
 
}

#export SSH_ENV="$HOME/.ssh/environment"
export SSH_ASKPASS="ZenityPassPhrase" 

function StartAgentSSH()
{
	local __call_locality=( SASSH StartAgentSSH ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ; 
 local StrAgentEnvFile=${SASSHEvFile:=environment} ; 
 local IsHomeUser=${SASSHIsUserBasedHome:=True};
 local StrPathBase=${SASSHRootPathNoneUser:=/root} ; 
 local StrAgentPathFile=${SASSHPathStorage:=.ssh};
 local IntDefaultSSHEnvChmod=${SASSHDefaultChmod:=600} ;
 local IsSetSSHENV=${SASSHIsSetSSHENV:=False};
 local IsDeregSSHENV=${SASSHUnregisterSSHENV:=False};
 local StrChmodApps=${SASSHChmodApps:=/bin/chmod}
 local StrSSHAddApps=${SASSHSSHADDApp:=/usr/bin/ssh-add} ; 
 local StrSSHAddAppsOpt=${SASSHSSHADDOpt:=} ; 
 local StrSSHAgentApps=${SASSHSSHAgentApp:=/usr/bin/ssh-agent} ; 
 local StrSSHAgentAppsOpt=${SASSHSSHAgentOpt:=} ; 
 local StrProcMemory=${SASSHProcessLink:=/proc} ;
 local StrStartServicesName=${SASSHStartServices:=__main_StartServices} ;
 local StrStopServicesName=${SASSHStopServices:=__main_StopServices} ;
 
 
 ### Create StrPathSSH and if IsHomeUser==False, StrPathSSH will own
 ### the StrPathBase value (default set to /root )
 eval $( BVTestVarName="StrPathSSH" \
         BVTestVarHold=${HOME} \
         BVTestBoolVarName=\${IsHomeUser} \
         BVTestBoolAssertion=\${StrPathBase} \
         BoolVarTestVarCreation )
 
 ### Appending to StrPathSSH , the .ssh path.
 StrPathSSH=${StrPathSSH}/${StrAgentPathFile} 
 
 function __main_StopServices()
 {
		local __call_locality=( Stop __main_StopServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ;   
  echo -ne "\n\t\033[01;31mDe-Register SSH agent...\033[00m\n\n" ; 
  test -f ${StrPathSSH}/${StrAgentEnvFile} && rm -f ${StrPathSSH}/${StrAgentEnvFile} ; 
  if [ "${IsDeregSSHENV:=False}" == "True" ] ; then 
   echo -ne "\n\t\033[01;31mDe-Register SSH_ENV...\033[00m\n\n" ; 
   unset SSH_ENV ; 
  fi 
  local IntPidAgent=${SSH_AGENT_PID:=-1}
  if [ ${IntPidAgent} -ne -1 ] ; then 
   echo -ne "\n\t\033[01;31mKilling SSH-Agent on PID:${IntPidAgent}\033[00m\n\n" ; 
   sudo kill -11 ${IntPidAgent} ; 
   test ! -d ${StrProcMemory}/${IntPidAgent} && unset SSH_AGENT_PID
  fi 
 }
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
 
  if [ "${IsSetSSHENV:=False}" == "True" ] ; then 
   if [ "${IsDeregSSHENV:=False}" == "True" ] ; then 
    echo -ne "\n\tDe-Register SSH_ENV...\n\n" ; 
    unset SSH_ENV ; 
   else
    echo -ne "\n\tRegistering SSH_ENV to file : ${StrPathSSH}/${StrAgentEnvFile}\n\n" ; 
    export SSH_ENV=${StrPathSSH}/${StrAgentEnvFile} ; 
   fi 
  fi
  
  if [ "${IsSetSSHENV:=False}" == "False" ] ; then 
   echo -ne "\n\t\033[01;33mInitializing new SSH agent...\033[00m\n\n"
   test -f ${StrPathSSH}/${StrAgentEnvFile} && rm -f ${StrPathSSH}/${StrAgentEnvFile}
   echo -ne "\n\t\033[01;33mLoading ${StrSSHAgentApps}...\033[00m\n\n"
   eval ${StrSSHAgentApps} ${StrSSHAgentAppsOpt} | sed 's/^echo/#echo/' > "${SSH_ENV}"
   echo -ne "SSHAgent\t\t\t\t\033[01;32m[ succeeded ]\033[00m\n" ; 
   eval ${StrChmodApps} ${IntDefaultSSHEnvChmod} "${SSH_ENV}"
   . "${SSH_ENV}" > /dev/null
   echo -ne "\n\t\033[01;33mLoading ${StrSSHAddApps}...\033[00m\n\n"
   eval ${StrSSHAddApps} ;
  fi
 }
 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n" ;
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
 eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrAgentEnvFile,IsHomeUser,StrPathBase,StrAgentPathFile,IsSetSSHENV,IsDeregSSHENV,StrSSHAddApps,StrSSHAddAppsOpt,StrSSHAgentApps,StrSSHAgentAppsOpt \
  VTVIsValueReAssign=True    \
  VTVIsValueToConvert=False  \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) ${StrStopServicesName} ; 
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrAgentEnvFile,IsHomeUser,StrPathBase,StrAgentPathFile,IsSetSSHENV,IsDeregSSHENV,IntDefaultSSHEnvChmod,StrChmodApps,StrSSHAddApps,StrSSHAddAppsOpt,StrSSHAgentApps,StrSSHAgentAppsOpt,StrProcMemory \
  VTVIsValueReAssign=True    \
  VTVIsValueToConvert=False  \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) ${StrStartServicesName}
 fi
 unset __main_StopServices __main_StopServices ;
 ### Discover StartAgentSSH function did leave it's sub-function out and living.
 ### While StartAgentSSH did not own Brace after function declaration its better
 ### to unset internal function and/or rewriting 
 ### function StartAgentSSH
 ### into 
 ### function StartAgentSSH() 
 
}

function StubStartAgent()
{
	local __call_locality=( SSA StubStartAgent ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ; 
 
 local ArrayArg=( $* ) ;
 StartAgentSSH;
}

function SSHAgentMemoryInfo()
{
	local __call_locality=( SSHAMI SSHAgentMemoryInfo ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ; 
 
 ps -ef | grep ${SSH_AGENT_PID} | grep 'ssh-agent$' > /dev/null ;
}

function AgentLoader()
{
	local __call_locality=( AL AgentLoader ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;  
 local StrStartServicesName=${ALStartServices:=__main_StartServices} ;
 local StrStopServicesName=${ALStopServices:=__main_StopServices} ;
 
 
 function __main_StopServices()
 {
		local __call_locality=( Stop __main_StopServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ;  
  SASSHUnregisterSSHENV=True SASSHIsSetSSHENV=True StartAgentSSH --stopservices
 }
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  ### Create environment for SSH_ENV 
  SASSHIsSetSSHENV=True StartAgentSSH ; 
  
  # Source SSH settings, if applicable
  if [ -f "${SSH_ENV}" ]; then
    . "${SSH_ENV}" > /dev/null
    #ps ${SSH_AGENT_PID} doesn't work under cygwin
    SSHAgentMemoryInfo || { StartAgentSSH ; } ;
  else
    StartAgentSSH ;
  fi 
 }

 StrSwitchMessages="""${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n""" ; 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
  # __main_StopServices ; ### replaced 
  eval ${StrStopServicesName} ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  # __main_StartServices ; ### replaced
  eval ${StrStartServicesName} ; 
 fi

}

function GetGitHubKey()
{
 ### List of Key:
 ### GetGitHubKeyPassphraseHook
 ### GetGitHubKeyIndex
 ### GetGitHubKeyDecoder
 ### 
 ### --- > see Fnct_GetSSHKey.py from https://github.com/priendeau/Technical-PorteFolio/
 ### This will replace the function with safer storage thru sqlobject and sqlite backend
 ### it using the same Zenity interface with PyZenity . 

 local __call_locality=( GetGitHubKey ) 
 local ArrayArg=( $* ) ;
 local StrPassphraseHook=${GetGitHubKeyPassphraseHook:=${IntDefaultSSHKey}} ;
 local DefaultKeylevelExist=$( declare -i | egrep -c "${StrPassphraseHook}" ); 
 local SSHPassKey ; 
 local StrDecodeBase=${GetGitHubKeyDecoder:=base64 --decode}

 function LowLevelDecoder( )
 {
    local __call_locality=( LowLevelDecoder ) 
    local ArrayArg=( $* ) ;
    ${LowLevelDecoderCmd:=base64 --decode} ;
 }

 if [ ${DefaultKeylevelExist:=0} -eq 0 ] ; then 
    SSHPassKey=${GetGitHubKeyIndex:=0} ;
 else
    eval SSHPassKey=\${${StrPassphraseHook}} ;
 fi

 local DisplayKeyName=${ArrayGitHubKeyName[${SSHPassKey}]} ;
 local KeyOutput=$( echo ${ArrayGitHubKey[${SSHPassKey}]} | LowLevelDecoderCmd=${StrDecodeBase} LowLevelDecoder ) ; 
 echo -ne "Key from ${DisplayKeyName}:\n[${KeyOutput}]\n"  > /dev/stderr ; 
}

function GetKeyChoice()
{

### Pre Variable List 
### GetKeyChoiceDisplayKey                  -> ( True | False )
###  - Inhibit custom passphrase beign displayed on screen while 
###    invoking ssh-add . 
### GetKeyChoiceEval                        -> ( True | False )
###  - Creating extra line of shell used to add some update to your current 
###    shell once the Application end it's task. In this case updating var 
###    IntDefaultSSHKey to reflect current key selection. 
###    ( usefull when re-calling GetGitHubKey ) 
### GetKeyChoiceAppsKeyProvider             -> ( default : GetGitHubKey ) 
###    Is the application responsible to provide you the passphrase in case
###    you haven't noticed... Assuming your working on your sysetem and this 
###    one is not lethal to your life. 
###    Note : Involving this setting mean you have to call the Function like 
###    this to let it work : eval $( GetKeyChoiceEval=True GetKeyChoice ) 
###    next time By calling GetGitHubKey it will give you actual Passphrase. 
### GetKeyChoicePassphraseHook              -> ( default : IntDefaultSSHKey )
###    Allow GetGitHubKey to refer to this key to seek for actual Passphrase.
###
### !!! Paranoid Level !!!
###
### GetKeyChoiceDecoderLevel                -> ( default : base64 --decode)
###    Allow safer decoding but need your hand and may interfer with stdout and
###    stderr , using GetKeyChoiceEval may interfer and not working while asking
###    you to enter another passphrase like using :
###    openssl enc -d -cast5-cbc -k <PASSWORD> 
###     - This <PASSWORD> must be somewhere like on stdin ( on screen ) if you forget
###     option -k in openssl or using file as password holder, but it store the password 
###    on the .bash_history.... why it's paranoid level. 
### GetKeyChoiceStorageSuffix               -> ( default : GitHubKey )
###    Allow to Store Key, name of the key and corresponding key-file from Another
###    Array usually having ArrayGitHubKey, ArrayGitHubKeyName ArrayGitHubKeyFile
###    it using suffix GitHubKey see -> 
###         Array : Array[GitHubKey], Array[GitHubKey]Name Array[GitHubKey]File 
###     this can serve managing different Array of Key and may store other type of 
###    key, like passphrase for pem-file in apache like ... 
###
### !!! patented - talent !!! 
### AppsRootName                           -> ( default : GetKeyChoice )
###     Wrapping this Function another one you can call the application differently
###     by doing sed and evoluated reg-exp, like using python module and re. 
###     using declare -f GetKeyChoice give you the full body and may serve as template.
###     using AppsRootName prevent ovewriting of the new function in memory by avoiding
###     overwriting all already prefixed variable from this sedding or replacing action. 
###     It's a patented - talent ... << Sam on radio ; patented - talent ... 
###     Who know friend... >> ...


    local ArrayArg=( $* ) ;
    local __call_locality=( GetKeyChoice ) ;
    local StrPassphraseHook=${GetKeyChoicePassphraseHook:=IntDefaultSSHKey} ;
    local StrDecoder=${GetKeyChoiceDecoderLevel:=base64 --decode}
    local StrStoreSuffix=${GetKeyChoiceStorageSuffix:=GitHubKey} ;
    eval unset ${StrPassphraseHook} ; 
	function TransformArray()
	{
	    local ArrayArg=( $* ) ;
	    local __call_locality=( TransformArray ) ;
		local StrScopeType="declare -a" ;
		if [ "${TransformArrayScope:=local}" == "local" ] ; then 
			StrScopeType="local" ;
		fi
		if [ "${TransformArrayScope:=global}" == "local" ] ; then 
			StrScopeType="declare -a"

		fi 
		local StrSed="""'s/__SCOPE__ //g;s/^[a-zA-Z0-9\-\_]*=/__NEW_ARRAY__=/g'""" ;
		StrSed=${StrSed//__SCOPE__/${StrScopeType}}
		StrSed=${StrSed//__NEW_ARRAY__/${ArrayArg[0]}}
		StrSed=${StrSed//\ /\\\ } ;
		StrSed=${StrSed//\-/\\\-} ;
		echo -ne "Sed: sed ${StrSed}\n" > /dev/stderr ;
		local StrArrayTransform=$( ${StrScopeType} | egrep "${StrScopeType} ${ArrayArg[0]}"  | $( eval sed ${StrSed} )  ) 
		echo -ne """${TransformArrayDecl:=local} ${StrArrayTransform} ;"""  
	}
    function ZenityMenuKey()
    {
        ### List of Key:
        local ArrayArg=( $* ) ;
        local __call_locality=( ZenityMenuKey )
        zenity --width=300 --height=300 --list --radiolist --text="Choose your Key to add inside AgentLoader" --column "Selection" --column "Key Name" 
    }
    function ReduceTagInSed()
    {
        local ArrayArg=( $* ) ;
        local __call_locality=( ReduceTagInSed ) ;
        sed -e 's/\([\\\/\$\}\{a-z]\)//g;s/\(([A-Z0-9]*:)\)/\1;/g;s/[\)\(\}\{\}]//g' | cut -d ";" -f 1 ;
    }
    function ListKeyName()
    {
        ### List of Key:
        local ArrayArg=( $* ) ;
        local __call_locality=( ListKeyName ) ;
		eval $( TransformArrayDecl=local TransformArrayScope=global TransformArray Array${ListKeyNameStorageSuffix:=GitHubKey}Name _EArrayName ) 
		#eval "local _EArray=( \${Array${ListKeyNameStorageSuffix:=GitHubKey}Name[@]//\"/\\\"} ) ;" 
		for (( intx=0 ; intx <= ${#_EArrayName[@]}-1 ; intx++ )) ; do 
			echo -ne "FALSE\n${_EArray[${intx}]}\n" ; 
		done 
    }
    function ExchangeKeyPair( ) 
    {
        ### List of Key:
        local ArrayArg=( $* ) ;
        local __call_locality=( ExchangeKeyPair )       
        local PathSSH=${HOME}/.ssh ; 
        
        if [ "${USER}" == "root" ] ; then 
            PathSSH=/root/.ssh ;
        fi
        cp ${PathSSH}/${ArrayGitHubKeyFile[${KeyId}]} ${PathSSH}/id_rsa
        cp ${PathSSH}/${ArrayGitHubKeyFile[${KeyId}]}.pub ${PathSSH}/id_rsa.pub
        if [ "${IsDisplaySavedKey:=False}" == "True" ] ; then 
            echo -ne "Add this key inside the required field:\n" > /dev/stderr ;
            GetGitHubKeyDecoder=${StrDecoder} GetGitHubKeyIndex=${KeyId} ${GetKeyChoiceAppsKeyProvider:=GetGitHubKey} > /dev/stderr ;
        fi
        test -e ${PathSSH}/environment && rm -f ${PathSSH}/environment 
        ssh-add > /dev/stderr ;         
    }
    local IsDisplaySavedKey=${GetKeyChoiceDisplayKey:=True} ;
    local IsArrayCreated=$( declare -a | egrep -c "ArrayGitHubKey" ) ;
    local KeyName=$( ListKeyName | ZenityMenuKey ) ;

    if [ "${KeyName:=None}" != "None" ] ; then 
        echo -ne "Key Name selected: ${KeyName}\n" > /dev/stderr ; 
        local KeyId=None ;
        if [ ${IsArrayCreated:=0} -gt 0 ] ; then 
            if [ "${KeyName:=None}" != "None" ] ; then 
                for (( x=0 ; x <= ${#ArrayGitHubKeyName[@]}-1 ; x++ )) ; do 
                    local ItemKey="${ArrayGitHubKeyName[${x}]}" ;
                    if [ "${KeyName}" == "${ItemKey:=None}" ] ; then 
                        KeyId=${x} ;
                    fi
                done 
                KeyId=${KeyId} IsDisplaySavedKey=${IsDisplaySavedKey} ExchangeKeyPair

            fi    
        else
            echo -ne "Function ${__call_locality[0]} Need At least those Array being declared : \n" > /dev/stderr ; 
            echo -ne "ArrayGitHubKey To Hold The PassPhrase in base64 format ( with no wrap line.) \n" > /dev/stderr ; 
            echo -ne "ArrayGitHubKeyName To Hold The Zenity List Menu showing you wich key to use \n" > /dev/stderr ; 
            echo -ne "ArrayGitHubKeyFile to hold file inside ${HOME} or .ssh path from user ${USER} to copy both KEYNAME-id_rsa KEYNAME-id_rsa.pub into id_rsa and id_rsa.pub \n" > /dev/stderr ; 
            echo -ne "Being Afraid to display a passphrase on the screen, set this function has GetKeyChoiceDisplayKey=False GetKeyChoice on prompt or your .bashrc to prevent to be display.\n" > /dev/stderr ; 
        fi
    else
        echo -ne "User Cancel the Action.\n" > /dev/stderr
    fi 
    if [ "${GetKeyChoiceEval:=False}" == "True" ] ; then 
        echo -ne "declare -i ${StrPassphraseHook}=\"${KeyId}\"\n" ;
    fi 
}
### An example of what to add inside your /root/.bashrc 
### 
### declare -a ArrayGitHubKey=( Tm9uZQo= Tm9uZQo= Tm9uZQo= ) ; -> Assuming both 3 passphrase are : "None", "None" and "None".
### declare -a ArrayGitHubKeyName=( "None" "GitHub Key" "PyPi SSH Key" ) ;
### declare -a ArrayGitHubKeyFile=( None github-id_rsa pypi-id_rsa ) ;
### 
### Using GetKeyChoice will display you all 3 choice and ( cancel button is not yet designe, but None choice work )
### 
### 


### yet Another Password generator.
unset GetPasswd ;
function GetPasswd()    
{ 
 local ArrayArg=( $* ) ; 
 local __call_locality=( GP GetPasswd ) ; 
 local Arg0=${ArrayArg[0]} ; 
 
 local IntDefaultPwdSize=${GPSize:=16} ;
 local IntDefaultFactor=${GPFactor:=1000} ; 
 local IntRandomSeedFactor=${GPRandomSeed:=10} ; 
 local StrPasswordTypeForm=${GPArgType:=cnsB1,cysB1,cnsyB1} ; 
 local IntPasswordType=${GPGenFormType:=0} ;
 
 local StrAppsPwdGenerator=${GPAppsGen:=pwgen} ;
 local BoolEvalCmdExit=${GPShowCmdEvalAndExit:=False} ; 

 unset __Loop ;
 function __Loop( )
 {
		local __call_locality=( _L __Loop  ) ;
		local ArrayArg=( $* ) ; 
		local Arg0=${ArrayArg[0]} ;
  local x=0; 
		echo -ne "Crunching for a factor of ${factor} password.\n" > /dev/stderr  ; 
  local value ; 
  while [ ${x} -ne ${factor} ] ; do 
   value=$( ${StrAppsPwdGenerator} ${StrPwGenFormPassword} ${IntDefaultPwdSize} );
			let x=$x+1 ; 
		done ; 
  echo -ne "\npasswd:[${value}]\n\n" > /dev/stderr  ; 
 }
 
 unset __Display ;
 function __Display()
 {
		local __call_locality=( _D __Display  ) ;
		local ArrayArg=( $* ) ; 
		local Arg0=${ArrayArg[0]} ;
  eval "local value=\"${StrAppsPwdGenerator} ${StrPwGenFormPassword} ${IntDefaultPwdSize}\"" ;
  echo -ne "\nCMD Eval:[ ${value} ]\n" > /dev/stderr ; 
  
 }
 unset __main_StartServices ;
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local ArrayArg=( $* ) ; 
		local Arg0=${ArrayArg[0]} ;
  local ArrayFormPassword=( ${StrPasswordTypeForm//,/ } ) ;
  local StrPwGenFormPassword=-${ArrayFormPassword[${IntPasswordType}]} ;
		local end=${IntDefaultFactor} ; 
		local factor=$(( ${end} * $(( ( ${RANDOM} % ${IntRandomSeedFactor} ) + 1 )) )) ; 
		
		local value="" ;
  ### 
  ### Password Line execution ( needed both in display and Loop command. )
  ### 
  local StrCmdPwdEval="""StrAppsPwdGenerator=${StrAppsPwdGenerator} StrPwGenFormPassword=${StrPwGenFormPassword} IntDefaultPwdSize=${IntDefaultPwdSize}""" ; 
  local StrLoopCmd="""${StrCmdPwdEval} factor=\${factor}""" ; 
  local StrDisplayCmd="""${StrCmdPwdEval}""" ; 
  
  #local IfCmd="BVTestVarName='StrFuncExec' BVTestVarHold='\$( StrCmdEval=\${StrCmdEval} factor=\${factor} __Loop )' BVTestBoolVarName='\${BoolEvalCmdExit}' BVTestBoolCase=True BVTestBoolAssertion='StrCmdEval=\${StrCmdEval} __Display' BVTestScopeTest=local BoolVarTestVarCreation "
  eval $( BVTestVarName='StrFuncExec'          \
  BVTestVarHold="${StrDisplayCmd} __Display"   \
  BVTestBoolVarName='${BoolEvalCmdExit}'       \
  BVTestBoolCase=False                         \
  BVTestBoolAssertion="${StrLoopCmd} __Loop" \
  BVTestScopeTest=local BoolVarTestVarCreation  ) ;
  
  eval $( BVTestVarName='StrFuncIsLoop'          \
  BVTestVarHold="$( eval ${StrFuncExec} )"   \
  BVTestBoolVarName='${BoolEvalCmdExit}'       \
  BVTestBoolCase=True                         \
  BVTestBoolAssertion="" \
  BVTestScopeTest=local BoolVarTestVarCreation  ) ;
  
		  
 }

 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  IntDefaultPwdSize=${IntDefaultPwdSize}       \
  IntDefaultFactor=${IntDefaultFactor}         \
  IntRandomSeedFactor=${IntRandomSeedFactor}   \
  IntPasswordType=${IntPasswordType}           \
  StrPwGenFormPassword=${StrPwGenFormPassword} \
  StrPasswordTypeForm=${StrPasswordTypeForm}   \
  StrAppsPwdGenerator=${StrAppsPwdGenerator}   \
  __main_StartServices ;
 fi	 
 

}

###     Not Needed anymore, see GetKeyChoice for a clever choice... Must be with XWindows or any Kde, gtk, gnome, Mate interface. 
#if [ -e "${HOME}/.ssh/environment" ] ; then 
# AgentLoader ;
#fi 

