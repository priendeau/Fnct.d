#!/bin/bash

### Package : _sub_Structure

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
if [ "${SubStructureExtVerb:=False}" == "True" ] ; then 
  function Verbosis()
  {
   local -a ArrayArg=( $* ) ; 
   local -a __call_locality=( Verb Verbosis )
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
        echo "${StrMsg}" ;  
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo "${StrMsg}" >> ${StrDevOut} ;
      else
       echo "${StrMsg}" > ${StrDevOut} ;
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis

fi ### End-of if-SubStructureExtVerb == [True/False]

### ValueToVariable
### Was moved into chunk to control version, another version without uses 
### of sed and less as possible of BoolVarTest and/or BoolVarTestVarCreation. 
### To call this version you will need to pass on command line 
### versionVTV=0.0.1 like :
### versionVTV=0.0.1 . /etc/init.d/Fnct.D/fnct_debian_lib

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
if [ "${versionVTV:=0.0.2}" == "0.0.1" ] ; then 
  unset ValueToVariable ; 
  . /etc/init.d/Fnct.D/482e0e5a-763b-11e6-8b1d-001e4c8856d6
fi ### End-of if-versionVTV == 0.0.1 .
### 

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
if [ "${versionGVR:=0.0.2}" == "0.0.2" ] ; then 
  ### GetVarReference
  unset GetVarReference
  . ${FNCTDLIBPATH}/6403c722-28a6-11e3-98a2-001b3875b29c
fi ### End-of if-versionGVR == 0.0.2 .

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
if [ "${versionGVRL:=0.0.2}" == "0.0.2" ] ; then 
  unset __GetVarReferenceList ;
  function __GetVarReferenceList( )
  {
    #local -a __call_locality=( __GVRL __GetVarReferenceList ) ;
    #local -a ArrayArg=( $* ) ; 
    #local Arg0="${ArrayArg[0]}" ;  
    local IsZenityBuildForm=${BuildForm:=False} ;
    ### Prefixed-Variable __GLRLAppsGuiBuilder is reserved for 
    ### user creating a better Gui-Builder than existing one 
    ### to form execution statement fo Bash ...
    local StrAppsGuiForm=${__GVRLAppsGuiBuilder:=ZenityBuildForm} ; 
    ### Exception to StrVariableList and uses of eval in this case, 
    ### it should require extra wrapup of an Evaluative Executive Brace, but using 
    ### an echo does replace it. Notice it's the cheating way to get rid of 
    ### back-slashing the quote, back-slashing the dollar-sign, back-slashing  the any
    ### 'compromized chars ', but it cost uses of echo, an application /bin/echo
    ### where is may cost cpu-cycle if it's in a loop, executed recurrently or
    ### managed of owner execution like sudo application "chown +S/bin/echo", we can
    ### be in big trouble...  
    local StrVariableList=$( echo """eval BuildForm=False  ${__call_locality[1]} --help 2> /dev/null | egrep -i \"^Variable ${__call_locality[0]}\" | cut -d ' ' -f 2 | tr '[:cntrl:]' ' '""" ) ; 
    local StrBuildFormResult ;
    if [ ${IsZenityBuildForm:=False} == "True" ] ; then 
     StrBuildFormResult=$( """{ ZBFFunctionName=${__call_locality[1]} ZenityBuildForm ; }""" ) ; 
     #eval $( eval """\\${__call_locality[1]} \\${StrAppsGuiForm} """ ) ; 
     #eval echo $( """echo -ne \"Function: ${__call_locality[1]} \" """ ) ;
     ### ; __GVRLVariableList="${StrVariableList// /,}" ZBFFunctionName=${__call_locality[1]} ${StrAppsGuiForm} ;""" ) ;   
    else
     echo "${StrVariableList}" ; 
    fi
    
  }
fi ### End-of if-versionGVRL == 0.0.2 .

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
if [ "${versionGVRCW:=0.0.2}" == "0.0.2" ] ; then 
  ### __GetVarReferenceCompWord
  unset __GetVarReferenceCompWord ; 
  . ${FNCTDLIBPATH}/023102e0-1833-11e3-98a2-001b3875b29c
  ### This is first pragma. BodyFunc Should manage it.
fi ### End-of if-versionGVRCW == 0.0.2 .

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
if [ "${versionGSPN:=0.0.2}" == "0.0.2" ] ; then 
  ### GetStdPrefixName 
  unset GetStdPrefixName ; 
  . ${FNCTDLIBPATH}/131cb830-8cd7-11e6-8b1d-001e4c8856d6
fi ### End-of if-versionGSPN == 0.0.2 .

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
if [ "${versionGSPN:=0.0.2}" == "0.0.1" ] ; then 
  ### GetStdPrefixName 
  unset GetStdPrefixName ; 
  . ${FNCTDLIBPATH}/69968204-0cf6-11e3-99bc-001b3875b29c
fi ### End-of if-versionGSPN == 0.0.1 .

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
if [ "${versionCA:=0.0.0}" == "0.0.0" ] ; then 
  echo -ne "\n\033[01;33m**************************************************\n\033[01;43mNo CallArgument / __Call_Argument in version 0.0.0\n\033[00m\033[01;33m**************************************************\033[00m\n" ; 
fi ### End-of if-versionYY == 0.0.X .

 
###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
if [ "${versionCA:=0.0.0}" == "0.0.2" ] ; then 
  #unset CallArgument ; 
  eval $( GFCFuncName=CallArgument GlobalFunctionCleaning ) ; 
  function CallArgument()
  {
    ### section : Function Signature
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( CA CallArgument ) ;
    local Arg0="${ArrayArg[0]}";
    local StrStartMain=${CAFuncStart:=__main_StartServices} ; 
    
    ### section : Variable uses
    local StrFuncName=${CAFunctName:=None} ; 
    local StrScope=${CACodeScope:=local} ;
    local BoolUsingSed=${CAUsingSedTrim:=True} ; 
    local BoolAddParent=${CAIsAddParent:=False} ; 
    local BoolChildBoot=${CAIsChildBoot:=True} ; 
    local BoolAddDebug=${CAIsAddDebug:=False} ; 
    local BoolAddInt=${CAIsAddInt:=False} ; 
    local BoolAddStr=${CAIsAddStr:=False} ; 
    local StrDebugList=${CAProvideDebug:=DisplayDebug,DisplayEntry,DisplayCmd,DisplayParserNotice}
    local StrIntList=${CAProvideInt:=VarA,VarA,VarA,VarA,Width,Height} ;
    local StrStrList=${CAProvideStr:=Title,Text,Span,Col1,Col2} ;
    local StrVarTpl="__SCOPE__ __0____VAR__=\${__SHORTNAME____1____VAR__:=__TYPE_BASED__}" ; 
    local StrBoolSet=${CABoolSetName:=Bool,Is} ;
    local StrIntSet=${CAIntSetName:="Int,''"} ;
    local StrStrSet=${CAStrSetName:="Str,''"} ;
    local StrVarList="StrVarList,StrFuncName,StrScope,StrStartMain,BoolChildBoot,BoolAddParent,BoolUsingSed,StrDebugList,StrIntList,StrStrList,StrVarTpl,BoolAddDebug,BoolAddInt,BoolAddStr,StrBoolSet,StrIntSet,StrStrSet" ; 


     
    function VarGenerator()
    {
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( VG VarGenerator ) ;
     local Arg0="${ArrayArg[0]}";
     
     local StrDebugList=${VGVarList:=Var1,Var2,Var3} ; 
     local StrVarSetDef=${VGVarSet:=Bool,Is} ; 
     local StrDefaulVarTpl=${VGVarTpl:="__0____VAR__=__SHORTNAME____1____VAR__"} ;  
     local StrDefaultValue=${VGVarValue:=None} ; 
     
     #echo -ne "\nDefault Value:[${StrDefaultValue}]\n" > /dev/stderr ; 
     #echo -ne "\nArrayVarExpression:[${StrVarSetDef}]\n" > /dev/stderr ; 
     local ArrayVarExpression=( ${StrVarSetDef//,/ } ) ;
     local ArrayDebugList=( ${StrDebugList//,/ } ) ;
     local StrAddCode ;
     local StrNewVarName ;
     local StrDbgVarParse ; 
     for (( intx=0 ; intx <= ${#ArrayDebugList[@]}-1 ; intx++ )) ; do
      StrNewVarName=${ArrayDebugList[${intx}]} ; 
      StrDbgVarParse=${StrDefaulVarTpl//__VAR__/${StrNewVarName}}
      StrAddCode="${StrAddCode} ; ${StrDbgVarParse}" ; 
      #if [ ${intx} -lt $(( ${#ArrayDebugList[@]}-1 )) ] ; then 
      # StrAddCode="${StrAddCode}" ; 
      #fi 
     done
     ### Affecting default Value.
     StrAddCode=${StrAddCode//__TYPE_BASED__/${StrDefaultValue}} ; 
     for(( intx=0; intx <= ${#ArrayVarExpression[@]} ; intx++ )) ; do 
      StrValueExpr=${ArrayVarExpression[${intx}]} ;
      if [ "${StrValueExpr:=''}" == "''" ] ; then 
       StrAddCode=${StrAddCode//__${intx}__/} ; 
      else
       StrAddCode=${StrAddCode//__${intx}__/${ArrayVarExpression[${intx}]}} ; 
      fi
     done 
     echo "${StrAddCode}" ;  
    }
    
    function __main_StartServices()
    {
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( Main __main_StartServices ) ;
     local Arg0="${ArrayArg[0]}";
     local StrShortName ; 
     if [ "${StrFuncName:=__main_StartServices}" == "__main_StartServices" ] ; then 
      StrShortName="Main"
     elif [ "${StrFuncName:=__main_StartServices}" == "__main_StopServices" ] ; then 
      StrShortName="Main"
     else
      StrShortName=$( GetStdPrefixName ${StrFuncName} ) ;
     fi 
     local StrBootStrap="__SCOPE__ StrStartMain=\${__SHORTNAME__FuncStart:=__main_StartServices} " ; 
     local StrArgumentCode="""__SCOPE__ ArrayArg=( \$* ) ; __SCOPE__  __call_locality=( __SHORTNAME__ __LONGNAME__ __PARENT_NAME__ ) ; __SCOPE__ Arg0=\${ArrayArg[0]} ; __SCOPE__ StrParentApps=\${__call_locality[1]} __BOOT_STRAP__ __DEBUG__ __ADD_INT__ __ADD_STR__""" ; 
     
     ### 
     ### Section Adding Debug Variable after specifying 
     ### CAIsDebugVar=True 
     ### CAProvideDebug=DisplayDebug,DisplayEntry,DisplayCmd ... 
     ### 

     local ArrayTagAdd=( BoolAddDebug,StrDebugList,StrBoolSet,__DEBUG__,False BoolAddInt,StrIntList,StrIntSet,__ADD_INT__,0 BoolAddStr,StrStrList,StrStrSet,__ADD_STR__,None ) ;
     local StrDebugTpl ; 
     local ArrayCurrGrp ; 
     local StrDebugStatement ; 
     local BoolCurrCond ; 
     local StrCurrLst ;
     local StrCurrSetVar ; 
     local StrTypeBasedValue ;
     for (( intGrpVarTag=0 ; intGrpVarTag <= ${#ArrayTagAdd[@]}-1  ; intGrpVarTag++ )); do 
      ArrayCurrGrp=( ${ArrayTagAdd[${intGrpVarTag}]//,/ } )
      eval BoolCurrCond="\${${ArrayCurrGrp[0]}}" ;
      eval StrCurrLst="\${${ArrayCurrGrp[1]}}" ; 
      eval StrCurrSetVar="\${${ArrayCurrGrp[2]}}" ;
      StrDebugTpl="${ArrayCurrGrp[3]}" ; 
      StrTypeBasedValue="${ArrayCurrGrp[4]}" ; 
      StrDebugStatement=${StrDebugTpl//;/} ; 
       
      if [ "${BoolCurrCond:=False}" == "False" ] ; then 
       StrArgumentCode=${StrArgumentCode//${StrDebugTpl}/} ; 
      else
       local StrDebugAddVar=$( VGVarTpl=${StrVarTpl}        \
                               VGVarList=${StrCurrLst}      \
                               VGVarSet="${StrCurrSetVar}"  \
                               VGVarValue="${StrTypeBasedValue}" \
                               VarGenerator ); 
       StrArgumentCode="${StrArgumentCode//${StrDebugStatement}/${StrDebugAddVar}}" ; 
      fi
     done 
    
     if [ "${BoolChildBoot:=False}" == "False" ] ; then 
      StrArgumentCode=${StrArgumentCode/__BOOT_STRAP__/} ; 
     else
      ### require to re-filter the __BOOT_STRAP__ when BoolAddParent==True
      ### and should remove the __BOOT_STRAP__
      if [ "${BoolAddParent:=False}" == "True" ] ; then 
       echo -ne "Addressed to function/sub-function ${StrFuncName}, Bad Signature.\n\tImpossible to allow implementation of Boot-signature under a sub-function structure.\nPlease review your prefixed-parameter to CAIsChildBoot=False when CAIsAddParent is set to True.\n" > /dev/stderr ; 
       StrArgumentCode=${StrArgumentCode/__BOOT_STRAP__/} ; 
       ### This situation should also remove about any trace of __PARENT__
       ### for supplying excessively information which are not working
       ### all-toghether. 
       StrArgumentCode=${StrArgumentCode//__PARENT_NAME__/} ;
      else
       StrArgumentCode=${StrArgumentCode/__BOOT_STRAP__/;${StrBootStrap}} ; 
      fi 
      
     fi 
     ### Notice on CAIsAddParent=True
     ### - usually, if it require to add a parent-name inside the the 
     ### Cal-argument, it mean there is already a top-function which this
     ### one is accessible and should provide a [SHORT-NAME]FunctStart=...
     ### and is barely not-accessible to recursively add another boot-access
     ### from sub-function and SHALL restrict to not provide a boot-acces. 
     ### And this is why it should remove information about pass-throught
     ### if we imply addinf a parent information inside the CallArgument. 
     ### 
     if [ "${BoolAddParent:=False}" == "True" ] ; then 
      ### This section should forbid the uses of an
      ### boot-access due to it's impossibility to access from 
      ### prompt... And should remove information about 
      ### __BOOT_STRAP__
      StrArgumentCode=${StrArgumentCode/__BOOT_STRAP__/} ; 
      StrArgumentCode=${StrArgumentCode//__PARENT_NAME__/\$\{StrParentApps\}} ; 
     else
      StrArgumentCode=${StrArgumentCode//__PARENT_NAME__/} ;
     fi

     StrArgumentCode=${StrArgumentCode//__SCOPE__/${StrScope}} ;
     StrArgumentCode=${StrArgumentCode//__PREFIX__/${StrPrefixVar}} ;
     StrArgumentCode=${StrArgumentCode//__SHORTNAME__/${StrShortName}} ;
     StrArgumentCode=${StrArgumentCode//__LONGNAME__/${StrFuncName}} ;
     
     if [ "${BoolUsingSed:=True}" == "False" ] ; then 
       StrArgumentCode=$( echo "${StrArgumentCode}" | /usr/bin/tr '[:cntrl:]' ' ' ) ; 
     else
       StrArgumentCode=$( echo "${StrArgumentCode}" | /bin/sed 's/\n/\\n/g;s/\r/\\r/g' ) ; 
     fi
     echo "${StrArgumentCode}" ; 
     
    }
    ### section : helper
    local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
    local StrNameHelper="\n\t\tStand for Meta-Function of Fnct.D";
    local StrSynopsis="${__call_locality[1]} in replacement of some step to code appropriate\n\t« Fnct.D » compliant function to talk and communicate  with other entity\n\tis a 'Procedure-ready'  to apply to a top-function and Prefixed-Variable \n\tcan  only add  Layer of information to help the function to grow in\n\tdiversity  of Fnct.D  method helping to  develop with less  code.\n";
    local StrSummary="This Meta-Function CallArgument is a mechanism describe\n\tin README.rst to inform function from it's name, it's Short-name and\n\tpresence of parent or in which function the sub-function is part of.\n\tThis Meta-Function generate important code and replace state-of-the-art\n\tdeclaration of __call_locality, StrParentApps, and also define the\n\tBootStrap name in top-function. Allowing to Create your Variable name\n\tauto-transited  to  Prefixed-Name,  make  it easy  ( after version\n\t0.0.2 ), since  uses of  Prefixed-variable  ( CAIsAddDebug, CAIsAddInt,\n\tCAIsAddStr ), and it's variable partner ( CAProvideDebug, CAProvideInt,\n\tCAProvideStr )  receiving in  CSV format  your  Variable and will be\n\tparsed to  Fnct.D  variable creation  algorithm.  Using it's definition\n\ttransition [CA{Bool,Int,Str}SetName] let  you change the Fnct.D Based\n\tPolished notation  and afford you a free hand in this design.  Back to\n\tBootstrap is a procedure handled by --start-services allow to start the\n\tMain function or  other subfunction if they are equiped of\n\tSecond-Role-Function.  Second-Role-Function  are  some functionality\n\tembedded inside a function called by the bootstrap process to give a\n\tsecond action call  from your  top-function.  Finally, MRU will be\n\timplemented from  here CallArgument,  where it's the function entry,\n\tand it's excellent location to start-reading from your command line\n\toption and Prefixed-Variable fixed to your Environment and make a entry\n\tto scan for your last command call from this function and will find-out\n\tlast similar componnent. Where MRU stand for « Most Recent Unit », it\n\tmade possible for function that do generate a constant output from\n\tbased command will always returning the same result.\n" ;
    #local StrSummary="This Meta-Function CallArgument" ; 
    local StrDescription="This section contain Detailed information for __FUNCT__" ;


    
    ### section : block if-switches
    if [ "${Arg0:=--startservices}" == "--help"	] ; then 
     GVRIsName=True \
     GVRIsSynopsis=True \
     GVRIsSummary=True \
     GVRIsDesc=True \
     GetVarReference ${__call_locality[1]} ; 
     echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
    elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
     eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
     echo -ne """${ArgGet}\n""" ;
    elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
     eval $( __GetVarReferenceList ) ;	
    elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
     eval $( VTVIsArrayStyleInsert=True \
          VTVValueEntry=${StrVarList}   \
          VTVIsValueReAssign=True       \
          VTVIsQuotedValue=True         \
          VTVIsValueToConvert=False     \
          VTVIsArrayStyleInsert=True    \
          ValueToVariable ) ${StrStartMain} ; 
    fi

  }
fi ### End-of if-versionCA == 0.0.2 .

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
if [ "${versionCA:=0.0.0}" == "0.0.1" ] ; then 
  ### A prototype to avoid declaring in wrong order the
  ### Arg0 and ArrayArg ... 
  ### It will create the appropriate code in correct order 
  ### to ensure Argument will be callable .
  eval $( GFCFuncName=__Call_Argument GlobalFunctionCleaning ) ; 
  #unset __Call_Argument ; 
  function __Call_Argument()
  {
    local -a __call_locality=( CA __Call_Argument ) ;
    local -a ArrayArg=( $* ) ;
    local Arg0="${ArrayArg[0]}";
    
    local StrFuncName=${CAFunctName:=None} ; 
    local StrScope=${CACodeScope:=local} ;
    local BoolUsingSed=${CAUsingSedTrim:=True} ; 
    local BoolAddParent=${CAIsAddParent:=False} ; 
    local BoolChildBoot=${CAIsChildBoot:=False} ; 
    local StrStartMain=${CAFuncStart:=__main_StartServices} ; 
    local StrShortName ; 
    local StrVarList="StrVarList,StrFuncName,StrScope,StrStartMain,StrShortName,BoolChildBoot,BoolAddParent,BoolUsingSed" ; 
    
    function __main_StartServices()
    {
     local -a __call_locality=( Main __main_StartServices ) ;
     local -a ArrayArg=( $* ) ;
     local Arg0="${ArrayArg[0]}";
     if [ "${StrFuncName:=__main_StartServices}" == "__main_StartServices" ] ; then 
      StrShortName="Main"
     elif [ "${StrFuncName:=__main_StartServices}" == "__main_StopServices" ] ; then 
      StrShortName="Main"
     else
      StrShortName=$( GetStdPrefixName ${StrFuncName} ) ;
     fi 
     local StrBootStrap="__SCOPE__ StrStartMain=\${__SHORTNAME__FuncStart:=__main_StartServices} ;" ; 
     local StrArgumentCode="""
     __SCOPE__ ArrayArg=( \$* ) ;
     __SCOPE__ __call_locality=( __SHORTNAME__ __LONGNAME__ __PARENT_NAME__ ) ;
     __SCOPE__ Arg0=\${ArrayArg[0]} ;
     __SCOPE__ StrParentApps=\${__call_locality[1]} ;
     __BOOT_STRAP__""" ; 
     if [ "${BoolAddParent:=False}" == "True" ] ; then 
      StrArgumentCode=${StrArgumentCode//__PARENT_NAME__/\$\{StrParentApps\}} ; 
      if [ "${BoolChildBoot:=False}" == "False" ] ; then 
       StrArgumentCode=${StrArgumentCode/__BOOT_STRAP__/} ; 
      fi 
     else
      StrArgumentCode=${StrArgumentCode//__PARENT_NAME__/} ;
     fi
     StrArgumentCode=${StrArgumentCode/__BOOT_STRAP__/${StrBootStrap}} ; 
     StrArgumentCode=${StrArgumentCode//__SCOPE__/${StrScope}} ;
     StrArgumentCode=${StrArgumentCode//__PREFIX__/${StrPrefixVar}} ;
     StrArgumentCode=${StrArgumentCode//__SHORTNAME__/${StrShortName}} ;
     StrArgumentCode=${StrArgumentCode//__LONGNAME__/${StrFuncName}} ;
     
     if [ "${BoolUsingSed:=True}" == "False" ] ; then 
       StrArgumentCode=$( echo "${StrArgumentCode}" | /usr/bin/tr '[:cntrl:]' ' ' ) ; 
     else
       StrArgumentCode=$( echo "${StrArgumentCode}" | /bin/sed 's/\n/\\n/g;s/\r/\\r/g' ) ; 
     fi
     echo ${StrArgumentCode} ; 
     
    }

    local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
    local StrNameHelper="Stand for Meta-Function of Fnct.D";
    local StrSynopsis="${__call_locality[1]} in replacement of some step to code appropriate Fnct.D compliant function to talk and communicate with other entity is a Procedure-ready to apply to a top-function and Prefixed-Variable can only add Layer of information to help the function to grow in diversity of Fnct.D method helping to develop with less code.";
    local StrSummary="This Meta-Function __Call_Argument is a mechanism describe in README.rst to inform function from it's name, it's Short-name and presence of parent or in which function the sub-function is part of. This Meta-Function generate important code and replace state-of-the-art declaration of __call_locality, StrParentApps, and also define the BootStrap name in top-function. Bootstrap is a procedure handled by --start-services allow to start the Main function or other subfunction if they are equiped of Second-Role-Function. Second-Role-Function are some functionality embedded inside a function called by the bootstrap process to give a second action call from your top-function. " ; 
    local StrDescription="This section contain Detailed information for __FUNCT__" ;
    
    if [ "${Arg0:=--startservices}" == "--help"	] ; then 
     GVRIsName=True GVRIsSynopsis=True GVRIsSummary=True GVRIsDesc=False GetVarReference ${__call_locality[1]} ; 
     echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
    elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
     eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
     echo -ne """${ArgGet}\n""" ;
    elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
     eval $( __GetVarReferenceList ) ;	
    elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
     eval $( VTVIsArrayStyleInsert=True \
          VTVValueEntry=${StrVarList}   \
          VTVIsValueReAssign=True       \
          VTVIsValueToConvert=False     \
          VTVIsArrayStyleInsert=True    \
          ValueToVariable ) ${StrStartMain} ; 
    fi

  }
fi ### End-of if-versionCA == 0.0.1 .

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
if [ "${versionGOD:=0.0.1}" == "0.0.1" ] ; then 

  ### GetOtherDate :
  ###
  ###
  ###	Full-length example : 
  ### Including Loop to create different day pattern
  ###
  ### hint:
  ### - Having to check 1 day before and 1 day after need to combine 
  ### settign GODReferenceFormat="__INT__ day" , and not "__INT__ day ago", give you positive forward in time
  ### setting GODIsLoop=True 
  ### setting GODLoop=-1,1 ( tricky but work ) , create interleave between -1 to 1, so it's -1 day in futur, 0 day in futur and 1 day in futur... 
  
  ### GODReferenceFormat="__INT__ day ago"  GODFormat="%Y%m%d" GODIsLoop=True GODLoop=1,4 GODVerbose=True  GetOtherDate
  ### Will display :
  ### 
  ### 20121010
  ### 20121011
  ### 20121012
  ###
  ### Short example :
  ### GetOtherDate
  ###
  ### Will display :
  ###
  ### 20121011
  ###
  ### GODReferenceFormat="__INT__ day ago"
  ###
  ###

  eval $( GFCFuncName=GetOtherDate GlobalFunctionCleaning ) ; 

  #unset GetOtherDate ;
  #unset Verbosis DateFunc ; 
  function GetOtherDate()
  {
    local -a ArrayArg=( $* ) ; 
    local -a __call_locality=( GOD GetOtherDate );
    local Arg0="${ArrayArg[0]}"; 
    local StrDateUnitPattern=${GODDateUnitPatrn:=__DATEUNIT__};
    local StrDateUnitReference=${GODDateUnit:="day"};
    local StrDateFormat=${GODFormat:=%Y%m%d} ;
    local StrDateIndicatorFormat=${GODReferenceFormat:=__INT__ ${StrDateUnitPattern}};
    local IntDayDiff=${GODReference:=0} ; 
    local StrDateApps=${GODMainApp:=/bin/date} ; 
    local isLoop=${GODIsLoop:=False} ;
    local LoopRange=${GODLoop:=0,3} ;
    local IsVerbose=${GODVerbose:=False} ;
    local StrNameHelper="A way to get a date already marshalled" 
    
      
    function Verbosis()
    {
     local -a ArrayArg=( $* ) ; 
     local -a __call_locality=( Verbosis Verbosis );
     local StrMsg=${VerbosisMsg:=__TEXT__} ; 
     local StrDevOut=${VerbosisDev:=/dev/stderr} ; 
     if [ "${VerboseState:=False}" == "True" ] ; then 
      echo -ne "VERBOSE:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
     
    }
    
    
    ### Example, must supplied a date from N and start counting from 
    ### date --date='20000101 00:00:00' +"%StrDateFormat"
    ### where StrDateFormat = Y%m%d %s %s 
    
    function DateFunc()
    {
     local -a ArrayArg=( $* ) ; 
     local -a __call_locality=( DateFunc DateFunc ) ;
     local StrEval="""${DateFuncApp} +"${DateFuncFormat:=%Y%m%d}" -d '${DateFuncIndicator}'""" ; 
     if [ "${DateFuncVerbose:=False}" == "True" ] ; then 
      VerbosisMsg=${StrEval} VerboseState=${IsVerbose} Verbosis ;
     fi 
     eval ${StrEval}
    }
    
    ### First Step, applying Incremental Unit to application Date:
    local StrDateIndicator=${StrDateIndicatorFormat} ;
    StrDateIndicator=${StrDateIndicator/${StrDateUnitPattern}/${StrDateUnitReference}} ;
    if [ "${isLoop:=False}" == "False" ] ; then 
     StrDateIndicator=${StrDateIndicator/__INT__/${IntDayDiff:=0}} 
    fi
    ### Temporary debug removed after found the bug.
    ### local StrDbg="Content of StrDateIndicator: [${StrDateIndicator}]\nContent of StrDateUnitReference: [${StrDateUnitReference}]" ; 
    ### VerbosisMsg=${StrDbg} VerboseState=${IsVerbose} Verbosis ;
     
    #local StrDateIndicator=${StrDateIndicatorFormat/__INT__/${IntDayDiff:=0}}  ;
    #StrDateIndicator=${StrDateIndicator/${StrDateUnitPattern}/${StrDateUnitReference}} ;
    
    local -a ArrayRange=( ${LoopRange/,/ } ) ;
    local OperRange="<=" ;  
    local OperRangeIn="Intx++" ;
    local OperBaseStart=${ArrayRange[0]} ;
    local IntEndLoop=$(( ${ArrayRange[$((${#ArrayRange[@]}-1))]} ));
    

    #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
    local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
    
    if [ "${Arg0:=--start}" == "--help" ] ; then 
     GVRIsName=True StrNameHelper=${StrNameHelper} GetVarReference ${__call_locality[1]} ; 
     echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
    elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
     eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
     echo -ne """${ArgGet}\n""" ; 			
    elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
     eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
    else	 
     if [ "${isLoop:=False}" == "True" ] ; then 
      local StrDebugMsg="ArrayRange, nb-element:${#ArrayRange[@]}, hold [ ${ArrayRange[@]} ]\n" ;
      VerbosisMsg=${StrDebugMsg} VerboseState=${IsVerbose} Verbosis  ;
      if (( ${ArrayRange[0]} > ${IntEndLoop} )) ; then 
       OperRange=">=" ;
       OperRangeIn="Intx--" ; 
       OperBaseStart=${ArrayRange[$((${#ArrayRange[@]-1))}]} ;
      fi		
      local StrDebugMsg="Looping from ${OperBaseStart} to ${IntEndLoop} \n" ;
      VerbosisMsg=${StrDebugMsg} VerboseState=${IsVerbose} Verbosis  ;
      for (( Intx=${OperBaseStart} ;  Intx ${OperRange} ${IntEndLoop} ; ${OperRangeIn} )) ; do 
        #StrDateIndicator="${StrDateIndicatorFormat/__INT__/${Intx}}" ; 
        local StrDateParsed=${StrDateIndicator};
        StrDateParsed=${StrDateParsed/__INT__/${Intx}} ;
        DateFuncVerbose=${IsVerbose} \
        DateFuncApp=${StrDateApps} \
        DateFuncFormat=${StrDateFormat} \
        DateFuncIndicator=${StrDateParsed} DateFunc ;
      done
     else 
      DateFuncApp=${StrDateApps} \
      DateFuncFormat=${StrDateFormat} \
      DateFuncIndicator=${StrDateIndicator} DateFunc ;
     fi
    fi 
  }
fi ### End-of if-versionGOD == 0.0.1 .

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
if [ "${versionGOD:=0.0.1}" == "0.0.2" ] ; then 

  eval $( GFCFuncName=GetOtherDate GlobalFunctionCleaning ) ; 
  #IntIsFunc=$( declare -F | egrep -c "GetOtherDate" ) ; 
  #if [ ${IntIsFunc:=0} -gt 0 ] ; then 
  # unset $( StrPrefix=$( GetStdPrefixName GetOtherDate ) ; GetVarReference GetOtherDate | egrep -i "^Variable" | sed 's/\(Variable \)\('${StrPrefix}'[a-zA-Z0-9]*\)\( ,\)/\2/g' | tr '[:cntrl:]' ' '  ) ; 
  # unset $( GetVarReference GetOtherDate | egrep -i "Function Member:" -A1 | tail -n1 | sed -r 's/,/ /g;s/[\t\ ]+/ /g' ) ; 
  #fi 
  #unset IntIsFunc StrPrefix ;
  
  #unset GetOtherDate ;
  #unset Verbosis DateFunc VersionApps __main_StartServices ; 
  function GetOtherDate()
  {
   function Verbosis()
   {
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Verb Verbosis ) ; 
    local Arg0="${ArrayArg[0]}" ; 
    local StrMsg=${VerbMsg:=__TEXT__} ; 
    local StrDevOut=${VerbDev:=/dev/stderr} ; 
    local IsVerboseState=${VerbState:=False} ;
    local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
    local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
    local IsDisplayFormatted=${VerbFormated:=True} ;
    local IsAppendMode=${VerbAppendDev:=False} ; 
    local IsExtendedOutput=${VerbExtendedOut:=False} ; 
    local ArrayArg=( $* ) ; 
    if [ "${IsVerboseState:=False}" == "True" ] ; then 
     if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
        echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
      else  
        echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
      fi
     else
      if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" ;  
       else
         echo "${StrMsg}" ;  
       fi
      else
       if [ "${IsAppendMode:=False}" == "True" ] ; then 
        if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
          echo -ne "${StrMsg}" >> ${StrDevOut} ;
        else
          echo "${StrMsg}" >> ${StrDevOut} ;
        fi
       else
        if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" > ${StrDevOut} ;
        else
         echo "${StrMsg}" > ${StrDevOut} ;
        fi 
       fi
      fi 
     fi 
    fi
   } 
   function VersionApps()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( VA VersionApps ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=VersionApps CAIsAddParent=True __Call_Argument ) ;
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=VersionApps CAIsAddParent=True CallArgument ) ;
    fi     
    local StrEvalCmd="""StrMsg=\"Application:__FUNCT__ , version:( versionTP:__VER_TP__ versionVTV:__VER_VTV__, versionCA:__VER_CA__, versionBVT:__VER_BVT__)\" ; 
    StrMsg=\${StrMsg//__VER_CA__/\${versionCA}} ;
    StrMsg=\${StrMsg//__VER_TP__/\${versionTP}} ;
    StrMsg=\${StrMsg//__VER_VTV__/\${versionVTV}} ;
    StrMsg=\${StrMsg//__VER_BVT__/\${versionBVT}} ;
    StrMsg=\${StrMsg//__FUNCT__/\${__call_locality[1]}} ;
    VerbMsg=\${StrMsg} VerbHeader=\"VERSION\" VerbEvalForm=False VerbFormated=True VerbState=${IsShowVersion:=True} VerbDev=/dev/stderr  Verbosis ; 
    """ ; 
    echo -ne "${StrEvalCmd}" ; 
   }     
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( GOD GetOtherDate ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=GetOtherDate CAIsAddParent=False __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=GetOtherDate CAIsAddParent=False CallArgument ) ;
   fi 
    
   local StrDateUnitPattern=${GODDateUnitPatrn:=__DATEUNIT__};
   local StrDateUnitReference=${GODDateUnit:="day"};
   local StrDateFormat=${GODFormat:=%Y%m%d} ;
   #local StrDateIndicatorFormat=${GODReferenceFormat:=__INT__ __DATE_FORMAT__};
   local IntDayDiff=${GODReference:=0} ; 
   local StrDateApps=${GODMainApp:=/bin/date} ; 
   local BoolScriptConversion=${GODIsScriptConv:=False} ; 
   local BoolScriptIsDateSupplied=${GODIsWithDS:=False} ;
   local BoolNanoRefScript=${GODScriptNanoVar:=False}
   local StrScriptTagNano=${GODScriptNano:=--assign=UnitRef=__NANO_SEC_REF__} ;
   local IntUnitNSRef=${GODNanoSecRef:=1000000000} ;
   local StrScriptTagSupplied=${GODScriptDS:=--assign=DateSupplied=__START_REF__} ;
   local StrScriptFile=${GODScriptFile:=/etc/init.d/Fnct.D/awk-script/GODDateToNS.awk} ;
   local StrFilterApps=${GODFilterApps:=/usr/bin/gawk} ; 
   local StrDateStart=${GODStartRef:=now} ; 
   local StrPipeCmd=${GODDefaultPipe:='|'} ; 
   local StrTagParser=${GODTagParserDef:=StrDateApps:__APPS__,IntDateIndex:__INT__,StrScriptTagNano:__FILTER_TIME_OPT__,StrScriptTagSupplied:__FILTER_OPT__,StrPipeCmd:__PIPE__,StrFilterApps:__FILTER__,StrScriptFile:__FILE_NAME__,IntUnitNSRef:__NANO_SEC_REF__,StrDateStart:__START_REF__,StrDateFormat:__DATE_FORMAT__,StrDateUnitReference:__DATEUNIT__} ; 
   local StrScriptTpl=${GODFilterTag:=__FILTER__ __FILTER_OPT__ __FILTER_TIME_OPT__ -f __FILE_NAME__ } ;
   local StrDateTpl=${GODDateTpl:="""__APPS__ +\"__DATE_FORMAT__\" --date '__START_REF__ __PERIOD__ __DATEUNIT__'"""}
   local StrTagOptManager=${GODBoolToTag:=BoolScriptIsDateSupplied:__FILTER_OPT__,BoolNanoRefScript:__FILTER_TIME_OPT__} ;
   local IsLoop=${GODIsLoop:=False} ;
   local IntLoopRange=${GODLoop:=0,3} ;
   local IsVerbose=${GODVerbose:=False} ;
   local IsShowVersion=${GODShowVersion:=True} ; 
   local IsShowParsedInfo=${GODShowParsing:=False} ;
   local IsShowEvalCmd=${GODShowEvalCmd:=False} ; 
   
   local StrVarList="IsShowEvalCmd,IsShowParsedInfo,IsShowVersion,StrTagOptManager,StrScriptTagNano,BoolNanoRefScript,IntUnitNSRef,StrPipeCmd,StrTagParser,StrScriptTpl,BoolScriptConversion,BoolScriptIsDateSupplied,StrScriptTagSupplied,StrScriptFile,StrFilterApps,StrDateStart,StrDateUnitPattern,StrDateUnitReference,StrDateFormat,StrDateIndicatorFormat,IntDayDiff,StrDateApps,IsLoop,IntLoopRange,IsVerbose" ; 

   local -a ArrayMsg ;
   ArrayMsg[0]="Entry in function" ;   
    

    ### Example, must supplied a date from N and start counting from 
    ### date --date='20000101 00:00:00' +"%StrDateFormat"
    ### where StrDateFormat = Y%m%d %s %s 
    
    function DateFunc()
    {
     if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
      local -a ArrayArg=( $* ) ;
      local -a __call_locality=( DF DateFunc ${StrParentApps} ) ;
      local Arg0="${ArrayArg[0]}" ; 
     elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
      eval $( eval CAFunctName=DateFunc CAIsAddParent=True __Call_Argument ) ;
     elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
      eval $( eval CAFunctName=DateFunc CAIsAddParent=True CallArgument ) ;
     fi 
     StrMsg=$( GetOtherDate --get ArrayMsg[0] ) ; 
     VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${IsVerbose} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

     local StrPairVarTag ;
     local StrVar ;
     local StrTag ;
     local StrEval=${StrDateTpl} ; 
     
     ### Principe of GODLoop
     ### with a First,Last value should increase the counter inside the date 
     ### query --date='__REFERENCE __INDICE__ __PERIOD_REFERENCE__'
     ### where __PERIOD_REFERENCE__ is by default is 'day', but can be 'minute'
     ### 'week', and severals forms of calendar word. 
     ### like this 2 sequence does report a minute loop, but onw does not 
     ### report 1 minutes in distam, time reference is not steady and does 
     ### come from application execution delay:
     ### GODFormat="%Y%m%d %H:%M:%S" GODShowEvalCmd=False GODShowParsing=False GODShowVersion=False GODVerbose=False GODIsLoop=True GODLoop=0,5 GODDateUnit='minute'  GetOtherDate
     ### Other one depend of a precise date and give exact minute :
     ### GODFormat="%Y%m%d %H:%M:%S" GODShowEvalCmd=False GODShowParsing=False GODShowVersion=False GODVerbose=False GODIsLoop=True GODLoop=0,5 GODDateUnit='minute' GODStartRef="20161128 22:53:18"  GetOtherDate
     ### Analyse if it coming from a Loop Or not, should depend from IntDateIndex, 
     ### but rely on IsLoop statement.
     if [ "${IsLoop:=False}" == "True" ] ; then 
      ### updating StrTagParser to include an updated value from __PERIOD__
      StrTagParser="${StrTagParser},IntDateIndex:__PERIOD__" ; 
     else
      ### Updating to Know default value inside IntDayDiff 
      StrTagParser="${StrTagParser},IntDayDiff:__PERIOD__" ; 
     
     fi 
     
     
     ### This is the array managing the Relation between Boolean declared in the 
     ### top-function and ability to suppress parsing of __TAG__ because 
     ### boolean value are false and don't require to append option to FILTER. 
     local ArrayBooleanTagRemove=( ${StrTagOptManager//,/ } ) ; 
     
     ### At this step belong to BoolScriptConversion to use a script to pass a date 
     ### for transformation start here and I supply the '|' or __PIPE__ and the template
     ### script to add the gawk options to it. 
     if [ "${BoolScriptConversion:=False}" == "True" ] ; then 
      StrEval="${StrEval} __PIPE__ ${StrScriptTpl}" ; 
     fi 
     
     ### This section generate IF-Statement to keep or remove the __TAG__
     ### from Filter Option it manage Presence of --assign=DateSupplied and 
     ### --assign=UnitRef in uses of a Parser for application gawk used 
     ### as filter . Representation of this parse : __APPS__ | __FILTER__
     ### where __APPS__ is the /bin/date and __FILTER__ the filter application
     ### to issue "something" from the output of __APPS__ . 
     
     for (( Intx=0 ; Intx <= ${#ArrayBooleanTagRemove[@]}-1 ; Intx++  )) ; do 
       StrPairVarTag=${ArrayBooleanTagRemove[${Intx}]} ; 
       StrTag=${StrPairVarTag/#[A-Za-z0-9]*:} ; 
       StrVar=${StrPairVarTag/%:${StrTag}} ;
       eval $( eval BVTIsPreambule=False                      \
                    BVTBoolVarName=\\\${\${StrVar}:=False}    \
                    BVTVarName=StrEval                        \
                    BVTBoolAssertion="\\"\${StrEval//${StrTag}/}\\"" \
                    BVTDisplayIf=${IsShowParsedInfo}          \
                    BVTBoolCase=False BVTIdType=0 BoolVarTest             ) ; 
     done  

     
     ### TagParser Command-line 
     ### that evaluate the rest of the Query started by StrEval .     
     eval $( eval TPListTag=${StrTagParser}      \
       TPArrayName=Array${__call_locality[0]}    \
       TPVarNameParsed="StrEval"                 \
       TPDisplayDebug=${IsShowParsedInfo}        \
       TPDisplayParserNotice=${IsShowParsedInfo} \
       TagParser ) ; 
     
     VerbMsg="${StrEval}" VerbHeader="${__call_locality[1]}-EVALCMD" VerbState=${IsShowEvalCmd} VerbDev=/dev/stderr Verbosis ;
     eval ${StrEval} 
    }
       
    function __main_StartServices()
    {
     if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
      local -a ArrayArg=( $* ) ;
      local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
      local Arg0="${ArrayArg[0]}" ; 
     elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
      eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
     elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
      eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ;
     fi 
     StrMsg=$( GetOtherDate --get ArrayMsg[0] ) ; 
     VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${IsVerbose} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
     
     local -a ArrayRange=( ${IntLoopRange/,/ } ) ;
     local OperRange="<=" ;  
     local OperRangeIn="IntDateIndex++" ;
     local OperBaseStart=${ArrayRange[0]} ;
     local IntEndLoop=$(( ${ArrayRange[$((${#ArrayRange[@]}-1))]} ));
     #local StrDateParsed=${StrDateIndicator};
     local StrDebugMsg ;
     
     ### Since the TagParser does convert the __INT__ into number from for_loop issueing
     ### a variable IntDateIndex, it's propagated with ValueToVariable and does it's 
     ### transformation from __INT__ to value IntDateIndex. 
     ### In case the application it not sollicitated to loop to extract a precise date in
     ### time, __INT__ is removed because it pass through the StrTagOptManager, 
     ### the StrTagOptManager from DateFunc does removing __TAG__ if an Boolean option
     ### it set to false. Noted if IsLoop==False, the StrDateTpl will be instantiated inside
     ### DateFunc and will remove __INT__ . Here The If-statement for IsLoop is only to start
     ### the Loop and alter IntDateIndex. 
    
     if [ "${IsLoop:=False}" == "True" ] ; then 
      StrDebugMsg="ArrayRange, nb-element:${#ArrayRange[@]}, hold [ ${ArrayRange[@]} ]\n" ;
      VerbMsg=${StrDebugMsg} VerbState=${IsVerbose} VerbHeader="${__call_locality[1]}-VERBOSE" VerbDev=/dev/stderr Verbosis  ;
      
      if (( ${ArrayRange[0]} > ${IntEndLoop} )) ; then 
       OperRange=">=" ;
       OperRangeIn="IntDateIndex--" ; 
       OperBaseStart=${ArrayRange[$((${#ArrayRange[@]-1))}]} ;
      fi
      StrDebugMsg="Looping from ${OperBaseStart} to ${IntEndLoop} \n" ;
      
      VerbMsg=${StrDebugMsg} VerbState=${IsVerbose} VerbHeader="${__call_locality[1]}-VERBOSE" VerbDev=/dev/stderr Verbosis  ;
      
      for (( IntDateIndex=${OperBaseStart} ;  IntDateIndex ${OperRange} ${IntEndLoop} ; ${OperRangeIn} )) ; do 
        
        eval $( eval \
         VTVValueEntry=${StrVarList},IntDateIndex \
         VTVIsArrayStyleInsert=True  \
         VTVIsValueReAssign=True     \
         VTVIsValueToConvert=False   \
         VTVIsQuotedValue=True       \
         ValueToVariable ) DateFunc ; 
      done
     else 
       eval $( eval \
        VTVValueEntry=${StrVarList},StrDateParsed \
        VTVIsArrayStyleInsert=True  \
        VTVIsValueReAssign=True     \
        VTVIsValueToConvert=False   \
        VTVIsQuotedValue=True       \
        ValueToVariable ) DateFunc ; 
     fi
    
    }   
    
    #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
    local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
    local StrNameHelper="A way to get a date already marshalled" ;
    
    ### StrNameHelper=${StrNameHelper}
    
    if [ "${Arg0:=--startservices}" == "--help" ] ; then 
     GVRIsName=True GetVarReference ${__call_locality[1]} ; 
     echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
    elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
     eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
     echo -ne """${ArgGet}\n""" ; 			
    elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
     eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
    elif [ "${Arg0:=--startservices}" == "--startservices"  ] ; then 
     ### Show the Application used function and their actual version. 
     eval $( VersionApps ) ;
     StrMsg=$( GetOtherDate --get ArrayMsg[0] ) ; 
     VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${IsVerbose} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
     ### Sanity check and clean-up during development. Common Prefixed Variable does exist in global scope
     ### during their uses with internal declaration in local... But it's not because 
     ### variable create in local accept variable in prefixed-name GOD... start in local too
     ### extracted from by-default they are global and some seem to be consider more important
     ### than new variable definition... 
     #unset $( ValueToVariable --list ; TagParser --list ; BoolVarTest --list ) ; 
     eval $( eval \
       VTVIsArrayStyleInsert=True  \
       VTVValueEntry=${StrVarList} \
       VTVIsValueReAssign=True     \
       VTVIsValueToConvert=False   \
       VTVIsQuotedValue=True       \
       ValueToVariable ) ${StrStartMain} ; 
        
    fi
  }
fi ### End-of if-versionGOD == 0.0.2 .

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
if [ "${versionGUUID:=0.0.2}" == "0.0.2" ] ; then 
  ### Notice : ca66ef20-e187-11e5-98a2-001e4c8856d6
  ### In near future, usues of GetUUID will be subject to a permanent survery this one 
  ### will be called, both a mechanism of storage, view and cleaning will be hook to this
  ### function, aka MD_CD. MD_CD have possibility to store creation date of path. wheres 
  ### some successive development will lead to read the file and or media invested for 
  ### storage of this information. This will also appear inside GetUUID and integrity
  ### test of the helper will reveal to start the storage. Future definition will start
  ### testing if GetUHelperName is UUIDHelper to start the storage and collection of information.
  ### This notice did not mention if new development will imply uses of sqlite for MD_CD
  ### data storage and shallow not mention if this GetUUID will either get one two storage 
  ### method. A basic work based on file collection will start be will probably move to 
  ### sqlite to render data parsible thru other tools to observe uses of this function. 
  ### 
  ### Notice : 282b59c0-e188-11e5-98a2-001e4c8856d6
  ### Will also invite to uses the Helper directly if some other alternative are inquirying 
  ### the uses of UUID. Goal of GetUUID is also to aggregate a function UUIDRegistration 
  ### which uses of BodyFunct will depend on. Other alternative like ShortRegistration of 
  ### Pattern, variable-set will also own it's registration . 

  #unset GetUUID ;
  #unset Verbosis ApplicationRegistrationIndex UUIDNoLoop UUIDLoop __main_StartServices ; 
  eval $( GFCFuncName=GetUUID GlobalFunctionCleaning ) ; 
 
  function GetUUID ()
  {
   ### This is a specialized Verbosis mode :
   ###  
   ###  All condition required to set VerbState=True 
   ###  All condition required to set a message with VerbMsg=STRING
   ###  
   ###  
   ### It can be used to :
   ###  - Echo result to be passed throught Value Result .
   ###  Required :
   ###  VerbEvalForm=True VerbFormated=False 
   ###  
   ###  VerbHeader Is ineffective
   ###  
   ### -Echo result can be append to file and not overwriting the content: 
   ###  Required ;
   ###  VerbFormated=False/True VerbAppendDev=True VerbDev=[ FILENAME | UUID ]
   ###  - Appending to file also required to be unique-file were no instance of 
   ###  Verbosis may point on same-file or loss of log will be CERTAIN.
   ###  -Pointing to Same-Destination require a lock Mechanism which is 
   ###  not implemented here
   ###  
   function Verbosis()
   {
    local -a ArrayArg=( $* ) ; 
    local -a __call_locality=( Verbosis Verb );
    local StrMsg=${VerbMsg:=__TEXT__} ; 
    local StrDevOut=${VerbDev:=/dev/stderr} ; 
    local IsVerboseState=${VerbState:=False} ;
    local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
    local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
    local IsDisplayFormatted=${VerbFormated:=True} ;
    local IsAppendMode=${VerbAppendDev:=False} ; 
    if [ "${IsVerboseState:=False}" == "True" ] ; then 
     if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
        echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
      else  
        echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
      fi
     else
      if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
         echo "${StrMsg}" ;  
      else
       if [ "${IsAppendMode:=False}" == "True" ] ; then 
        echo "${StrMsg}" >> ${StrDevOut} ;
       else
        echo "${StrMsg}" > ${StrDevOut} ;
       fi
      fi 
     fi 
    fi
   } ;
   ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
   local -a ArrayArg=( $* ) ; 
   local -a __call_locality=( GetU GetUUID ) ;
   local Arg0="${ArrayArg[0]}" ;
   local BoolTimeBased=${GetUTimeBased:=True}
   local BoolLoop=${GetULoop:=False} ;
   local IntSeqLoop=${GetUSeq:=1} ; 
   local StrGetHelperName=${GetUHelperName:=UUIDHelper} ;
   local StrUUIDHelperStream=${GetUHelper:=UUIDHApps= UUIDHSwitches= __HELPERNAME__} ; 
   local BoolIsHelper=${GetUIsHelper:=False} ; 
   ### No Need to transfert TypeAppsName, its recuperated by StrAppsNameCall .
   local TypeAppsName=${GetUAppsDef:=__HELPERNAME__ --get UUIDHApps}
   local StrUUIDActionName=${GetUActionFunc:=UUIDNoLoop,UUIDLoop} ;
   local IsVerbosis=${GetUVerbosis:=False} ;
   local IsUUIDDbCreation=${GetUDBCreation:=False};
   local IsUUIDDbImport=${GetUDbImport:=False};
   local StrDbURI=${GetUDBPath:=/var/cache/fnct.D/db/sqlite/GetUUID.sqlite}
   local StrDbSchema=${GetUDBSchema:=/etc/init.d/Fnct.D/getUUID.schema}
   local BoolCallRegistered=${GetUIDRegister:=False}; 
   local StrAppsRegister=${GetUAppsRegisterName:=None};
   local StrUUIDIndexName=${GetUIDName=.GetUUID};
   local StrAppsNameCall=${TypeAppsName//__HELPERNAME__/${StrGetHelperName}} ; 
   if [ "${BoolIsHelper:=False}" == "True" ] ; then 
    ### Section not ready, use a Declaration to call it, but no Helper are 
    ### available at this time. 
    ### While it's not ready-yet it scheduled and 
    ### only providers are ZenityPrefixedVarSelection->BuildListInformation which 
    ### is usefull method to make __TAG__ from List variable from a function .
    ### The first workable is GnrlPrsrInfctr->RepositoryCreation which is 
    ### suppose to answer. So supposing we have to split-down GnrlPrsrInfctr to 
    ### version 0.0.1 for restriction policy like "Not Allowing creation of path or
    ### repository" we should receive "nothing or None" and GetUUID can not pass 
    ### informations for creating Database location. Initially only the getter for  
    ### UUIDHApps can be implemented. 
    local StrAppsName=$( ${StrAppsNameCall} ) ; 
   fi 
   local StrParentApps=${__call_locality[1]} ; 
   local StrVarList="StrAppsName,StrAppsNameCall,StrUUIDIndexName,StrAppsRegister,BoolCallRegistered,StrDbSchema,StrDbURI,IsUUIDDbImport,IsUUIDDbCreation,IsVerbosis,StrUUIDActionName,StrUUIDHelperStream,StrGetHelperName,IntSeqLoop,BoolLoop,BoolTimeBased,StrParentApps,StrVarList"; 
   
   ArrayMsg[1]="UUID StrAppsName: ${StrAppsName}" ; 
   VerbState=${IsVerbosis} VerbMsg=${ArrayMsg[1]} Verbosis;

   StrUUIDHelperStream=${StrUUIDHelperStream//__HELPERNAME__/${StrGetHelperName}} ;
   StrUUIDHelperStream=${StrUUIDHelperStream//UUIDHApps=/UUIDHApps=${StrAppsName}} ; 
   
   function ApplicationRegistrationIndex()
   {
    local -a ArrayArg=( $* ) ; 
    local -a __call_locality=( ARI ApplicationRegistrationIndex ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ;
   
    
   }


   
   function UUIDNoLoop()
   {
    local -a ArrayArg=( $* ) ; 
    local -a __call_locality=( UUIDNL UUIDNoLoop ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ;
    #eval $( ${StrUUIDHelper} ) ;
    local StrMsg="UUID HELPER: ${StrUUIDHelper}" ;
    VerbState=${IsVerbosis} VerbMsg=${StrMsg} VerbHeader="VERBOSE" Verbosis;
    eval ${StrUUIDHelper} ;
   }
   
   function UUIDLoop()
   {
    local -a ArrayArg=( $* ) ; 
    local -a __call_locality=( UUIDL UUIDLoop ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ;
    local -a ArrayMsg=( ) ;
    ArrayMsg[0]="UUID LOOPSEQ: ${IntSeqLoop}";
    ArrayMsg[1]="UUID HELPER: ${StrUUIDHelper}\n" ;
    
    VerbState=${IsVerbosis} VerbMsg=${ArrayMsg[0]} Verbosis;
    for (( intX=0 ; intX <= $(( ${IntSeqLoop}-1 )) ; intX++ )) ; do
     VerbState=${IsVerbosis} VerbMsg=${ArrayMsg[1]} VerbHeader="VERBOSE" Verbosis;
     eval ${StrUUIDHelper} ;
    done 
   }
   
   function __main_StartServices()
   {
    local -a ArrayArg=( $* ) ; 
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ;
    local IntUUIDHelperIndex=0 ;
    local IntUUIDActionIndex=0 ; 
    local StrUUIDOption="" ;
    local StrUUIDHelper=""
    local StrAction=""
    local -a ArrayUUIDState=( Helper Action ) ; 
    local ArrayMsg=( ) ;
    ### Array conversion from StrUUIDActionName, using string delimiter char ',' ; 
    local ArrayUUIDAction=( ${StrUUIDActionName//,/ } ) ; 

    eval $( BVTDisplayShowDebug=${IsVerbosis}  \
      BVTDisplayIf=${IsVerbosis}  \
      BVTIsPreambule=True         \
      BVTIsValueToVar=False       \
      BVTBoolCase=False           \
      BVTBoolVarName="\${BoolTimeBased:=True}" \
      BVTVarName='StrUUIDOption'  \
      BVTVarHold=\"-t\"           \
      BVTBoolAssertion=\"-r\" BVTIdType=0      \
      BoolVarTest ;           ) ; 
     ### local StrUUIDOption="-t" ; 
     ### if [ "${BoolTimeBased:=True}" == "False" ] ; then 
     ###  StrUUIDOption="-r"
     ### fi 
    
    StrUUIDHelper=${StrUUIDHelperStream} ; 
    StrUUIDHelper=${StrUUIDHelper//UUIDHSwitches=/UUIDHSwitches=${StrUUIDOption}}  ;
    #StrUUIDHelper=$( eval ${StrUUIDHelperStream} ) ; 
    ArrayMsg[1]="UUID __main_StartServices: content of StrUUIDHelper:[${StrUUIDHelper}]" ; 
    VerbState=${IsVerbosis} VerbMsg=${ArrayMsg[1]} VerbHeader="VERBOSE" Verbosis ;
    #echo -ne "[UUID __main_StartServices: content of StrUUIDHelper:[${StrUUIDHelper}]]\n" > /dev/stderr 

    ### BoolvarTest replace following into 2 If-clause made from an Array
    ### creating a variable form "IntUUID[ Helper, Action ]Index"=1 if BoolLoop==True . 
    ### if [ "${BoolLoop:=False}" == "True" ] ; then 
    ###   IntUUIDHelperIndex=1 ;
    ###   IntUUIDActionIndex=1 ; 
    ### fi   
    for StrUUIDState in ${ArrayUUIDState[@]} ; do  
     eval $( eval BVTDisplayShowDebug=${IsVerbosis}  \
       BVTDisplayIf=${IsVerbosis}  \
       BVTIsPreambule=False        \
       BVTIsValueToVar=False       \
       BVTBoolCase=True            \
       BVTBoolVarName="\${BoolLoop:=False}" \
       BVTVarName='IntUUID${StrUUIDState}Index'  \
       BVTBoolAssertion=1  BVTIdType=0           \
       BoolVarTest ;           ) ; 
    done    
    

    ### Since variable are created with value==0, I can enforce the 
    ### value to 1 on if it's true .
    # else 
    # IntUUIDHelperIndex=0 ; 
    # IntUUIDActionIndex=0 ; 
    
    StrAction=${ArrayUUIDAction[${IntUUIDActionIndex}]} ; 
    ArrayMsg[2]="UUID ACTION: ${StrAction}" ; 
    VerbState=${IsVerbosis} VerbMsg=${ArrayMsg[2]} VerbHeader="VERBOSE" Verbosis ;
    #echo -ne "[UUID ACTION: ${StrAction}]\n" > /dev/stderr  ;
    eval $( VTVIsArrayStyleInsert=True \
            VTVIsValueReAssign=True    \
            VTVIsQuotedValue=True      \
            VTVIsValueToConvert=False  \
            VTVValueEntry=IsVerbosis,StrAction,StrUUIDHelper,IntSeqLoop ValueToVariable ) ${StrAction} ; 
   } 
   
   #local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n" ;
   local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
   
   if [ "${Arg0:=--startservices}" == "--help"	] ; then 
     GetVarReference ${__call_locality[1]} ; 
     echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ;
   elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
    eval $( __GetVarReferenceCompWord ) ;
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;	
   elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
    eval $( VTVIsArrayStyleInsert=True \
            VTVIsValueReAssign=True    \
            VTVIsQuotedValue=True      \
            VTVIsValueToConvert=False  \
            VTVValueEntry=${StrVarList} ValueToVariable ) __main_StartServices 
   ### replacement IsVerbosis,BoolTimeBased,BoolLoop,IntSeqLoop,StrGetHelperName,StrUUIDHelperStream,StrUUIDActionName by StrVarList
   fi 

  }
fi ### End-of if-versionGUUID == 0.0.2 .


### 
###  Notice : 
###  Note reference : 2953b00a-749e-11e6-8b1d-001e4c8856d6
###  - Well compromised Recurrent function for low-use od stdout for variable transfert use. 
###  
###  MdCd is an important tool and test-case to establish a datafile merely recognized like 
###  low-level certificate. This application create path, put templated structure of important 
###  file for your services . The default behavior is described by this box
###  
###  Using Mdcd becoming mainstream, after port to Mint 17.3 Rosawhich is Mate distribution with
### core of Xenial Ubuntu, I do profit from lack of dependence to add package installer inside 
### some application and upgrading Mdcd, by getting out the Sha1sum agent that produce a validity
### context after creating the Path, dunping the structure file like .gitignore MANIFEST.in, 
###  README.rst it can add many more struture depending of the file-model described own to 
###  add it to Mdcd.  Registration of the action is comming and will also have it's «Jeton» inside
###  SSHServicesRequest . Protection of Mdcd is keep inside the main Mdcd file and require only to
###  push the location of the lock for a precise place accessible by any to allow strict survey and 
###  avoid multiple path creation in a backup-storyboard reading. 
###  
###  A backup-storyboard... is Incremental awarness made by many application shelve to allow
###   - reading the structure once and updating it based on time . 
###   - Avoiding touching file recurrently to reduce access time in a network access. 
###     - Known to be important .htaccess inside webservices, a live-incremental backup with 
###       high priority on backuping change of .htaccess / .htpassword can lock the access to
###       it and slowing the services respond. 
###  
###  While elaborating this backup-storyboard in late 2012 during first draft of fnct_lib for 
###  development of UpdateSquashFS, set of tools was developped to update a btrfs tree with 
###  possibility to update the SquashFS 4Gb or 8Gb boosted parameter by re-wrinting the 
###  usb-disk-writer to accept higher value ; an update of squahfs pivot was bringing too much
###  cpu time until I do realize fuse-fs stack a common socket-file was not ignored and being
###  put inside the squashfs device with all the command. Some update were made to develop a 
###  so similar GetterByLineData application this one failed for problems of Stdout output 
###  during _func_eval_cmd and producing error... A this moment the primary version of fnct_lib
###  did not handle the output individully and was not possible to make-it appart... 
###  In one word, the Ubuntu 10 was holding on arch 64 bit and working on a 16Gb partition to 
###  practice a pivot of 8 Gb after update. A Somewhat StackSpace , DblSpace like microsoft did 
###  for version msdos 6.02 and beyond that merely did not work for having same problems called 
###  file/buffer memory being a disk section being not ignored and slowing the dblspace... 
###  
###  
###  

###  
###  Application Box:
###  +GetterByLineData+----------------------------------------+
###  |                                                         |
###  |                                                         |
###  |Tree Order :                                             |
###  |                                                         |
###  |                                                         |
###  |           +----------------+GetHeader                   |
###  |GetFile+--+FileSplitAction                               |
###  |           +----------------+GetContent                  |
###  |                            |                            |
###  |                            +-----------ShaSum1Content   |
###  |                                                         |
###  +----------------------------------------------------------
###  
###  Major Function coming with the Application :
###  Are all accessible thru GBLDAction where :
###  
###  GetFile ---->Throw the whole content of the file
###               GetFile is also First Order in the Execution.
###  
###  GetHeader ----> Most of file are 2 lines height, Being a text-format of 
###                  2 lines, the lenght can be illimited for second one...
###                  In this case we have put the SHA1SUM of the content to
###                  proove the content in second line is safe and can be trusted.
###  
###  
###  
###  GetContent ---> Get the content of second-text field. 
###  
###  FileSplitAction ---> The intermediate action preceding GetHeader and GetFile
###  
###  ShaSum1Content ----> The result of GetContent. 
###  
###  
###  - A tiny lexic appear by using ShaSum1Content and require to Call GetContent,
###  
###  while this one query-back FileSplitAction that take GetFile. During the 
###  call of this structure, no varaible are query thru the stdout and are queryed
###  thru Getter by using the mechanism of GetterByLineData --get ... Even Text
###  Message are Array of Text a the root level of the GetterByLineData. 
###  
###  
###  
###  
###  Note: reference file 0f86b448-72f4-11e6-8b1d-001e4c8856d6 a un-approved chunk file will
### be acknoledged by ZenityFileEditor, but still require some work before frozing the
### integrity. GetterByLineData Also work with function call and external function call
### alike ZenityStructure can borought the GetterByLineData structure to replace the 
### footprint of chunk developement. 
### 

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###

if [ "${versionGBLD:=0.0.2}" == "0.0.2" ] ; then 
  #unset GetterByLineData ; 
  eval $( GFCFuncName=GetterByLineData GlobalFunctionCleaning ) ; 

  function GetterByLineData()
  {
   function Verbosis()
   {
    local -a ArrayArg=( $* ) ; 
    local -a __call_locality=( Verbosis Verb  ) ;
    local StrMsg=${VerbMsg:=__TEXT__} ; 
    local StrDevOut=${VerbDev:=/dev/stderr} ; 
    local IsVerboseState=${VerbState:=False} ;
    local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
    local IsDisplayFormatted=${VerbFormated:=True} ;
    if [ "${IsVerboseState:=False}" == "True" ] ; then 
     if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     else
       echo -ne "${StrMsg}\n" > ${StrDevOut} ;
     fi 
    fi
   } 
   ### Model : VerbHeader="DEBUG" VerbMsg=${StrMsg}  VerbDev=/dev/stderr VerbFormated=True VerbState=True Verbosis
   local -a ArrayArg=( $* ) ; 
   local -a __call_locality=( GBLD GetterByLineData ) ;
   local Arg0="${ArrayArg[0]}" ; 
   local StrParentApps="${__call_locality[1]}" ;
   local StrAppsTail=${GBLDTailApps:=/usr/bin/tail} ;
   local StrAppsHead=${GBLDHeadApps:=/usr/bin/head} ;
   local StrFStats=${GBLDFileStats:=/usr/bin/wc} ;
   local StrFStatsOpt=${GBLDFileStatsOpt:=__APPS__ -c __FILE__} ;
   local StrTailOpt=${GBLDTailCmd:=__APPS__ -n 1} ;
   local StrHeadOpt=${GBLDHeadCmd:=__APPS__ -n __INTLINE__} ;
   local StrFileStoreInfo=${GBLDFileStoreInfo:=None} ;
   local IntLineId=${GBLDLineID:=1} ; 
   local IsVerbose=${GBLDVerbose:=False} ; 
   local IsShaRemovingComment=${GBLDIsShaRemoveComment:=True} ; 
   local StrAction=${GBLDAction:=FileSplitAction} ;
   local IsActionReturnError=${GBLDActionReturnError:=False} ; 
   local StrVerboseMacro="" ; 
   local vret=0 ;
   local StrMsg="" ; 
   local StrVarListTransfert="IsShaRemovingComment,StrParentApps,IntGCID,IntGHID,IsVerbose,IsActionReturnError,StrFileStoreInfo,IntLineId,Stream,StrAppsTail,StrAppsHead,StrAction,StrParentApps,StrVerbosisMacro,StrFStats,StrFStatsOpt" ; 
   local -a ArrayMsg=( ) ;
   
   ArrayMsg[0]="Verbose is Turned On" ; 
   ArrayMsg[1]="File is Present, Size:__FILE_SIZE__, Name=__FILE__" ; 
   ArrayMsg[2]="File is not Present or experiencing access restriction. File=__FILE__" ; 
   ArrayMsg[3]="Extraction Starting from line __START_LINE__ From file __FILE__." ; 
   ArrayMsg[4]="Cmdline Head:__CMDLINE__" ; 
   ArrayMsg[5]="Cmdline Tail:__CMDLINE__" ; 
   ArrayMsg[6]="Template: __CMDLINE__" ; 
   ArrayMsg[7]="Action Does require to return a value" ; 
   ArrayMsg[8]="Action Does not require to return a value" ; 
   ArrayMsg[9]="CmdLine: __CMDLINE__" ; 
   ArrayMsg[10]="Starting function __main_StartServices" ; 

   function GetFile()
   {
    local -a ArrayArg=( $* ) ; 
    local -a __call_locality=( GF GetFile ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
    local StrFile="${StrFileStoreInfo:=None}" ;
    local StrParserFileStats="${StrFStatsOpt//__APPS__/${StrFStats}}" ; 
    StrParserFileStats="${StrParserFileStats//__FILE__/${StrFile}}" ; 
    StrMsg=$( ${StrParentApps} --get ArrayMsg[9] ) ; 
    StrMsg=${StrMsg//__CMDLINE__/${StrParserFileStats}} ; 
    VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
    vret=0 ; 
    if [ -f ${StrFile} ] ; then 
      IntFileRes=$( ${StrParserFileStats} ) ;
      IntFileSize=${IntFileRes/% [a-zA-Z0-9\/\_\-\=\"\(\)\]\[\)\(\=]*/} ;
      StrMsg=$( ${StrParentApps} --get ArrayMsg[1] ) ; 
      StrMsg=${StrMsg//__FILE_SIZE__/${IntFileSize}} ; 
      StrMsg=${StrMsg//__FILE__/${StrFile}} ; 
      VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}"  VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
     cat ${StrFile} ; 
     vret=0 ;   
    else
     StrMsg=$( ${StrParentApps} --get ArrayMsg[2] ) ;  
     StrMsg=${StrMsg/__FILE__/${StrFile}} ; 
     VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
     vret=1 ; 
    fi 
    return ${vret}
   }	
   
   function GetHeader()
   {
    local -a ArrayArg=( $* ) ; 
    local -a __call_locality=( GH GetHeader ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
    local IntLineId=${IntGHId:=1} ; 
    StrHeaderStream=$( GBLDActionReturnError=True GBLDAction=FileSplitAction GBLDFileStoreInfo=${StrFileStoreInfo} GBLDLineID=${IntLineId} GetterByLineData	 ) ; 
    if [ "${IsShaRemovingComment}" == "True" ] ; then 
     echo "${StrHeaderStream/\#/}" ; 
    else
     echo "${StrHeaderStream}" ; 
    fi
    
    return $? ;
   }
   
   function GetContent()
   {	
    local -a __call_locality=( GC GetContent ${StrParentApps} ) ;
    local -a ArrayArg=( $* ) ; 
    local IntLineId=${IntGCId:=2} ; 
    echo $( GBLDActionReturnError=True GBLDAction=FileSplitAction GBLDFileStoreInfo=${StrFileStoreInfo} GBLDLineID=${IntLineId} GetterByLineData	 ) ; 
    return $? ;
   }
   
   function FileSplitAction( )
   {
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( FSA FileSplitAction ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ;  
    
    local Stream=$( GBLDActionReturnError=True GBLDAction=GetFile GFStoreInfo=${StrFileStoreInfo} GetterByLineData ) ;
    local vret=$? ; 
    local StrCmdParseHead=$( ${StrParentApps} --get StrHeadOpt ) ;
    local StrCmdParseTail=$( ${StrParentApps} --get StrTailOpt ) ;
    local IntLineStart=$( ${StrParentApps} --get IntLineId ) ; 
    StrMsg=$( ${StrParentApps} --get ArrayMsg[3] ) ;
    StrMsg=${StrMsg//__START_LINE__/${IntLineStart}} ; StrMsg=${StrMsg//__FILE__/${StrFileStoreInfo}} ;   
    VerbHeader="VERBOSE-${StrParentApps}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
    StrCmdParseHead=${StrCmdParseHead//__INTLINE__/${IntLineStart}} ;
    StrCmdParseHead=${StrCmdParseHead//__APPS__/${StrAppsHead}}
    StrCmdParseTail=${StrCmdParseTail//__APPS__/${StrAppsTail}} ; 
    StrMsg=$( ${StrParentApps} --get ArrayMsg[4] ) ;
    StrMsg=${StrMsg//__CMDLINE__/${StrCmdParseHead}}
    VerbHeader="VERBOSE-${StrParentApps}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
    
    StrMsg=$( ${StrParentApps} --get ArrayMsg[5] ) ;
    StrMsg=${StrMsg//__CMDLINE__/${StrCmdParseTail}}

    VerbHeader="VERBOSE-${StrParentApps}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
    
    if [ ${vret:=-1} -eq 0 ] ; then 
      echo "${Stream}" | ${StrCmdParseHead} | ${StrCmdParseTail} ;
      return 0 ; 
    else
      return 1 ;
    fi
   }
   
   function ShaSum1Content()
   {
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( FSA ShaSum1Content ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ;  
    local Stream=$( GBLDActionReturnError=True GBLDAction=GetContent GFStoreInfo=${StrFileStoreInfo} GetterByLineData ) ;	
    local vret=$? ; 
    if [ ${vret:=-1} -eq 0 ] ; then 
      echo "${Stream}" | /usr/bin/sha1sum | /usr/bin/cut -d ' ' -f 1 ;
      return 0 ; 
    else
      return 1 ;
    fi
   }
   
   
   function __main_StartServices()
   {
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ;  
    
    StrCmd="eval \$( VTVIsArrayStyleInsert=True VTVValueEntry=__LIST_VAR__ VTVIsValueReAssign=True VTVIsValueToConvert=False VTVIsArrayStyleInsert=True ValueToVariable ) __ACTION__ __RETURN_FORM__" ; 
    StrMsg=$( ${StrParentApps} --get ArrayMsg[6] ) ;
    StrMsg=${StrMsg//__CMDLINE__/${StrCmd}}
    VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
    
    if [ "${IsActionReturnError:=False}" == "True" ] ; then 
     StrMsg=$( ${StrParentApps} --get ArrayMsg[7] ) ;
     VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 

     StrCmd=${StrCmd//__RETURN_FORM__/ ; vret=\$? ;} ; 
    else
     StrMsg=$( ${StrParentApps} --get ArrayMsg[8] ) ;
     VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
     StrCmd=${StrCmd//__RETURN_FORM__/ ;} ; 
    fi 
    
    StrCmd=${StrCmd//__LIST_VAR__/${StrVarListTransfert}}
    StrCmd=${StrCmd//__ACTION__/${StrAction}}
    
    StrMsg=$( ${StrParentApps} --get ArrayMsg[9] ) ;
    StrMsg=${StrMsg//__CMDLINE__/${StrCmd}}
    VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
    eval "${StrCmd}" ; 
    if [ "${IsActionReturnError:=False}" == "True" ] ; then 
     StrMsg="Action return value: ${vret}" ; 
     VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
     return ${vret} ; 
    fi 
   }
    
   local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;

   if [ "${Arg0:=--startservices}" == "--help"	] ; then 
     GetVarReference ${__call_locality[1]} ; 
     echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ;
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
   elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
    eval $( __GetVarReferenceCompWord ) ;
   elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
     VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${ArrayMsg[0]}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
     StrMsg=$( ${__call_locality[1]} --get ArrayMsg[10] ) ;
     VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
    eval $( VTVIsArrayStyleInsert=True           \
            VTVValueEntry=${StrVarListTransfert} \
            VTVIsValueReAssign=True              \
            VTVIsValueToConvert=False            \
            VTVIsArrayStyleInsert=True           \
            ValueToVariable ) __main_StartServices
   fi

   ### unset Verbosis GetFile GetHeader GetContent FileSplitAction __main_StartServices ; 
  }

fi ### End-of if-versionGBLD == 0.0.2 .



###
### Part of MRU Engine, MRU Stand for 'Most Recent Unit', akin to
### acheive example of function storing theirs answer from based 
### Prefixed-variable configuration, somes application producing 
### finite answer to deserve having the same result one and over.
### MRU will accept to find the stored answer from Configured 
### Call_Argument call.  Skip the function processing
### If an identity was already find and does answer to same strict
### Prefixed-Variable analyse.
### While Call_Argument may take the control over the 
###
### By definition :
### {PrefixedVariableSuffix}FuncStart, Generating during Call_Argument
### by declaring it by default to __main_StartServices a sub-process
### withing Call_Argument will change it to another function if the 
### Query of Storage of the Prefixed-Variable have found an identity.
### 
### These type of line a Cumuling Prefixed-Parameter of function 
### where They can change and surely grow in size. Application
### FOSME does simply received a generated list of Prefixed-Variable
### where no worry about Exception in packing that having Hard-coded
### and fast method to process the information and Specialized
### method are Packing the CSV with the Group of information. 
###
### Other uses will have to override some condition within this 
### strictly design, Unique-ID based on UUID + SHA1SUM will have to 
### provide or to override to work.
###
### Part of MRU Engine, FOSME, FunctOfStringMechnExtrc stand for
### 'Function Of Sting Mechanical Extraction' 
### - a Function receiving All Pair or Pre-Fixed Variable coming
### from a Call-Argument compatible to marshall Prefixed-variable of a 
### candidate Function Having MRU
###

### Following this example, A Mechanical String is a result of a mechanical
### addition of other String ( commonly happen inside CSV compactation) and 
### does not observe a strict relation of number of Comma separated Value 
### by number of element, to relate a presence of a correct chain of 
### information. This correct chain of information may contains data located
### at the end, having no data at all:
### Example of Mechanical String:
###
### -> astr="StrValue:__TAG__,StrValue2:__TAG2__,IntValue:__INT__," ;
###
### Does contains 2 level of delimited value where CSV=':' is finite
### and are strict relation of data, and CVS=',' are supplyed in excess
### for having not verified the end or having a pattern of insertion 
### that include the CSV=',':
###
### Data='Variable:__TAG__,'
###
### Where Data is the type of information present in a method that 
### rapidly concatenate Value and CSV at once.
###
### This example is able to count The number of CSV and does present
### a mechanical data-compaction and do have the ability to be separated 
### in group of Variable:Value. Regardless uses of pattern matching it 
### use directly the mechanism in bash called :
###
###  - Remove matching prefix pattern   [ Shortest: ${parameter#word} & 
###                                       Longest:  ${parameter##word}
###  - Remove  matching suffix pattern. [ Shortest: ${parameter%word} & 
###                                       Longest:  ${parameter%%word}
###
### Where some parser like TagParser does require a Strict Pattern matching to 
### produce a valid separation of the information. This one is free of Pattern
### matching than CSV itself. Called 'Matching-reduction' by Removing all 
### 'matching prefix pattern' inside the 'matching prefix pattern' , subsituting
###  the present Stem by reducing the size of the String by it's size and 
### re-processing the Matching-reduction.
###
### Apparatus:
###
### astr="StrValue:__TAG__,StrValue2:__TAG2__,IntValue:__INT__," ;  ;  ;      
### IntCsvCount=$( cstr=${astr//,/} ; echo $(( ${#astr} - ${#cstr} )) ) ;
### bstr="" ;
### for (( intx=0 ; intx <= ${IntCsvCount}-1 ; intx++ )) ; do
###   bstr=${astr%*${astr#*,}} ;
###   astr=${astr:${#bstr}:$(( ${#astr} - ${#bstr}))} ;
###   echo -ne "Element: ${bstr}\n" ;
### done
###
### function FunctOfStringMechnExtrc()
### - Function to Mechanically extract Group of Chainned-data and to call a 
### function with this element. String Should be packed with CSV by definition
### of Packing elements in order of :
### 'Data1:Data2,' 
###
### Where :
###  Data1 is a first group of chainned data.
###  Data2 is a second group of chainned data.
###  ':' is the CSV of the binded Data1 and Data2
###  ',' is the unmonitored CSV where it may developt a long chain and 
### not truncating the remainded second level CSV. 
###
### - This function Will pass to a Function The extracted information.
### - This function may refuse to work on packed data with non 
### mechanical-String packing. 
### - This mean it require an Prefixed-variable to enforce the action. 
###  - Enforced action will also alter the mechanical-string. 
###  - Token of identity will be send in required case . 
###  - In case receiving a Mechanical-String with information like
###  Identity token, shall require to enforce the action in identity
###  missmatch. 
###
###
###

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
if [ "${versionFOSME:=0.0.1}" == "0.0.1" ] ; then 
 
  eval $( GFCFuncName=FunctOfStringMechnExtrc GlobalFunctionCleaning ) ; 
 
  function FunctOfStringMechnExtrc()
  {
   function Verbosis()
   {
    #eval $( CAFunctName=Verbosis CAIsAddParent=False __Call_Argument ) ; 
    local -a ArrayArg=( $* ) ; 
    local -a __call_locality=( Verb Verbosis )
    local StrMsg=${VerbMsg:=__TEXT__} ; 
    local StrDevOut=${VerbDev:=/dev/stderr} ; 
    local IsVerboseState=${VerbState:=False} ;
    local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
    local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
    local IsDisplayFormatted=${VerbFormated:=True} ;
    local IsAppendMode=${VerbAppendDev:=False} ; 
    if [ "${IsVerboseState:=False}" == "True" ] ; then 
     if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
        echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
      else  
        echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
      fi
     else
      if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
         echo "${StrMsg}" ;  
      else
       if [ "${IsAppendMode:=False}" == "True" ] ; then 
        echo "${StrMsg}" >> ${StrDevOut} ;
       else
        echo "${StrMsg}" > ${StrDevOut} ;
       fi
      fi 
     fi 
    fi
   } 
   ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
   if [ "${versionCA:=0.0.0}" == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( FOSME FunctOfStringMechnExtrc ) ;
    local Arg0="${ArrayArg[0]}";  
    local StrStartMain=${FOSMEFuncStart:=__main_StartServices} ; 
    local StrParentApps=${__call_locality[1]} ; 
   elif [ "${versionCA:=0.0.0}" == "0.0.1" ] ; then 
    eval $( eval CAFunctName=FunctOfStringMechnExtrc CAIsAddParent=False __Call_Argument ) ; 
   elif [ "${versionCA:=0.0.0}" == "0.0.2" ] ; then 
    eval $( eval CAFunctName=FunctOfStringMechnExtrc CAIsAddParent=False CallArgument ) ; 
   fi  
   
   ### 
   ### By Default
   ### The configured application is SRU (Search Recent Unit)
   ### and/or Create Storage Unit ( Prefixed-Variable SRU / CSU ).
   ### 
   local BoolDisplayDebug=${FOSMEIsDisplayDebug:=True} ; 
   local BoolDisplayCmd=${FOSMEIsDisplayDebug:=False} ; 
   local BoolDisplayEntry=${FOSMEIsDisplayDebug:=False} ; 
   local BoolProvideToken=${FOSMEProvideToken:=False} ; 
   local BoolStartUntoken=${FOSMEStartUntoken:=False} ; 
   local BoolFuncIsVerb=${FOSMEUseVerbosisFunc:=False} ; 
   local BoolFuncIsPrefix=${FOSMEUsePrefixedValue:=True} ; 
   local BoolUseVTV=${FOSMEUseVTV:=False} ; 
   local StrVTVTpl=${FOSMEVTVTPL:='eval __TES__ eval __REGISTRY__ VTVValueEntry=__VAR_ENTRY__ ValueToVariable __TEE__ __FNCT__'}
   local StrVTVRegistry=${FOSMEVTVRegistry:='VTVIsArrayStyleInsert=True VTVIsQuotedValue=True VTVIsValueReAssign=True VTVIsValueToConvert=False'} ; 
   local StrInternalVTVReg=${FOSMEInternalVTVReg:='VTVIsArrayStyleInsert=True VTVIsQuotedValue=True VTVIsValueReAssign=True VTVIsValueToConvert=False'} ; 
   
   local StrDefaultCSVGroup=${FOSMECsvByPacking:=','} ;
   local StrDefaultCSVPair=${FOSMECsvByGroup:=':'} ;
   local StrFuncName=${FOSMEFuncName:=None} ; 
   local StrStreamInformation=${FOSMEStream:='StrValue:__TAG__,StrValue2:__TAG2__,IntValue:__INT__,'} ;
   local StrStreamCodec=${FOSMECodec:=text,text} ; 
   local StrStreamDTD=${FOSMEDtdCodec:=data CSVGROUP data CSVPACKING} ; 
   local StrTokenID=${FOSMESHAToken:=None} ; 
   local StrFuncOptPair=${FOSMEFuncParamPair:='CRUPair=__DATA__'} ;
   local SrtCmdAppTplPrefix=${FOSMEAppTplPrefix:=UUID=__UUID__ __OPTPAIR__=__DATA__ __FNCT__} ; 
   local StrCmdAppTplOptArg=${FOSMEAppTplOptArg:=UUID=__UUID__ __FNCT__ --__OPTPAIR__=__DATA__} ; 
   
   local StrVarList="BoolDisplayDebug,BoolDisplayCmd,BoolDisplayEntry,BoolProvideToken,BoolStartUntoken,BoolFuncIsVerb,BoolFuncIsPrefix,BoolUseVTV,StrVTVTpl,StrVTVRegistry,StrDefaultCSVGroup,StrDefaultCSVPair,StrFuncName,StrStreamInformation,StrStreamCodec,StrStreamDTD,StrTokenID,StrFuncOptPair,SrtCmdAppTplPrefix,StrCmdAppTplOptArg,StrInternalVTVReg" ; 

   local -a ArrayMsg ;
   ArrayMsg[0]="Entry in function __VAR__,__VER__" ;
   ArrayMsg[1]="Status of \n\tBoolDisplayDebug: __DisplayDebug__\n\BoolDisplayCmd: __DisplayCmd__\n\BoolDisplayEntry: __DisplayEntry__\n" ; 
   ArrayMsg[2]="Text Query: __TEXT__" ; 
   
   function MatchingReductionFilter()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}";  
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ; 
    fi   
    
    local StrStreamLine=${StrStreamInformation} ;
    local StrChunk="" ;
    local StrTplDTD=${StrStreamDTD} ; 

    StrMsg=$( ${StrParentApps} --get ArrayMsg[2] ) ;
    StrMsg=${StrMsg//__TEXT__/${StrStreamLine}} ; 
    VerbMsg=${StrMsg} VerbHeader=DEBUG VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis

    ### A copy of the DTD and it require to parse the 1st level of CSV 
    StrTplDTD="${StrTplDTD//CSVPACKING/${StrDefaultCSVGroup}}" ;
    StrTplDTD="${StrTplDTD//${StrTplDTD//${StrTplDTD%*data ,}}/\${StrStreamLine#*,\}}" ; 
    StrTplDTD="${StrTplDTD//astr/CSVGROUP /%}" ;
    StrTplDTD="\${${StrTplDTD/data /StrStreamLine}}" ; 
    
    StrMsg="Chunk defined Algo:[__STR__]" ; 
    StrMsg=${StrMsg//__STR__/${StrTplDTD}} ;
    VerbMsg=${StrMsg} VerbHeader=DEBUG VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis
    
    # data CSVGROUP data ,
    # ${astr%*data ,}
    # data CSVGROUP
    # ${astr//${astr//${astr%*data ,}}/\${StrStreamInformation#*,\}}
    # data CSVGROUP ${StrStreamInformation#*,}
    ### Remove all Packed csv for group packing and substract StreamLine by the substitutitued string length
    ### where substitutitued string is the Packed csv removed String. 
    local IntCsvCount=$( StrCh=${StrStreamLine//${${StrDefaultCSVGroup}}/} ; echo $(( ${#StrStreamLine} - ${#StrCh} )) ) ;
    for (( intx=0 ; intx <= ${IntCsvCount}-1 ; intx++ )) ; do
      eval "StrChunk=${StrTplDTD}" ; 
      #StrChunk=${StrStreamInformation%*${StrStreamInformation#*,}} ;
      
      StrStreamLine=${StrStreamLine:${#StrChunk}:$(( ${#StrStreamLine} - ${#StrChunk}))} ;
      StrMsg="Element: __VALUE__" ; 
      VerbMsg=${StrMsg//__VALUE__/${StrChunk}} VerbHeader=DEBUG VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis
    done
    
   }
   
   function __main_StopServices()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}";  
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ; 
    fi   
    
    
   }
   
   function __main_StartServices
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}";  
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ; 
    fi   
    StrMsg=$( ${StrParentApps} --get ArrayMsg[1] ) ; 
    StrMsg=${StrMsg//__DisplayDebug__/${BoolDisplayDebug}} ; 
    StrMsg=${StrMsg//__DisplayCmd__/${BoolDisplayCmd}} ; 
    StrMsg=${StrMsg//__DisplayEntry__/${BoolDisplayEntry}} ; 
    VerbMsg=${StrMsg} VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis
    
    $( eval \
       VTVValueEntry=${StrVarList} \
       ${StrInternalVTVReg} \
       ValueToVariable ) MatchingReductionFilter ; 
   
   }
   
   local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
   local StrNameHelper="${__call_locality[1]}\n\t";
   local StrSynopsis="\n\t";
   local StrSummary="\n\t" ; 
   local StrDescription="\n\t" ;

  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    GVRIsName=True     \
    GVRIsSynopsis=True \
    GVRIsSummary=True  \
    GVRIsDesc=True     \
    GVRIOldPrefix=False  GetVarReference ${__call_locality[1]} ;
    echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ;
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    eval $( __GetVarReferenceList ) ;	
   elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
    eval $( eval VTVIsArrayStyleInsert=True  \
              VTVValueEntry=${StrVarList} \
              VTVIsQuotedValue=True       \
              VTVIsValueReAssign=True     \
              VTVIsValueToConvert=False   \
              ValueToVariable ) __main_StopServices ;
   elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
    StrMsg=${ArrayMsg[0]}; 
    StrMsg=${StrMsg//__VAR__/FOSME} ; 
    StrMsg=${StrMsg//__VER__/${versionFOSME}} ; 
    VerbMsg=${StrMsg//__VALUE__/${StrChunk}} VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolDisplayEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis

    eval $( eval VTVIsArrayStyleInsert=True  \
                 VTVValueEntry=${StrVarList} \
                 VTVIsQuotedValue=True       \
                 VTVIsValueReAssign=True     \
                 VTVIsValueToConvert=False   \
                 ValueToVariable ) ${StrStartMain} ; 
   fi
  }
  
fi   

if [ "${versionLA:=0.0.0}" == "0.0.0" ] ; then 
 eval $( GFCFuncName=LoopArray GlobalFunctionCleaning ) ;

 function LoopArray()
 {
  function Verbosis()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Verb Verbosis ) ; 
   local Arg0=${ArrayArg[0]} ; 
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local IsExtendedOutput=${VerbExtendedOut:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
      if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" ;  
      else
        echo "${StrMsg}" ;  
      fi
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" >> ${StrDevOut} ;
       else
         echo "${StrMsg}" >> ${StrDevOut} ;
       fi
      else
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" > ${StrDevOut} ;
       else
        echo "${StrMsg}" > ${StrDevOut} ;
       fi 
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
  
  function GArray()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( GA GArray ) ;
   AGIndexName=${GAIname:=None} AGArray=${GAArray:=None} AGIsVerbose=False LSPFuncStart=ArrayGetter LoopSetupProperty ;
  }
  
  function SArray()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( SA SArray ) ;
   ASValue=${SAValue:=None} ASIndexName=${SAIname:=None} ASArray=${SAArray:=None} AGIsVerbose=False LSPFuncStart=ArraySetter LoopSetupProperty ;
  }
   
  local -a ArrayArg=( $* ) ;
  local -a __call_locality=( LA LoopArray ) ;
  if [ "${versionCA:=0.0.0}" == "0.0.0" ] ; then 
    local Arg0="${ArrayArg[0]}" ;  
    local StrParentApps=${__call_locality[1]} ; 
    local StrStartMain=${LAFuncStart:=__main_StartServices} ; 
  elif [ "${versionCA:=0.0.0}" == "0.0.2" ] ; then 
    eval $( eval CAFunctName=LoopArray CAIsAddDebug=True CAIsAddParent=False CallArgument ) ;
  fi 

  local StrArrayName=${LAArray=ArrayCmd} ;
  local StrCurrentAction=${LAAction:=loop} ;
  local StrIndexUpdate=${LAIndexUpdate:=None} ;
  local StrValueUpdate=${LAValue:=None} ; 
  local StrFunctionName=${LAFuncName:=GArray} ; 
  local StrValueEntry=${LAFuncValEntry:=UUID} ; 
  local StrAppsVarList=${LAFuncVarList:=None} ; 
  local BoolQuoteOnValue=${LAIsQuotingValue:=False} ;
  local StrDevErr=${LAOutputRedir:=/dev/stderr} ;  
  local StrVTVRegistry=${LAFuncVTV:=VTVIsWhiteList=True,VTVIsArrayStyleInsert=True,VTVIsValueReAssign=True,VTVIsValueToConvert=False,VTVIsArrayStyleInsert=True,VTVIsQuotedValue=True} ; 
  local StrVarList="StrParentApps,StrStartMain,StrArrayName,StrCurrentAction,StrIndexUpdate,StrValueUpdate,StrFunctionName,StrValueEntry,StrAppsVarList,StrVTVRegistry,BoolQuoteOnValue,StrDevErr,${StrAppsVarList}" ;
  
  ### 
  ### Action performed in 'LAAction' :
  ### loop         : Will perform a simple loop and enumerate both index 
  ###                and value of this one. 
  ###
  ### update       : Will Update the Array in 'LAArray' by specifying
  ###                following prefixed-variable : 
  ###                - LAIndexUpdate
  ###                    - Index name in Associative Array.
  ###                - LAValue
  ###                    - The value to add or update inside 
  ###                      the associative Array. 
  ###
  ### function     : Will perform a loop and each element will passed to
  ###                your function. As long you have filled theses 
  ###                prefixed-variable:
  ###                - LAFuncName 
  ###                  - The Function Name required to loop. 
  ###                - LAFuncValEntry
  ###                  - Inside which prefixed variable to transmit your value.
  ###                  - Telling to LAFuncValEntry=Arg1 will push the value 
  ###                  inside the Arg[1] of function call. 
  ###
  ###
  ### function_vtv : Will perform a loop and each element will be passed to 
  ###                your function. As long you have filled prefixed-variable
  ###                belong to ValueToVariable, including annexing all Variable
  ###                name to a VarList which transmit value to your function/ 
  ###                - LAFuncVarList
  ###                  - The variable used in your main-function or in global
  ###                  mode. This is to help-you transporting value required in
  ###                  your function if they already own specific 
  ###                  variable-assignation type and specific 
  ###                  assignation-operation.
  ###                - LAFuncVTV 
  ###                  - Some are already defined and are  important, you can add
  ###                  some extra. 
  ###                - LAFuncValEntry
  ###                  - Required as Action 'function', Function-name is to be 
  ###                    supplied. 
  ###
  ### help          : Will display the help provided by GetVarReference
  ###
  ### get           : Will report variable name value. Suggesting to read for 
  ###                 Internal variable name, it accept array member in form
  ###                 ARRAY[INDICE]. You should provide the variable name in 
  ###                 first argument of a function. 
  ###
  ###

  local ArrayLoopCmd ; 
  local IntIndexCmd=0 ; 
  ArrayLoopCmd[0]="""__VAL_ENTRY__=__QUOTE____VALUE____QUOTE__ __FUNCT__""" ; 
  ArrayLoopCmd[1]="""__FUNCT__ __QUOTE____VALUE____QUOTE__""" ; 
  ArrayLoopCmd[2]="""eval \$( eval __VTV__ \
                     VTVWhiteListTransfert=UUID  \
                     VTVValueEntry=__VARLIST__ \
                     ValueToVariable ) __FUNCT__ """
  ArrayLoopCmd[3]="""eval \$( eval __VTV__ \
                     VTVWhiteListTransfert=UUID  \
                     VTVValueEntry=__VARLIST__ \
                     ValueToVariable ) __FUNCT__ __QUOTE____VALUE____QUOTE__ """

  local -a ArrayMsg ; 
  ArrayMsg[0]="Internal Help." ; 
  ArrayMsg[1]="Action imply a Getter to a variable(__VAR__)" ; 
  ArrayMsg[2]="\nElement number: __ORDER__\nindex: __INDEX__,\nvalue:[__VALUE__\t]" ; 
  ArrayMsg[3]="Passing a function in a loop." ; 
  ArrayMsg[4]="Eval command passing all the value to ValueToVariable." ; 
  ArrayMsg[5]="Eval command passing values to ValueToVariable, but passing to Arg1 of function." ; 
  ArrayMsg[6]="Passing a function in a ValueToVariable function.\n\tWith property of __SPEC__" ; 
  ArrayMsg[7]="__KEY__:[ __VALUE__ ]" ; 
  ArrayMsg[8]="Simply looping accross index-name of __ARRAY__" ; 
  ArrayMsg[9]="Entry in function __FUNC__." ; 
  ArrayMsg[10]="All Index of __ARRAY__:[ __INDEX__ ]" ; 

  local StrMsg=${ArrayMsg[9]} ; 
  StrMsg=${StrMsg//__FUNCT__/${__call_locality[1]}} ; 
  VerbMsg=${StrMsg} VerbState=${BoolDisplayEntry} VerbHeader="ENTRY" VerbEvalForm=False VerbFormated=True VerbDev=${StrDevErr} Verbosis ; 

  eval """local AIndex=( \${!${StrArrayName}[@]} ) """ ;
  StrMsg=${ArrayMsg[10]} ; 
  StrMsg=${StrMsg//__ARRAY__/${StrArrayName}} ; 
  StrMsg=${StrMsg//__INDEX__/${AIndex[@]}} ; 
  VerbMsg=${StrMsg} VerbState=${BoolDisplayDebug} VerbHeader="DEBUG" VerbEvalForm=False VerbFormated=True VerbDev=${StrDevErr} Verbosis ; 

  local StrTpl ;
  local CharQuote=$( printf "\042" '%c' ) ; 

  ###
  ###  Section 
  if [ "${StrCurrentAction:=loop}" == "help" ] ; then 
   echo -ne "${ArrayMsg[0]}\n" > /dev/stderr ; 
   GetVarReference ${__call_locality[1]} ; 
  elif [ "${StrCurrentAction:=loop}" == "get" ] ; then 
   ###
   ###  Section Action==get
    StrMsg=${ArrayMsg[1]} ; 
    StrMsg=${StrMsg//__VAR__/${ArrayArg[0]}} ; 
    #echo -ne "${StrMsg}\n" > /dev/stderr ; 
    VerbMsg=${StrMsg} VerbState=${BoolDisplayDebug} VerbHeader="DEBUG" \
    VerbEvalForm=False VerbFormated=True VerbDev=${StrDevErr} \
    Verbosis ; 
    eval """local ArgGet=\${${ArrayArg[0]}}"""  ;
    VerbMsg=${ArgGet} VerbState=True VerbEvalForm=True \
    VerbFormated=False VerbDev=/dev/stdout \
    Verbosis ; 
    #echo -ne """${ArgGet}\n"""  ;
  elif [ "${StrCurrentAction:=loop}" == "loop" ] ; then 
   ###
   ###  Section Action==loop
   StrMsg=${ArrayMsg[8]} ; 
   StrMsg=${StrMsg//__ARRAY__/${StrArrayName}} ;
   VerbMsg=${StrMsg} VerbState=${BoolDisplayEntry} VerbHeader="ENTRY" \
   VerbEvalForm=False VerbFormated=True VerbDev=${StrDevErr} \
   Verbosis ; 
   
   for (( intx=0 ; intx <= $(( ${#AIndex[@]}-1 )) ; intx++ )) ; do 
    eval """StrArrayValue=\${${StrArrayName}[${AIndex[${intx}]}]}""" ; 
    StrMsg=${ArrayMsg[2]} ; 
    StrMsg=${StrMsg//__ORDER__/${intx}} ; 
    StrMsg=${StrMsg//__INDEX__/${AIndex[${intx}]}} ; 
    StrMsg=${StrMsg//__VALUE__/${StrArrayValue}} ; 
    VerbMsg=${StrMsg} VerbState=${BoolDisplayDebug} VerbHeader="DEBUG" \
    VerbEvalForm=False VerbFormated=True VerbDev=${StrDevErr} \
    Verbosis ; 
    #echo -ne "${StrMsg}\n" > /dev/stderr ;  
   done  
  elif [ "${StrCurrentAction:=loop}" == "update" ] ; then
   ###
   ###  Section Action==update
   ###
    eval SAIname="${StrIndexUpdate}" \
    SAArray="${StrArrayName}" \
    SAValue="${StrValueUpdate}" \
    SArray ;
  elif [ "${StrCurrentAction:=loop}" == "function" ] ; then 
   ###
   ###  Section function
   ###
   #echo -ne "${ArrayMsg[3]}\n" > /dev/stderr ; 
   VerbMsg=${ArrayMsg[3]} VerbState=${BoolDisplayEntry} VerbHeader="ENTRY" \
   VerbEvalForm=False VerbFormated=True VerbDev=${StrDevErr} \
   Verbosis ; 
   IntIndexCmd=0 ; 
   if [ "${StrValueEntry:=UUID}" == "Arg1" ] ; then 
    IntIndexCmd=1 ; 
   fi

   StrTpl="${ArrayLoopCmd[${IntIndexCmd}]}" ; 
   if [ "${BoolQuoteOnValue:=False}" == "True" ] ; then 
    StrTpl=${StrTpl//__QUOTE__/${CharQuote}} ; 
   else
    StrTpl=${StrTpl//__QUOTE__/} ; 
   fi 
   
   for (( intx=0 ; intx <= $(( ${#AIndex[@]}-1 )) ; intx++ )) ; do 
    eval """StrArrayValue=\${${StrArrayName}[${AIndex[${intx}]}]}""" ; 
    StrCmd=${StrTpl} ; 
    StrCmd=${StrCmd//__VAL_ENTRY__/${StrValueEntry}} ; 
    StrCmd=${StrCmd//__VALUE__/${StrArrayValue}} ; 
    StrCmd=${StrCmd//__FUNCT__/${StrFunctionName}} ; 
    
    VerbMsg=${StrCmd} VerbState=${BoolDisplayCmd} VerbHeader="CMD" \
    VerbEvalForm=False VerbFormated=True VerbDev=${StrDevErr} \
    Verbosis ; 
    eval ${StrCmd} ; 
    StrMsg=${ArrayMsg[2]} ; 
    StrMsg=${StrMsg//__ORDER__/${intx}} ; 
    StrMsg=${StrMsg//__INDEX__/${AIndex[${intx}]}} ; 
    StrMsg=${StrMsg//__VALUE__/${StrArrayValue}} ; 
    VerbMsg=${StrMsg} VerbState=${BoolDisplayDebug} VerbHeader="DEBUG" \
    VerbEvalForm=False VerbFormated=True VerbDev=${StrDevErr} \
    Verbosis ; 
   done  
  elif [ "${StrCurrentAction:=loop}" == "function_vtv" ] ; then 
   ###
   ###  Section Action==function_vtv
   ###
   IntIndexCmd=2 ;
   StrAddText="${ArrayMsg[4]}" ; 
   if [ "${StrValueEntry:=UUID}" == "Arg1" ] ; then 
    IntIndexCmd=3 ; 
    StrAddText="${ArrayMsg[5]}" ; 
   fi

   StrMsg=${ArrayMsg[6]} ; 
   StrMsg=${StrMsg//__SPEC__/${StrAddText}} ; 
   VerbMsg=${StrMsg} VerbState=${BoolDisplayEntry} VerbHeader="ENTRY" \
   VerbEvalForm=False VerbFormated=True VerbDev=${StrDevErr} \
   Verbosis ; 
   #echo -ne "${StrMsg}\n" > /dev/stderr ; 
   #eval """StrArrayValue=\${${StrArrayName}[${AIndex[${intx}]}]}""" ; 
   StrTempVarList="${StrVarList}" ;
   
   StrTpl="${ArrayLoopCmd[${IntIndexCmd}]}" ; 
   if [ "${BoolQuoteOnValue:=False}" == "True" ] ; then 
    StrTpl=${StrTpl//__QUOTE__/${CharQuote}} ; 
   else
    StrTpl=${StrTpl//__QUOTE__/} ; 
   fi 


   for (( intx=0 ; intx <= $(( ${#AIndex[@]}-1 )) ; intx++ )) ; do 
    eval """StrArrayValue=\${${StrArrayName}[${AIndex[${intx}]}]}""" ; 
    StrVarList="${StrVarList},StrArrayValue=${CharQuote}${StrArrayValue}${CharQuote}" ; 
    StrCmd=${StrTpl} ; 
    StrCmd=${StrCmd//__VTV__/${StrVTVRegistry//,/ }} ;
    StrCmd=${StrCmd//__VARLIST__/${StrVarList}} ;
    StrCmd=${StrCmd//__FUNCT__/${StrFunctionName}} ;
    StrCmd=${StrCmd//__VALUE__/${StrArrayValue}} ;
    
    VerbMsg=${StrCmd} VerbState=${BoolDisplayCmd} VerbHeader="CMD" \
    VerbEvalForm=False VerbFormated=True VerbDev=${StrDevErr} \
    Verbosis ; 
  
    eval ${StrCmd} ; 
    StrVarList=${StrTempVarList} ; 
   done  
   
  fi 
 }
fi #End-if versionLA==0.0.0

 ### ValueToVariable :
 ###
 ###
 ###	Full-length example : 
 ### Including 1 example :
 ###
 ### $> 
 ### 
 ### - It Open Windows from Zenity with parameter for Text-info in editable
 ### mode.
 ### 
 ### It Open by default a uuid-like temporary file. There is no actual was
 ### to modify the name, but assuming the implementation of ZenityShellEval
 ### imply a limited acces to shell, you might recuper information from shell
 ### or futur adding to transfert a name or simple renaming the uuid-like
 ### file-name... This is to prevent auto-execution of a script from 
 ### canned-design by playing with without having all clearly create your 
 ### shell script and/or having fully pseudo-code explained and having 
 ### confirmation of your design work... 

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
if [ "${versionVTV:=0.0.2}" == "0.0.2" ] ; then 
 
  #unset ValueToVariable
  eval $( GFCFuncName=ValueToVariable GlobalFunctionCleaning ) ; 

### ----                                                                           ----
### ---- Because version 0.0.1 did not work, trying to make things clear with this ----
### ---- definition on developping safe function                                   ----
### 
### For some reason, ValueToVariable need to be changed, since unknow reason
### comming from gtk-terminal istance that do not clean function en even with
### using unset and new declaration by file leave breathless having problems 
### to resolve the problems in loop of BoolVarTest, in replacement of BoolVarTestVarCreation
### in hope reducing length of pre-fixed var, thi function will be tested with version 
### 0.0.2 of ValueToVariable that loop inside declaration of BoolVarTest and both 
### BoolVarTestVarCreation but not alone... 
### This version will work with copy of  StrValueParser , and reduce the copy size by 
### retrieving the Variable name . 
###
### The goal still the same :
### 1 - Respect Polish notation for all filtered value.
###  -> which mean rejected variable for wrong value should be observed.
###  -> rejected value should not interrupt the feed and should only 
###  -> not made it available.  
###  -> may agree next development of a white-list after first conclusion. 
### 2 - Notation in form of :
###     Var1=${Var1} Var2=${Var2} is imperative
### 3 - Uses of this exterior format observed should be keept:
###     eval $( VTV...=... VTV...=... VTV...=... ValueToVariable ) __FUNCTION
###  -> Can be good to implement a IsEvalFunctionThrow=True in next version
###
  function ValueToVariable( )
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( VTV ValueToVariable ) ;
   local Arg0="${ArrayArg[0]}" ;
   
   local StrReAssign=${VTVValueRe:=StrTestA_1,StrTestB_1,StrCTest1_1,StrDTest2_1,IntA_1,IntB_1,IsTestA_1,IsNotTestA_1}
   local StrValueParser=${VTVValueEntry:=StrTestA,StrTestB,StrCTest1,StrDTest2,IntA,IntB,IsTestA,IsNotTestA};
   local IsEntryInComaSep=${VTVIsArrayStyleInsert:=False} ; 
   local StrSepList=${VTVSepList:=",;:"} ;
   local IntValueSep=${VTVISeparatorType:=0};
   local StrVarFilter=${VTVVarFilter:=[SIB][tnos][a-zA-Z0-9_]*__SEP__} ; 
   local StrRejectionList=${VTVRejectionFilter:=[a-zA-Z0-9_]*} ; 
   local IsWhiteList=${VTVIsWhiteList:=False} ;
   local StrWhiteListAgree=${VTVWhiteListTransfert:=CFLAGS,LDFLAGS,CC,GCC,CPP} ;
   local IsValueSimpleConvert=${VTVIsValueToConvert:=True} ;
   local IsValueToReAssign=${VTVIsValueReAssign:=True} ;
   local StrPrefix=${VTVReasignPrefix:=None} ;
   local StrSuffix=${VTVReasignSuffix:=None} ;
   local IsValueIndTransform=${VTVIsTransformed:=False} ;
   local IsValueTransScript=${VTVIsTransHadScript:=False} ;
   local IsDisplayDebug=${VTVIsDebugDisplay:=False} ; 
   local IsSlowDebugOut=${VTVIsSlowDebug:=False} ; 
   local BoolIsQuoteValue=${VTVIsQuotedValue:=False} ; 
   local StrDefaultTransScript=${VTVITransformScript:=None} ;
   local StrScriptApps=${VTVAppsScripter:=/usr/bin/gawk} ;
   local StrScriptAppsOpt=${VTVAppsScripterOpt:=--field-separator=__SEP__ --file=__FILE__ __VAR_ASSIGN__ }
   local StrExtraVarScript=${VTVScriptInterVar:=--assign=__VAR__=__VALUE__} ;
   local StrScriptParser=${VTVAppsParser:=__APPS__ __OPT__} ;
    
   function Verbosis()
   {
    local -a ArrayArg=( $* ) ; 
    local -a __call_locality=( Verbosis Verb );
    local StrMsg=${VerbMsg:=__TEXT__} ; 
    local StrDevOut=${VerbDev:=/dev/stderr} ; 
    local IsVerboseState=${VerbState:=False} ;
    local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
    local IsDisplayFormatted=${VerbFormated:=True} ;
    if [ "${IsVerboseState:=False}" == "True" ] ; then 
     if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     else
       echo -ne "${StrMsg}\n" > ${StrDevOut} ;
     fi 
    fi
   } 
   ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
    
   ### Odd information treted by sed . 
   ### local StrAppsName=${VTVAppsName:=/bin/sed} ; 
   ### local StrAppsOpt=${VTVAppsOpt:=-r} ;
   ### local StrDefaultSedScript='s/([SIBA][tnosr][tror]*[a-zA-Z0-9]+)/\$\{\1\}/g' ;
   ### local StrDefaultAssignScript='s/([SIBA][tnosr][tror]*[a-zA-Z0-9]+)/\1=\$\{\1\}/g' ;
   ### local StrDefaultTransform=${VTVDefaultTransform:='s/([SIB][tnos][tro][a-zA-Z0-9]+)/\\$\{\1\}/g'} ;

   function VarFilter()
   {
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( VF VarFilter ) ;
    local Arg0="${ArrayArg[0]}" ;
    local StrParserReassign=$( ValueToVariable --get StrReAssign ) ; 
    local StrParserList=$( ValueToVariable --get StrValueParser ) ;
    local StrListSep=$( ValueToVariable --get StrSepList ) ;
    local IntCharSel=$( ValueToVariable --get IntValueSep ) ;
    local StrRejectionFilter=$( ValueToVariable --get StrRejectionList ) ; 
    local StrFilter=$( ValueToVariable --get StrVarFilter ) ; 
    local StrFilter2=${StrVarFilter} ; 
    local StrPrefix=$( ValueToVariable --get StrPrefix ) ; 
    local StrSuffix=$( ValueToVariable --get StrSuffix ) ; 
    local IsValueIndTransform=$( ValueToVariable --get IsValueIndTransform ) ; 
    local IsValueToReAssign=$( ValueToVariable --get IsValueToReAssign ) ; 
    local IsValueSimpleConvert=$( ValueToVariable --get IsValueSimpleConvert ) ; 
    local IsSlowDebugOut=$( ValueToVariable --get IsSlowDebugOut ) ; 
    local BoolIsQuoteValue=$( ValueToVariable --get VTVIsQuotedValue ) ; 
    local IsWhiteList=$( ValueToVariable --get IsWhiteList ) ; 
    local StrWhiteListAgree=$( ValueToVariable --get StrWhiteListAgree ) ;
    local -a ArrayWhiteList=( ${StrWhiteListAgree//,/ } ) ;  
    local StrNPrefix="" ;  
    local StrNSuffix="" ; 
    local StrCharSep=${StrListSep:${IntCharSel}:1} ; 
    StrFilter=${StrFilter//__SEP__/${StrCharSep}} ; 
    StrFilter2=${StrFilter2__SEP__/${StrCharSep}} ; 
    local -a ArrayVarList=(  ) ; 
    local -a ArrayRejectionList=( ) ; 
    local IntNotEmptyList=1 ;
    local IntSizeBuffe=0 ; 
    local StrNewVarEntry="" ; 
    ### Changing side , now becoming IsValueToReAssign 
    
    if [ "${BoolIsQuoteValue:=False}" == "True" ] ;  then 
     StrMsg="Application is Quoting value from assignation." 
     VerbMsg="${StrMsg}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
    fi
    if [ "${IsValueToReAssign:=False}" == "False" ] ;  then 
     ### Now IsValueToReAssign == False 
     StrMsg="Application is not Transforming Variable during passing-thru action."
     VerbMsg="${StrMsg//__VAR__/${StrNewVarEntry}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
    ### End of if-"${IsValueToReAssign:=True}"
    else
     ### Now IsValueToReAssign == True 
     StrMsg="Application is Transforming Variable during passing-thru action."
     VerbMsg="${StrMsg}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
     
     if [ "${StrPrefix:=None}" != "None" ] ; then 
      StrMsg="Application Add a Prefix named='__PREFIX__' during passing-thru action."
      VerbMsg="${StrMsg//__PREFIX__/${StrPrefix}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
      StrNPrefix=${StrPrefix} ; 
     # End of if-${StrPrefix}
     fi
     
     if [ "${StrSuffix:=None}" != "None" ] ; then 
      StrMsg="Application Add a Suffix named='__SUFFIIX__' during passing-thru action."
      VerbMsg="${StrMsg//__SUFFIIX__/${StrSuffix}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
      StrNSuffix=${StrSuffix} ; 
     # End of if-${StrSufix}
     fi 
    
    fi 
    
    ### Exchanging side : become IsValueSimpleConvert 
    if [ "${IsValueSimpleConvert:=False}" == "True" ] ; then 
     StrMsg="Application Does depend of a table-of Reassignation see VTVValueRe "
     VerbMsg="${StrMsg}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
    else
     StrMsg="Application Does not depend of a table-of Reassignation see VTVValueRe "
     VerbMsg="${StrMsg}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
  
    fi
   
    StrMsg="Initial Variable List: __VAR__ " ; 
    VerbMsg="${StrMsg//__VAR__/${StrParserList}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
    
    StrMsg="Initial Filter To Split Member between Separator '__SEP__' : '__FILTER__' " ; 
    StrMsg=${StrMsg//__SEP__/${StrCharSep}} ; 
    StrMsg=${StrMsg//__FILTER__/${StrFilter}} ; 
    VerbMsg="${StrMsg}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
    local StrTestFilter="" ; 
    local IntPolishForm=0 ; 
    while [ ${IntNotEmptyList:=1} -ne 0 ] ; do
      ### We do start with state IntPolishForm, for test not done at this moment. 
      IntPolishForm=0
      ### StrNewVarEntry="${StrParserList/#[SIB][tnos][a-zA-Z0-9_]*${StrCharSep}}" ; 
      ### Require detection of ',' or __SEP__ if the last one is only the variable name
      ### it stay in negative parsing .
      StrNewVarEntry="" ; 
      StrNewVarReassign="" ; 
      
      if [ "${StrParserList//${StrCharSep}/}" == "${StrParserList}" ] ; then 
       StrMsg="No New Separator '__SEP__' found inside Parsing String." ;
       VerbMsg="${StrMsg//__SEP__/${StrCharSep}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
       StrNewVarEntry=${StrParserList} ;
       StrParserList=${StrParserList//${StrNewVarEntry}/} ; 

       eval """StrTestFilter=${StrNewVarEntry//${StrFilter//${StrCharSep}/}/} ;"""
       if [ "${StrTestFilter:=None}" == "None" ] ; then 
        ### variable name is normal polish-like noted form 
        IntPolishForm=1 ; 
       else 
        ### pass2 we do not own empty variable assigned by default to None.
        ### pass2 reducing to a global match.
        StrTestFilter=${StrTestFilter//${StrRejectionFilter}/}
        if [ "${StrTestFilter:=None}" == "None" ] ; then 
         IntPolishForm=0
         ### I do have variables like Cflags, CFLAGS, LDFLAGS, Ldflags...
        fi 
       fi 
      
      else
       eval StrNewVarEntry="${StrParserList/#${StrFilter}}" ; 
       ### This case, apply to a more global case , not polish-like variable name are subject
       ### to pass-thru String Operator ${__VARNAME__/#...[SIB][tnos][tro][a-zA-Z0-9] 
       ### so it's important to reduce the string by the filter and will be consider as 
       ### rejected and will not be filterred, Unlike Polis-like var-name will. 
       ### After a second-filter like more global in  StrRejectionFilter will erase it 
       ### consider having a Rejected var name. 
       StrMsg="New Entry:__VAR__" ;
       VerbMsg="${StrMsg//__VAR__/${StrNewVarEntry}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
       
       ### pass 1 , reduce with StrFilter.
       eval """StrTestFilter=${StrNewVarEntry//${StrFilter//${StrCharSep}/}/} ;"""
       StrMsg="Pass1 PolishNoted variable rejected:__VAR__" ;
       VerbMsg="${StrMsg//__VAR__/${StrTestFilter:=None}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 

       ### pass 1 will, only reduce to nil polish-like variable. 
       if [ "${StrTestFilter:=None}" == "None" ] ; then 
        ### variable name is normal polish-like noted form 
        IntPolishForm=1 ; 
       else 
        ### pass2 we do not own empty variable assigned by default to None.
        ### pass2 reducing to a global match.
        StrTestFilter=${StrTestFilter//${StrRejectionFilter}/}
        if [ "${StrTestFilter:=None}" == "None" ] ; then 
         IntPolishForm=0
         ### We do have variable le Cflags, CFLAGS, LDFLAGS, Ldflags...
        fi 
       fi 
      fi 
      ### At this moment we do compare string and string stipped from 
      ### Separator. At the end this string does equal the striped string 
      ### for having no __SEP__ to remove, so we end with the name of the last variable.
      StrParserList=${StrParserList//${StrCharSep}${StrNewVarEntry}/} ;
     
      if [ "${IsDisplayDebug:=False}" == "True" ] ; then 
       if [ "${IsSlowDebugOut:=False}" == "True" ] ; then 
         sleep 1 ; 
       fi ; 
      fi 
      
      
      ### Changinf side, become IsValueSimpleConvert
      if [ "${IsValueSimpleConvert:=False}" == "True" ] ; then 
       if [ "${StrParserReassign//${StrCharSep}/}" == "${StrParserReassign}" ] ; then 
        StrMsg="No New Separator '__SEP__' found inside Re-Assignation List." ;
        VerbMsg="${StrMsg//__SEP__/${StrCharSep}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
        StrNewVarReassign=${StrParserReassign} ; 
        StrParserList=${StrParserReassign//${StrNewVarReassign}/} ; 
       else
        StrNewVarReassign="${StrParserReassign/#${StrFilter2}}" ;
        StrParserReassign=${StrParserReassign//${StrCharSep}${StrNewVarReassign}/} ;
       fi
      fi 
     
     ### It important to remove the "Separator + Variable name" to ensure Buffer become empty.
     ### Noted: The processor '/#' inside a String only output what is lying at the end  and 
     ### we do filtering a last value without the remaining char and not appearing inside the 
     ### StrNewVarEntry so adding the char-separator to remove is important. 
      ### Changing Side, become IsValueToReAssign
      if [ "${IsValueToReAssign:=False}" == "True" ] ; then 
        ### Changing Side, become IsValueSimpleConvert
        if [ "${IsValueSimpleConvert:=False}" == "True" ] ; then 
         ArrayVarList[${#ArrayVarList[@]}]="""${StrNPrefix}${StrNewVarReassign}${StrNSuffix}=\${${StrNewVarEntry}}""" ;
         ### IsValueSimpleConvert-> True, IsValueToReAssign->True
        else
         ### Now IsValueSimpleConvert==False
         if [ ${IntPolishForm:=0} -eq 1  ] ; then 
          ArrayVarList[${#ArrayVarList[@]}]="""${StrNewVarEntry}=\${${StrNewVarEntry}}""" ; 
         elif [ "${IsWhiteList:=False}" == "True" ] ; then 
          ### White-list can be inserted here after ele claude from this statement. 
          IntScanWhite=0 ; 
          for StrNameVar in ${ArrayWhiteList[@]} ; do 
           if [ "${StrNewVarEntry}" == "${StrNameVar}" ] ; then 
            IntScanWhite=1 ; 
           fi 
          done
          if [ ${IntScanWhite:=0} -eq 1 ] ; then 
           StrMsg="Element __VAR__ is White-Listed, added to normal flow."
           VerbMsg="${StrMsg//__VAR__/${StrNewVarEntry}}" VerbHeader="WHITELIST-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
           if [ "${BoolIsQuoteValue:=False}" == "True" ] ; then 
            ArrayVarList[${#ArrayVarList[@]}]="""${StrNewVarEntry}=\"\${${StrNewVarEntry}}\"""" ; 
           else
            ArrayVarList[${#ArrayVarList[@]}]="""${StrNewVarEntry}=\${${StrNewVarEntry}}""" ; 
           fi
          fi    
         ### end of elif "${IsWhiteList:=False}" from if-${IntPolishForm:=0}
         else
           if [ "${BoolIsQuoteValue:=False}" == "True" ] ; then 
            ArrayRejectionList[${#ArrayRejectionList[@]}]="${StrNewVarEntry}" ;
           else
            ArrayRejectionList[${#ArrayRejectionList[@]}]=${StrNewVarEntry} ;
           fi
         fi 
         ### IsValueSimpleConvert-> False, IsValueToReAssign->True
        ### End of if "${IsValueSimpleConvert:=False}"
        fi 
      ### End of if-"${IsValueToReAssign:=False}"
      else
        ### Now IsValueToReAssign == False 
        ### Changing side, becoming IsValueSimpleConvert 
        if [ "${IsValueSimpleConvert:=False}" == "True" ] ; then 
         if [ "${BoolIsQuoteValue:=False}" == "True" ] ; then 
          ArrayVarList[${#ArrayVarList[@]}]="""${StrNewVarReassign}=\"\${${StrNewVarEntry}}\"""" ;
         else
          ArrayVarList[${#ArrayVarList[@]}]="""${StrNewVarReassign}=\${${StrNewVarEntry}}""" ;
         fi
         ### Note there is already protection inside if [ "${IsValueIndTransform:=False}... 
         ### and we do prevent putting nil-sized variable but should pose a problems . 
         ### IsValueSimpleConvert-> False IsValueToReAssign-> True
        else
         ### Now IsValueSimpleConvert == False 
         if [ "${BoolIsQuoteValue:=False}" == "True" ] ; then 
           ArrayVarList[${#ArrayVarList[@]}]="""${StrNewVarEntry}=\"\${${StrNewVarEntry}}\"""" ;
         else
           ArrayVarList[${#ArrayVarList[@]}]="""${StrNewVarEntry}=\${${StrNewVarEntry}}""" ;
         fi
         ### Note there is already protection inside if [ "${IsValueIndTransform:=False}... 
         ### and we do prevent putting nil-sized variable but should pose a problems . 
         ### End of if-IsValueToReAssign
        fi
       ### End of if-IsValueSimpleConvert
      fi
      IntSizeBuffer=${#StrParserList} ; 
      if [ ${IntSizeBuffer:=0} -eq 0 ] ; then 
       IntNotEmptyList=0; 
       StrMsg="Reached end of StrParserList."
       VerbMsg="${StrMsg}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
       ### we do set IntNotEmptyList to 0 meaning inspecting for 
       ### possibility of having an Not Empty List is now at 0 mean
       ### no we dont own it at all because it's now at 0;
       ### End of if-IntSizeBuffer
      fi ; 
       
    done 
    StrMsg="Rejection List Parser:__VAR__" ; 
    StrListReject="${ArrayRejectionList[@]}" ; 
    VerbMsg="${StrMsg//__VAR__/${StrListReject:=None}}" VerbHeader="" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
    
    local StrStreamOut; 
    if [ "${BoolIsQuoteValue:=False}" == "True" ] ; then 
     StrStreamOut="${ArrayVarList[@]//=/=\"}" ;
     StrStreamOut=${StrStreamOut// /\" } ;
     StrStreamOut="${StrStreamOut}\" " ;
    else
    StrStreamOut=${ArrayVarList[@]} ; 
    fi
    ###VerbMsg="${ArrayVarList[@]}" VerbHeader="" VerbFormated=False VerbState=True StrDevOut=/dev/stdout  Verbosis ; 
    
    StrMsg="Variable Parser:__VAR__" ; 
    VerbMsg="${StrMsg//__VAR__/${StrStreamOut}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
    
    eval ${StrStreamOut} ; 
  }
   
   function AppsParser()
   {
    local -a ArrayArg=( $* ) ;   
    local -a __call_locality=( AP AppsParser ) ;
    local Arg0="${ArrayArg[0]}" ;
    local -a ArrayGetter=( StrSepList IsDisplayDebug IsValueTransScript StrDefaultTransScript StrScriptApps StrScriptAppsOpt StrScriptParser StrValueParser  ) ; 
    local -a ArrayTagParser=( __APPS__:StrScriptApps __OPT__:StrScriptAppsOpt __SEP__:StrCharSep __FILE__:StrDefaultTransScript __VAR_ASSIGN__:StrExtraVarScript ) ; 
    ### local StrSepList=$( ValueToVariable --get StrSepList ) ;
    ### local IntValueSep=$( ValueToVariable --get IntValueSep ) ;
    local StrCharSep=${StrSepList:${IntValueSep}:1} ;
    
    ### Loop to search thru Getter all Master variable from top function 
    for StrVar in ${ArrayGetter[@]} ; do 
     $( eval """${StrVar}=\$( ValueToVariable --get ${StrVar} )""" ) ; 
    done 
    
    local StrParserCmd="${StrScriptParser}" ; 
    ### Loop for parsing tag and variable from  ArrayTagParser which is a collection
    ### of required variable to form a syntax of a command . The example taking
    ### gawk or gnu-awk but can be adjusted on shell by changing pre-fixed variable 
    ### VTVAppsParser VTVScriptInterVar VTVAppsScripterOpt VTVAppsScripter ... 
    for StrPairTag in ${ArrayTagParser[@]} ; do 
     StrPairLeft=${StrPairElem/%:[SIBA][tnosr][tror]*[a-zA-Z0-9]*/};
     StrPairRight=${StrPairElem/#__[a-zA-Z0-9]*:/};    
     $( eval """StrParserCmd=${StrParserCmd//${StrPairLeft}/\${${StrPairRight}}}""" ) ; 
    done 
    StrMsg="CmdLine: __CMDLINE__"
    VerbMsg="${StrMsg//__CMDLINE__/${StrParserCmd}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr Verbosis ; 
    eval $( ${StrParserCmd} ) ; 
   
   }
   
   function __main_StartServices()
   {
     local -a ArrayArg=( $* ) ;   
     local -a __call_locality=( Main __main_StartServices ) ;
     local Arg0="${ArrayArg[0]}" ;
     local IsValueSimpleConvert=$( ValueToVariable --get IsValueSimpleConvert ) ;  
     local IsValueTransScript=$( ValueToVariable --get IsValueTransScript ) ; 
     if [ "${IsValueSimpleConvert:=True}" == "True" ] ; then 
      VarFilter ; 
     elif [ "${IsValueToReAssign:=False}" == "True" ] ; then 
      VarFilter ;
     elif [ "${IsValueTransScript:=False}" == "True" ] ; then 
      AppsParser ; 
      ### Note inside IsValueTransScript Meaning it does not worry of all other 
      ### exception like VTVIsValueToConvert VTVIsValueReAssign VTVIsTransformed
      ### because script calling is exterior and do not interfer with Boolean value
      ### reserved for VarFilter . 
     else
     ### Changing role it's not VTVIsValueToConvert to use first , but VTVIsValueReAssign
      StrMsg="At least VTVIsValueReAssign or VTVIsTransHadScript should be True."
      VerbMsg="${StrMsg}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=True VerbDev=/dev/stderr Verbosis ; 
     fi
   }

   local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
   local StrNameHelper="ValueToVariable\t\tThe Fnct.D Mechanisme acting as Re-Copy Pass-Thru Variable in Variable authorized to be transfered from Higher-level function to Sub-Level Function.";
   local StrSynopsis="Since implementation of TSR resident like Python command-not-found or any type of Layer in interactive Shell in Both Curse Bash Command-Line and/or xterminal, gtk-terminal, The behavior of function is not clear and are not totally accessible. ValueToVariable eliminate problems of declare and following constraint, local variable can travel thru sub-function. ";
   local StrSummary="ValueToVariable allow creation of variable Assignation before running the application or function. Creating a code evaluation it return in form of VAR1=\${VAR1}  VAR2=\${VAR2} Application ; Where VAR1,VAR2 will be already available inside nestled function or real-function . If the are made from Top-function, Shell command like declare make variable existing beyond Master Function Body, which overcrowding variable after death or termination of function uses if unset still existing and increase amount of memory without cleaning it. The mechanism is Filtering throught and acting like Filter over Polish Notation Respect to enforce uses of Strict Notation to have an idea of their uses. Since Polish notation is adopted inside the Fnct.D, uses of evaluation brace to expand code inside function like BoolVarTest( newest version of BoolVarTestVarCreation) expanding Preambule-code, The If-N clause and it's Assertion code inside function to make parseable function to analyse it faster and discover bottle-neck by developping more assertion clause and action. ValueToVariable is madatory associated with  Prompt mechanism to pass the __main_StartServices and receive the authorized variable list. Must read inside Description most-standard case Prefixed Variable, describe most frequent uses of Prefixed-Variable for common task between Function. While Whitelist is an accute case to transfert External variable being recognized by the Shell, some function had becoming totally blind behind variable visibility, WhiteList is popular with compiler, link-edition and pre-processor application. "
   local StrDescription="\nComment over Obsolete Prefixed-Var\nThey are not in effect and might be re-attributed. Initially work altogether VTVValueRe VTVIsTransformed were removed from prototype aka ancester of BoolVarTestVarCreation coming from old_var_fnct_lib. Where fews functions filters the contents of this function with 'declare -f' to inspect variable presence and create an assignation table, this was removed even from prototype having problems in handling the table correctly.\n\nComment over VTVAppsScripter\nDefault is Awk while some may like something else, it's also play with performance being AWK as long you define the VTVAppsParser, VTVScriptInterVar, VTVAppsScripterOpt, VTVITransformScript you can define application like Python,Ruby,Perl...\n\nComment over VTVIsWhiteList\nFor Unusual Variable name, and or information too-short for variable name, being consider like not so used but Lacking of Regularity in your code using not conformant Polish-notation variable Like Rachid1,Rachid2,Rachid3,RachidN, you must use WhiteList Option. Also same for uses of externals variable like CC,CFLAGS,LDFLAGS,GCC... These by-passing the Polish-notation filter and transfert-them after-filter Effect.\n\n\nComment over VTVRejectionFilter\nInitially inside the ValueToVariable engine it filter VTVRejectionFilter, and after filter with VTVVarFilter and what failling remain inside WhiteList and wait if Option IsWhiteList is trigger.\n\nComment over VTVIsArrayStyleInsert\nWhile Shell-Array are not totally recognized information inside array, Integer and STRING are taken together, if you do have problem in regard of integer being reported not like your design is thinked try to enforce a IF test with integer with forced value. Because ValueToVariable take individually elements and assign it before calling your function you do have more change to keep variable structure than creation an allocation-holder and calculating like registry access. Another case where Array are altering the information in regard of loosing the Interger value is the uses of Associative array. Index are STRING and content too. We do recommend also to profit from Getter in place inside function from Fnct.D Structure and adopt a recuperation methode throught Getter. Default is False, but we recommend it to Set True form more than one Variable. Professionnal uses had enforced the uses of Variable Transfert holding name inside the Variable and call only this one ex, calling StrVarList=StrVar1,StrVar2 calling StrVarList inside VTVValueEntry does not need an Array Style Insert.\n\nComment over VTVIsWhiteList\nUses of Whitelist where some power mechanisme like compiler depend of variable like CFLAGS, LDFLAGS... do require it if your out of generating code from shell or out of main Function do require a function white list \n\nComment over VTVValueEntry Know Effect\nIn many sub-function does prove there is no creation of variable but Assignation by-Recopy.\n\nComment over VTVIsDebugDisplay\nWhile the mechanism can not be directly see from calling it directly from Command-Shell it get on with eval and it's optimized to work with simple Executive-Evaluative Brace only the DebugDisplay option will let you see the result. Information are ouputed on /dev/stderr.\n\nComment over VTVIsTransHadScrip\n like Awk Script and it's a mechanism totally non-interactive ans pass-throught do directly to this action, with dependancy of VTVITransformScript, VTVAppsScripter, VTVAppsScripterOpt, theses options are not certified yet.\nValueToVariable Prefixed-Variable informations\n\nBoolean Notice Prefixed Variable:\n\nVTVIsArrayStyleInsert\tSet True/False ArrayStyle is a declaration passed throught a variable and fastest way to pass theses elements are with separator or common method is « Comma Separated Value ». Further Information seek second part.\nVTVIsTransformed\tSet True/False Reserved and Obsoleted until all the function exception will be tested.\nVTVIsTransHadScrip\tSet True/False This Prefixed-Variable is Unique and only accept VTVIsArrayStyleInsert and activate the uses of independent script.\nVTVIsDebugDisplay\tSet True/False Allow outputing Debug Statement. \nVTVIsSlowDebug\t\tSet True/False This option is not improving Speed of your function and does slow-down the option DebugDisplay if you do have problem to filter All the Displayed Debug information.\nVTVIsValueToConvert\tSet True/False Is mostly False, this Prefixed-variable allow variable having other name, and respectly have en entry and importance inside way variable are mangled, activating uses of VTVReasignPrefix, VTVReasignSuffix\n\nImportant Notice, most-standard case Prefixed Variable:\n\n\n\nImportant Notice, NonTrivial Prefixed Variable:\n\nVTVVarFilter\t\tSTRING Regular Expression, from Bash Expansion algorithm, mostly like regular expression, but not full-length regular expression.\nVTVRejectionFilter\tSTRING Regular Expression, from Bash Expansion algorithm Rejection filter is also know for what will remain inside WhiteList Option\nVTVIsWhiteList\t\tSTRING Separated with Comma is the exeption List to pass throught .\nVTVITransformScript\tSTRINGScript Filename use inside VTVAppsScripterOpt under TAG __FILE__. Neglecting VTVAppsScripterOpt to own TAG __FILE__ will not work .\nVTVAppsScripter\tSTRING Default is /usr/bin/gawk\nVTVAppsScripterOpt\tSTRING Reserved for VTVAppsScripter or application wrap-up, handle most of variable call for an application wrapper.\nVTVScriptInterVar\tSTRING Repsonsible to answer to TAG __VAR_ASSIGN__ inside VTVAppsScripterOpt is a method transfering other variable with --assign from awk/gawk option look for awk manual for further information.\nVTVAppsParser\tSTRING It's TAG definition where __APPS__ is awk/gawk, any application and __OPT__. The __OPT__ is namespace for all Prefixed Variable VTVScriptInterVar, VTVAppsScripterOpt and VTVITransformScript.\n\n\nImportant Notice, Obsoletes Prefixed Variable:\n\nVTVValueRe\t\tSet True/False [INEFFECTIVE] Was working with VTVIsTransformed\nVTVIsTransformed\tSet True/False [INEFFECTIVE] Was used in conjunction with VTVValueRe and require VTVValueEntry and does associate 1 on 1, so having to inspect the variable list to fit with element make a decision to remove the prototype from this function.\n" ; 
    
    
   if [ "${Arg0:=--startservices}" == "--help"	] ; then 
     GVRIsName=True GVRIsSynopsis=True GVRIsSummary=True GVRIsDesc=True GetVarReference ${__call_locality[1]} ; 
     echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ;
   elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
    eval $( __GetVarReferenceCompWord ) ;
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    StrMsg="Status BuildForm:__BF__, __call_locality:${__call_locality[1]}" ;
    VerbMsg="${StrMsg//__BF__/${BuildForm}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} VerbDev=/dev/stderr Verbosis ; 
    eval $( __GetVarReferenceList ) ;
   elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
    __main_StartServices; 
   fi

  }

fi ### End-of if-versionVTV == 0.0.2 .

### TagParser :
###
### Tag Parser	 Ability To parse tagged Information from known variable name.
###	
### Synopsis 
### This is a simple application to provide to function conversion of String of 
### text with Tag ( noted __TAG__ by default ).
###
### Summary
### Providing a Text transformation from provided varaible name inside  parameter. 
### Content expect to exist inside a function, this is a provided evaluation of a 
### loop transformaing an Entry variable name from tag supplied. Noted the 
### evaluation brace is required, a.k.a $( TP...=... eval TagParser ) to add the 
### code directly inside your function. The mechanism allow uses of definied 
### array of desired scope type it is not desctructive for array and does not 
### give the destruct code for Variable name such Array inside Prefixed-Variable 
### TPArrayName.
###

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###

if [ "${versionTP:=0.0.2}" == "0.0.2" ] ; then 
  #unset TagParser ; 
  eval $( GFCFuncName=TagParser GlobalFunctionCleaning ) ; 
 
  function TagParser( )
  {
   function Verbosis()
   {
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Verb Verbosis ) ; 
    local Arg0=${ArrayArg[0]} ; 
    local StrMsg=${VerbMsg:=__TEXT__} ; 
    local StrDevOut=${VerbDev:=/dev/stderr} ; 
    local IsVerboseState=${VerbState:=False} ;
    local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
    local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
    local IsDisplayFormatted=${VerbFormated:=True} ;
    local IsAppendMode=${VerbAppendDev:=False} ; 
    local IsExtendedOutput=${VerbExtendedOut:=False} ; 
    local ArrayArg=( $* ) ; 
    if [ "${IsVerboseState:=False}" == "True" ] ; then 
     if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
        echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
      else  
        echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
      fi
     else
      if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" ;  
       else
         echo "${StrMsg}" ;  
       fi
      else
       if [ "${IsAppendMode:=False}" == "True" ] ; then 
        if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
          echo -ne "${StrMsg}" >> ${StrDevOut} ;
        else
          echo "${StrMsg}" >> ${StrDevOut} ;
        fi
       else
        if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" > ${StrDevOut} ;
        else
         echo "${StrMsg}" > ${StrDevOut} ;
        fi 
       fi
      fi 
     fi 
    fi
   } 
   ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis

   #local -a ArrayArg=( $* ) ; 
   #local -a __call_locality=( TP TagParser ) ;
   #local Arg0="${ArrayArg[0]}" ;
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( TP TagParser ) ;
    local Arg0="${ArrayArg[0]}" ; 
    local StrParentApps=${__call_locality[1]} ;
    local StrStartMain=${TPFuncStart:=__main_StartServices} ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=TagParser CAIsAddParent=False __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=TagParser CAIsAddParent=False CallArgument ) ;
   fi  
   ### 20170122 - Officially added CallArgument Block
   
   local StrTagList=${TPListTag:=StrA:__TAGA__,StrB:__TAGB__,IntA:__INT__} ; 
   local StrArrayName=${TPArrayName:=ArrayTagParser} ;
   local StrIterName=${TPIterNameVar:=TagParser} ;
   local StrLeftPattern=${TPLeftStrPtrn:='[SIB][tnos][a-zA-Z0-9_]*:'} ; 
   local StrRightPattern=${TPRightStrPtrn:=':__[A-Za-z0-9\_]*'} ;
   local StrScopeVar=${TPScopeVar:=local} ; 
   local StrVarAssign=${TPVarNameParsed:=StrVarEntry} ;
   local BoolInvertPairMatch=${TPIsMatchRtoL:=True} ;
   local BoolDebugDisplay=${TPDisplayDebug:=False} ;
   local BoolDisplayEvalOnly=${TPDisplayEvalOnly:=False} ;
   local BoolDisplayParserAction=${TPDisplayParserNotice:=False} ; 
   local BoolUsingSed=${TPUsingSedTrim:=True} ;  
   local StrStartMain=${TPFuncStart:=__main_StartServices} ; 
   local StrParentApps=${__call_locality[1]} ;
   ### 20161004 - Added BoolUsingSed, set it to False will filter StrInitCmd with tr instead 
   local StrVarList="StrMainStart,StrParentApps,BoolUsingSed,BoolDisplayParserAction,BoolInvertPairMatch,BoolDisplayEvalOnly,StrTagList,StrArrayName,StrIterName,StrLeftPattern,StrRightPattern,StrCmd,StrScopeVar,StrVarAssign" ; 
   
   ### Removed by confusion in code transformation . 
   ###local StrVarEntry=${TPVarEntry:=StrEntry} ; 
   function __main_StartServices()
   {
    local -a ArrayArg=( $* ) ; 
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ;
    local -a ArrayTagParser=( ${StrTagList//,/ } ) ; 
      
    ### 
    ### This is the injected code wil be outputed and 
    ### require evaluation and execution brace :
    ### in form $( eval __CODE__ ) like Value To Variable
    ### require form $( eval __CODE__ ) Function-name 
    ### 
    local StrPairEvalOrder="" ;
    if [ "${BoolInvertPairMatch:=True}" == "True" ] ; then 
     ### For member of tag in writed in form  RtoL is True : R-> __TAG__, L->Variable
     ### Substitution goes in this way, Looking for Tag in PairRight and replacing it by Content in
     ### PairLeft. 
     #StrPairEvalOrder="eval ${StrVarAssign}=\${${StrVarAssign}//${StrPairRight}/\${\${StrPairLeft}}}"; 
     StrPairEvalOrder="""eval ${StrVarAssign}=\\\${\\${StrVarAssign}//\${StrPairRight}/\\\${\${StrPairLeft}}} """;
    else
     ### For member of tag in writed in form LtoR is True : L-> __TAG__, R->Variable 
     ### StrPairEvalOrder="eval ${StrVarAssign}=\${${StrVarAssign}//${StrPairLeft}/\${\${StrPairRight}}}"; 
     ### Substitution goes in this way, Looking for Tag in PairLeft and replacing it by Content in
     ### PairRight. 
     StrPairEvalOrder="""\$( eval ${StrVarAssign}=\\\${\\${StrVarAssign}//${StrPairLeft}/\\\${\${StrPairRight}}} )""";
    fi
    
    ### Notice: 804885f8-2537-11e7-8b1d-001e4c8856d6
    ### While StrMsg is often used with Verbosis in many function 
    ### TagParser generating it's own code inside your function by calling 
    ### TagParser over the evaluation execution brace, using StrMsg despite 
    ### having other clue to parse a long-messages with lot's of TAG, will 
    ### be overwritten by the evaluation of StrInitCmd which re-use StrMsg.
    ### So TagParser will try to parse the Internal message against your 
    ### variable to parse. Following algorithm verify if StrMsg is used in 
    ### declaration of StrVarAssign used from Pre-fixed Variable 
    ### TPVarNameParsed . 
    local StrInternalMsg="StrMsg" ; 
    if [ "${StrVarAssign:=StrVarEntry}" == "StrMsg" ] ; then 
     ### Changing the Definition of StrInternalMsg to something 
     ### else .
     local StrValueVarGen="0" ;
     local StrRndVarSuf ; 
     while [ ${StrValueVarGen:=None} != "None" ] ; do 
      StrRndVarSuf=$( /usr/bin/pwgen -c01 4 ) ; 
      eval "local Str${StrRndVarSuf}" ; 
      eval "StrValueVarGen=\${Str${StrRndVarSuf}}" ; 
     done 
     StrInternalMsg="Str${StrRndVarSuf}" ;  
    fi 
     
    ### Notice: to find out Left Section in RtoL ( extracting Variable name) we 
    ### must erase the __TAG__ Name leaving only the Variable name:
    ### example in String = StrA:__TAGA__
    ### Extracting part 'StrA', require to erase the __TAGA__ 
    ### mean using ${String/%__RIGHT_PATTERN__} ; 
    ### Uses of String substitution with partial erase of the String for a 
    ### one step imply to detect the partial-to-erase and result is what is
    ### remaining in the String .... 
    # for __ITER__ in \${__ARRAY_NAME__[@]}  ; do 
    
    ### Section Internal Code generating Parsing Action.
    local StrInitCmd="""${StrScopeVar} intx=0 ; ${StrScopeVar} StrPairLeft ; 
    ${StrScopeVar} StrPairRight ; 
    ${StrScopeVar} -a __ARRAY_NAME__=( ${StrTagList//,/ } ) ; 
    ${StrScopeVar} __VAR_MSG__=\"PairLeft( __LEFT__ ), PairRight( __RIGHT__ ), Query( __QUERY__)\" ; 
    for (( intx=0 ; intx <= \${#__ARRAY_NAME__[@]}-1 ; intx++ )) ; do 
      __ITER__=\${__ARRAY_NAME__[\${intx}]} ; 
      AStrMsg=\"\${StrMsg}\" ;
      StrPairRight=\"\${__ITER__/#__LEFT_PATTERN__/}\" ; 
      StrPairLeft=\"\${__ITER__/%__RIGHT_PATTERN__/}\" ; 
      AStrMsg=\${AStrMsg//__LEFT__/\${StrPairLeft}} ;
      AStrMsg=\${AStrMsg//__RIGHT__/\${StrPairRight}} ;
      AStrMsg=\${AStrMsg//__QUERY__/\${${StrVarAssign}}} ;
      VerbMsg=\${AStrMsg} VerbHeader=TAGPARSER VerbState=${BoolDisplayParserAction} VerbFormated=True VerbDev=/dev/stderr Verbosis ; 
      __PAIR_EXCHANGE_ORDER__ ; 
    done ; 
    unset intx StrPairRight StrPairLeft __ARRAY_NAME__ __VAR_MSG__ ;""" ; 
    ### Added 20161004 - Filtering excess of control caracter . 
    ### Sed does filtering the excessive \n \r into \\n and \\r 
    ### and /usr/bin/tr does remote it, it change the form of the query but does not 
    ### alter the code. 
    if [ "${BoolUsingSed:=True}" == "False" ] ; then 
     StrCmd=$( echo "${StrInitCmd}" | /usr/bin/tr '[:cntrl:]' ' ' ) ; 
    else
     StrCmd=$( echo "${StrInitCmd}" | /bin/sed 's/\n/\\n/g;s/\r/\\r/g' ) ; 
    fi 
    
    
    StrCmd=${StrCmd//__VAR_MSG__/${StrInternalMsg}} ; 
    StrCmd=${StrCmd//__ITER__/${StrIterName}} ; 
    StrCmd=${StrCmd//__LEFT_PATTERN__/${StrLeftPattern}} ; 
    StrCmd=${StrCmd//__RIGHT_PATTERN__/${StrRightPattern}} ; 
    StrCmd=${StrCmd//__ARRAY_NAME__/${StrArrayName}} ; 
    StrCmd=${StrCmd//__PAIR_EXCHANGE_ORDER__/${StrPairEvalOrder}}  ; 
    
    StgMsg="CmdLine: __CMD__" ; 
    VerbMsg=${StgMsg//__CMD__/${StrCmd}} VerbHeader="DEBUG:${__call_locality[1]}" VerbState=${BoolDebugDisplay} VerbFormated=True VerbDev=/dev/stderr Verbosis
    
    if [ "${BoolDisplayEvalOnly:=False}" == "False" ] ; then 
     ### 20161004, changing Verbosis model, support Evaluation. and is not thowing the code 
     ### on /dev/stdout but general device. 
     VerbMsg=${StrCmd} VerbEvalForm=True VerbFormated=False VerbState=True Verbosis ; 
    fi
   } 
   
   local StrSwitchMessages="\n${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
   local StrNameHelper="${__call_locality[1]}\n\t Ability To parse tagged Information from known variable name.";
   local StrSynopsis="\n\tThis is a simple application to provide to function conversion\n\tof String of text with Tag ( noted __TAG__ by default ). ";
   local StrSummary="\n\tProviding a Text transformation from provided varaible name inside\n\tparameter.Content expect to exist inside a function, this  is  a\n\tprovided evaluation of a loop transformaing an Entry variable name\n\tfrom tag supplied. Noted the evaluation brace is required, a.k.a\n\t\$( TP...=... eval TagParser ) to add the code directly inside your\n\tfunction. The mechanism allow uses of definied array of desired\n\tscope type it is not desctructive for array and does not give the\n\tdestruct code for Variable name such Array inside Prefixed-Variable\n\tTPArrayName."
   local StrDescription="\nParser notice\n\n  TPListTag\tSTRING Depending of the Prefixed Variable TPIsMatchRtoL it\n\t\ttaking form VARIABLE:__TAG__ and are comma separated value\n  TPArrayName\tSTRING Falcutative depending the number of reccurrence of\n\t\tthe Parser not executed and may interfer if the Parser\n\t\tCode is mangled and if extended Choice are affected to erase\n\t\tthe unset at the end. Sometimes the array name can already\n\t\tbe in uses and may affect your operation.\n\n  TPIterNameVar\tSTRING Falcutative, change the String-Iterated item looped\n\t\tinside the Array.\n  TPVarNameParsed\n\t\tSTRING Is the entry varaible holding the CODE/Template with\n\t\t__TAG__ to be parsed. We advise using a copy of this Variable\n\t\tbecause it re-write the content of it.\n  TPScopeVar\tSTRING and can be single-quoted STRING, Inside function 'local'\n\t\tis important or your function will use external variable.\n\t\tmaking it public or external use declare instead.\n\n  TPLeftStrPtrn\tSTRING Regular expression from Variable substitution algorithm,\n\t\tit remove the Left Side to kept the right side Be careful with\n\t\tthis.\n  TPRightStrPtrn\tSTRING Regular expression from Variable substitution algorithm\n\t\tsuppress the __TAG__ form to keep the variable name usually,\n\t\tbecarefull uses ${VAR/#PTRN/'SEP'} and ${VAR/%'SEP'PTRN} method see in Bash document.\n\nBoolean variable notice:\n\n  TPIsMatchRtoL\tSet To True/False Invert Composition of tag in your design,\n\t\tSet to TRUE Variable in TPListTag required to be composed in\n\t\tform VARIABLE:__TAG__, if FALSE in form __TAG__:Variable\n\n  TPDisplayDebug\n\t\tSet To True/False Display Extra Debug during action, all\n\t\toutputed to /dev/stderr to not confuse the parser.\n  TPDisplayEvalOnly\n\t\tSet To True/False Allow displaying the Injected code in eval\n\t\tfunction using the Tag Parser.\n  TPDisplayParserNotice\n\t\tSet To True/False For function equiped of a Verbosis see\n\t\tfnct_debian_list for Verbosis example and will display by Tag\n\t\tpair the result the exanche and actual qiery it should happen\n\t\tafter the Parsing.\n" ; 
   
   ### End-function block for switches handling. 
   
   if [ "${Arg0:=--startservices}" == "--help"	] ; then 
     GVRIsName=True         \
     GVRIsSynopsis=True     \
     GVRIsSummary=True      \
     GVRIsDesc=True         \
     GetVarReference ${__call_locality[1]} ; 
     VerbMsg=${StrSwitchMessages} \
     VerbExtendedOut=True   \
     VerbDev=/dev/stderr    \
     VerbState=True         \
     VerbFormated=False     \
     Verbosis ; 
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ;
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;	
   elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
    eval $( __GetVarReferenceCompWord ) ;
   elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
    eval $( eval VTVValueEntry=${StrVarList}  \ 
            VTVIsArrayStyleInsert=True        \
            VTVIsValueReAssign=True           \
            VTVIsQuotedValue=True             \
            VTVIsValueToConvert=False         \
            ValueToVariable   ) ${StrStartMain} ; 
   fi 
   
  }

fi ### End-of if-versionTP == 0.0.2 .

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
if [ "${versionBVT:=0.0.2}" == "0.0.2" ] ; then 
  #unset BoolVarTest IntDefautlType BVTIdType ; 
  #unset StrVarBoolTest StrDefaultBoolTest StrNotAsserted StrScopeType StrIfTestType StrIfStringOp IsPreambule StrDefaultEndTest IsTypePreamb StrVTRPrbTpl StrVTRPrbVar StrVTRPrbVTReg StrVTRPrbVTFnct IsTypeAssert StrVTRAsrtTpl StrVTRAsrtVar StrVTRAsrtVTReg StrVTRAsrtVTFnct StrKeyTestType IntDefautlType IsDisplayIfStatement StrIfPattern ArrayIfPattern ArrayAssertion StrTestTemplate IsPreambulePolNtRespt ;
  #unset Verbosis __main_StartServices ;
  eval $( GFCFuncName=BoolVarTest GlobalFunctionCleaning ) ; 
 
  function BoolVarTest()
  {
 
   ### The main goal : 
   ### Will represent a correct view of this example into pattern . 
   ### 
   ###   local StrMultipleFileSelectionAttr="--multiple"
   ###   if [ "${StrZenityFSMultipleFile}" == "False" ] ; then 
   ###    StrMultipleFileSelectionAttr="" ; 
   ###   fi 
   ### 
   ### Into CommandLine Echo like pattern and  being evaluated to create following statement:
   ### - Having a variable A Holding a content. 
   ### - Having a Prefixed-Var named B holding either False Or True like ${Prefixed_Var_named_B:=False}
   ### - On Having Reverse position inside ${Prefixed_Var_named_B:=False}, content of variable A, should
   ### Be erased of asking to get alternative.
   ### 
   ### Answer to pattern, 
   ### 
   ### BVTVarName=StrMultipleFileSelectionAttr BVTVarHold="--multiple" BVTBoolVarName=StrZenityFSMultipleFile BoolVarTest 
   ### 
   ### Nominal purposes: 
   ### This is intended to supply a Boolean test and Value Association, done in one line, 
   ### it allow to generate a range of variable being Transited from Prefixed-Var and value
   ### passed in a query, which is sometimes had no value and give extra code that might trigger error. 
   ### 
   ### For a Generated example between command-line BoolVarTest and Pre-fixed value, see 
   ### 
   ### BoolVarTest for substitution of StrFileTmp from function ZenityShellEval()
   ### Note reference : f1161962-0ad8-11e3-b166-001b3875b29c  
   ### 
   ### 
   ###  Warning : 
   ###  Note reference : 7236e956-f6cf-11e5-98a2-001e4c8856d6
   ###  - Recurrent call in BoolVarTest
   ###  and avoid uses of  ValueToVariable . 
   ###  While BoolVarTest is a low-level call indirectly call
   ###  by ValueToVariable it's hard to define first will end having 
   ###  good sub-body to acheive a strict identity and be able to 
   ###  parse all variable before BoolVarTest 'will' have to 
   ###  end a possible __main_start_services if this one is implemented 
   ###  with normal body-topology  .  So it's not recommended to use 
   ###  ValueToVariable inside BoolVarTest has long there is 
   ###  a better mechanisms correcting this problems in bash of recurrent  
   ###  function call recurently a lower level function will simply loop
   ###  and not finishing the work . 
   ### 
   ### 
   ### 
 
   ### Factory Section 
    function Verbosis()
    {
     #eval $( CAFunctName=Verbosis CAIsAddParent=False __Call_Argument ) ; 
     local -a ArrayArg=( $* ) ; 
     local StrMsg=${VerbMsg:=__TEXT__} ; 
     local StrDevOut=${VerbDev:=/dev/stderr} ; 
     local IsVerboseState=${VerbState:=False} ;
     local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
     local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
     local IsDisplayFormatted=${VerbFormated:=True} ;
     local IsAppendMode=${VerbAppendDev:=False} ; 
     if [ "${IsVerboseState:=False}" == "True" ] ; then 
      if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
       if [ "${IsAppendMode:=False}" == "True" ] ; then 
         echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
       else  
         echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
       fi
      else
       if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
          echo "${StrMsg}" ;  
       else
        if [ "${IsAppendMode:=False}" == "True" ] ; then 
         echo "${StrMsg}" >> ${StrDevOut} ;
        else
         echo "${StrMsg}" > ${StrDevOut} ;
        fi
       fi 
      fi 
     fi
    } 
    ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
   
   local -a ArrayArg=( $* ) ; 
   local -a __call_locality=( BVT BoolVarTest ) ;
   local Arg0="${ArrayArg[0]}" ;
   local StrParentApps="${__call_locality[1]}" ;
   local StrStartMain=${BVTFuncStart:=__main_StartServices} ;
   ### End of Factory Section.
   local -a ArrayTypeTest=( "False" "True" ) ;
   local -a ArrayPreambule=( ) ; 
   local -a ArrayIfPattern=( ) ;
   ### We do Agree if the clause using an Execution-ASSERTION-type  inside the 
   ### If-clause the section after the 'then' shoud not carry any trace of 
   ### BVTVarName, like default one StrAttrHold="" ... but should hold a trace of 
   ### $ eval $( VTV...=... VTV...=... ValueToVariable ) Function-Name
   local StrVarNamed=${BVTVarName:='StrAttrHold'} ; 
   
   local StrNewVarNamed=${BVTNewVarAssertion:='StrNewVarAssertion'}
   ###
   ### New Variable is cretead inside the Assertion Field 
   ### after forced expiration by uses of BVTIsPrmblVarCylceEnd( BoolEndLifeCycleInAssert )
   ### - it require BVTIsPreambule( IsPreambule ) == True or either 
   ### case implicitly uses of BVTIdType=4 + 5 for if-else-fi in portion
   ### BVTIdType=4 to make the section if-else does own an assertion field where we can suspect 
   ### forcing termination of life cycle in Assertion. While BVTIdType=5 for Else does
   ### already start-your assignation inside an assertion without presence of a if-statement 
   ### because we are inside an unilateral region, after the If where the condition does
   ### not fit and offering objective alternative. So we keep uses of BoolVarName and 
   ### Not BVTNewVarAssertion. 
   ### Best way to explain it is feeding an Array and this one can receive a portion of information
   ### in case BVTBoolAssertion requiere information from a test. Like the case where a 
   ### content tested from the IF operator suggest to submit a empty value and test does 
   ### create a BVTBoolAssertion to Feed the Array with message "EMPTY" instead of nothing.
   ### and in case of Else depicted by BVTIdType=5 also receive it from BVTBoolAssertion 
   ### and gather a situation where it non-empty information from what the Array will receive.
   ### Suggest in case of BVTIdType=4 to uses it's option of BVTNewVarAssertion( StrNewVarNamed )
   ### holding the information of the Array, BVTBoolAssertion the content because It does hold a 
   ### BVTVarHold from relation ( BVTVarName <-- BVTVarHold ) and if BVTVarHold is empty
   ### It's useless inside Assertion to talk about BVTVarName and better to submit a 
   ### BVTNewVarAssertion inside the Assertion. 
  
   
   local StrVarNamedHold=${BVTVarHold:='CONTENT'} ; 
   ### Following variable Stand for Is-Preambule-Polish-Notation-Respect is respected ( 
   ### like allow cleaning content and validate output for easy-Integer respect instead 
   ### of having case like IntValue="0" so far is valuable, but fail in case and if test -> 
   ### if [ "0" -eq 0 ] ; then ; fi , will notice some problems. )
 
   ###############
   ### Belong to Preambule Section Only:
   ###############
   
   ### Master Switch in case, If there is an Preambule in your ValueToVariable condition
   ### set this to True. Setting this to false will:
   ### Remove the Preambule section and avoid creating an Executive-Assertion at this place. 
   local IsPreambule=${BVTIsPreambule:=True} ; 
   
   local BoolEndLifeCycleInAssert=${BVTIsPrmblVarCylceEnd:=False} ;
   ### This Boolean is only available for case where ValueToVariable is not 
   ### activate for having template parsing of ValueToVariable calling a function.
   ### It does suspect life-cycle does end life-cycle any variable pre-declared  
   ### because it suspect launching it an reporting active declared variable inside 
   ### Variable registry of BVTVTVVarA. 
   ### For This Preambule is does let exist BVTVarName Inside the Preambule, 
   ### may re-use it for a test inside the IF operator and explicitly terminate
   ### the uses of BVTVarName and does supply another variable name like 
   ### BVTNewVarAssertion, because it suppose affecting remain dedicated information
   ### inside Prefixed-Variable BVTBoolAssertion. so instead of having 
   ### 
   ### StrVarNamed <-- BVTBoolAssertion  
   ### It will do :
   ### StrNewVarNamed <-- BVTBoolAssertion 
   ### 
   ### 
   
   
   ### Stand for Is there is a Preambule with Variable uses, To Start creating a 
   ### Variable with name LIKE CC, CFLAGS, LDFLAGS is not a good idea as long yo do 
   ### set BVTIsPrmblPlNt to False, this will avoid filtering the variable and 
   ### Ensure Wrapping from simple quote '"' any String Like variable name and wraping 
   ### True/False in boolean case from simple quote '"' 
   local IsPreambulePolNtRespt=${BVTIsPrmblPlNt:=True} ; 
   
   ### Section ValueToVariable in Preambule 
   ### Also we should understand having declared in a case where BVTIsPreambule=False
   ### there is no way to draw an Preambule in mode Execution-ASSERTION made from ValueToVariable.
   local IsTypePreamb=${BVTIsValueToVar:=False} ;
 
   ### Required variable to manage or configure a ValueToVariable Assertion inside Preambule Only.
   local StrVTRPrbTpl=${BVTVTVTPL:=eval __TES__ eval __REGISTRY_PRE__ VTVValueEntry=__VAR_ENTRY_PRE__ ValueToVariable __TEE__ __FNCT_PRE__} ;
   
   ### BVTVTVVar is the most used, allowing to pass-thru the variable in uses with 
   ### the same name to the function associate to Executive-Assertion inside the Preambule.
   ###
   local StrVTRPrbVar=${BVTVTVVar:=IsVerbose,IsDebug} ;
   
   ### BVTVTReg, Called BoolVarTest ValueToVariable Registry 
   ### is plain Prefixed-Variable associate to pass-thru mechanisme
   ###
   ### To eliminate confusion an action of 
   ###
   ### Taking what is in left-leg members to a similar name to right-leg member 
   ### describe by VAR1 = VAR1 is an Re-Assignation, or copy-variable algorithm.
   ### This is not the mechanisme that copy the variable name but entry-in function
   ### having a role to isolate the Variable and copy the content. Proof of fact  
   ### the variable is re-copied, it lost it's value at the end of the sub-function
   ### going back to value of the variable before the entry inside the sub-function.
   ###
   ###
   local StrVTRPrbVTReg=${BVTVTReg:=VTVIsArrayStyleInsert=True VTVIsValueReAssign=True VTVIsValueToConvert=False} ;
   
   ### BVTVTFnct 
   ###
   ### You do have a function to fill here to enable the pass-thru to a function 
   ### this is the part required to let having a function Executed during pre-ambule.
   ###
   local StrVTRPrbVTFnct=${BVTVTFnct:='__FNCT__'} ;
   
   ###############
   ### End of Preambule Section .
   ###############
   
   ### 
   ### BVTBoolVarName is :
   ### the Left member in a if-clause evaluation :
   ### noted :
   ### if [ BVTBoolVarName == "True" ] ; then ... ; fi 
   ### 
   ### But this as also had effect to not correctly specified variable if it's 
   ### an active form variable 
   ### Where BVTBoolVarName=BoolIsAnyAction
   ### 
   ### and :
   ### local BoolIsAnyAction="False"
   ### if [ BoolIsAnyAction == "True" ] ; then ... ; fi
   ### ---> Should never analyse the if clause as ${BoolIsAnyAction} == "True", 
   ### but simply doing errors.
   ### 
   ### so it's important inside BVTBoolVarName to specified the Variable brace in evaluation mode like 
   ### BVTBoolVarName=\${BoolIsAnyAction} BVT...=... BVT...=... BVT...=... BoolVarTest
   ### 
   local StrVarBoolTest=${BVTBoolVarName:=IsVarShould} ; 
   local StrDefaultBoolTest=${BVTBoolCase:=False} ;
   
   ### BVTQuoteIntLeftMember
   ### 
   ### This is forcing a dollar quoting of a value of BVTBoolVarName
   ### a.k.a the Left member in a if-statement. where usually from pattern
   ### inside String Type (with BVTIfType=String, by default) we have
   ### [ \"__VAR_BOOL_TEST__\" __OP__ \"__DEFAULT_BOOL_TEST__\" ]
   ### Being guillemets quoted '"', but inside BVTIfType=Int, the 
   ### default Test statement is :
   ### [ __VAR_BOOL_TEST__ __OP__ __DEFAULT_BOOL_TEST__ ]
   ### Where __VAR_BOOL_TEST__ may be specified by 
   ### BVTBoolVarName=Variable
   ### or StrVarBoolTest by a value or a variable. 
   ### BVTQuoteIntLeftMember quote the Variable to ${Variable}
   ###
   ### BVTQuoteIntLeftMember works only with BVTIfType="Int" .
   ###
   local IsQuotedIntLeftMember=${BVTQuoteIntLeftMember:=False} ; 

   ### BVTBoolAssertion
   ### In case where BVTIsPreambule==True it's the holder of any information for assignation 
   ### of BVTVarName( StrVarNamed ) to receive the information, so at the end of the BoolVarTest
   ### StrVarNamed will exist in you code with the value of BVTBoolAssertion . In case where 
   ### BVTIsPrmblVarCylceEnd==True (BoolEndLifeCycleInAssert ) it does not change the role of 
   ### BVTBoolAssertion except BVTBoolAssertion will assign it's content to another variable 
   ### name. This case the new-variable name is BVTNewVarAssertion( StrNewVarNamed ) 
   ### 
   local StrNotAsserted=${BVTBoolAssertion:=\"\"} ;
   local StrScopeType=${BVTScopeTest:='local'} ;
   local StrIfTestType=${BVTIfType:='String'} ; 
   local StrIfStringOp=${BVTIfOp:='=='} ;
   local StrDefaultEndTest=${BVTConclude:=';'} ;
 
   ### Section ValueToVariable in Assertion .
   local IsTypeAssert=${BVTIsValueToVarAssert:=False};
   local StrVTRAsrtTpl=${BVTVTVTPLA:='eval __TES__ eval __REGISTRY_ASRT__ VTVValueEntry=__VAR_ENTRY_ASRT__ ValueToVariable __TEE__ __FNCT_ASRT__'} ;
   local StrVTRAsrtVar=${BVTVTVVarA:='IsVerbose,IsDebug'};
   local StrVTRAsrtVTFnct=${BVTVTFnctA:='__FNCT__'}
   local StrVTRAsrtVTReg=${BVTVTRegA:='VTVIsArrayStyleInsert=True VTVIsValueReAssign=True VTVIsValueToConvert=False'} ; 
   local StrKeyTestType=${BVTType:='if:fi,if:elif,elif:elif,elif:else,if:else,else:fi,elif:fi'} ;
   local IntDefautlType=${BVTIdType:=0} ; 
   local IsShowDebug=${BVTDisplayShowDebug:=False} ;
   local IsDisplayIfStatement=${BVTDisplayIf:=False} ; 
   local -a ArrayVarTestType=( "String" "File" "Test" "Int" "Shell" ) ;
   local StrVarListTransfert="IsQuotedIntLeftMember,StrNewVarNamed,BoolEndLifeCycleInAssert,StrTestTemplate,IsDisplayIfStatement,IntDefautlType,StrKeyTestType,StrVTRAsrtVTFnct,StrVTRAsrtVTReg,StrVTRAsrtVar,StrVTRAsrtTpl,IsTypeAssert,StrVTRPrbVTFnct,StrVTRPrbVTReg,StrVTRPrbVar,StrVTRPrbTpl,IsTypePreamb,StrDefaultEndTest,IsPreambule,StrIfStringOp,StrIfTestType,StrScopeType,StrNotAsserted,StrDefaultBoolTest,StrVarBoolTest,IsPreambulePolNtRespt,StrVarNamedHold,StrVarNamed,StrParentApps" ; 
   
   local StrTestTemplate=""" __PREAMBULE__ \
  __IF_PATTERN__  \
  __ASSERTION__ \
  __END_TEST__ __END_MARK__ """ ;
 
   ### Comment of ArrayIfPattern[0]
   ###  
   ### BVTIfType="String", will pop ArrayIfPattern[0], inside 
   ### ArrayIfPattern, Loop. Uses of BVTIfOp is by default '=='
   
   ### Comment of ArrayIfPattern[1]
   ###  
   ### BVTIfType="File", will pop ArrayIfPattern[1], inside 
   ### ArrayIfPattern, Loop. Where tag __OP__ can be replaced by
   ### BVTIfOp=-f (testing file), BVTIfOp=-L (testing link )
   
   ### Comment of ArrayIfPattern[2]
   ###  
   ### BVTIfType="Test", will pop ArrayIfPattern[2], inside 
   ### ArrayIfPattern, Loop. Where tag __OP__ can be replaced by
   ### BVTIfOp=-f (testing file), BVTIfOp=-L (testing link ) 
   ### Actuall does not supply the rest of the statement which 
   ### is experimental actually.
   
   ### Comment of ArrayIfPattern[3]
   ###  
   ### BVTIfType="Int", will pop ArrayIfPattern[3], inside 
   ### ArrayIfPattern, Loop. Where tag __OP__ can be replaced by
   ### BVTIfOp=-eq or '-lt', or '-gt' . Tag __DEFAULT_BOOL_TEST__
   ### is not quoted and may suggest inserting Direct value. 
   ### Tag __VAR_BOOL_TEST__ is not quoted and Suggest to quote it
   ### by default unless execption is granted, like BVQuoteIntLeftMember.
   ### dollar quoted value from prompt insertion. Suggested
   
   ### Comment of ArrayIfPattern[4]
   ###  
   ### BVTIfType="Shell", will pop ArrayIfPattern[4], inside 
   ### ArrayIfPattern, Loop. Where there is no __VAR_BOOL_TEST__
   ### and result some uniquely from $? or execute and returned
   ### status. 
   
   ### In Future version of BoolVarTest, It can suspect moving  in 
   ### ArrayIfPattern into associating array which cut in loop processing
   ### and associative array have been strengthen by uses of LoopShellScript
   ### and MakeHuffmanPair application which deal with extra factor like 
   ### execution of time and multiplicity of test. 
   ###
   ArrayIfPattern[0]="""__START_TEST__ [ \"__VAR_BOOL_TEST__\" __OP__ \"__DEFAULT_BOOL_TEST__\" ] """ ;
   ArrayIfPattern[1]="""__START_TEST__ [ \"__OP__ \"__DEFAULT_BOOL_TEST__\" ] """ ;
   ArrayIfPattern[2]="""__START_TEST__ \$( test \"__OP__ \"__DEFAULT_BOOL_TEST__\" ) """ ;
   ArrayIfPattern[3]="""__START_TEST__ [ __VAR_BOOL_TEST__ __OP__ __DEFAULT_BOOL_TEST__ ] """ ;
   ArrayIfPattern[4]="""eval __VAR_NAMED__ ; res=\$? ; __START_TEST__  [ \${res:=1} __OP__ __DEFAULT_BOOL_TEST__ ] """ ;
   
   function __main_StartServices
   {
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}";  
    ### 
    ### Getter Section, 
    ### Retrieving information from Main Function BoolVarTest
    local -a ArrayTestType=( ${StrKeyTestType//,/ } ) ; 
    local -a ArrayTestSection=( ${ArrayTestType[${IntDefautlType:=0}]//:/ } ) ; 
    
    ### Note : ArrayTestSection should test if value end with 'fi' and will require an extra semi-colon
    ### before adding element 'fi' --> 'else ... (;) fi ' 
    if [ "${ArrayTestSection[1]}" == "fi" ] ; then 
     ArrayTestSection[1]="; ${ArrayTestSection[1]}" ; 
    fi 
    # local ArrayIfPattern=(  ) ;
    local -a ATestType=( $( BoolVarTest --get ArrayVarTestType[@] ) ) ; 
    
    ### Cleaning the Template against non-evaluable or non-visible char.
    StrTestTemplate=$( echo "${StrTestTemplate}" | /bin/sed 's/\n/\\n/g;s/\r/\\r/g' ) ; 
    
    ### Other variable required ;
    local StrCurrentIfPatrn ;  
    local StrLcTTpl="${StrTestTemplate}" ; 
    local StrIfPattern ; 
    
    local -a ArrayPreambule=( ) ; 
    ArrayPreambule[0]="__SCOPE__ __VAR_NAME__=__VALUE__" ;
    
    local -a ArrayAssertion; 
    ArrayAssertion[0]="__ASRT_VAR__NAME__=__ASRT_VAR_VALUE__" ;
    ArrayAssertion[1]="__ASRT_VAR__NAME1__=__ASRT_VAR_VALUE__" ;
    local IntDefaultCycleAssert=0 ; 
    
    ### Referred by this section: DEFINITION of PREAMBULE-LIFE-CYCLE
    ### It requiert to change the ArrayAssertion index to 0 to 1 in 
    ### case It does receive a termination of the variable from Preambule
    ### being tested and should not mention it everywhere and even provide 
    ### Another Variable. 
    if [ "${BoolEndLifeCycleInAssert:=False}" == "True" ] ; then 
     IntDefaultCycleAssert=1 ; 
    fi 
    ###
    ### ArrayIfPattern, Loop and test to select proper 
    ### StrIfTestType and it's Operator StrIfStringOp.
    ###
    for (( intx=0 ; intx <= ${#ATestType[@]}-1 ; intx++ )) ; do 
     if [ "${StrIfTestType}" == "${ATestType[${intx}]}" ] ; then 
      StrCurrentIfPatrn=$( BoolVarTest --get ArrayIfPattern[${intx}] )
      StrIfPattern=${StrCurrentIfPatrn//__OP__/${StrIfStringOp}} ; 
     fi 
     
    done ; 
    StrMsg="Type of VarTest: ${StrIfPattern}, StringOP: ${StrIfStringOp}" ;
    VerbMsg=${StrMsg} VerbHeader="DEBUG" VerbState="${IsShowDebug}" VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    #local -a ArrayTagParseOpt=( "StrVarBoolTest:__VAR_BOOL_TEST__" "StrDefaultBoolTest:__DEFAULT_BOOL_TEST__" "StrVarNamed:__VAR_NAMED__" ) ; 
    #for StrSyntaxItem in ${ArrayTagParseOpt[@]} ; do
      #### Extract the Left-side or Variable-Name
      #StrPairLeft=${StrSyntaxItem/%:__[A-Z_]*} ;
      #### Get the Right part by removing the '${StrPairLeft}:' from StrSyntaxItem
      #StrPairRight=${StrSyntaxItem/#${StrPairLeft}:};
      #eval StrVarNameP="\${${StrPairLeft}}" ; 
      #StrIfPattern=${StrIfPattern//${StrPairRight}/${StrVarNameP}} ;
      #StrMsg="Replacing Tag:__TAG__ by Variable: __VAR__, Value:( __VALUE__ )" ;
      #StrMsg=${StrMsg//__TAG__/${StrPairRight}}
      #StrMsg=${StrMsg//__VAR__/${StrPairLeft}}
      #StrMsg=${StrMsg//__VALUE__/${StrVarNameP}}
      #VerbMsg=${StrMsg} VerbHeader="DEBUG" VerbState="${IsShowDebug}" VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    #done 
    # 
    # StrPairRight="${StrSyntaxItem/#\_\_[A-Z_]*,/}" ; 
    # StrPairLeft="${StrSyntaxItem/%,[A-Z][A-Za-z0-9]*/}" ;
    # eval $( StrIfPattern=${StrIfPattern//${StrPairLeft}/\${${StrPairRight}}} ) ; 
    #done 
    ### replaced: StrIfPattern=${StrIfPattern//__VAR_BOOL_TEST__/$( ${StrParentApps} --get StrVarBoolTest )} ;
    ### This test is moved out from For-Loop, causing premature-evaluation. 
    
    ###
    ### Section, Parsing the __VAR_BOOL_TEST__
    ###
    
    ### In case IsQuotedIntLeftMember=True, and BVTIfType=Int
    ### or __VAR_BOOL_TEST__ can be passed as value of the variable in
    ### a left member test. 
    if [ "${StrIfTestType:=String}" == "Int" ] ; then 
     if [ "${IsQuotedIntLeftMember:=False}" == "True" ] ; then 
      StrIfPattern=${StrIfPattern//__VAR_BOOL_TEST__/\${${StrVarBoolTest}'}'} ;
     else
      StrIfPattern=${StrIfPattern//__VAR_BOOL_TEST__/${StrVarBoolTest}} ;
     fi
    else 
     StrIfPattern=${StrIfPattern//__VAR_BOOL_TEST__/${StrVarBoolTest}} ; 
    fi 
    ### replace: StrIfPattern=${StrIfPattern//__DEFAULT_BOOL_TEST__/$( ${StrParentApps} --get StrDefaultBoolTest )} ;
    StrIfPattern=${StrIfPattern//__DEFAULT_BOOL_TEST__/${StrDefaultBoolTest}} ;
    ### replaced: StrIfPattern=${StrIfPattern//__VAR__NAMED__/$( ${StrParentApps} --get StrVarNamed )} ;
    StrIfPattern=${StrIfPattern//__VAR__NAMED__/${StrVarNamed}} ;
 
 
    ### Old Preambule : ${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\"" 
    ### Old Assertion : \${StrVarNamed}=\${StrNotAsserted} ; 
    
    if [ "${IsTypeAssert:=False}" == "True" ] ; then 
     StrLcTTpl=${StrLcTTpl//__ASSERTION__/${StrVTRAsrtTpl}} ;
     StrLcTTpl=${StrLcTTpl//__REGISTRY_ASRT__/${StrVTRAsrtVTReg}} ;
     StrLcTTpl=${StrLcTTpl//__VAR_ENTRY_ASRT__/${StrVTRAsrtVar}} ;
     StrLcTTpl=${StrLcTTpl//__TES__/\$(} ;
     StrLcTTpl=${StrLcTTpl//__TEE__/)} ;
       ### 2016-08-29, require a ';' at the end of a command or an error will occur 
       ### after the preambule or near the end after assertion
       ### 2016-10-18, The StrDefaultEndTest is required in case IntDefautlType=3,4
       ### required to put a '; else' where case for IntDefautlType=3 imply elif...else
       ### IntDefautlType=4 imply else .. fi
       ### While the rest remain under __IF_STATEMENT for if-elif, and 2 condidition manage
       ### their own assertion with semi-colon end-statement... 
       case ${IntDefautlType:=0} in 
        1 | 2 | 3 | 4 ) StrLcTTpl=${StrLcTTpl//__FNCT_ASRT__/${StrVTRAsrtVTFnct} ${StrDefaultEndTest}} ;; 
        0 | 6 ) StrLcTTpl=${StrLcTTpl//__FNCT_ASRT__/${StrVTRAsrtVTFnct}} ;;
        5 ) StrLcTTpl=${StrLcTTpl//__FNCT_ASRT__/${StrVTRAsrtVTFnct}} ;;
       esac ; 
       #if [ ${IntDefautlType:=0} -eq 3 ] ; then 
       # StrLcTTpl=${StrLcTTpl//__FNCT_ASRT__/${StrVTRAsrtVTFnct} ${StrDefaultEndTest}} ;
       #elif [ ${IntDefautlType:=0} -eq 4 ] ; then 
       # StrLcTTpl=${StrLcTTpl//__FNCT_ASRT__/${StrVTRAsrtVTFnct} ${StrDefaultEndTest}} ;
       #elif [ ${IntDefautlType:=0} -eq 6 ] ; then 
       # StrLcTTpl=${StrLcTTpl//__FNCT_ASRT__/${StrVTRAsrtVTFnct} ${StrDefaultEndTest}} ;
       #else
       # StrLcTTpl=${StrLcTTpl//__FNCT_ASRT__/${StrVTRAsrtVTFnct}} ;
       #fi 
    else
     StrLcTTpl=${StrLcTTpl//__ASSERTION__/${ArrayAssertion[${IntDefaultCycleAssert}]}} ;
     ### TITLE: DEFINITION of PREAMBULE-LIFE-CYCLE in Preambule to Assertion .
     ### Location to supply another variable name if Variable from Preambule does
     ### only receive information from outside assignation ( reveive a value from a $( ... ) )
     ### and test is only to qualify another operation like other type of assignation
     ### or even uses in Not-only Assertion-field comming from IsPreambule==False 
     ### ...
     ### In this case a Prefixed-Variable with value True/False To expire Lifetime of 
     ### StrVarNamed should be set to false and in case of True for expiration of 
     ### cycle life of StrVarNamed, to supply inside another prefixed-variable 
     ### to hold the name of this new variable.  
     
     ### Life-Cycle opposition : 
     ### Since a life cycle from a variable may end before entering inside the 
     ### assertion, changing the variable name of __ASRT_VAR__NAME__ and __ASRT_VAR__NAME1__
     ### in the same time did not interfe Because ArrayAssertion depend of IntDefaultCycleAssert
     ### and this allow reporting the proper name inside the StrLcTTpl which is not existing 
     ### in case IntDefaultCycleAssert=0 for case of feeding the TAG __ASRT_VAR__NAME1__ 
     ### As long it noticed here. 
     StrLcTTpl=${StrLcTTpl//__ASRT_VAR__NAME__/${StrVarNamed}} ;
     StrLcTTpl=${StrLcTTpl//__ASRT_VAR__NAME1__/${StrNewVarNamed}} ;
     
     StrLcTTpl=${StrLcTTpl//__ASRT_VAR_VALUE__/${StrNotAsserted}} ;
    fi 
    
    if [ "${IsPreambule:=True}" == "False" ] ; then 
     ### This section exist only because BVTIsPreambule=False allow to completely remove the 
     ### preambule. Having work around like using IntDefautlType=[1,2,3,4] can remove the 
     ### preambule and we are out of problem... Not so clean and some efforts are trying to 
     ### resolve 
     StrLcTTpl=${StrLcTTpl//__PREAMBULE__/} ; 
    else
      if [ "${IsTypePreamb:=False}" == "True" ] ; then 
       StrLcTTpl=${StrLcTTpl//__PREAMBULE__/${StrVTRPrbTpl}} ; 
       StrLcTTpl=${StrLcTTpl//__VAR_ENTRY_PRE__/${StrVTRPrbVar}} ; 
       StrLcTTpl=${StrLcTTpl//__REGISTRY_PRE__/${StrVTRPrbVTReg}} ; 
       StrLcTTpl=${StrLcTTpl//__TES__/\$(} ; 
       StrLcTTpl=${StrLcTTpl//__TEE__/)} ; 
       ### 2016-08-29, require a ';' at the end of a command or an error will occur 
       ### after the preambule or near the end after assertion
       StrLcTTpl=${StrLcTTpl//__FNCT_PRE__/${StrVTRPrbVTFnct} ;} ; 
      ### Second clause of if-"${IsTypePreamb:=False}" == "True"
      ### here stil in "${IsPreambule:=True}" == "True"
      else
       ### Missing, Initially we have defined here some Polish notation and we 
       ### don't have any test related to Integer, String and so forth... 
       ### 20160907- made it clear , scope test have something with ValueToVariable to produce infinite loop.
       ### inside __Action from ValueToVariable sub-function a loop of pair Variable:Variable are parsed
       ### inside an evaluation and does infinitely loop fir 3 items...
       ### discover the wa not inside tring-brace, but conformely not be the reason why
       ### scopetest == ',' and produce ',' instead of result from query .
       if [ "${IsPreambulePolNtRespt:=True}" == "False" ] ; then 
        StrLcTTpl="""${StrLcTTpl//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\";}""" ; 
        ### end of second clause of if [ ${IsPreambulePolNtRespt:=True} == "True"
        ### here, still in "${IsTypePreamb:=False}" == "True"
        ### here, on side of ${IsPreambulePolNtRespt:=True} == "False"
       ### Reverted condition to  put least part of code first. 
       else 
        ### To Qualify all test we do Made a First variable StrTypeVar ; Will hold 
        ### the conclusion into
        ### following answer form ( Bool / Int / String ) ; 
        ### between String Test or Not 
        ### Test is made in this order : -> Do we discover something else than number 
        ### inside the StrVarNamedHold
        ### First the copy made from StrVarNamedHold remove every number and test the 
        ### value.
        ### Secondly ( might not be immediately ), Detecting 0L , or simply called 
        ### Long not rationnal
        ### inside script but might be interresting . 
        ### Succedding to removing all number, counting the remaining char. 
        local StrVarHoldTest="${StrVarNamedHold}" ; 
        local StrTypeVar="None" ; 
        
        ### Because Boolean are Special case, are likely to be String with only 
        ### 2 type of answer, True/False, It's like old story of Coolege Programmation
        ### Introduction 101 at Rosemont Cegep in 1997-1999 using Pascal and pseudo-code.
        ### It does the same for Boolean, having to type it plain text True/False and 
        ### the lexer/parser inide should understand what is Boolean to what is not... 
        ### In This context, we have craft a singular one with filtering .
        
        ### Special Case, detection of Boolean are made with sed reduction of specific
        ### Sub-Group. Especially found nothing inside Regular Expression of O'Reilly 
        ### Pocket reference, but still only a Pocket Reference. 
        
        ### Bash Big Line, It's especially important to declare it correctly and allow 
        ### type definition rather to not filtering the input at start and have many
        ### messages having problems to handle variable. Especially in Bash is actor
        ### or builtin/function/shell script to generate error on type not correctly 
        ### handled. If the variable is designe as Integer and hold String-like 
        ### information, if you do notthing with that variable or called-it 
        ### future-design, it won't tell you problems until the day you start to use it.
        
        ### Before reducing everything to nil, do a Boolean Detection:
        ### Since migration to Mint 17.3 and bash : 2016-09-02
        ### version:( GNU bash, version 4.3.11(1)-release (x86_64-pc-linux-gnu) )
        ### the sed behavior is not working like mint 12/13 .
        ### the Sed forma syntax : 
        ###   echo "${StrVarHoldTest}" | sed 's/[{'True','False'}]//g'
        ###   for simply taking out False and True reducing the Variable to Nothing and hold 
        ###   less than 0 charlong it simply not working in this version .
        StrVarHoldTest=$( echo "${StrVarHoldTest}" | sed 's/True//g;s/False//g'  ) ; 
        local IntPolishBool=${#StrVarHoldTest};
        local IntPolishgString ;
        local IntPolishInteger ;
        if [ ${IntPolishBool:=0} -eq 0 ] ; then 
         ### It's a Boolean form notation 
         StrTypeVar="Bool" ;  
         ### end of if-${IntPolishBool:=0} -eq 0
         ### here, still in "${IsTypePreamb:=False}" == "True"
         ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
        fi 
        
        ### If previous test did not transform the result into Bool.
        if [ "${StrTypeVar:=None}" == "None" ] ; then 
         StrVarHoldTest=$( echo ${StrVarHoldTest} | sed 's/[0-9]//g' ) ;
         IntPolishInteger=${#StrVarHoldTest} ; 
         StrTypeVar="Int"
         ### end of if-"${StrTypeVar:=None}" == "None"
         ### here, still in "${IsTypePreamb:=False}" == "True"
         ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
        fi 
        
        ### If previous test did not transform the result into Int.
        if [ "${StrTypeVar:=None}" == "None" ] ; then 
         StrVarHoldTest=$( echo ${StrVarHoldTest} | sed 's/[A-Za-z\ ]//g'  | tr '[:graph:]' ' ' | tr '[:cntrl:]' ' ' | tr '[:punct:]' ' ' | tr '[:space:]' ' ' | sed 's/ //g' ) ;
         IntPolishgString=${#StrVarHoldTest} ;
         StrTypeVar="String"
         ### end of if-"${StrTypeVar:=None}" == "None" 
         ### here, still in "${IsTypePreamb:=False}" == "True"
         ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
        fi 
        
        ### If previous test did not transform the result into String.
        if [ "${StrTypeVar:=None}" == "None" ] ; then 
         if [ ${IntPolishInteger:=0} -gt 0 ] ; then 
           ### it's not number 
           if [ ${IntPolishgString:=0} -eq 0 ] ; then 
            ### It own couple of extra char inside and should be see as String . 
            StrTypeVar="String" ; 
           fi 
         fi
        ### end of if-"${StrTypeVar:=None}" == "None"
        ### here, still in "${IsTypePreamb:=False}" == "True"
        ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
        fi 
        
        if [ "${StrTypeVar:=None}" == "None" ] ; then 
         if [ ${IntPolishInteger:=0} -eq 0 ] ; then 
          ### It's formely all number 
          StrTypeVar="Int" ; 
         fi
        ### end of if-${StrTypeVar:=None} == "None"
        ### here, still in "${IsTypePreamb:=False}" == "True"
        ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
        fi
        
        if [ ${StrTypeVar:=None} == "Int" ] ; then 
         StrLcTTpl=${StrLcTTpl//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=${StrVarNamedHold};} ; 
        elif [ ${StrTypeVar:=None} == "String" ] ; then 
         StrLcTTpl=${StrLcTTpl//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\";} ; 
        elif [ ${StrTypeVar:=None} == "Bool" ] ; then 
         StrLcTTpl=${StrLcTTpl//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\";} ; 
        ### end of N-clause of if ${StrTypeVar:=None} == "Int"
        ### here, still in "${IsTypePreamb:=False}" == "True"
        ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
        else
         ### Keep as String .
         StrLcTTpl=${StrLcTTpl//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\";} ;  
        ### end of if-${StrTypeVar:=None} == "Int"
        ### here, still in "${IsTypePreamb:=False}" == "True"
        ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
        fi  
       # end of if-${IsPreambulePolNtRespt:=True} == "True"
       ### After this ${IsPreambulePolNtRespt:=True} == "False"
       fi 
       
      ### end of else, second clause  of if "${IsTypePreamb:=False}" == "True"
      ### after this "${IsTypePreamb:=False}" == "False" 
      fi
    ### end of if-"${IsPreambule:=True}" == "True" 
    fi
    ###
    ### Section __IF_PATTERN__, filtering from StrIfPattern required part
    ### of __IF_PATTERN__ to fill . 
    ###
    case ${IntDefautlType} in 
     1|2|4|6|0 ) StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ;;
     3 ) StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern}} ;;
     5 ) StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/} ;;
    esac ; 
    #if [ ${IntDefautlType:=0} -eq 0 ] ; then  
    # StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ; 
    #elif [ ${IntDefautlType:=0} -eq 1 ] ; then  
    # StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ; 
    #elif [ ${IntDefautlType:=0} -eq 2 ] ; then  
    # StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ; 
    #elif [ ${IntDefautlType:=0} -eq 3 ] ; then  
    # StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ; 
    #elif [ ${IntDefautlType:=0} -eq 4 ] ; then  
    # StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ; 
    #elif [ ${IntDefautlType:=0} -eq 5 ] ; then  
    # StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ; 
    #elif [ ${IntDefautlType:=0} -eq 6 ] ; then  
    # StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ; 
    #fi
    
    StrLcTTpl=${StrLcTTpl//__START_TEST__/${ArrayTestSection[0]}} ; 
    ### It do define an exception, for BVTIdType=1,2 It does end the __END_TEST__
    ### by elif and either to not be specified because concatenating 2 types BVTIdType=1+2
    ### will left an empty elif while I do request to concatenate a if-elif + elif-elif
    ### so appending a BVTIdType=2 after a BVTIdType=1 requiert to elimitate last segment.
    ### called __END_TEST__. 
    case ${IntDefautlType} in 
     3|4|5|6|0 ) StrLcTTpl=${StrLcTTpl//__END_TEST__/${ArrayTestSection[1]}} ;;
     1|2 ) StrLcTTpl=${StrLcTTpl//__END_TEST__/} ;;
    esac ;
    ### Uses of Array BVTType 
    ### index of operation : 
    ### 0 -> if:fi,
    ### 1 -> if:elif,
    ### 2 -> elif:elif,
    ### 3 -> elif:else,
    ### 4 -> if:else,
    ### 5 -> else:fi
    ### Exception in case IntDefautlType=4 for Imbrication of if, we need to 
    ### suppress the StrDefaultEndTest or provide a return caracter to allow 
    ### to fill second declaration of BoolVarTest with state 
    ### IntDefautlType=4 , Supply a first level if/else 
    case ${IntDefautlType:=0} in 
     1|2|3|4|5|6|0 ) StrLcTTpl=${StrLcTTpl//__END_MARK__/} ;; 
     #'None')  StrLcTTpl=${StrLcTTpl//__END_MARK__/${StrDefaultEndTest}} ;;
    esac ;
    #if [ ${IntDefautlType:=0} -eq 1 ] ; then 
    # StrLcTTpl=${StrLcTTpl//__END_MARK__/} ; 
    #elif [ ${IntDefautlType:=0} -eq 2 ] ; then 
    # StrLcTTpl=${StrLcTTpl//__END_MARK__/} ; 
    #elif [ ${IntDefautlType:=0} -eq 3 ] ; then 
    # StrLcTTpl=${StrLcTTpl//__END_MARK__/} ; 
    #elif [ ${IntDefautlType:=0} -eq 4 ] ; then 
    # StrLcTTpl=${StrLcTTpl//__END_MARK__/} ; 
    #elif [ ${IntDefautlType:=0} -eq 5 ] ; then 
    # StrLcTTpl=${StrLcTTpl//__END_MARK__/} ; 
    #elif [ ${IntDefautlType:=0} -eq 6 ] ; then 
    # StrLcTTpl=${StrLcTTpl//__END_MARK__/} ; 
    #else
    # StrLcTTpl=${StrLcTTpl//__END_MARK__/${StrDefaultEndTest}} ;  
    #fi 
    ###
    ### End-Section __IF_PATTERN__
    ###  
    ###   
    
    
    ### 
    ### Section We transform StrTestTemplate into 
    ### IF 
    ### ...
    ### FI 
    ### IF  
    ### ...
    ### ELIF 
    ### ELIF 
    ### ...
    ### ELSE, 
    ### ... --> See BVTType for all choice made by default. It's a 2 choice 
    ### method and don't forget, it cover only One test at the time, 
    ### Either to not execute it after parsing you can call BoolVarTest
    ### many time and glueing result_BVT1 + result_BVT2 + result_BVT3
    ### to form a complete 
    ### 
    ### if   +
    ### ...  +--> Made by BVTType=1 BoolVarTest Stored in Var1
    ### elif +
    ### ...
    ### elif +
    ### ...  +--> Made by BVTType=2 BoolVarTest Stored in Var2
    ### elif +
    ### ...
    ### else +
    ### ...  +--> Made by BVTType=5 BoolVarTest Stored in Var3
    ### fi   +
    ### And A new variable NewVarTEst=${Var1}${Var2}${Var3} will hold the entire 
    ### test ...
    ### Notice there is odd sequence where the last line of your test SHOULD
    ### END with FI, like BVTType=4 BoolVarTest
    ### with if-else marker. This Boolean test does include a TAG named __END_MARK__
    ### with help you changing it for a 'fi' or either a semi-colon ';' 
    ### See BVTConclude where is default is semi-colon ';', but may old
    ### value like BVTConclude='fi ;' , BVTConclude='fi'   
   
    local StrMsg="Function ${__call_locality[1]}, Display Result:\n ${StrLcTTpl}\n" ; 
    VerbMsg="${StrMsg}" VerbState="${IsDisplayIfStatement}" VerbDev=/dev/stderr Verbosis ; 
    ### Output in evaluation compatible form . 
    VerbMsg="${StrLcTTpl}" VerbEvalForm=True VerbFormated=False VerbState=True VerbHeader="" Verbosis ; 
   
   }
   
   local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;

   ### End-If-Block for Switches management.
   if [ "${Arg0:=--startservices}" == "--help"	] ; then 
     GetVarReference ${__call_locality[1]} ; 
     echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ;
   elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
    eval $( __GetVarReferenceCompWord ) ;
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
   elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
    eval $( eval VTVValueEntry=${StrVarListTransfert} \
            VTVIsValueReAssign=True    \ 
            VTVIsValueToConvert=False  \
            VTVIsQuotedValue=True      \
            VTVIsArrayStyleInsert=True \
            ValueToVariable ) ${StrStartMain} 
   fi
   
  }

   
fi ### End-of if-versionBVT == 0.0.1 .

###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
case ${versionMC:=0.0.0} in
 "0.0.0" | "0.0.1") unset GetDateReportCreation MdCd ; versionMC=${versionMC} . ${FNCTDLIBPATH}/0f86b448-72f4-11e6-8b1d-001e4c8856d6 ;;
 "0.0.2" ) versionMC=${versionMC:=0.0.2} . ${FNCTDLIBPATH}/0f86b448-72f4-11e6-8b1d-001e4c8856d6  ;;
esac ### End-of case-versionMC == 0.0.X .


if [ "${versionSIC}" == "0.0.0" ] ; then 

  unset ScriptImageConversion ; 
  function ScriptImageConversion()
  {
    local StrImgCp=$( base64 --wrap=0 ${SICFileName:=None} ) ;
    local IntSegment=${SICSegmentLength:=48} ; 
    local IntImgCp=${#StrImgCp} ; 
    local StrScriptVarbuil="" ;
    while [ ${IntImgCp:=0} -gt 0 ] ; do 
      StrScriptVarbuil="${StrScriptVarbuil}\"${StrImgCp:0:${IntSegment}}\"__ADD__" ; 
      StrImgCp=${StrImgCp:${IntSegment}:$(( ${#StrImgCp}-${IntSegment} ))} ; 
      IntImgCp=${#StrImgCp} ; 
      if [ ${IntImgCp:=0} -ge ${IntSegment} ] ; then 
       StrScriptVarbuil=${StrScriptVarbuil//__ADD__/+} ; 
      else
       StrScriptVarbuil=${StrScriptVarbuil//__ADD__/} ; 
      fi 
    done 
  }

fi #EndIf "${versionSIC}" == "0.0.0" 

if [ "${versionSIC}" == "0.0.1" ] ; then 
  
  eval $( GFCFuncName=ScriptImageConversion GlobalFunctionCleaning ) ; 

  function ScriptImageConversion()
  {
   function Verbosis()
   {
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Verb Verbosis ) ; 
    local Arg0=${ArrayArg[0]} ; 
    local StrMsg=${VerbMsg:=__TEXT__} ; 
    local StrDevOut=${VerbDev:=/dev/stderr} ; 
    local IsVerboseState=${VerbState:=False} ;
    local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
    local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
    local IsDisplayFormatted=${VerbFormated:=True} ;
    local IsAppendMode=${VerbAppendDev:=False} ; 
    local IsExtendedOutput=${VerbExtendedOut:=False} ; 
    local ArrayArg=( $* ) ; 
    if [ "${IsVerboseState:=False}" == "True" ] ; then 
     if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
        echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
      else  
        echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
      fi
     else
      if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" ;  
       else
         echo "${StrMsg}" ;  
       fi
      else
       if [ "${IsAppendMode:=False}" == "True" ] ; then 
        if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
          echo -ne "${StrMsg}" >> ${StrDevOut} ;
        else
          echo "${StrMsg}" >> ${StrDevOut} ;
        fi
       else
        if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" > ${StrDevOut} ;
        else
         echo "${StrMsg}" > ${StrDevOut} ;
        fi 
       fi
      fi 
     fi 
    fi
   } 
   ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( SIC ScriptImageConversion ) ;
    local Arg0="${ArrayArg[0]}" ; 
    local StrParentApps=${__call_locality[1]} ;
    local StrStartMain=${SCHFuncStart:=__main_StartServices} ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=ScriptImageConversion CAIsAddParent=False __Call_Argument ) ; 
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=ScriptImageConversion CAIsAddParent=False CallArgument ) ;
   fi #EndIf ${versionCA:=0.0.0} == "0.0.0" 
   
   local StrScript=${SICScriptType:=javascript} ; 
   local IntSegLength=${SICSegmentLength:=48} ;
   local StrFileName=${SICFilename:=file.png} ;
   local BoolAddHeader=${SICAddHeader:=True} ;
   local StrVarName=${SICVariableName:=None} ;
   local StrHeaderTpl=${SICHeaderTpl:=data:image/__MIMETYPE__;base64,} ;
   local StrVarForm=${SICVarCreation:='javascript:var__SPACE____VAR____SPACE__=__SPACE__:+:;,python:__VAR____SPACE__=__SPACE__:.:__NONE__,java:__VAR____SPACE__=__SPACE__:+:;',jython:__VAR____SPACE__=__SPACE__:.:;} ; 
   local StrVTVRegistry=${SICVTVReg:=VTVIsQuotedValue=True,VTVIsArrayStyleInsert=True,VTVIsValueReAssign=True,VTVIsValueToConvert=False} ; 
   local BoolDisplayDebug=${SICDisplayDebug:=False} ; 
   local StrVarList="StrScript,IntSegLength,StrFileName,BoolAddHeader,StrVarName,StrVTVRegistry,StrHeaderTpl,StrEvalConcat,StrVarForm,BoolDisplayDebug" ;
   
   local -a ArrayMsg ;
   ArrayMsg[0]="Entry in function" ;   
   ArrayMsg[1]="\nLanguage Script:__SCRIPT__\nTemplate for variable uses:'__TEMPLATE__'\nConcatenation Operator: '__OPERTATOR__'\nLine terminator: '__TERMINATOR__'" ; 
   ArrayMsg[2]="Base64 file size:__INT__ byte(s)" ; 
   ArrayMsg[4]="Base64 Stream splited into __INT__ chunk." ; 
   
   function FileFormatDetection()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( FFD FileFormatDetection ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=FileFormatDetection CAIsAddParent=True __Call_Argument ) ;
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=FileFormatDetection CAIsAddParent=True CallArgument ) ;
    fi 
    local StrFileName=${FFDFile:=None} ; 
    local StrApp=${FFDApps:=/usr/bin/file} ; 
    ${StrApp} ${StrFileName} | /usr/bin/cut -d ':' -f 2 | /usr/bin/cut -d ' ' -f 2 | tr '[:upper:]' '[:lower:]' ; 
 
   }
   
   function __main_StartServices()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ;
    fi 
    StrMsg=$( ScriptImageConversion --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

    StrScript=$( echo ${StrScript} | tr '[:upper:]' '[:lower:]'  ) ; 
    
    local StrImgCp ; 
    local StrMimeType ;
    local StrFileHeader ; 
    local StrScriptVarbuild="" ;
    local StrSegmentCreation ; 
    local IntImgCp ; 
    local StrMsg ; 
    local IntChunkCount=0 ; 
    
    local -A ArrayConfig ; 
    local -a ArrayVarCreation=( ${StrVarForm//,/ } ) ; 
    local StrASeg ;
    StrMsg=$( ScriptImageConversion --get ArrayMsg[1]  ) ; 
    for (( intI=0 ; intI <= ${#ArrayVarCreation[@]}-1 ; intI++ )) ; do 
     StrASeg=${ArrayVarCreation[${intI}]} ; 
     ArrayConfig["script"]="${StrASeg/%:[a-zA-Z_+;]*}" ; 
     if [ "${StrScript:=javascript}" == "${ArrayConfig[script]}" ] ; then 
      StrASeg="${StrASeg/#${ArrayConfig[script]}:}" ; 
      ArrayConfig["template"]="${StrASeg/%:[a-zA-Z_+;]*}" ; 
      StrASeg="${StrASeg/#${ArrayConfig[template]}:}" ; 
      ArrayConfig["operator"]="${StrASeg/%:[a-zA-Z_+;]*}" ; 
      StrASeg="${StrASeg/#${ArrayConfig[operator]}:}" ; 
      ArrayConfig["terminator"]="${StrASeg/%:[a-zA-Z_+;]*}" ; 
      StrMsg=${StrMsg//__SCRIPT__/${ArrayConfig["script"]}} ; 
      StrMsg=${StrMsg//__TEMPLATE__/${ArrayConfig["template"]}} ; 
      StrMsg=${StrMsg//__OPERTATOR__/${ArrayConfig["operator"]}} ; 
      StrMsg=${StrMsg//__TERMINATOR__/${ArrayConfig["terminator"]}} ; 
     fi 
    done 
    VerbMsg=${StrMsg} VerbState=${BoolDisplayDebug} VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True  VerbDev=/dev/stderr  Verbosis ; 
    if [ "${StrVarName:=None}" != "None" ] ; then 
      StrScriptVarbuild="${StrScriptVarbuild}${ArrayConfig[template]}" ; 
      StrScriptVarbuild="${StrScriptVarbuild//__SPACE__/ }" ; 
      StrScriptVarbuild="${StrScriptVarbuild//__VAR__/${StrVarName}}" ; 
    fi 
    
    if [ "${BoolAddHeader:=False}" == "True" ] ; then 
     StrMimeType=$( FFDFile=${StrFileName} FileFormatDetection )
     StrFileHeader=${StrHeaderTpl//__MIMETYPE__/${StrMimeType}}
     StrScriptVarbuild="${StrScriptVarbuild}\"${StrFileHeader}\"${ArrayConfig[operator]}\n" ; 
    fi 
    
    StrImgCp=$( /usr/bin/base64 --wrap=0 ${StrFileName} ) ;
    IntImgCp=${#StrImgCp} ; 
    StrMsg=$( ScriptImageConversion --get ArrayMsg[2]  ) ; 
    StrMsg=${StrMsg//__INT__/${IntImgCp}} ; 
    VerbMsg=${StrMsg} VerbState=${BoolDisplayDebug} VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True  VerbDev=/dev/stderr  Verbosis ;  
    
    while [ ${IntImgCp:=0} -gt 0 ] ; do 
     StrSegmentCreation="\"${StrImgCp:0:${IntSegLength}}\"__ADD__\n"  ;
     IntSegSize=${#StrSegmentCreation} ; 
     StrImgCp=${StrImgCp:${IntSegLength}:$(( ${#StrImgCp}-${IntSegLength} ))} ; 
     IntImgCp=${#StrImgCp} ; 
     if [ ${IntSegSize:=0} -gt $(( ${IntSegLength} - 1 )) ] ; then 
      StrSegmentCreation="${StrSegmentCreation//__ADD__/${ArrayConfig[operator]}}" ; 
     else
      StrSegmentCreation="${StrSegmentCreation//__ADD__/${ArrayConfig[terminator]}}";
     fi 
     
     StrScriptVarbuild="${StrScriptVarbuild}${StrSegmentCreation}" ; 
  
     IntChunkCount=$(( ${IntChunkCount} + 1 )) ; 
    done
    StrScriptVarbuild=${StrScriptVarbuild//__NONE__/} ; 
    
    StrMsg=$( ScriptImageConversion --get ArrayMsg[4]  ) ; 
    StrMsg=${StrMsg//__INT__/${IntChunkCount}} ; 
    VerbMsg=${StrMsg} VerbState=${BoolDisplayDebug} VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True  VerbDev=/dev/stderr  Verbosis ;  
    
    echo -ne "${StrScriptVarbuild}" ; 
    ### VerbMsg=${StrScriptVarbuild} VerbState=True VerbEvalForm=False VerbFormated=False  Verbosis ; 
       
   }
   function __main_StopServices()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( Main __main_StopServices ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True __Call_Argument ) ;
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True CallArgument ) ;
    fi 
    StrMsg="Entry in function" ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   }
   
   local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
   local StrNameHelper="${__call_locality[1]}\tSimple Image converter to provide Base64 and Script\n\t\t\tuses of encoded Stream.\n";
   local StrSummary="\n\tIntended for Javascript, it ouput in base64 with Stream of String with \n\tconcatenated result for reducing printing problem of long-lines of base64\n \tinside Javascript. As example providing embedded images in base64 inside \n\tHTML Image tag accept a base64 inside src attribute with \n\tproper Header.\n" ; 
   local StrSynopsis="\n\tAfter providing Image File name, Type of Script and length of the segment \n\tit will generate a pure base64 Stream from many lines separed with a \n\tconcatenate operator\n\n\tsimple use:\n\t SICFilename=file.png SICSegmentLength=48 SICScriptType=javascript \n\t ScriptImageConversion\n\n\tWill ouput:\n\t\"/9j/4AAQSkZJRgABAQEAYABgAAD/4QAWRXhpZgAASUkqAAgA\"+\n\t\"AAAAAAAAAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkS\"+\n\t\"Ew8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgy\"+\n\t\"PC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIy\"+\n\t\"MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIy\"+\n\t...\n";
   local StrDescription="\n\tOther example like adding the Base64 header for image identification by \n\tthe browser. It require at least the file should be know of file \n\t(/usr/bin/file). in case it does not recognize it, follow manpage of \n\t/usr/bin/file (man 1 file) while you may have to add Header of the \n\tunidentified file inside the magic file.\n\n \tIn case it require to add the header because your browser support the Image \n\tsrc attribute to handle base64 :\n\n\tSICFilename=file.png SICAddHeader=True SICSegmentLength=48 \n\tSICScriptType=javascript\n\tWill ouput:\n\t\"data:image/png;base64\"+\n\t\"/9j/4AAQSkZJRgABAQEAYABgAAD/4QAWRXhpZgAASUkqAAgA\"+\n\t\"AAAAAAAAAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkS\"+\n\t\"Ew8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgy\"+\n\t\"PC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIy\"+\n\t\"MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIy\"+\n\t...\n" ;
  
   if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    GVRIsName=True     \
    GVRIsSummary=True  \
    GVRIsSynopsis=True \
    GVRIsDesc=True     \
    GetVarReference ${__call_locality[1]} ; 
    echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ;
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    eval $( __GetVarReferenceList ) ;	
   elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
    eval $( eval \
      ${StrVTVRegistry//,/ }  \
      VTVValueEntry=${StrVarList} \
      VTVIsWhiteList=True         \
      VTVWhiteListTransfert=UUID  \
      ValueToVariable ) __main_StopServices ; 
   elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
    # eval $( eval VersionApps ) ; 
    StrMsg=$( ScriptImageConversion --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    eval $( eval \
      ${StrVTVRegistry//,/ }  \
      VTVValueEntry=${StrVarList} \
      ValueToVariable ) ${StrStartMain}
   fi   

 
  }

fi #End-if "${versionSIC}" == "0.0.1"


###
### Versioning and Variable Block , 
### « 'Versioning' From french, 'de versions des' »
###
if [ "${versionSCH}" == "0.0.1" ] ; then 
  
  eval $( GFCFuncName=ServiceControllerHandler GlobalFunctionCleaning ) ; 
  
  function ServiceControllerHandler()
  {
   function Verbosis()
   {
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Verb Verbosis ) ; 
    local Arg0=${ArrayArg[0]} ; 
    local StrMsg=${VerbMsg:=__TEXT__} ; 
    local StrDevOut=${VerbDev:=/dev/stderr} ; 
    local IsVerboseState=${VerbState:=False} ;
    local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
    local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
    local IsDisplayFormatted=${VerbFormated:=True} ;
    local IsAppendMode=${VerbAppendDev:=False} ; 
    local IsExtendedOutput=${VerbExtendedOut:=False} ; 
    local ArrayArg=( $* ) ; 
    if [ "${IsVerboseState:=False}" == "True" ] ; then 
     if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
        echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
      else  
        echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
      fi
     else
      if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" ;  
       else
         echo "${StrMsg}" ;  
       fi
      else
       if [ "${IsAppendMode:=False}" == "True" ] ; then 
        if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
          echo -ne "${StrMsg}" >> ${StrDevOut} ;
        else
          echo "${StrMsg}" >> ${StrDevOut} ;
        fi
       else
        if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" > ${StrDevOut} ;
        else
         echo "${StrMsg}" > ${StrDevOut} ;
        fi 
       fi
      fi 
     fi 
    fi
   } 
   ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( SCH ServiceControllerHandler ) ;
    local Arg0="${ArrayArg[0]}" ; 
    local StrParentApps=${__call_locality[1]} ;
    local StrStartMain=${SCHFuncStart:=__main_StartServices} ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=ServiceControllerHandler CAIsAddParent=False __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=ServiceControllerHandler CAIsAddParent=False CallArgument ) ;
   fi  
      
   local StrPathLoopState=${SCHSInstancePath:=/var/cache/Fnct.D} ;  
   local StrFunctionName=${SCHFunctionName:=None} ; 
   local StrDefaultAction=${SCHAction:=Loop} ; 
   local BoolRemoveFileAction=${SCHRemoveFileAction:=False} ; 
   local StrPathActionState=${LSSLoopFile:=__PATH__/__ACTION__-__SHORTFUNC__-__UUID__} ; 
   
   local StrTextZenityEmpty="""<span font_family=\"monospace\" size=\"large\">List of instance for function __FUNCT__ is empty</span>""" ;
   local StrTextZenityList="""Select UUID instance of function __FUNCT__ to Shutdown Application or interrupt action:__ACTION__""" ; 
   local StrUUID="" ; 
   local StrVarList="StrPathLoopState,StrTextZenityEmpty,StrTextZenityList,StrFunctionName,StrDefaultAction,BoolRemoveFileAction,StrPathActionState" ;
   
   local -a ArrayMsg ;
   
   ArrayMsg[0]="Entry in function" ;   
   
   function __main_StartServices()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ;
    fi 
    StrMsg=$( ServiceControllerHandler --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    
    ### Difference with LSSServices , having a function-name filter to issues 
    ### a search based on Function Criteron and Action-type. 
    ### LSSServices does only interrupt Loop from LoopShellScript while 
    ### this application will stop all UUID-instance from a specific /var/cache
    ### initialized services . 
    ### In action there is a default Loop, action but can handle other semantic 
    ### word depending of the structure of the __main_StartServices, as example 
    ### DoCtrlHandler will accept diferent action to take place, like 
    ### environment, loop and conditional action inside a loop. 
    local StrShortName=$( GetStdPrefixName ${StrFunctionName} ) ; 
    
    local IntGrepResult=$( find ${StrPathLoopState} -maxdepth 1 -type f -iname "${StrDefaultAction}-${StrShortName}*" | egrep -ic "[a-fA-F0-9]*-[a-fA-F0-9]*-[a-fA-F0-9]*-[a-fA-F0-9]*-[a-fA-F0-9]*" ) ; 
    
    local StrZenityListUUID=$( find ${StrPathLoopState} -maxdepth 1 -type f -iname "${StrDefaultAction}-${StrShortName}*" -printf "FALSE %f\n" | sed 's/-/ /g' | cut -d ' ' -f 1,4-8 | sed 's/ /-/g;s/FALSE-/FALSE /g' | tr '[:cntrl:]' ' '  ) ; 
    
    StrMsg="Element(s) inside StrZenityListUUID:( __STR__) Detected Item: __INT__" ;
    StrMsg=${StrMsg//__STR__/${StrZenityListUUID}} ;
    StrMsg=${StrMsg//__INT__/${IntGrepResult}} ;
    
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    local IntLenZenityList=${#StrZenityListUUID}
    StrTextZenityList=${StrTextZenityList//__FUNCT__/${StrFunctionName}} ;
    StrTextZenityList=${StrTextZenityList//__ACTION__/${StrDefaultAction}} ; 
    
    if [ ${IntGrepResult:=0} -gt 0 ] ; then 
     local ArrayServicesStop=( $( zenity --width=400 --height=400 --list --text="${StrTextZenityList}" --column="Selection" --column="UUID Instance" --separator=' ' --checklist --multiple  ${StrZenityListUUID} ) ) ; 
     local IntCountID=${#ArrayServicesStop[@]} ; 
     
     StrMsg="Nb Element inside ArrayServicesStop: __INT__" ;
     StrMsg=${StrMsg//__INT__/${#ArrayServicesStop[@]}} 
     VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
     
     ### Prepare the StrPathActionState to hold Path, Action and Function. 
     ### Will leave UUID field as tag to allow parsing-it inside the for-action. 
     local StrActionTrigger=${StrPathActionState} ; 

     StrActionTrigger=${StrActionTrigger//__PATH__/${StrPathLoopState}} ; 
     StrActionTrigger=${StrActionTrigger//__ACTION__/${StrDefaultAction}} ; 
     StrActionTrigger=${StrActionTrigger//__SHORTFUNC__/${StrShortName}} ; 
     if [ ${IntCountID:=0} -gt 0 ] ; then 
      for (( intx=0 ; intx <= ${IntCountID}-1 ; intx++ )) ; do 
       StrUUID=${ArrayServicesStop[${intx}]} ; 
       if [ "${BoolRemoveFileAction:=False}" == "True" ] ; then 
         rm -f ${StrActionTrigger//__UUID__/${StrUUID}}  ; 
       else
         UUID=${StrUUID} ${StrFunctionName} --stopservices ;
       fi 
      done 
     fi 
    else
     
     StrTextZenityEmpty=${StrTextZenityEmpty//__FUNCT__/${StrFunctionName}} ; 
     zenity --info --text="${StrTextZenityEmpty}" ; 
    fi 
   }
   function __main_StopServices()
   {
    if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
     local -a ArrayArg=( $* ) ;
     local -a __call_locality=( Main __main_StopServices ${StrParentApps} ) ;
     local Arg0="${ArrayArg[0]}" ; 
    elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
     eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True __Call_Argument ) ;
    elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
     eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True CallArgument ) ;
    fi 
    StrMsg="Entry in function" ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   }
       
   local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
   local StrNameHelper="${__call_locality[1]}\tAn application to manage Function instance having an Action like Loop, Iteration, initialisation to \n\t\t\t\tShutdown or to stop it's services.";
   local StrSummary="This application does end an application. Require to specify SCHFunctionName=FunctionName it stop the services by calling it's stop-switches '--stopservices'. " ; 
   local StrSynopsis="Here Some example to use this function\n\t\tSCHFunctionName=LoopShellScript ServiceControllerHandler\n\n\t\tWill display a Zenity List-container to select multiple instance or death-instance of the application and the \n\t\tServiceControllerHandler will remove them. \n\n\tUsing directly the remove mechanism to remove the file without using the application stop-services switches\n\tcan be called like this:\n\n\tSCHFunctionName=LoopShellScript SCHRemoveFileAction=True SCHFunctionName=StartSlewAnalysis ServiceControllerHandler\n\n\tWill remove the file only. ";
   local StrDescription="This application Can Stop a services or remove a specific Action file held in cache path of Fnct.D or specified by SCHSInstancePath. This application can also remove file other than Loop-file, require to fill SCHAction  with 'Loop', 'Iteration', 'Env' or any prefix found inside the cache path of Fnct.D . If the application is launched with Prefixed-Variable SCHRemoveFileAction=True, it simply remove the file with parameter added like SCHAction, SCHFunctionName and even SCHSInstancePath. " ;
   
    
   if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    GVRIsName=True     \
    GVRIsSummary=True  \
    GVRIsSynopsis=True \
    GVRIsDesc=True     \
    GetVarReference ${__call_locality[1]} ; 
    echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ;
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    eval $( __GetVarReferenceList ) ;	
   elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
    eval $( eval \
      VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      VTVIsWhiteList=True         \
      VTVWhiteListTransfert=UUID  \
      ValueToVariable ) __main_StopServices ; 
   elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
    # eval $( eval VersionApps ) ; 
    StrMsg=$( ServiceControllerHandler --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    eval $( eval \
      VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      ValueToVariable ) ${StrStartMain}
   fi   
  }

fi ### End-of if-versionSCH == 0.0.1 .



### Unitary test command : unset BoolVarTest ; . /etc/init.d/Fnct.D/fnct_debian_lib BVTVarHold='' BVTVTVVar=BoolDisplayFnctD,StrUrlGetter,BoolEvalCmdExit,StrAppsPwdGenerator,IntDefaultPwdSize,IntDefaultFactor,IntRandomSeedFactor,StrPasswordTypeForm,IntPasswordType,IsAutoInstallPwgen,StrDebInstallMethod,StrDebianInstallerType,StrAptLineCmd,StrGdebiPackageName,StrGdebiDownloadPack,StrFnctDSvrBVTVC BVTVTFnct=__Display BVTBoolVarName=${BoolEvalCmdExit:=False} BVTBoolCase=False BVTBoolAssertion='' BVTIsPreambule=True BVTScopeTest=local BVTVTVVarA=BoolDisplayFnctD,StrUrlGetter,BoolEvalCmdExit,StrAppsPwdGenerator,IntDefaultPwdSize,IntDefaultFactor,IntRandomSeedFactor,StrPasswordTypeForm,IntPasswordType,IsAutoInstallPwgen,StrDebInstallMethod,StrDebianInstallerType,StrAptLineCmd,StrGdebiPackageName,StrGdebiDownloadPack,StrFnctDSvrBVTVC BVTVTFnctA=__Loop BVTIsValueToVar=True BVTIsValueToVarAssert=True BVTDisplayIf=True BoolVarTest



