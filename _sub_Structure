
### Package : _sub_Structure


### ValueToVariable
### Was moved into chunk to control version, another version without uses 
### of sed and less as possible of BoolVarTest and/or BoolVarTestVarCreation. 
### To call this version you will need to pass on command line 
### versionVTV=0.0.1 like :
### versionVTV=0.0.1 . /etc/init.d/Fnct.D/fnct_debian_lib

if [ "${versionVTV:=0.0.2}" == "0.0.1" ] ; then 
 unset ValueToVariable ; 
 . /etc/init.d/Fnct.D/482e0e5a-763b-11e6-8b1d-001e4c8856d6
fi 
### 

if [ "${versionGVR:=0.0.2}" == "0.0.2" ] ; then 
 ### GetVarReference
 unset GetVarReference
 . ${FNCTDLIBPATH}/6403c722-28a6-11e3-98a2-001b3875b29c
fi

if [ "${versionGVRL:=0.0.2}" == "0.0.2" ] ; then 
 unset __GetVarReferenceList ;
 function __GetVarReferenceList( )
 {
   #local __call_locality=( __GVRL __GetVarReferenceList ) ;
   #local ArrayArg=( $* ) ; 
   #local Arg0=${ArrayArg[0]} ;  
   local IsZenityBuildForm=${BuildForm:=False} ;
   ### Prefixed-Variable __GLRLAppsGuiBuilder is reserved for 
   ### user creating a better Gui-Builder than existing one 
   ### to form execution statement fo Bash ...
   local StrAppsGuiForm=${__GVRLAppsGuiBuilder:=ZenityBuildForm} ; 
   ### Exception to StrVariableList and uses of eval in this case, 
   ### it should require extra wrapup of an Evaluative Executive Brace, but using 
   ### an echo does replace it. Notice it's the cheating way to get rid of 
   ### back-slashing the quote, back-slashing the dollar-sign, back-slashing  the any
   ### 'compromized chars ', but it cost uses of echo, an application /bin/echo
   ### where is may cost cpu-cycle if it's in a loop, executed recurrently or
   ### managed of owner execution like sudo application "chown +S/bin/echo", we can
   ### be in big trouble...  
   local StrVariableList=$( echo """eval BuildForm=False  ${__call_locality[1]} --help 2> /dev/null | egrep -i \"^Variable ${__call_locality[0]}\" | cut -d ' ' -f 2 | tr '[:cntrl:]' ' '""" ) ; 
   local StrBuildFormResult ;
   if [ ${IsZenityBuildForm:=False} == "True" ] ; then 
    StrBuildFormResult=$( """{ ZBFFunctionName=${__call_locality[1]} ZenityBuildForm ; }""" ) ; 
    #eval $( eval """\\${__call_locality[1]} \\${StrAppsGuiForm} """ ) ; 
    #eval echo $( """echo -ne \"Function: ${__call_locality[1]} \" """ ) ;
    ### ; __GVRLVariableList="${StrVariableList// /,}" ZBFFunctionName=${__call_locality[1]} ${StrAppsGuiForm} ;""" ) ;   
   else
    echo "${StrVariableList}" ; 
   fi
   
 }
### End-of if-${versionGVRL} 
fi

if [ "${versionGVRCW:=0.0.2}" == "0.0.2" ] ; then 
 ### __GetVarReferenceCompWord
 unset __GetVarReferenceCompWord ; 
 . ${FNCTDLIBPATH}/023102e0-1833-11e3-98a2-001b3875b29c
 ### This is first pragma. BodyFunc Should manage it.
### End-of if-${versionGVRCW} 
fi


if [ "${versionGSPN:=0.0.2}" == "0.0.2" ] ; then 
 ### GetStdPrefixName 
 unset GetStdPrefixName ; 
 . ${FNCTDLIBPATH}/69968204-0cf6-11e3-99bc-001b3875b29c
fi

if [ "${versionCA:=0.0.0}" == "0.0.0" ] ; then 
echo -ne "\n\033[01;33m**************************************************\n\033[01;43mNo CallArgument / __Call_Argument in version 0.0.0\n\033[00m\033[01;33m**************************************************\033[00m\n" ; 
fi

if [ "${versionCA:=0.0.0}" == "0.0.2" ] ; then 
 unset CallArgument ; 
 function CallArgument()
 {
   local __call_locality=( CA CallArgument ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]};
   
   local StrFuncName=${CAFunctName:=None} ; 
   local StrScope=${CACodeScope:=local} ;
   local BoolUsingSed=${CAUsingSedTrim:=True} ; 
   local BoolAddParent=${CAIsAddParent:=False} ; 
   local BoolChildBoot=${CAIsChildBoot:=False} ; 
   local StrStartMain=${CAFuncStart:=__main_StartServices} ; 
   local StrShortName ; 
   local StrVarList="StrVarList,StrFuncName,StrScope,StrStartMain,StrShortName,BoolChildBoot,BoolAddParent,BoolUsingSed" ; 
   
   function __main_StartServices()
   {
    local __call_locality=( Main __main_StartServices ) ;
    local ArrayArg=( $* ) ;
    local Arg0=${ArrayArg[0]};
    if [ "${StrFuncName:=__main_StartServices}" == "__main_StartServices" ] ; then 
     StrShortName="Main"
    elif [ "${StrFuncName:=__main_StartServices}" == "__main_StopServices" ] ; then 
     StrShortName="Main"
    else
     StrShortName=$( GetStdPrefixName ${StrFuncName} ) ;
    fi 
    local StrBootStrap="__SCOPE__ StrStartMain=\${__SHORTNAME__FuncStart:=__main_StartServices} ;" ; 
    local StrArgumentCode="""__SCOPE__ __call_locality=( __SHORTNAME__ __LONGNAME__ __PARENT_NAME__ ) ; __SCOPE__ ArrayArg=( \$* ) ; __SCOPE__ Arg0=\${ArrayArg[0]} ; __SCOPE__ StrParentApps=\${__call_locality[1]} ; __BOOT_STRAP__""" ; 
    if [ "${BoolAddParent:=False}" == "True" ] ; then 
     StrArgumentCode=${StrArgumentCode//__PARENT_NAME__/\$\{StrParentApps\}} ; 
     if [ "${BoolChildBoot:=False}" == "False" ] ; then 
      StrArgumentCode=${StrArgumentCode/__BOOT_STRAP__/} ; 
     fi 
    else
     StrArgumentCode=${StrArgumentCode//__PARENT_NAME__/} ;
    fi
    StrArgumentCode=${StrArgumentCode/__BOOT_STRAP__/${StrBootStrap}} ; 
    StrArgumentCode=${StrArgumentCode//__SCOPE__/${StrScope}} ;
    StrArgumentCode=${StrArgumentCode//__PREFIX__/${StrPrefixVar}} ;
    StrArgumentCode=${StrArgumentCode//__SHORTNAME__/${StrShortName}} ;
    StrArgumentCode=${StrArgumentCode//__LONGNAME__/${StrFuncName}} ;
    
    if [ "${BoolUsingSed:=True}" == "False" ] ; then 
      StrArgumentCode=$( echo "${StrArgumentCode}" | /usr/bin/tr '[:cntrl:]' ' ' ) ; 
    else
      StrArgumentCode=$( echo "${StrArgumentCode}" | /bin/sed 's/\n/\\n/g;s/\r/\\r/g' ) ; 
    fi
    echo "${StrArgumentCode}" ; 
    
   }

   local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
   local StrNameHelper="__Call_Argument\tStand for Meta-Function of Fnct.D";
   local StrSummary="This Meta-Function __Call_Argument is a mechanism describe in README.rst to inform function from it's name, it's Short-name and presence of parent or in which function the sub-function is part of. This Meta-Function generate important code and replace state-of-the-art declaration of __call_locality, StrParentApps, and also define the BootStrap name in top-function. Bootstrap is a procedure handled by --start-services allow to start the Main function or other subfunction if they are equiped of Second-Role-Function. Second-Role-Function are some functionality embedded inside a function called by the bootstrap process to give a second action call from your top-function. " ; 
   local StrSynopsis="__Call_Argument in replacement of some step to code appropriate Fnct.D compliant function to talk and communicate with other entity is a Procedure-ready to apply to a top-function and Prefixed-Variable can only add Layer of information to help the function to grow in diversity of Fnct.D method helping to develop with less code.";
   local StrDescription="This section contain Detailed information for __FUNCT__" ;
   
   if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    GVRIsName=True GVRIsSynopsis=True GVRIsSummary=True GVRIsDesc=False GetVarReference ${__call_locality[1]} ; 
    echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ;
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    eval $( __GetVarReferenceList ) ;	
   elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
    eval $( VTVIsArrayStyleInsert=True \
         VTVValueEntry=${StrVarList}   \
         VTVIsValueReAssign=True       \
         VTVIsValueToConvert=False     \
         VTVIsArrayStyleInsert=True    \
         ValueToVariable ) ${StrStartMain} ; 
   fi

 }

### End-of if-versionCA == 0.0.2 . 
fi 

if [ "${versionCA:=0.0.0}" == "0.0.1" ] ; then 
 ### A prototype to avoid declaring in wrong order the
 ### Arg0 and ArrayArg ... 
 ### It will create the appropriate code in correct order 
 ### to ensure Argument will be callable .
 unset __Call_Argument ; 
 function __Call_Argument()
 {
   local __call_locality=( CA __Call_Argument ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]};
   
   local StrFuncName=${CAFunctName:=None} ; 
   local StrScope=${CACodeScope:=local} ;
   local BoolUsingSed=${CAUsingSedTrim:=True} ; 
   local BoolAddParent=${CAIsAddParent:=False} ; 
   local BoolChildBoot=${CAIsChildBoot:=False} ; 
   local StrStartMain=${CAFuncStart:=__main_StartServices} ; 
   local StrShortName ; 
   local StrVarList="StrVarList,StrFuncName,StrScope,StrStartMain,StrShortName,BoolChildBoot,BoolAddParent,BoolUsingSed" ; 
   
   function __main_StartServices()
   {
    local __call_locality=( Main __main_StartServices ) ;
    local ArrayArg=( $* ) ;
    local Arg0=${ArrayArg[0]};
    if [ "${StrFuncName:=__main_StartServices}" == "__main_StartServices" ] ; then 
     StrShortName="Main"
    elif [ "${StrFuncName:=__main_StartServices}" == "__main_StopServices" ] ; then 
     StrShortName="Main"
    else
     StrShortName=$( GetStdPrefixName ${StrFuncName} ) ;
    fi 
    local StrBootStrap="__SCOPE__ StrStartMain=\${__SHORTNAME__FuncStart:=__main_StartServices} ;" ; 
    local StrArgumentCode="""__SCOPE__ __call_locality=( __SHORTNAME__ __LONGNAME__ __PARENT_NAME__ ) ; __SCOPE__ ArrayArg=( \$* ) ; __SCOPE__ Arg0=\${ArrayArg[0]} ; __SCOPE__ StrParentApps=\${__call_locality[1]} ; __BOOT_STRAP__""" ; 
    if [ "${BoolAddParent:=False}" == "True" ] ; then 
     StrArgumentCode=${StrArgumentCode//__PARENT_NAME__/\$\{StrParentApps\}} ; 
     if [ "${BoolChildBoot:=False}" == "False" ] ; then 
      StrArgumentCode=${StrArgumentCode/__BOOT_STRAP__/} ; 
     fi 
    else
     StrArgumentCode=${StrArgumentCode//__PARENT_NAME__/} ;
    fi
    StrArgumentCode=${StrArgumentCode/__BOOT_STRAP__/${StrBootStrap}} ; 
    StrArgumentCode=${StrArgumentCode//__SCOPE__/${StrScope}} ;
    StrArgumentCode=${StrArgumentCode//__PREFIX__/${StrPrefixVar}} ;
    StrArgumentCode=${StrArgumentCode//__SHORTNAME__/${StrShortName}} ;
    StrArgumentCode=${StrArgumentCode//__LONGNAME__/${StrFuncName}} ;
    
    if [ "${BoolUsingSed:=True}" == "False" ] ; then 
      StrArgumentCode=$( echo "${StrArgumentCode}" | /usr/bin/tr '[:cntrl:]' ' ' ) ; 
    else
      StrArgumentCode=$( echo "${StrArgumentCode}" | /bin/sed 's/\n/\\n/g;s/\r/\\r/g' ) ; 
    fi
    echo "${StrArgumentCode}" ; 
    
   }

   local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
   local StrNameHelper="__Call_Argument\tStand for Meta-Function of Fnct.D";
   local StrSummary="This Meta-Function __Call_Argument is a mechanism describe in README.rst to inform function from it's name, it's Short-name and presence of parent or in which function the sub-function is part of. This Meta-Function generate important code and replace state-of-the-art declaration of __call_locality, StrParentApps, and also define the BootStrap name in top-function. Bootstrap is a procedure handled by --start-services allow to start the Main function or other subfunction if they are equiped of Second-Role-Function. Second-Role-Function are some functionality embedded inside a function called by the bootstrap process to give a second action call from your top-function. " ; 
   local StrSynopsis="__Call_Argument in replacement of some step to code appropriate Fnct.D compliant function to talk and communicate with other entity is a Procedure-ready to apply to a top-function and Prefixed-Variable can only add Layer of information to help the function to grow in diversity of Fnct.D method helping to develop with less code.";
   local StrDescription="This section contain Detailed information for __FUNCT__" ;
   
   if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    GVRIsName=True GVRIsSynopsis=True GVRIsSummary=True GVRIsDesc=False GetVarReference ${__call_locality[1]} ; 
    echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ;
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    eval $( __GetVarReferenceList ) ;	
   elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
    eval $( VTVIsArrayStyleInsert=True \
         VTVValueEntry=${StrVarList}   \
         VTVIsValueReAssign=True       \
         VTVIsValueToConvert=False     \
         VTVIsArrayStyleInsert=True    \
         ValueToVariable ) ${StrStartMain} ; 
   fi

 }

### End-of if-versionCA == 0.0.1 . 
fi

if [ "${versionGOD:=0.0.2}" == "0.0.2" ] ; then 

  ### GetOtherDate :
  ###
  ###
  ###	Full-length example : 
  ### Including Loop to create different day pattern
  ###
  ### hint:
  ### - Having to check 1 day before and 1 day after need to combine 
  ### settign GODReferenceFormat="__INT__ day" , and not "__INT__ day ago", give you positive forward in time
  ### setting GODIsLoop=True 
  ### setting GODLoop=-1,1 ( tricky but work ) , create interleave between -1 to 1, so it's -1 day in futur, 0 day in futur and 1 day in futur... 
  
  ### GODReferenceFormat="__INT__ day ago"  GODFormat="%Y%m%d" GODIsLoop=True GODLoop=1,4 GODVerbose=True  GetOtherDate
  ### Will display :
  ### 
  ### 20121010
  ### 20121011
  ### 20121012
  ###
  ### Short example :
  ### GetOtherDate
  ###
  ### Will display :
  ###
  ### 20121011
  ###
  ### GODReferenceFormat="__INT__ day ago"
  ###
  ###


 unset GetOtherDate ;
 function GetOtherDate()
 {
   local __call_locality=( GOD GetOtherDate );
   local ArrayArg=( $* ) ; 
   local Arg0=${ArrayArg[0]}; 
   local StrDateUnitPattern=${GODDateUnitPatrn:=__DATEUNIT__};
   local StrDateUnitReference=${GODDateUnit:="day"};
   local StrDateFormat=${GODFormat:=%Y%m%d} ;
   local StrDateIndicatorFormat=${GODReferenceFormat:=__INT__ ${StrDateUnitPattern}};
   local IntDayDiff=${GODReference:=0} ; 
   local StrDateApps=${GODMainApp:=/bin/date} ; 
   local isLoop=${GODIsLoop:=False} ;
   local LoopRange=${GODLoop:=0,3} ;
   local IsVerbose=${GODVerbose:=False} ;
   local StrNameHelper="A way to get a date already marshalled" 
   
     
   function Verbosis()
   {
    local __call_locality=( Verbosis Verbosis );
    local StrMsg=${VerbosisMsg:=__TEXT__} ; 
    local StrDevOut=${VerbosisDev:=/dev/stderr} ; 
    local ArrayArg=( $* ) ; 
    if [ "${VerboseState:=False}" == "True" ] ; then 
     echo -ne "VERBOSE:[ ${StrMsg} ]\n" > ${StrDevOut} ;
    fi
    
   }
   
   function DateFunc()
   {
    local __call_locality=( DateFunc DateFunc ) ;
    local ArrayArg=( $* ) ; 
    local StrEval="""${DateFuncApp} +"${DateFuncFormat:=%Y%m%d}" -d '${DateFuncIndicator}'""" ; 
    if [ "${DateFuncVerbose:=False}" == "True" ] ; then 
     VerbosisMsg=${StrEval} VerboseState=${IsVerbose} Verbosis ;
    fi 
    eval ${StrEval}
   }
   
   ### First Step, applying Incremental Unit to application Date:
   local StrDateIndicator=${StrDateIndicatorFormat} ;
   StrDateIndicator=${StrDateIndicator/${StrDateUnitPattern}/${StrDateUnitReference}} ;
   if [ "${isLoop:=False}" == "False" ] ; then 
    StrDateIndicator=${StrDateIndicator/__INT__/${IntDayDiff:=0}} 
   fi
   ### Temporary debug removed after found the bug.
   ### local StrDbg="Content of StrDateIndicator: [${StrDateIndicator}]\nContent of StrDateUnitReference: [${StrDateUnitReference}]" ; 
   ### VerbosisMsg=${StrDbg} VerboseState=${IsVerbose} Verbosis ;
    
   #local StrDateIndicator=${StrDateIndicatorFormat/__INT__/${IntDayDiff:=0}}  ;
   #StrDateIndicator=${StrDateIndicator/${StrDateUnitPattern}/${StrDateUnitReference}} ;
   
   local ArrayRange=( ${LoopRange/,/ } ) ;
   local OperRange="<=" ;  
   local OperRangeIn="Intx++" ;
   local OperBaseStart=${ArrayRange[0]} ;
   local IntEndLoop=$(( ${ArrayRange[$((${#ArrayRange[@]}-1))]} ));
   

   #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
   local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
   
   if [ "${Arg0:=--start}" == "--help" ] ; then 
    GVRIsName=True StrNameHelper=${StrNameHelper} GetVarReference ${__call_locality[1]} ; 
    echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ; 			
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
   else	 
    if [ "${isLoop:=False}" == "True" ] ; then 
     local StrDebugMsg="ArrayRange, nb-element:${#ArrayRange[@]}, hold [ ${ArrayRange[@]} ]\n" ;
     VerbosisMsg=${StrDebugMsg} VerboseState=${IsVerbose} Verbosis  ;
     if (( ${ArrayRange[0]} > ${IntEndLoop} )) ; then 
      OperRange=">=" ;
      OperRangeIn="Intx--" ; 
      OperBaseStart=${ArrayRange[$((${#ArrayRange[@]-1))}]} ;
     fi		
     local StrDebugMsg="Looping from ${OperBaseStart} to ${IntEndLoop} \n" ;
     VerbosisMsg=${StrDebugMsg} VerboseState=${IsVerbose} Verbosis  ;
     for (( Intx=${OperBaseStart} ;  Intx ${OperRange} ${IntEndLoop} ; ${OperRangeIn} )) ; do 
       #StrDateIndicator="${StrDateIndicatorFormat/__INT__/${Intx}}" ; 
       local StrDateParsed=${StrDateIndicator};
       StrDateParsed=${StrDateParsed/__INT__/${Intx}} ;
       DateFuncVerbose=${IsVerbose} \
       DateFuncApp=${StrDateApps} \
       DateFuncFormat=${StrDateFormat} \
       DateFuncIndicator=${StrDateParsed} DateFunc ;
     done
    else 
     DateFuncApp=${StrDateApps} \
     DateFuncFormat=${StrDateFormat} \
     DateFuncIndicator=${StrDateIndicator} DateFunc ;
    fi
   fi 
 }


 ### End-of if-${versionGVR}
fi

if [ "${versionGUUID:=0.0.2}" == "0.0.2" ] ; then 
  ### Notice : ca66ef20-e187-11e5-98a2-001e4c8856d6
  ### In near future, usues of GetUUID will be subject to a permanent survery this one 
  ### will be called, both a mechanism of storage, view and cleaning will be hook to this
  ### function, aka MD_CD. MD_CD have possibility to store creation date of path. wheres 
  ### some successive development will lead to read the file and or media invested for 
  ### storage of this information. This will also appear inside GetUUID and integrity
  ### test of the helper will reveal to start the storage. Future definition will start
  ### testing if GetUHelperName is UUIDHelper to start the storage and collection of information.
  ### This notice did not mention if new development will imply uses of sqlite for MD_CD
  ### data storage and shallow not mention if this GetUUID will either get one two storage 
  ### method. A basic work based on file collection will start be will probably move to 
  ### sqlite to render data parsible thru other tools to observe uses of this function. 
  ### 
  ### Notice : 282b59c0-e188-11e5-98a2-001e4c8856d6
  ### Will also invite to uses the Helper directly if some other alternative are inquirying 
  ### the uses of UUID. Goal of GetUUID is also to aggregate a function UUIDRegistration 
  ### which uses of BodyFunct will depend on. Other alternative like ShortRegistration of 
  ### Pattern, variable-set will also own it's registration . 

 unset GetUUID 
 function GetUUID ()
 {
  local __call_locality=( GetU GetUUID ) ;
  local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ;
  local BoolTimeBased=${GetUTimeBased:=True}
  local BoolLoop=${GetULoop:=False} ;
  local IntSeqLoop=${GetUSeq:=1} ; 
  local StrGetHelperName=${GetUHelperName:=UUIDHelper} ;
  local StrUUIDHelperStream=${GetUHelper:=UUIDHApps= UUIDHSwitches= __HELPERNAME__} ; 
  ### No Need to transfert TypeAppsName, its recuperated by StrAppsNameCall .
  local TypeAppsName=${GetUAppsDef:=__HELPERNAME__ --get UUIDHApps}
  local StrUUIDActionName=${GetUActionFunc:=UUIDNoLoop,UUIDLoop} ;
  local IsVerbosis=${GetUVerbosis:=False} ;
  local IsUUIDDbCreation=${GetUDBCreation:=False};
  local IsUUIDDbImport=${GetUDbImport:=False};
  local StrDbURI=${GetUDBPath:=/var/cache/fnct.D/db/sqlite/GetUUID.sqlite}
  local StrDbSchema=${GetUDBSchema:=/etc/init.d/Fnct.D/getUUID.schema}
  local BoolCallRegistered=${GetUIDRegister:=False}; 
  local StrAppsRegister=${GetUAppsRegisterName:=None};
  local StrUUIDIndexName=${GetUIDName=.GetUUID};
  local StrAppsNameCall=${TypeAppsName//__HELPERNAME__/${StrGetHelperName}} ; 
  local StrAppsName=$( ${StrAppsNameCall} ) ; 
  local StrParentApps=${__call_locality[1]} ; 
  local StrVarList="StrAppsName,StrAppsNameCall,StrUUIDIndexName,StrAppsRegister,BoolCallRegistered,StrDbSchema,StrDbURI,IsUUIDDbImport,IsUUIDDbCreation,IsVerbosis,StrUUIDActionName,StrUUIDHelperStream,StrGetHelperName,IntSeqLoop,BoolLoop,BoolTimeBased,StrParentApps,StrVarList"; 
  
  ArrayMsg[1]="UUID StrAppsName: ${StrAppsName}" ; 
  VerbState=${IsVerbosis} VerbMsg=${ArrayMsg[1]} Verbosis;

  StrUUIDHelperStream=${StrUUIDHelperStream//__HELPERNAME__/${StrGetHelperName}} ;
  StrUUIDHelperStream=${StrUUIDHelperStream//UUIDHApps=/UUIDHApps=${StrAppsName}} ; 


  ### This is a specialized Verbosis mode :
  ###  
  ###  All condition required to set VerbState=True 
  ###  All condition required to set a message with VerbMsg=STRING
  ###  
  ###  
  ### It can be used to :
  ###  - Echo result to be passed throught Value Result .
  ###  Required :
  ###  VerbEvalForm=True VerbFormated=False 
  ###  
  ###  VerbHeader Is ineffective
  ###  
  ### -Echo result can be append to file and not overwriting the content: 
  ###  Required ;
  ###  VerbFormated=False/True VerbAppendDev=True VerbDev=[ FILENAME | UUID ]
  ###  - Appending to file also required to be unique-file were no instance of 
  ###  Verbosis may point on same-file or loss of log will be CERTAIN.
  ###  -Pointing to Same-Destination require a lock Mechanism which is 
  ###  not implemented here
  ###  
  function Verbosis()
  {
   local __call_locality=( Verbosis Verb );
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
        echo "${StrMsg}" ;  
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo "${StrMsg}" >> ${StrDevOut} ;
      else
       echo "${StrMsg}" > ${StrDevOut} ;
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis

  
  function ApplicationRegistrationIndex()
  {
   local __call_locality=( ARI ApplicationRegistrationIndex ${StrParentApps} ) ;
   local ArrayArg=( $* ) ; 
   local Arg0=${ArrayArg[0]} ;
  
   
  }


  
  function UUIDNoLoop()
  {
   local __call_locality=( UUIDNL UUIDNoLoop ${StrParentApps} ) ;
   local ArrayArg=( $* ) ; 
   local Arg0=${ArrayArg[0]} ;
   #eval $( ${StrUUIDHelper} ) ;
   local StrMsg="UUID HELPER: ${StrUUIDHelper}" ;
   VerbState=${IsVerbosis} VerbMsg=${StrMsg} VerbHeader="VERBOSE" Verbosis;
   eval ${StrUUIDHelper} ;
  }
  
  function UUIDLoop()
  {
   local __call_locality=( UUIDL UUIDLoop ${StrParentApps} ) ;
   local ArrayArg=( $* ) ; 
   local Arg0=${ArrayArg[0]} ;
   local ArrayMsg=( ) ;
   ArrayMsg[0]="UUID LOOPSEQ: ${IntSeqLoop}";
   ArrayMsg[1]="UUID HELPER: ${StrUUIDHelper}\n" ;
   
   VerbState=${IsVerbosis} VerbMsg=${ArrayMsg[0]} Verbosis;
   for (( intX=0 ; intX <= $(( ${IntSeqLoop}-1 )) ; intX++ )) ; do
    VerbState=${IsVerbosis} VerbMsg=${ArrayMsg[1]} VerbHeader="VERBOSE" Verbosis;
    eval ${StrUUIDHelper} ;
   done 
  }
  
  function __main_StartServices()
  {
   local __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
   local Arg0=${ArrayArg[0]} ;
   local ArrayArg=( $* ) ; 
   local IntUUIDHelperIndex=0 ;
   local StrUUIDOption="" ;
   local StrUUIDHelper=""
   local StrAction=""
   local ArrayMsg=( ) ;
   ### Array conversion from StrUUIDActionName, using string delimiter char ',' ; 
   local ArrayUUIDAction=( ${StrUUIDActionName//,/ } ) ; 
   local IntUUIDActionIndex=0 ; 

   if [ "${BoolTimeBased:=True}" == "True" ] ; then 
    StrUUIDOption="-t"
   else 
    StrUUIDOption="-r"
   fi 
   StrUUIDHelper=${StrUUIDHelperStream} ; 
   StrUUIDHelper=${StrUUIDHelper//UUIDHSwitches=/UUIDHSwitches=${StrUUIDOption}}  ;
   #StrUUIDHelper=$( eval ${StrUUIDHelperStream} ) ; 
   ArrayMsg[1]="UUID __main_StartServices: content of StrUUIDHelper:[${StrUUIDHelper}]" ; 
   VerbState=${IsVerbosis} VerbMsg=${ArrayMsg[1]} VerbHeader="VERBOSE" Verbosis ;
   #echo -ne "[UUID __main_StartServices: content of StrUUIDHelper:[${StrUUIDHelper}]]\n" > /dev/stderr 

   if [ "${BoolLoop:=False}" == "True" ] ; then 
    IntUUIDHelperIndex=1 ;
    IntUUIDActionIndex=1 ; 
   else 
    IntUUIDHelperIndex=0 ; 
    IntUUIDActionIndex=0 ; 
   fi 
   StrAction=${ArrayUUIDAction[${IntUUIDActionIndex}]} ; 
   ArrayMsg[2]="UUID ACTION: ${StrAction}" ; 
   VerbState=${IsVerbosis} VerbMsg=${ArrayMsg[2]} VerbHeader="VERBOSE" Verbosis ;
   #echo -ne "[UUID ACTION: ${StrAction}]\n" > /dev/stderr  ;
   eval $( VTVIsArrayStyleInsert=True \
           VTVIsValueReAssign=True \
           VTVIsValueToConvert=False \
           VTVValueEntry=IsVerbosis,StrAction,StrUUIDHelper,IntSeqLoop ValueToVariable ) ${StrAction} ; 
  } 
  
  #local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n" ;
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    GetVarReference ${__call_locality[1]} ; 
    echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
   eval $( __GetVarReferenceCompWord ) ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;	
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
   eval $( VTVIsArrayStyleInsert=True \
           VTVIsValueReAssign=True \
           VTVIsValueToConvert=False \
           VTVValueEntry=StrVarList ValueToVariable ) __main_StartServices 
  ### replacement IsVerbosis,BoolTimeBased,BoolLoop,IntSeqLoop,StrGetHelperName,StrUUIDHelperStream,StrUUIDActionName by StrVarList
  fi 

 }

### End-of if-"${versionGUUID}"
fi


### 
###  Notice : 
###  Note reference : 2953b00a-749e-11e6-8b1d-001e4c8856d6
###  - Well compromised Recurrent function for low-use od stdout for variable transfert use. 
###  
###  MdCd is an important tool and test-case to establish a datafile merely recognized like 
###  low-level certificate. This application create path, put templated structure of important 
###  file for your services . The default behavior is described by this box
###  
###  Using Mdcd becoming mainstream, after port to Mint 17.3 Rosawhich is Mate distribution with
### core of Xenial Ubuntu, I do profit from lack of dependence to add package installer inside 
### some application and upgrading Mdcd, by getting out the Sha1sum agent that produce a validity
### context after creating the Path, dunping the structure file like .gitignore MANIFEST.in, 
###  README.rst it can add many more struture depending of the file-model described own to 
###  add it to Mdcd.  Registration of the action is comming and will also have it's «Jeton» inside
###  SSHServicesRequest . Protection of Mdcd is keep inside the main Mdcd file and require only to
###  push the location of the lock for a precise place accessible by any to allow strict survey and 
###  avoid multiple path creation in a backup-storyboard reading. 
###  
###  A backup-storyboard... is Incremental awarness made by many application shelve to allow
###   - reading the structure once and updating it based on time . 
###   - Avoiding touching file recurrently to reduce access time in a network access. 
###     - Known to be important .htaccess inside webservices, a live-incremental backup with 
###       high priority on backuping change of .htaccess / .htpassword can lock the access to
###       it and slowing the services respond. 
###  
###  While elaborating this backup-storyboard in late 2012 during first draft of fnct_lib for 
###  development of UpdateSquashFS, set of tools was developped to update a btrfs tree with 
###  possibility to update the SquashFS 4Gb or 8Gb boosted parameter by re-wrinting the 
###  usb-disk-writer to accept higher value ; an update of squahfs pivot was bringing too much
###  cpu time until I do realize fuse-fs stack a common socket-file was not ignored and being
###  put inside the squashfs device with all the command. Some update were made to develop a 
###  so similar GetterByLineData application this one failed for problems of Stdout output 
###  during _func_eval_cmd and producing error... A this moment the primary version of fnct_lib
###  did not handle the output individully and was not possible to make-it appart... 
###  In one word, the Ubuntu 10 was holding on arch 64 bit and working on a 16Gb partition to 
###  practice a pivot of 8 Gb after update. A Somewhat StackSpace , DblSpace like microsoft did 
###  for version msdos 6.02 and beyond that merely did not work for having same problems called 
###  file/buffer memory being a disk section being not ignored and slowing the dblspace... 
###  
###  
###  

###  
###  Application Box:
###  +GetterByLineData+----------------------------------------+
###  |                                                         |
###  |                                                         |
###  |Tree Order :                                             |
###  |                                                         |
###  |                                                         |
###  |           +----------------+GetHeader                   |
###  |GetFile+--+FileSplitAction                               |
###  |           +----------------+GetContent                  |
###  |                            |                            |
###  |                            +-----------ShaSum1Content   |
###  |                                                         |
###  +----------------------------------------------------------
###  
###  Major Function coming with the Application :
###  Are all accessible thru GBLDAction where :
###  
###  GetFile ---->Throw the whole content of the file
###               GetFile is also First Order in the Execution.
###  
###  GetHeader ----> Most of file are 2 lines height, Being a text-format of 
###                  2 lines, the lenght can be illimited for second one...
###                  In this case we have put the SHA1SUM of the content to
###                  proove the content in second line is safe and can be trusted.
###  
###  
###  
###  GetContent ---> Get the content of second-text field. 
###  
###  FileSplitAction ---> The intermediate action preceding GetHeader and GetFile
###  
###  ShaSum1Content ----> The result of GetContent. 
###  
###  
###  - A tiny lexic appear by using ShaSum1Content and require to Call GetContent,
###  
###  while this one query-back FileSplitAction that take GetFile. During the 
###  call of this structure, no varaible are query thru the stdout and are queryed
###  thru Getter by using the mechanism of GetterByLineData --get ... Even Text
###  Message are Array of Text a the root level of the GetterByLineData. 
###  
###  
###  
###  
###  Note: reference file 0f86b448-72f4-11e6-8b1d-001e4c8856d6 a un-approved chunk file will
### be acknoledged by ZenityFileEditor, but still require some work before frozing the
### integrity. GetterByLineData Also work with function call and external function call
### alike ZenityStructure can borought the GetterByLineData structure to replace the 
### footprint of chunk developement. 
### 

if [ "${versionGBLD:=0.0.2}" == "0.0.2" ] ; then 
 unset GetterByLineData ; 
 function GetterByLineData()
 {
  local __call_locality=( GBLD GetterByLineData ) ;
  local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ; 
  local StrParentApps="${__call_locality[1]}" ;
  local StrAppsTail=${GBLDTailApps:=/usr/bin/tail} ;
  local StrAppsHead=${GBLDHeadApps:=/usr/bin/head} ;
  local StrFStats=${GBLDFileStats:=/usr/bin/wc} ;
  local StrFStatsOpt=${GBLDFileStatsOpt:=__APPS__ -c __FILE__} ;
  local StrTailOpt=${GBLDTailCmd:=__APPS__ -n 1} ;
  local StrHeadOpt=${GBLDHeadCmd:=__APPS__ -n __INTLINE__} ;
  local StrFileStoreInfo=${GBLDFileStoreInfo:=None} ;
  local IntLineId=${GBLDLineID:=1} ; 
  local IsVerbose=${GBLDVerbose:=False} ; 
  local IsShaRemovingComment=${GBLDIsShaRemoveComment:=True} ; 
  local StrAction=${GBLDAction:=FileSplitAction} ;
  local IsActionReturnError=${GBLDActionReturnError:=False} ; 
  local StrVerboseMacro="" ; 
  local vret=0 ;
  local StrMsg="" ; 
  local StrVarListTransfert="IsShaRemovingComment,StrParentApps,IntGCID,IntGHID,IsVerbose,IsActionReturnError,StrFileStoreInfo,IntLineId,Stream,StrAppsTail,StrAppsHead,StrAction,StrParentApps,StrVerbosisMacro,StrFStats,StrFStatsOpt" ; 
  local ArrayMsg=( ) ;
  
  ArrayMsg[0]="Verbose is Turned On" ; 
  ArrayMsg[1]="File is Present, Size:__FILE_SIZE__, Name=__FILE__" ; 
  ArrayMsg[2]="File is not Present or experiencing access restriction. File=__FILE__" ; 
  ArrayMsg[3]="Extraction Starting from line __START_LINE__ From file __FILE__." ; 
  ArrayMsg[4]="Cmdline Head:__CMDLINE__" ; 
  ArrayMsg[5]="Cmdline Tail:__CMDLINE__" ; 
  ArrayMsg[6]="Template: __CMDLINE__" ; 
  ArrayMsg[7]="Action Does require to return a value" ; 
  ArrayMsg[8]="Action Does not require to return a value" ; 
  ArrayMsg[9]="CmdLine: __CMDLINE__" ; 
  ArrayMsg[10]="Starting function __main_StartServices" ; 
  

  function Verbosis()
  {
   local __call_locality=( Verbosis Verb  ) ;
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
      echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
    else
      echo -ne "${StrMsg}\n" > ${StrDevOut} ;
    fi 
   fi
  } 
  ### Model : VerbHeader="DEBUG" VerbMsg=${StrMsg}  VerbDev=/dev/stderr VerbFormated=True VerbState=True Verbosis
   
  
  function GetFile()
  {
   local __call_locality=( GF GetFile ${StrParentApps} ) ;
   local ArrayArg=( $* ) ; 
   local Arg0="${ArrayArg[0]}" ; 
   local StrFile="${StrFileStoreInfo:=None}" ;
   local StrParserFileStats="${StrFStatsOpt//__APPS__/${StrFStats}}" ; 
   StrParserFileStats="${StrParserFileStats//__FILE__/${StrFile}}" ; 
   StrMsg=$( ${StrParentApps} --get ArrayMsg[9] ) ; 
   StrMsg=${StrMsg//__CMDLINE__/${StrParserFileStats}} ; 
   VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
   vret=0 ; 
   if [ -f ${StrFile} ] ; then 
     IntFileRes=$( ${StrParserFileStats} ) ;
     IntFileSize=${IntFileRes/% [a-zA-Z0-9\/\_\-\=\"\(\)\]\[\)\(\=]*/} ;
     StrMsg=$( ${StrParentApps} --get ArrayMsg[1] ) ; 
     StrMsg=${StrMsg//__FILE_SIZE__/${IntFileSize}} ; 
     StrMsg=${StrMsg//__FILE__/${StrFile}} ; 
     VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}"  VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
    cat ${StrFile} ; 
    vret=0 ;   
   else
    StrMsg=$( ${StrParentApps} --get ArrayMsg[2] ) ;  
    StrMsg=${StrMsg/__FILE__/${StrFile}} ; 
    VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
    vret=1 ; 
   fi 
   return ${vret}
  }	
  
  function GetHeader()
  {
   local __call_locality=( GH GetHeader ${StrParentApps} ) ;
   local ArrayArg=( $* ) ; 
   local Arg0=${ArrayArg[0]} ; 
   local IntLineId=${IntGHId:=1} ; 
   StrHeaderStream=$( GBLDActionReturnError=True GBLDAction=FileSplitAction GBLDFileStoreInfo=${StrFileStoreInfo} GBLDLineID=${IntLineId} GetterByLineData	 ) ; 
   if [ "${IsShaRemovingComment}" == "True" ] ; then 
    echo "${StrHeaderStream/\#/}" ; 
   else
    echo "${StrHeaderStream}" ; 
   fi
   
   return $? ;
  }
  
  function GetContent()
  {	
   local __call_locality=( GC GetContent ${StrParentApps} ) ;
   local IntLineId=${IntGCId:=2} ; 
   echo $( GBLDActionReturnError=True GBLDAction=FileSplitAction GBLDFileStoreInfo=${StrFileStoreInfo} GBLDLineID=${IntLineId} GetterByLineData	 ) ; 
   return $? ;
  }
  
  function FileSplitAction( )
  {
   local __call_locality=( FSA FileSplitAction ${StrParentApps} ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]} ;  
   
   local Stream=$( GBLDActionReturnError=True GBLDAction=GetFile GFStoreInfo=${StrFileStoreInfo} GetterByLineData ) ;
   local vret=$? ; 
   local StrCmdParseHead=$( ${StrParentApps} --get StrHeadOpt ) ;
   local StrCmdParseTail=$( ${StrParentApps} --get StrTailOpt ) ;
   local IntLineStart=$( ${StrParentApps} --get IntLineId ) ; 
   StrMsg=$( ${StrParentApps} --get ArrayMsg[3] ) ;
   StrMsg=${StrMsg//__START_LINE__/${IntLineStart}} ; StrMsg=${StrMsg//__FILE__/${StrFileStoreInfo}} ;   
   VerbHeader="VERBOSE-${StrParentApps}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
   StrCmdParseHead=${StrCmdParseHead//__INTLINE__/${IntLineStart}} ;
   StrCmdParseHead=${StrCmdParseHead//__APPS__/${StrAppsHead}}
   StrCmdParseTail=${StrCmdParseTail//__APPS__/${StrAppsTail}} ; 
   StrMsg=$( ${StrParentApps} --get ArrayMsg[4] ) ;
   StrMsg=${StrMsg//__CMDLINE__/${StrCmdParseHead}}
   VerbHeader="VERBOSE-${StrParentApps}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
   
   StrMsg=$( ${StrParentApps} --get ArrayMsg[5] ) ;
   StrMsg=${StrMsg//__CMDLINE__/${StrCmdParseTail}}

   VerbHeader="VERBOSE-${StrParentApps}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
   
   if [ ${vret:=-1} -eq 0 ] ; then 
     echo "${Stream}" | ${StrCmdParseHead} | ${StrCmdParseTail} ;
     return 0 ; 
   else
     return 1 ; 		
   fi
  }
  
  function ShaSum1Content()
  {
   local __call_locality=( FSA ShaSum1Content ${StrParentApps} ) ;
   local ArrayArg=( $* ) ;
   local Arg0="${ArrayArg[0]}" ;  
   local Stream=$( GBLDActionReturnError=True GBLDAction=GetContent GFStoreInfo=${StrFileStoreInfo} GetterByLineData ) ;	
   local vret=$? ; 
   if [ ${vret:=-1} -eq 0 ] ; then 
     echo "${Stream}" | /usr/bin/sha1sum | /usr/bin/cut -d ' ' -f 1 ;
     return 0 ; 
   else
     return 1 ; 		
   fi
  }
  
  
  function __main_StartServices()
  {
   local __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]} ;  
   
   StrCmd="eval \$( VTVIsArrayStyleInsert=True VTVValueEntry=__LIST_VAR__ VTVIsValueReAssign=True VTVIsValueToConvert=False VTVIsArrayStyleInsert=True ValueToVariable ) __ACTION__ __RETURN_FORM__" ; 
   StrMsg=$( ${StrParentApps} --get ArrayMsg[6] ) ;
   StrMsg=${StrMsg//__CMDLINE__/${StrCmd}}
   VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
   
   if [ "${IsActionReturnError:=False}" == "True" ] ; then 
    StrMsg=$( ${StrParentApps} --get ArrayMsg[7] ) ;
    VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 

    StrCmd=${StrCmd//__RETURN_FORM__/ ; vret=\$? ;} ; 
   else
    StrMsg=$( ${StrParentApps} --get ArrayMsg[8] ) ;
    VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
    StrCmd=${StrCmd//__RETURN_FORM__/ ;} ; 
   fi 
   
   StrCmd=${StrCmd//__LIST_VAR__/${StrVarListTransfert}}
   StrCmd=${StrCmd//__ACTION__/${StrAction}}
   
   StrMsg=$( ${StrParentApps} --get ArrayMsg[9] ) ;
   StrMsg=${StrMsg//__CMDLINE__/${StrCmd}}
   VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
   eval "${StrCmd}" ; 
   if [ "${IsActionReturnError:=False}" == "True" ] ; then 
    StrMsg="Action return value: ${vret}" ; 
    VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
    return ${vret} ; 
   fi 
  }
   
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;

  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    GetVarReference ${__call_locality[1]} ; 
    echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
  elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
   eval $( __GetVarReferenceCompWord ) ;
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
    VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${ArrayMsg[0]}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
    StrMsg=$( ${__call_locality[1]} --get ArrayMsg[10] ) ;
    VerbHeader="VERBOSE-${__call_locality[1]}" VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbFormated=True VerbState=${IsVerbose} Verbosis ; 
   eval $( VTVIsArrayStyleInsert=True           \
           VTVValueEntry=${StrVarListTransfert} \
           VTVIsValueReAssign=True              \
           VTVIsValueToConvert=False            \
           VTVIsArrayStyleInsert=True           \
           ValueToVariable ) __main_StartServices
  fi

  unset Verbosis GetFile GetHeader GetContent FileSplitAction __main_StartServices ; 
 }
 ### end-of if-${versionGBLD}
fi

 ### ValueToVariable :
 ###
 ###
 ###	Full-length example : 
 ### Including 1 example :
 ###
 ### $> 
 ### 
 ### - It Open Windows from Zenity with parameter for Text-info in editable
 ### mode.
 ### 
 ### It Open by default a uuid-like temporary file. There is no actual was
 ### to modify the name, but assuming the implementation of ZenityShellEval
 ### imply a limited acces to shell, you might recuper information from shell
 ### or futur adding to transfert a name or simple renaming the uuid-like
 ### file-name... This is to prevent auto-execution of a script from 
 ### canned-design by playing with without having all clearly create your 
 ### shell script and/or having fully pseudo-code explained and having 
 ### confirmation of your design work... 

if [ "${versionVTV:=0.0.2}" == "0.0.2" ] ; then 
 unset ValueToVariable
 function ValueToVariable( )
 {
   ### ----                                                                           ----
   ### ---- Because version 0.0.1 did not work, trying to make things clear with this ----
   ### ---- definition on developping safe function                                   ----
   ### 
   ### For some reason, ValueToVariable need to be changed, since unknow reason
   ### comming from gtk-terminal istance that do not clean function en even with
   ### using unset and new declaration by file leave breathless having problems 
   ### to resolve the problems in loop of BoolVarTest, in replacement of BoolVarTestVarCreation
   ### in hope reducing length of pre-fixed var, thi function will be tested with version 
   ### 0.0.2 of ValueToVariable that loop inside declaration of BoolVarTest and both 
   ### BoolVarTestVarCreation but not alone... 
   ### This version will work with copy of  StrValueParser , and reduce the copy size by 
   ### retrieving the Variable name . 
   ###
   ### The goal still the same :
   ### 1 - Respect Polish notation for all filtered value.
   ###  -> which mean rejected variable for wrong value should be observed.
   ###  -> rejected value should not interrupt the feed and should only 
   ###  -> not made it available.  
   ###  -> may agree next development of a white-list after first conclusion. 
   ### 2 - Notation in form of :
   ###     Var1=${Var1} Var2=${Var2} is imperative
   ### 3 - Uses of this exterior format observed should be keept:
   ###     eval $( VTV...=... VTV...=... VTV...=... ValueToVariable ) __FUNCTION
   ###  -> Can be good to implement a IsEvalFunctionThrow=True in next version
   ###
   
   
  local ArrayArg=( $* ) ;
  local __call_locality=( VTV ValueToVariable ) ;
  local Arg0="${ArrayArg[0]}" ;
  
  local StrReAssign=${VTVValueRe:=StrTestA_1,StrTestB_1,StrCTest1_1,StrDTest2_1,IntA_1,IntB_1,IsTestA_1,IsNotTestA_1}
  local StrValueParser=${VTVValueEntry:=StrTestA,StrTestB,StrCTest1,StrDTest2,IntA,IntB,IsTestA,IsNotTestA};
  local IsEntryInComaSep=${VTVIsArrayStyleInsert:=False} ; 
  local StrSepList=${VTVSepList:=",;:"} ;
  local IntValueSep=${VTVISeparatorType:=0};
  local StrVarFilter=${VTVVarFilter:=[SIB][tnos][a-zA-Z0-9_]*__SEP__} ; 
  local StrRejectionList=${VTVRejectionFilter:=[a-zA-Z0-9_]*} ; 
  local IsWhiteList=${VTVIsWhiteList:=False} ;
  local StrWhiteListAgree=${VTVWhiteListTransfert:=CFLAGS,LDFLAGS,CC,GCC,CPP} ;
  local IsValueSimpleConvert=${VTVIsValueToConvert:=True} ;
  local IsValueToReAssign=${VTVIsValueReAssign:=True} ;
  local StrPrefix=${VTVReasignPrefix:=None} ;
  local StrSuffix=${VTVReasignSuffix:=None} ;
  local IsValueIndTransform=${VTVIsTransformed:=False} ;
  local IsValueTransScript=${VTVIsTransHadScript:=False} ;
  local IsDisplayDebug=${VTVIsDebugDisplay:=False} ; 
  local IsSlowDebugOut=${VTVIsSlowDebug:=False} ; 
  local StrDefaultTransScript=${VTVITransformScript:=None} ;
  local StrScriptApps=${VTVAppsScripter:=/usr/bin/gawk} ;
  local StrScriptAppsOpt=${VTVAppsScripterOpt:=--field-separator=__SEP__ --file=__FILE__ __VAR_ASSIGN__ }
  local StrExtraVarScript=${VTVScriptInterVar:=--assign=__VAR__=__VALUE__} ;
  local StrScriptParser=${VTVAppsParser:=__APPS__ __OPT__} ;
   
  function Verbosis()
  {
   local __call_locality=( Verbosis Verb );
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
      echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
    else
      echo -ne "${StrMsg}\n" > ${StrDevOut} ;
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis
   
  ### Odd information treted by sed . 
  ### local StrAppsName=${VTVAppsName:=/bin/sed} ; 
  ### local StrAppsOpt=${VTVAppsOpt:=-r} ;
  ### local StrDefaultSedScript='s/([SIBA][tnosr][tror]*[a-zA-Z0-9]+)/\$\{\1\}/g' ;
  ### local StrDefaultAssignScript='s/([SIBA][tnosr][tror]*[a-zA-Z0-9]+)/\1=\$\{\1\}/g' ;
  ### local StrDefaultTransform=${VTVDefaultTransform:='s/([SIB][tnos][tro][a-zA-Z0-9]+)/\\$\{\1\}/g'} ;

  function VarFilter()
  {
   local __call_locality=( VF VarFilter ) ;
		 local Arg0=${ArrayArg[0]} ;
		 local ArrayArg=( $* ) ;
   local StrParserReassign=$( ValueToVariable --get StrReAssign ) ; 
   local StrParserList=$( ValueToVariable --get StrValueParser ) ;
   local StrListSep=$( ValueToVariable --get StrSepList ) ;
   local IntCharSel=$( ValueToVariable --get IntValueSep ) ;
   local StrRejectionFilter=$( ValueToVariable --get StrRejectionList ) ; 
   local StrFilter=$( ValueToVariable --get StrVarFilter ) ; 
   local StrFilter2=${StrVarFilter} ; 
   local StrPrefix=$( ValueToVariable --get StrPrefix ) ; 
   local StrSuffix=$( ValueToVariable --get StrSuffix ) ; 
   local IsValueIndTransform=$( ValueToVariable --get IsValueIndTransform ) ; 
   local IsValueToReAssign=$( ValueToVariable --get IsValueToReAssign ) ; 
   local IsValueSimpleConvert=$( ValueToVariable --get IsValueSimpleConvert ) ; 
   local IsSlowDebugOut=$( ValueToVariable --get IsSlowDebugOut ) ; 
   local IsWhiteList=$( ValueToVariable --get IsWhiteList ) ; 
   local StrWhiteListAgree=$( ValueToVariable --get StrWhiteListAgree ) ;
   local ArrayWhiteList=( ${StrWhiteListAgree//,/ } ) ;  
   local StrNPrefix="" ;  
   local StrNSuffix="" ; 
   local StrCharSep=${StrListSep:${IntCharSel}:1} ; 
   StrFilter=${StrFilter//__SEP__/${StrCharSep}} ; 
   StrFilter2=${StrFilter2__SEP__/${StrCharSep}} ; 
   local ArrayVarList=(  ) ; 
   local ArrayRejectionList=( ) ; 
   local IntNotEmptyList=1 ;
   local IntSizeBuffe=0 ; 
   local StrNewVarEntry="" ; 
   ### Changing side , now becoming IsValueToReAssign 
   if [ "${IsValueToReAssign:=False}" == "False" ] ;  then 
    ### Now IsValueToReAssign == False 
    StrMsg="Application is not Transforming Variable during passing-thru action."
    VerbMsg="${StrMsg//__VAR__/${StrNewVarEntry}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
   ### End of if-"${IsValueToReAssign:=True}"
   else
    ### Now IsValueToReAssign == True 
    StrMsg="Application is Transforming Variable during passing-thru action."
    VerbMsg="${StrMsg}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
    
    if [ "${StrPrefix:=None}" != "None" ] ; then 
     StrMsg="Application Add a Prefix named='__PREFIX__' during passing-thru action."
     VerbMsg="${StrMsg//__PREFIX__/${StrPrefix}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
     StrNPrefix=${StrPrefix} ; 
    # End of if-${StrPrefix}
    fi
    
    if [ "${StrSuffix:=None}" != "None" ] ; then 
     StrMsg="Application Add a Suffix named='__SUFFIIX__' during passing-thru action."
     VerbMsg="${StrMsg//__SUFFIIX__/${StrSuffix}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
     StrNSuffix=${StrSuffix} ; 
    # End of if-${StrSufix}
    fi 
   
   fi 
   
   ### Exchanging side : become IsValueSimpleConvert 
   if [ "${IsValueSimpleConvert:=False}" == "True" ] ; then 
    StrMsg="Application Does depend of a table-of Reassignation see VTVValueRe "
    VerbMsg="${StrMsg}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
   else
    StrMsg="Application Does not depend of a table-of Reassignation see VTVValueRe "
    VerbMsg="${StrMsg}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
 
   fi
  
   StrMsg="Initial Variable List: __VAR__ " ; 
   VerbMsg="${StrMsg//__VAR__/${StrParserList}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
   
   StrMsg="Initial Filter To Split Member between Separator '__SEP__' : '__FILTER__' " ; 
   StrMsg=${StrMsg//__SEP__/${StrCharSep}} ; 
   StrMsg=${StrMsg//__FILTER__/${StrFilter}} ; 
   VerbMsg="${StrMsg}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
   local StrTestFilter="" ; 
   local IntPolishForm=0 ; 
   while [ ${IntNotEmptyList:=1} -ne 0 ] ; do
     ### We do start with state IntPolishForm, for test not done at this moment. 
     IntPolishForm=0
     ### StrNewVarEntry="${StrParserList/#[SIB][tnos][a-zA-Z0-9_]*${StrCharSep}}" ; 
     ### Require detection of ',' or __SEP__ if the last one is only the variable name
     ### it stay in negative parsing .
     StrNewVarEntry="" ; 
     StrNewVarReassign="" ; 
     
     if [ "${StrParserList//${StrCharSep}/}" == "${StrParserList}" ] ; then 
      StrMsg="No New Separator '__SEP__' found inside Parsing String." ;
      VerbMsg="${StrMsg//__SEP__/${StrCharSep}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
      StrNewVarEntry=${StrParserList} ;
      StrParserList=${StrParserList//${StrNewVarEntry}/} ; 

      eval """StrTestFilter=${StrNewVarEntry//${StrFilter//${StrCharSep}/}/} ;"""
      if [ "${StrTestFilter:=None}" == "None" ] ; then 
       ### variable name is normal polish-like noted form 
       IntPolishForm=1 ; 
      else 
       ### pass2 we do not own empty variable assigned by default to None.
       ### pass2 reducing to a global match.
       StrTestFilter=${StrTestFilter//${StrRejectionFilter}/}
       if [ "${StrTestFilter:=None}" == "None" ] ; then 
        IntPolishForm=0
        ### We do have variable le Cflags, CFLAGS, LDFLAGS, Ldflags...
       fi 
      fi 
     
     else
      eval StrNewVarEntry="${StrParserList/#${StrFilter}}" ; 
      ### This case, apply to a more global case , not polish-like variable name are subject
      ### to pass-thru String Operator ${__VARNAME__/#...[SIB][tnos][tro][a-zA-Z0-9] 
      ### so it's important to reduce the string by the filter and will be consider as 
      ### rejected and will not be filterred, Unlike Polis-like var-name will. 
      ### After a second-filter like more global in  StrRejectionFilter will erase it 
      ### consider having a Rejected var name. 
      StrMsg="New Entry:__VAR__" ;
      VerbMsg="${StrMsg//__VAR__/${StrNewVarEntry}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
      
      ### pass 1 , reduce with StrFilter.
      eval """StrTestFilter=${StrNewVarEntry//${StrFilter//${StrCharSep}/}/} ;"""
      StrMsg="Pass1 PolishNoted variable rejected:__VAR__" ;
      VerbMsg="${StrMsg//__VAR__/${StrTestFilter:=None}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 

      ### pass 1 will, only reduce to nil polish-like variable. 
      if [ "${StrTestFilter:=None}" == "None" ] ; then 
       ### variable name is normal polish-like noted form 
       IntPolishForm=1 ; 
      else 
       ### pass2 we do not own empty variable assigned by default to None.
       ### pass2 reducing to a global match.
       StrTestFilter=${StrTestFilter//${StrRejectionFilter}/}
       if [ "${StrTestFilter:=None}" == "None" ] ; then 
        IntPolishForm=0
        ### We do have variable le Cflags, CFLAGS, LDFLAGS, Ldflags...
       fi 
      fi 
     fi 
     ### At this moment we do compare string and string stipped from 
     ### Separator. At the end this string does equal the striped string 
     ### for having no __SEP__ to remove, so we end with the name of the last variable.
     StrParserList=${StrParserList//${StrCharSep}${StrNewVarEntry}/} ;
    
     if [ "${IsDisplayDebug:=False}" == "True" ] ; then 
      if [ "${IsSlowDebugOut:=False}" == "True" ] ; then 
        sleep 1 ; 
      fi ; 
     fi 
     
     
     ### Changinf side, become IsValueSimpleConvert
     if [ "${IsValueSimpleConvert:=False}" == "True" ] ; then 
      if [ "${StrParserReassign//${StrCharSep}/}" == "${StrParserReassign}" ] ; then 
       StrMsg="No New Separator '__SEP__' found inside Re-Assignation List." ;
       VerbMsg="${StrMsg//__SEP__/${StrCharSep}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
       StrNewVarReassign=${StrParserReassign} ; 
       StrParserList=${StrParserReassign//${StrNewVarReassign}/} ; 
      else
       StrNewVarReassign="${StrParserReassign/#${StrFilter2}}" ;
       StrParserReassign=${StrParserReassign//${StrCharSep}${StrNewVarReassign}/} ;
      fi
     fi 
    
    ### It important to remove the "Separator + Variable name" to ensure Buffer become empty.
    ### Noted: The processor '/#' inside a String only output what is lying at the end  and 
    ### we do filtering a last value without the remaining char and not appearing inside the 
    ### StrNewVarEntry so adding the char-separator to remove is important. 
     ### Changing Side, become IsValueToReAssign
     if [ "${IsValueToReAssign:=False}" == "True" ] ; then 
       ### Changing Side, become IsValueSimpleConvert
       if [ "${IsValueSimpleConvert:=False}" == "True" ] ; then 
        ArrayVarList[${#ArrayVarList[@]}]="""${StrNPrefix}${StrNewVarReassign}${StrNSuffix}=\${${StrNewVarEntry}}""" ;
        ### IsValueSimpleConvert-> True, IsValueToReAssign->True
       else
        ### Now IsValueSimpleConvert==False
        if [ ${IntPolishForm:=0} -eq 1  ] ; then 
         ArrayVarList[${#ArrayVarList[@]}]="""${StrNewVarEntry}=\${${StrNewVarEntry}}""" ; 
        elif [ "${IsWhiteList:=False}" == "True" ] ; then 
         ### White-list can be inserted here after ele claude from this statement. 
         IntScanWhite=0 ; 
         for StrNameVar in ${ArrayWhiteList[@]} ; do 
          if [ "${StrNewVarEntry}" == "${StrNameVar}" ] ; then 
           IntScanWhite=1 ; 
          fi 
         done
         if [ ${IntScanWhite:=0} -eq 1 ] ; then 
          StrMsg="Element __VAR__ is White-Listed, added to normal flow."
          VerbMsg="${StrMsg//__VAR__/${StrNewVarEntry}}" VerbHeader="WHITELIST-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
          ArrayVarList[${#ArrayVarList[@]}]="""${StrNewVarEntry}=\${${StrNewVarEntry}}""" ; 
         fi    
        ### end of elif "${IsWhiteList:=False}" from if-${IntPolishForm:=0}
        else
          ArrayRejectionList[${#ArrayRejectionList[@]}]=${StrNewVarEntry} ;
        fi 
        ### IsValueSimpleConvert-> False, IsValueToReAssign->True
       ### End of if "${IsValueSimpleConvert:=False}"
       fi 
     ### End of if-"${IsValueToReAssign:=False}"
     else
       ### Now IsValueToReAssign == False 
       ### Changing side, becoming IsValueSimpleConvert 
       if [ "${IsValueSimpleConvert:=False}" == "True" ] ; then 
        ArrayVarList[${#ArrayVarList[@]}]="""${StrNewVarReassign}=\${${StrNewVarEntry}}""" ;
        ### Note there is already protection inside if [ "${IsValueIndTransform:=False}... 
        ### and we do prevent putting nil-sized variable but should pose a problems . 
        ### IsValueSimpleConvert-> False IsValueToReAssign-> True
       else
        ### Now IsValueSimpleConvert == False 
        ArrayVarList[${#ArrayVarList[@]}]="""${StrNewVarEntry}=\${${StrNewVarEntry}}""" ;
        ### Note there is already protection inside if [ "${IsValueIndTransform:=False}... 
        ### and we do prevent putting nil-sized variable but should pose a problems . 
        ### End of if-IsValueToReAssign
       fi
      ### End of if-IsValueSimpleConvert
     fi
     IntSizeBuffer=${#StrParserList} ; 
     if [ ${IntSizeBuffer:=0} -eq 0 ] ; then 
      IntNotEmptyList=0; 
      StrMsg="Reached end of StrParserList."
      VerbMsg="${StrMsg}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
      ### we do set IntNotEmptyList to 0 meaning inspecting for 
      ### possibility of having an Not Empty List is now at 0 mean
      ### no we dont own it at all because it's now at 0;
      ### End of if-IntSizeBuffer
     fi ; 
      
   done 
   StrMsg="Rejection List Parser:__VAR__" ; 
   StrListReject=${ArrayRejectionList[@]} ; 
   VerbMsg="${StrMsg//__VAR__/${StrListReject:=None}}" VerbHeader="" VerbFormated=True VerbState=${IsDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
   
   StrMsg="Variable Parser:__VAR__" ; 
   VerbMsg="${StrMsg//__VAR__/${ArrayVarList[@]}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
   
   ###VerbMsg="${ArrayVarList[@]}" VerbHeader="" VerbFormated=False VerbState=True StrDevOut=/dev/stdout  Verbosis ; 
   eval ${ArrayVarList[@]} ; 
 }
  
  function AppsParser()
  {
   local __call_locality=( AP AppsParser ) ;
		 local Arg0=${ArrayArg[0]} ;
		 local ArrayArg=( $* ) ;   
   local ArrayGetter=( StrSepList IsDisplayDebug IsValueTransScript StrDefaultTransScript StrScriptApps StrScriptAppsOpt StrScriptParser StrValueParser  ) ; 
   local ArrayTagParser=( __APPS__:StrScriptApps __OPT__:StrScriptAppsOpt __SEP__:StrCharSep __FILE__:StrDefaultTransScript __VAR_ASSIGN__:StrExtraVarScript ) ; 
   ### local StrSepList=$( ValueToVariable --get StrSepList ) ;
   ### local IntValueSep=$( ValueToVariable --get IntValueSep ) ;
   local StrCharSep=${StrSepList:${IntValueSep}:1} ;
   
   ### Loop to search thru Getter all Master variable from top function 
   for StrVar in ${ArrayGetter[@]} ; do 
    $( eval """${StrVar}=\$( ValueToVariable --get ${StrVar} )""" ) ; 
   done 
   
   local StrParserCmd="${StrScriptParser}" ; 
   ### Loop for parsing tag and variable from  ArrayTagParser which is a collection
   ### of required variable to form a syntax of a command . The example taking
   ### gawk or gnu-awk but can be adjusted on shell by changing pre-fixed variable 
   ### VTVAppsParser VTVScriptInterVar VTVAppsScripterOpt VTVAppsScripter ... 
   for StrPairTag in ${ArrayTagParser[@]} ; do 
    StrPairLeft=${StrPairElem/%:[SIBA][tnosr][tror]*[a-zA-Z0-9]*/};
    StrPairRight=${StrPairElem/#__[a-zA-Z0-9]*:/};    
    $( eval """StrParserCmd=${StrParserCmd//${StrPairLeft}/\${${StrPairRight}}}""" ) ; 
   done 
   StrMsg="CmdLine: __CMDLINE__"
   VerbMsg="${StrMsg//__CMDLINE__/${StrParserCmd}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=${IsDisplayDebug} StrDevOut=/dev/stderr Verbosis ; 
   eval $( ${StrParserCmd} ) ; 
  
  }
  
  function __main_StartServices()
  {
   local __call_locality=( Main __main_StartServices ) ;
		 local Arg0=${ArrayArg[0]} ;
		 local ArrayArg=( $* ) ;   
    local IsValueSimpleConvert=$( ValueToVariable --get IsValueSimpleConvert ) ;  
    local IsValueTransScript=$( ValueToVariable --get IsValueTransScript ) ; 
    if [ "${IsValueSimpleConvert:=True}" == "True" ] ; then 
     VarFilter ; 
    elif [ "${IsValueToReAssign:=False}" == "True" ] ; then 
     VarFilter ;
    elif [ "${IsValueTransScript:=False}" == "True" ] ; then 
     AppsParser ; 
     ### Note inside IsValueTransScript Meaning it does not worry of all other 
     ### exception like VTVIsValueToConvert VTVIsValueReAssign VTVIsTransformed
     ### because script calling is exterior and do not interfer with Boolean value
     ### reserved for VarFilter . 
    else
    ### Changing role it's not VTVIsValueToConvert to use first , but VTVIsValueReAssign
     StrMsg="At least VTVIsValueReAssign or VTVIsTransHadScript should be True."
     VerbMsg="${StrMsg}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=True StrDevOut=/dev/stderr Verbosis ; 
    fi
  }

  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  local StrNameHelper="ValueToVariable\t\tThe Fnct.D Mechanisme acting as Re-Copy Pass-Thru Variable in Variable authorized to be transfered from Higher-level function to Sub-Level Function.";
  local StrSynopsis="Since implementation of TSR resident like Python command-not-found or any type of Layer in interactive Shell in Both Curse Bash Command-Line and/or xterminal, gtk-terminal, The behavior of function is not clear and are not totally accessible. ValueToVariable eliminate problems of declare and following constraint, local variable can travel thru sub-function. ";
  local StrSummary="ValueToVariable allow creation of variable Assignation before running the application or function. Creating a code evaluation it return in form of VAR1=\${VAR1}  VAR2=\${VAR2} Application ; Where VAR1,VAR2 will be already available inside nestled function or real-function . If the are made from Top-function, Shell command like declare make variable existing beyond Master Function Body, which overcrowding variable after death or termination of function uses if unset still existing and increase amount of memory without cleaning it. The mechanism is Filtering throught and acting like Filter over Polish Notation Respect to enforce uses of Strict Notation to have an idea of their uses. Since Polish notation is adopted inside the Fnct.D, uses of evaluation brace to expand code inside function like BoolVarTest( newest version of BoolVarTestVarCreation) expanding Preambule-code, The If-N clause and it's Assertion code inside function to make parseable function to analyse it faster and discover bottle-neck by developping more assertion clause and action. ValueToVariable is madatory associated with  Prompt mechanism to pass the __main_StartServices and receive the authorized variable list. Must read inside Description most-standard case Prefixed Variable, describe most frequent uses of Prefixed-Variable for common task between Function. While Whitelist is an accute case to transfert External variable being recognized by the Shell, some function had becoming totally blind behind variable visibility, WhiteList is popular with compiler, link-edition and pre-processor application. "
  local StrDescription="\nComment over Obsolete Prefixed-Var\nThey are not in effect and might be re-attributed. Initially work altogether VTVValueRe VTVIsTransformed were removed from prototype aka ancester of BoolVarTestVarCreation coming from old_var_fnct_lib. Where fews functions filters the contents of this function with 'declare -f' to inspect variable presence and create an assignation table, this was removed even from prototype having problems in handling the table correctly.\n\nComment over VTVAppsScripter\nDefault is Awk while some may like something else, it's also play with performance being AWK as long you define the VTVAppsParser, VTVScriptInterVar, VTVAppsScripterOpt, VTVITransformScript you can define application like Python,Ruby,Perl...\n\nComment over VTVIsWhiteList\nFor Unusual Variable name, and or information too-short for variable name, being consider like not so used but Lacking of Regularity in your code using not conformant Polish-notation variable Like Rachid1,Rachid2,Rachid3,RachidN, you must use WhiteList Option. Also same for uses of externals variable like CC,CFLAGS,LDFLAGS,GCC... These by-passing the Polish-notation filter and transfert-them after-filter Effect.\n\n\nComment over VTVRejectionFilter\nInitially inside the ValueToVariable engine it filter VTVRejectionFilter, and after filter with VTVVarFilter and what failling remain inside WhiteList and wait if Option IsWhiteList is trigger.\n\nComment over VTVIsArrayStyleInsert\nWhile Shell-Array are not totally recognized information inside array, Integer and STRING are taken together, if you do have problem in regard of integer being reported not like your design is thinked try to enforce a IF test with integer with forced value. Because ValueToVariable take individually elements and assign it before calling your function you do have more change to keep variable structure than creation an allocation-holder and calculating like registry access. Another case where Array are altering the information in regard of loosing the Interger value is the uses of Associative array. Index are STRING and content too. We do recommend also to profit from Getter in place inside function from Fnct.D Structure and adopt a recuperation methode throught Getter. Default is False, but we recommend it to Set True form more than one Variable. Professionnal uses had enforced the uses of Variable Transfert holding name inside the Variable and call only this one ex, calling StrVarList=StrVar1,StrVar2 calling StrVarList inside VTVValueEntry does not need an Array Style Insert.\n\nComment over VTVIsWhiteList\nUses of Whitelist where some power mechanisme like compiler depend of variable like CFLAGS, LDFLAGS... do require it if your out of generating code from shell or out of main Function do require a function white list \n\nComment over VTVValueEntry Know Effect\nIn many sub-function does prove there is no creation of variable but Assignation by-Recopy.\n\nComment over VTVIsDebugDisplay\nWhile the mechanism can not be directly see from calling it directly from Command-Shell it get on with eval and it's optimized to work with simple Executive-Evaluative Brace only the DebugDisplay option will let you see the result. Information are ouputed on /dev/stderr.\n\nComment over VTVIsTransHadScrip\n like Awk Script and it's a mechanism totally non-interactive ans pass-throught do directly to this action, with dependancy of VTVITransformScript, VTVAppsScripter, VTVAppsScripterOpt, theses options are not certified yet.\nValueToVariable Prefixed-Variable informations\n\nBoolean Notice Prefixed Variable:\n\nVTVIsArrayStyleInsert\tSet True/False ArrayStyle is a declaration passed throught a variable and fastest way to pass theses elements are with separator or common method is « Comma Separated Value ». Further Information seek second part.\nVTVIsTransformed\tSet True/False Reserved and Obsoleted until all the function exception will be tested.\nVTVIsTransHadScrip\tSet True/False This Prefixed-Variable is Unique and only accept VTVIsArrayStyleInsert and activate the uses of independent script.\nVTVIsDebugDisplay\tSet True/False Allow outputing Debug Statement. \nVTVIsSlowDebug\t\tSet True/False This option is not improving Speed of your function and does slow-down the option DebugDisplay if you do have problem to filter All the Displayed Debug information.\nVTVIsValueToConvert\tSet True/False Is mostly False, this Prefixed-variable allow variable having other name, and respectly have en entry and importance inside way variable are mangled, activating uses of VTVReasignPrefix, VTVReasignSuffix\n\nImportant Notice, most-standard case Prefixed Variable:\n\n\n\nImportant Notice, NonTrivial Prefixed Variable:\n\nVTVVarFilter\t\tSTRING Regular Expression, from Bash Expansion algorithm, mostly like regular expression, but not full-length regular expression.\nVTVRejectionFilter\tSTRING Regular Expression, from Bash Expansion algorithm Rejection filter is also know for what will remain inside WhiteList Option\nVTVIsWhiteList\t\tSTRING Separated with Comma is the exeption List to pass throught .\nVTVITransformScript\tSTRINGScript Filename use inside VTVAppsScripterOpt under TAG __FILE__. Neglecting VTVAppsScripterOpt to own TAG __FILE__ will not work .\nVTVAppsScripter\tSTRING Default is /usr/bin/gawk\nVTVAppsScripterOpt\tSTRING Reserved for VTVAppsScripter or application wrap-up, handle most of variable call for an application wrapper.\nVTVScriptInterVar\tSTRING Repsonsible to answer to TAG __VAR_ASSIGN__ inside VTVAppsScripterOpt is a method transfering other variable with --assign from awk/gawk option look for awk manual for further information.\nVTVAppsParser\tSTRING It's TAG definition where __APPS__ is awk/gawk, any application and __OPT__. The __OPT__ is namespace for all Prefixed Variable VTVScriptInterVar, VTVAppsScripterOpt and VTVITransformScript.\n\n\nImportant Notice, Obsoletes Prefixed Variable:\n\nVTVValueRe\t\tSet True/False [INEFFECTIVE] Was working with VTVIsTransformed\nVTVIsTransformed\tSet True/False [INEFFECTIVE] Was used in conjunction with VTVValueRe and require VTVValueEntry and does associate 1 on 1, so having to inspect the variable list to fit with element make a decision to remove the prototype from this function.\n" ; 
   
   
  ### 
  ### 
  ###  \n
   
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    ### Not listed inside live-documentation: GVRIsDesc=True 
    GVRIsName=True GVRIsSynopsis=True GVRIsSummary=True GVRIsDesc=True GetVarReference ${__call_locality[1]} ; 
    echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
		 eval $( __GetVarReferenceCompWord ) ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   StrMsg="Status BuildForm:__BF__, __call_locality:${__call_locality[1]}" ;
   VerbMsg="${StrMsg//__BF__/${BuildForm}}" VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbState=True StrDevOut=/dev/stderr Verbosis ; 
   eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
   __main_StartServices; 
  fi

 }
### End of if-${versionVTV:=0.0.2}" == 
fi

 ### TagParser :
 ###
 ### Tag Parser	 Ability To parse tagged Information from known varable name.
 ###	
 ### Synopsis 
 ### This is a simple application to provide to function conversion of String of 
 ### text with Tag ( noted __TAG__ by default ).
 ###
 ### Summary
 ### Providing a Text transformation from provided varaible name inside  parameter. 
 ### Content expect to exist inside a function, this is a provided evaluation of a 
 ### loop transformaing an Entry variable name from tag supplied. Noted the 
 ### evaluation brace is required, a.k.a $( TP...=... eval TagParser ) to add the 
 ### code directly inside your function. The mechanism allow uses of definied 
 ### array of desired scope type it is not desctructive for array and does not 
 ### give the destruct code for Variable name such Array inside Prefixed-Variable 
 ### TPArrayName.
 ###

if [ "${versionTP:=0.0.2}" == "0.0.2" ] ; then 

 function TagParser( )
 {
  local __call_locality=( TP TagParser ) ;
  local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ;
  
  local StrTagList=${TPListTag:=StrA:__TAGA__,StrB:__TAGB__,IntA:__INT__} ; 
  local StrArrayName=${TPArrayName:=ArrayTagParser} ;
  local StrIterName=${TPIterNameVar:=TagParser} ;
  local StrLeftPattern=${TPLeftStrPtrn:='[SIB][tnos][a-zA-Z0-9_]*:'} ; 
  local StrRightPattern=${TPRightStrPtrn:=':__[A-Za-z0-9_,]*'} ;
  local StrScopeVar=${TPScopeVar:=local} ; 
  local StrVarAssign=${TPVarNameParsed:=StrVarEntry} ;
  local BoolInvertPairMatch=${TPIsMatchRtoL:=True} ;
  local BoolDebugDisplay=${TPDisplayDebug:=False} ;
  local BoolDisplayEvalOnly=${TPDisplayEvalOnly:=False} ;
  local BoolDisplayParserAction=${TPDisplayParserNotice:=False} ; 
  local BoolUsingSed=${TPUsingSedTrim:=True} ;  
  ### 20161004 - Added BoolUsingSed, set it to False will filter StrInitCmd with tr instead 
  local StrVarList="BoolUsingSed,BoolDisplayParserAction,BoolInvertPairMatch,BoolDisplayEvalOnly,StrTagList,StrArrayName,StrIterName,StrLeftPattern,StrRightPattern,StrCmd,StrScopeVar,StrVarAssign" ; 
  
  ### Removed by confusion in code transformation . 
  ###local StrVarEntry=${TPVarEntry:=StrEntry} ; 
   
  
  ### This is a specialized Verbosis mode :
  ###  
  ###  All condition required to set VerbState=True 
  ###  All condition required to set a message with VerbMsg=STRING
  ###  
  ###  
  ### It can be used to :
  ###  - Echo result to be passed throught Value Result .
  ###  Required :
  ###  VerbEvalForm=True VerbFormated=False 
  ###  
  ###  VerbHeader Is ineffective
  ###  
  ### -Echo result can be append to file and not overwriting the content: 
  ###  Required ;
  ###  VerbFormated=False/True VerbAppendDev=True VerbDev=[ FILENAME | UUID ]
  ###  - Appending to file also required to be unique-file were no instance of 
  ###  Verbosis may point on same-file or loss of log will be CERTAIN.
  ###  -Pointing to Same-Destination require a lock Mechanism which is 
  ###  not implemented here
  ###  
  function Verbosis()
  {
   local __call_locality=( Verbosis Verb );
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
        echo "${StrMsg}" ;  
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo "${StrMsg}" >> ${StrDevOut} ;
      else
       echo "${StrMsg}" > ${StrDevOut} ;
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis
   
  

  function __main_StartServices()
  {
   local __call_locality=( Main __main_StartServices ${StrParent} ) ;
   local Arg0=${ArrayArg[0]} ;
   local ArrayArg=( $* ) ; 
   local ArrayTagParser=( ${StrTagList//,/ } ) ; 
  
   ### 
   ### This is the injected code wil be outputed and 
   ### require evaluation and execution brace :
   ### in form $( eval __CODE__ ) like Value To Variable
   ### require form $( eval __CODE__ ) Function-name 
   ### 
   local StrPairEvalOrder="" ;
   if [ "${BoolInvertPairMatch:=True}" == "True" ] ; then 
    ### For member of tag in writed in form  RtoL is True : R-> __TAG__, L->Variable
    ### Substitution goes in this way, Looking for Tag in PairRight and replacing it by Content in
    ### PairLeft. 
    #StrPairEvalOrder="eval ${StrVarAssign}=\${${StrVarAssign}//${StrPairRight}/\${\${StrPairLeft}}}"; 
    StrPairEvalOrder="""eval ${StrVarAssign}=\\\${\\${StrVarAssign}//\${StrPairRight}/\\\${\${StrPairLeft}}} """;
   else
    ### For member of tag in writed in form LtoR is True : L-> __TAG__, R->Variable 
    ### StrPairEvalOrder="eval ${StrVarAssign}=\${${StrVarAssign}//${StrPairLeft}/\${\${StrPairRight}}}"; 
    ### Substitution goes in this way, Looking for Tag in PairLeft and replacing it by Content in
    ### PairRight. 
    StrPairEvalOrder="""\$( eval ${StrVarAssign}=\\\${\\${StrVarAssign}//${StrPairLeft}/\\\${\${StrPairRight}}} )""";
   fi
    
   ### Notice: to find out Left Section in RtoL ( extracting Variable name) we 
   ### must erase the __TAG__ Name leaving only the Variable name:
   ### example in String = StrA:__TAGA__
   ### Extracting part 'StrA', require to erase the __TAGA__ 
   ### mean using ${String/%__RIGHT_PATTERN__} ; 
   ### Uses of String substitution with partial erase of the String for a 
   ### one step imply to detect the partial-to-erase and result is what is
   ### remaining in the String .... 
   # for __ITER__ in \${__ARRAY_NAME__[@]}  ; do 
   local StrInitCmd="""${StrScopeVar} intx=0 ; ${StrScopeVar} StrPairLeft ; 
   ${StrScopeVar} StrPairRight ; 
   ${StrScopeVar} __ARRAY_NAME__=( ${StrTagList//,/ } ) ; 
   ${StrScopeVar} StrMsg=\"PairLeft( __LEFT__ ), PairRight( __RIGHT__ ), Query( __QUERY__)\" ; 
   for (( intx=0 ; intx <= \${#__ARRAY_NAME__[@]}-1 ; intx++ )) ; do 
     __ITER__=\${__ARRAY_NAME__[\${intx}]} ; 
     AStrMsg=\"\${StrMsg}\" ;
     StrPairRight=\"\${__ITER__/#__LEFT_PATTERN__/}\" ; 
     StrPairLeft=\"\${__ITER__/%__RIGHT_PATTERN__/}\" ; 
     AStrMsg=\${AStrMsg//__LEFT__/\${StrPairLeft}} ;
     AStrMsg=\${AStrMsg//__RIGHT__/\${StrPairRight}} ;
     AStrMsg=\${AStrMsg//__QUERY__/\${${StrVarAssign}}} ;
     VerbMsg=\${AStrMsg} VerbHeader=TAGPARSER VerbState=${BoolDisplayParserAction} VerbFormated=True VerbDev=/dev/stderr Verbosis ; 
     __PAIR_EXCHANGE_ORDER__ ; 
   done ; 
   unset intx StrPairRight StrPairLeft __ARRAY_NAME__ ;""" ; 
   ### Added 20161004 - Filtering excess of control caracter . 
   ### Sed does filtering the excessive \n \r into \\n and \\r 
   ### and /usr/bin/tr does remote it, it change the form of the query but does not 
   ### alter the code. 
   if [ "${BoolUsingSed:=True}" == "False" ] ; then 
    StrCmd=$( echo "${StrInitCmd}" | /usr/bin/tr '[:cntrl:]' ' ' ) ; 
   else
    StrCmd=$( echo "${StrInitCmd}" | /bin/sed 's/\n/\\n/g;s/\r/\\r/g' ) ; 
   fi 
   
   StrCmd=${StrCmd//__ITER__/${StrIterName}} ; 
   StrCmd=${StrCmd//__LEFT_PATTERN__/${StrLeftPattern}} ; 
   StrCmd=${StrCmd//__RIGHT_PATTERN__/${StrRightPattern}} ; 
   StrCmd=${StrCmd//__ARRAY_NAME__/${StrArrayName}} ; 
   StrCmd=${StrCmd//__PAIR_EXCHANGE_ORDER__/${StrPairEvalOrder}}  ; 
   
   StgMsg="CmdLine: __CMD__" ; 
   VerbMsg=${StgMsg//__CMD__/${StrCmd}} VerbHeader="DEBUG:${__call_locality[1]}" VerbState=${BoolDebugDisplay} VerbFormated=True VerbDev=/dev/stderr Verbosis
   
   if [ "${BoolDisplayEvalOnly:=False}" == "False" ] ; then 
    ### 20161004, changing Verbosis model, support Evaluation. and is not thowing the code 
    ### on /dev/stdout but general device. 
    VerbMsg=${StrCmd} VerbEvalForm=True VerbFormated=False VerbState=True Verbosis ; 
   fi
  } 
  
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  local StrNameHelper="Tag Parser\t Ability To parse tagged Information from known varable name.";
  local StrSynopsis="This is a simple application to provide to function conversion of String of text with Tag ( noted __TAG__ by default ). ";
  local StrSummary="Providing a Text transformation from provided varaible name inside  parameter. Content expect to exist inside a function, this is a provided evaluation of a loop transformaing an Entry variable name from tag supplied. Noted the evaluation brace is required, a.k.a \$( TP...=... eval TagParser ) to add the code directly inside your function. The mechanism allow uses of definied array of desired scope type it is not desctructive for array and does not give the destruct code for Variable name such Array inside Prefixed-Variable TPArrayName."
  local StrDescription="\nParser notice\n\n  TPListTag\tSTRING Depending of the Prefixed Variable TPIsMatchRtoL it taking form VARIABLE:__TAG__ and are comma separated value\n  TPArrayName\tSTRING Falcutative depending the number of reccurrence of the Parser not executed and may interfer if the Parser Code is mangled and if extended Choice are affected to erase the unset at the end. Sometimes the array name can already be in uses and may affect your operation.\n\n  TPIterNameVar\tSTRING Falcutative, change the String-Iterated item looped inside the Array.\n  TPVarNameParsed\tSTRING Is the entry varaible holding the CODE/Template with __TAG__ to be parsed. We advise using a copy of this Variable because it re-write the content of it.\n  TPScopeVar\tSTRING and can be single-quoted STRING, Inside function 'local' is important or your function will use external variable. making it public or external use declare instead.\n\n  TPLeftStrPtrn\tSTRING Regular expression from Variable substitution algorithm, it remove the Left Side to kept the right side Be careful with this.\n  TPRightStrPtrn\tSTRING Regular expression from Variable substitution algorithm suppress the __TAG__ form to keep the variable name usually, becarefull uses ${VAR/#PTRN/'SEP'} and ${VAR/%'SEP'PTRN} method see in Bash document.\n\nBoolean variable notice:\n\n  TPIsMatchRtoL\t\tSet To True/False Invert Composition of tag in your design, Set to TRUE Variable in TPListTag required to be composed in form VARIABLE:__TAG__, if FALSE in form __TAG__:Variable\n\n  TPDisplayDebug\t\tSet To True/False Display Extra Debug during action, all outputed to /dev/stderr to not confuse the parser.\n  TPDisplayEvalOnly\tSet To True/False Allow displaying the Injected code in eval function using the Tag Parser.\n  TPDisplayParserNotice\tSet To True/False For function equiped of a Verbosis see fnct_debian_list for Verbosis example and will display by Tag pair the result the exanche and actual qiery it should happen after the Parsing.\n" ; 
  
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    GVRIsName=True GVRIsSynopsis=True GVRIsSummary=True GVRIsDesc=True GetVarReference ${__call_locality[1]} ; 
    VerbMsg=${StrSwitchMessages} VerbDev=/dev/stderr VerbState=True VerbFormated=False VerbHeader="" Verbosis ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;	
  elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
   eval $( __GetVarReferenceCompWord ) ;
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
   eval $( VTVValueEntry=${StrVarList}, \ 
           VTVIsArrayStyleInsert=True \
           VTVIsValueReAssign=True \
           VTVIsValueToConvert=False \
           ValueToVariable  ) __main_StartServices ; 
  fi 
  
 }

### End of if-${versionTP:=0.0.2}" == 
fi 

if [ "${versionBVT:=0.0.2}" == "0.0.2" ] ; then 
 unset BoolVarTest ; 
 function BoolVarTest()
 {

 ### The main goal : 
 ### Will represent a correct view of this example into pattern . 
 ### 
 ###   local StrMultipleFileSelectionAttr="--multiple"
 ###   if [ "${StrZenityFSMultipleFile}" == "False" ] ; then 
 ###    StrMultipleFileSelectionAttr="" ; 
 ###   fi 
 ### 
 ### Into CommandLine Echo like pattern and  being evaluated to create following statement:
 ### - Having a variable A Holding a content. 
 ### - Having a Prefixed-Var named B holding either False Or True like ${Prefixed_Var_named_B:=False}
 ### - On Having Reverse position inside ${Prefixed_Var_named_B:=False}, content of variable A, should
 ### Be erased of asking to get alternative.
 ### 
 ### Answer to pattern, 
 ### 
 ### BVTVarName=StrMultipleFileSelectionAttr BVTVarHold="--multiple" BVTBoolVarName=StrZenityFSMultipleFile BoolVarTest 
 ### 
 ### Nominal purposes: 
 ### This is intended to supply a Boolean test and Value Association, done in one line, 
 ### it allow to generate a range of variable being Transited from Prefixed-Var and value
 ### passed in a query, which is sometimes had no value and give extra code that might trigger error. 
 ### 
 ### For a Generated example between command-line BoolVarTest and Pre-fixed value, see 
 ### 
 ### BoolVarTest for substitution of StrFileTmp from function ZenityShellEval()
 ### Note reference : f1161962-0ad8-11e3-b166-001b3875b29c  
 ### 
 ### 
 ###  Warning : 
 ###  Note reference : 7236e956-f6cf-11e5-98a2-001e4c8856d6
 ###  - Recurrent call in BoolVarTest
 ###  and avoid uses of  ValueToVariable . 
 ###  While BoolVarTest is a low-level call indirectly call
 ###  by ValueToVariable it's hard to define first will end having 
 ###  good sub-body to acheive a strict identity and be able to 
 ###  parse all variable before BoolVarTest 'will' have to 
 ###  end a possible __main_start_services if this one is implemented 
 ###  with normal body-topology  .  So it's not recommended to use 
 ###  ValueToVariable inside BoolVarTest has long there is 
 ###  a better mechanisms correcting this problems in bash of recurrent  
 ###  function call recurently a lower level function will simply loop
 ###  and not finishing the work . 
 ### 
 ### 
 ### 

 ### Factory Section 
  unset StrVarBoolTest StrDefaultBoolTest StrNotAsserted StrScopeType StrIfTestType StrIfStringOp IsPreambule StrDefaultEndTest IsTypePreamb StrVTRPrbTpl StrVTRPrbVar StrVTRPrbVTReg StrVTRPrbVTFnct IsTypeAssert StrVTRAsrtTpl StrVTRAsrtVar StrVTRAsrtVTReg StrVTRAsrtVTFnct StrKeyTestType IntDefautlType IsDisplayIfStatement StrIfPattern ArrayIfPattern ArrayAssertion StrTestTemplate IsPreambulePolNtRespt ;
  unset Verbosis __main_StartServices ;
  local __call_locality=( BVT BoolVarTest ) ;
  local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ;
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 ### End of Factory Section.
  local ArrayTypeTest=( False True ) ;
  local ArrayPreambule=( ) ; 
  local ArrayIfPattern=( ) ;
  ### We do Agree if the clause using an Execution-ASSERTION-type  inside the 
  ### If-clause the section after the 'then' shoud not carry any trace of 
  ### BVTVarName, like default one StrAttrHold="" ... but should hold a trace of 
  ### $ eval $( VTV...=... VTV...=... ValueToVariable ) Function-Name
  local StrVarNamed=${BVTVarName:=StrAttrHold} ; 
  local StrVarNamedHold=${BVTVarHold:=CONTENT} ; 
  ### Following variable Stand for Is-Preambule-Polish-Notation-Respect is respected ( 
  ### like allow cleaning content and validate output for easy-Integer respect instead 
  ### of having case like IntValue="0" so far is valuable, but fail in case and if test -> 
  ### if [ "0" -eq 0 ] ; then ; fi , will notice some problems. )

  ###############
  ### Belong to Preambule Section Only:
  ###############
  
  ### Master Switch in case, If there is an Preambule in your ValueToVariable condition
  ### set this to True. Setting this to false will:
  ### Remove the Preambule section and avoid creating an Executive-Assertion at this place. 
  local IsPreambule=${BVTIsPreambule:=True} ; 
  ### Stand for Is there is a Preambule with Variable uses, To Start creating a 
  ### Variable with name LIKE CC, CFLAGS, LDFLAGS is not a good idea as long yo do 
  ### set BVTIsPrmblPlNt to False, this will avoid filtering the variable and 
  ### Ensure Wrapping from simple quote '"' any String Like variable name and wraping 
  ### True/False in boolean case from simple quote '"' 
  local IsPreambulePolNtRespt=${BVTIsPrmblPlNt:=True} ; 
  
  ### Section ValueToVariable in Preambule 
  ### Also we should understand having declared in a case where BVTIsPreambule=False
  ### there is no way to draw an Preambule in mode Execution-ASSERTION made from ValueToVariable.
  local IsTypePreamb=${BVTIsValueToVar:=False} ;

  ### Required variable to manage or configure a ValueToVariable Assertion inside Preambule Only.
  local StrVTRPrbTpl=${BVTVTVTPL:=eval __TES__  __REGISTRY_PRE__ VTVValueEntry=__VAR_ENTRY_PRE__ ValueToVariable __TEE__ __FNCT_PRE__} ;
  
  ### BVTVTVVar is the most used, allowing to pass-thru the variable in uses with 
  ### the same name to the function associate to Executive-Assertion inside the Preambule.
  ###
  local StrVTRPrbVar=${BVTVTVVar:=IsVerbose,IsDebug} ;
  
  ### BVTVTReg, Called BoolVarTest ValueToVariable Registry 
  ### is plain Prefixed-Variable associate to pass-thru mechanisme
  ###
  ### To eliminate confusion an action of 
  ###
  ### Taking what is in left-leg members to a similar name to right-leg member 
  ### describe by VAR1 = VAR1 is an Re-Assignation, or copy-variable algorithm.
  ### This is not the mechanisme that copy the variable name but entry-in function
  ### having a role to isolate the Variable and copy the content. Proof of fact  
  ### the variable is re-copied, it lost it's value at the end of the sub-function
  ### going back to value of the variable before the entry inside the sub-function.
  ###
  ###
  local StrVTRPrbVTReg=${BVTVTReg:=VTVIsArrayStyleInsert=True VTVIsValueReAssign=True VTVIsValueToConvert=False} ;
  
  ### BVTVTFnct 
  ###
  ### You do have a function to fill here to enable the pass-thru to a function 
  ### this is the part required to let having a function Executed during pre-ambule.
  ###
  local StrVTRPrbVTFnct=${BVTVTFnct:=__FNCT__} ;
  
  ###############
  ### End of Preambule Section .
  ###############
  
  ### 
  ### BVTBoolVarName is :
  ### the Left member in a if-clause evaluation :
  ### noted :
  ### if [ BVTBoolVarName == "True" ] ; then ... ; fi 
  ### 
  ### But this as also had effect to not correctly specified variable if it's 
  ### an active form variable 
  ### Where BVTBoolVarName=BoolIsAnyAction
  ### 
  ### and :
  ### local BoolIsAnyAction="False"
  ### if [ BoolIsAnyAction == "True" ] ; then ... ; fi
  ### ---> Should never analyse the if clause as ${BoolIsAnyAction} == "True", 
  ### but simply doing errors.
  ### 
  ### so it's important inside BVTBoolVarName to specified the Variable brace in evaluation mode like 
  ### BVTBoolVarName=\${BoolIsAnyAction} BVT...=... BVT...=... BVT...=... BoolVarTest
  ### 
  local StrVarBoolTest=${BVTBoolVarName:=IsVarShould} ; 
  local StrDefaultBoolTest=${BVTBoolCase:=False} ;
  local StrNotAsserted=${BVTBoolAssertion:=\"\"} ;
  local StrScopeType=${BVTScopeTest:=local} ;
  local StrIfTestType=${BVTIfType:=String} ; 
  local StrIfStringOp=${BVTIfOp:='=='} ;
  local StrDefaultEndTest=${BVTConclude:=";"} ;

  ### Section ValueToVariable in Assertion .
  local IsTypeAssert=${BVTIsValueToVarAssert:=False};
  local StrVTRAsrtTpl=${BVTVTVTPLA:=eval __TES__  __REGISTRY_ASRT__ VTVValueEntry=__VAR_ENTRY_ASRT__ ValueToVariable __TEE__ __FNCT_ASRT__} ;
  local StrVTRAsrtVar=${BVTVTVVarA:=IsVerbose,IsDebug};
  local StrVTRAsrtVTReg=${BVTVTRegA:=VTVIsArrayStyleInsert=True VTVIsValueReAssign=True VTVIsValueToConvert=False}
  local StrVTRAsrtVTFnct=${BVTVTFnctA:=__FNCT__}
  local StrKeyTestType=${BVTType:='if:fi,if:elif,elif:elif,elif:else,if:else,else:fi'} ;
  local IntDefautlType=${BVTIdType:=0} ; 
  local IsShowDebug=${BVTDisplayShowDebug:=False} ;
  local IsDisplayIfStatement=${BVTDisplayIf:=False} ; 
  local ArrayVarTestType=( String File Test Int Shell ) ;
  local StrParentApps="BoolVarTest" ;
  local StrVarListTransfert="StrTestTemplate,IsDisplayIfStatement,IntDefautlType,StrKeyTestType,StrVTRAsrtVTFnct,StrVTRAsrtVTReg,StrVTRAsrtVar,StrVTRAsrtTpl,IsTypeAssert,StrVTRPrbVTFnct,StrVTRPrbVTReg,StrVTRPrbVar,StrVTRPrbTpl,IsTypePreamb,StrDefaultEndTest,IsPreambule,StrIfStringOp,StrIfTestType,StrScopeType,StrNotAsserted,StrDefaultBoolTest,StrVarBoolTest,IsPreambulePolNtRespt,StrVarNamedHold,StrVarNamed,StrParentApps" ; 
  
  local StrTestTemplate=""" __PREAMBULE__ \
 __IF_PATTERN__  \
 __ASSERTION__ \
 __END_TEST__ __END_MARK__ """ ;

  ArrayIfPattern[0]="""__START_TEST__ [ \"__VAR_BOOL_TEST__\" __OP__ \"__DEFAULT_BOOL_TEST__\" ] """ ;
  ArrayIfPattern[1]="""__START_TEST__ [ \"__OP__ \"__DEFAULT_BOOL_TEST__\" ] """ ;
  ArrayIfPattern[2]="""__START_TEST__ \$( test \"__OP__ \"__DEFAULT_BOOL_TEST__\" ) """ ;
  ArrayIfPattern[3]="""__START_TEST__ [ __VAR_BOOL_TEST__ __OP__ __DEFAULT_BOOL_TEST__ ] """ ;
  ArrayIfPattern[4]="""eval __VAR__NAMED__ ; res=\$? ; __START_TEST__  [ \${res:=1} __OP__ __DEFAULT_BOOL_TEST__ ] """ ;
  
  function Verbosis()
  {
   local __call_locality=( Verbosis Verb );
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
      echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
    else
      echo -ne "${StrMsg}\n" > ${StrDevOut} ;
    fi 
   fi
  }
  
  


  function __main_StartServices
  {
   local __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]};  
   ### 
   ### Getter Section, 
   ### Retrieving information from Main Function BoolVarTest
   local ArrayTestType=( ${StrKeyTestType//,/ } ) ; 
   local ArrayTestSection=( ${ArrayTestType[${IntDefautlType}]//:/ } ) ; 
   
   ### Note : ArrayTestSection should test if value end with 'fi' and will require an extra semi-colon
   ### before adding element 'fi' --> 'else ... (;) fi ' 
   if [ "${ArrayTestSection[1]}" == "fi" ] ; then 
    ArrayTestSection[1]="; ${ArrayTestSection[1]}" ; 
   fi 
   # local ArrayIfPattern=(  ) ;
   local ATestType=( $( ${StrParentApps} --get ArrayVarTestType[@] ) ) ; 

   ### Other variable required ;
   local StrCurrentIfPatrn ;  
   local StrLcTTpl=${StrTestTemplate} ; 
   local StrIfPattern ; 
   
   local ArrayPreambule=( ) ; 
   ArrayPreambule[0]="__SCOPE__ __VAR_NAME__=__VALUE__" ;
   
   local ArrayAssertion=( ) ; 
   ArrayAssertion[0]="__ASRT_VAR__NAME__=__ASRT_VAR_VALUE__" ;
   
   ###
   ### ArrayIfPattern, Loop and test to select proper 
   ### StrIfTestType and it's Operator StrIfStringOp.
   ###
   for (( intx=0 ; intx <= ${#ATestType[@]}-1 ; intx++ )) ; do 
    if [ "${StrIfTestType}" == "${ATestType[${intx}]}" ] ; then 
     StrCurrentIfPatrn=$( ${StrParentApps} --get ArrayIfPattern[${intx}] )
     StrIfPattern=${StrCurrentIfPatrn//__OP__/${StrIfStringOp}} ; 
    fi 
    
   done ; 
   StrMsg="Type of VarTest: ${StrIfPattern}, StringOP: ${StrIfStringOp}" ;
   VerbHeader="DEBUG" VerbState="${IsShowDebug}" VerbDev=/dev/stderr VerbMsg=${StrMsg} Verbosis ;
   
   local ArrarTagParseOpt=( __VAR_BOOL_TEST__,StrVarBoolTest __DEFAULT_BOOL_TEST__,StrDefaultBoolTest __VAR__NAMED__,StrVarNamed )
   #for StrSyntaxItem in ${ArrarTagParseOpt[@]} ; do
   # StrPairRight="${StrSyntaxItem/#\_\_[A-Z_]*,/}" ; 
   # StrPairLeft="${StrSyntaxItem/%,[A-Z][A-Za-z0-9]*/}" ;
   # eval $( StrIfPattern=${StrIfPattern//${StrPairLeft}/\${${StrPairRight}}} ) ; 
   #done 
   ### replaced: StrIfPattern=${StrIfPattern//__VAR_BOOL_TEST__/$( ${StrParentApps} --get StrVarBoolTest )} ;
   StrIfPattern=${StrIfPattern//__VAR_BOOL_TEST__/${StrVarBoolTest}} ;
   ### replace: StrIfPattern=${StrIfPattern//__DEFAULT_BOOL_TEST__/$( ${StrParentApps} --get StrDefaultBoolTest )} ;
   StrIfPattern=${StrIfPattern//__DEFAULT_BOOL_TEST__/${StrDefaultBoolTest}} ;
   ### replaced: StrIfPattern=${StrIfPattern//__VAR__NAMED__/$( ${StrParentApps} --get StrVarNamed )} ;
   StrIfPattern=${StrIfPattern//__VAR__NAMED__/${StrVarNamed}} ;


   ### Old Preambule : ${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\"" 
   ### Old Assertion : \${StrVarNamed}=\${StrNotAsserted} ; 
   
   if [ "${IsTypeAssert:=False}" == "True" ] ; then 
    StrLcTTpl=${StrLcTTpl//__ASSERTION__/${StrVTRAsrtTpl}} ;
    StrLcTTpl=${StrLcTTpl//__REGISTRY_ASRT__/${StrVTRAsrtVTReg}} ;
    StrLcTTpl=${StrLcTTpl//__VAR_ENTRY_ASRT__/${StrVTRAsrtVar}} ;
    StrLcTTpl=${StrLcTTpl//__TES__/\$(} ;
    StrLcTTpl=${StrLcTTpl//__TEE__/)} ;
      ### 2016-08-29, require a ';' at the end of a command or an error will occur 
      ### after the preambule or near the end after assertion
    StrLcTTpl=${StrLcTTpl//__FNCT_ASRT__/${StrVTRAsrtVTFnct} } ;
   else
    StrLcTTpl=${StrLcTTpl//__ASSERTION__/${ArrayAssertion[0]}} ;
    StrLcTTpl=${StrLcTTpl//__ASRT_VAR__NAME__/${StrVarNamed}} ;
    StrLcTTpl=${StrLcTTpl//__ASRT_VAR_VALUE__/${StrNotAsserted}} ;
   fi 
   
   if [ "${IsPreambule:=True}" == "False" ] ; then 
    ### This section exist only because BVTIsPreambule=False allow to completely remove the 
    ### preambule. Having work around like using IntDefautlType=[1,2,3,4] can remove the 
    ### preambule and we are out of problem... Not so clean and some efforts are trying to 
    ### resolve 
    StrLcTTpl=${StrLcTTpl//__PREAMBULE__/} ; 
   else
     if [ "${IsTypePreamb:=False}" == "True" ] ; then 
      StrLcTTpl=${StrLcTTpl//__PREAMBULE__/${StrVTRPrbTpl}} ; 
      StrLcTTpl=${StrLcTTpl//__VAR_ENTRY_PRE__/${StrVTRPrbVar}} ; 
      StrLcTTpl=${StrLcTTpl//__REGISTRY_PRE__/${StrVTRPrbVTReg}} ; 
      StrLcTTpl=${StrLcTTpl//__TES__/\$(} ; 
      StrLcTTpl=${StrLcTTpl//__TEE__/)} ; 
      ### 2016-08-29, require a ';' at the end of a command or an error will occur 
      ### after the preambule or near the end after assertion
      StrLcTTpl=${StrLcTTpl//__FNCT_PRE__/${StrVTRPrbVTFnct} ;} ; 
     ### Second clause of if-"${IsTypePreamb:=False}" == "True"
     ### here stil in "${IsPreambule:=True}" == "True"
     else
      ### Missing, Initially we have defined here some Polish notation and we 
      ### don't have any test related to Integer, String and so forth... 
      ### 20160907- made it clear , scope test have something with ValueToVariable to produce infinite loop.
      ### inside __Action from ValueToVariable sub-function a loop of pair Variable:Variable are parsed
      ### inside an evaluation and does infinitely loop fir 3 items...
      ### discover the wa not inside tring-brace, but conformely not be the reason why
      ### scopetest == ',' and produce ',' instead of result from query .
      if [ "${IsPreambulePolNtRespt:=True}" == "False" ] ; then 
       StrLcTTpl="""${StrLcTTpl//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\" ;}""" ; 
       ### end of second clause of if [ ${IsPreambulePolNtRespt:=True} == "True"
       ### here, still in "${IsTypePreamb:=False}" == "True"
       ### here, on side of ${IsPreambulePolNtRespt:=True} == "False"
      ### Reverted condition to  put least part of code first. 
      else 
       ### To Qualify all test we do Made a First variable StrTypeVar ; Will hold 
       ### the conclusion into
       ### following answer form ( Bool / Int / String ) ; 
       ### between String Test or Not 
       ### Test is made in this order : -> Do we discover something else than number 
       ### inside the StrVarNamedHold
       ### First the copy made from StrVarNamedHold remove every number and test the 
       ### value.
       ### Secondly ( might not be immediately ), Detecting 0L , or simply called 
       ### Long not rationnal
       ### inside script but might be interresting . 
       ### Succedding to removing all number, counting the remaining char. 
       local StrVarHoldTest=${StrVarNamedHold} ; 
       local StrTypeVar="None" ; 
       
       ### Because Boolean are Special case, are likely to be String with only 
       ### 2 type of answer, True/False, It's like old story of Coolege Programmation
       ### Introduction 101 at Rosemont Cegep in 1997-1999 using Pascal and pseudo-code.
       ### It does the same for Boolean, having to type it plain text True/False and 
       ### the lexer/parser inide should understand what is Boolean to what is not... 
       ### In This context, we have craft a singular one with filtering .
       
       ### Special Case, detection of Boolean are made with sed reduction of specific
       ### Sub-Group. Especially found nothing inside Regular Expression of O'Reilly 
       ### Pocket reference, but still only a Pocket Reference. 
       
       ### Bash Big Line, It's especially important to declare it correctly and allow 
       ### type definition rather to not filtering the input at start and have many
       ### messages having problems to handle variable. Especially in Bash is actor
       ### or builtin/function/shell script to generate error on type not correctly 
       ### handled. If the variable is designe as Integer and hold String-like 
       ### information, if you do notthing with that variable or called-it 
       ### future-design, it won't tell you problems until the day you start to use it.
       
       ### Before reducing everything to nil, do a Boolean Detection:
       ### Since migration to Mint 17.3 and bash : 2016-09-02
       ### version:( GNU bash, version 4.3.11(1)-release (x86_64-pc-linux-gnu) )
       ### the sed behavior is not working like mint 12/13 .
       ### the Sed forma syntax : 
       ###   echo "${StrVarHoldTest}" | sed 's/[{'True','False'}]//g'
       ###   for simply taking out False and True reducing the Variable to Nothing and hold 
       ###   less than 0 charlong it simply not working in this version .
       StrVarHoldTest=$( echo "${StrVarHoldTest}" | sed 's/True//g;s/False//g'  ) ; 
       local IntPolishBool=${#StrVarHoldTest};
       local IntPolisgString ;
       local IntPolishInteger ;
       if [ ${IntPolishBool:=0} -eq 0 ] ; then 
        ### It's a Boolean form notation 
        StrTypeVar="Bool" ;  
        ### end of if-${IntPolishBool:=0} -eq 0
        ### here, still in "${IsTypePreamb:=False}" == "True"
        ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
       fi 
       
       ### If previous test did not transform the result into Bool.
       if [ "${StrTypeVar:=None}" == "None" ] ; then 
        StrVarHoldTest=$( echo ${StrVarHoldTest} | sed 's/[0-9]//g' ) ;
        IntPolishInteger=${#StrVarHoldTest} ; 
        StrTypeVar="Int"
        ### end of if-"${StrTypeVar:=None}" == "None"
        ### here, still in "${IsTypePreamb:=False}" == "True"
        ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
       fi 
       
       ### If previous test did not transform the result into Int.
       if [ "${StrTypeVar:=None}" == "None" ] ; then 
        StrVarHoldTest=$( echo ${StrVarHoldTest} | sed 's/[A-Za-z\ ]//g'  | tr '[:graph:]' ' ' | tr '[:cntrl:]' ' ' | tr '[:punct:]' ' ' | tr '[:space:]' ' ' | sed 's/ //g' ) ;
        IntPolisgString=${#StrVarHoldTest} ;
        StrTypeVar="String"
        ### end of if-"${StrTypeVar:=None}" == "None" 
        ### here, still in "${IsTypePreamb:=False}" == "True"
        ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
       fi 
       
       ### If previous test did not transform the result into String.
       if [ "${StrTypeVar:=None}" == "None" ] ; then 
        if [ ${IntPolishInteger:=0} -gt 0 ] ; then 
          ### it's not number 
          if [ ${IntPolisgString:=0} -eq 0 ] ; then 
           ### It own couple of extra char inside and should be see as String . 
           StrTypeVar="String" ; 
          fi 
        fi
       ### end of if-"${StrTypeVar:=None}" == "None"
       ### here, still in "${IsTypePreamb:=False}" == "True"
       ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
       fi 
       
       if [ ${StrTypeVar:=None} == "None" ] ; then 
        if [ ${IntPolishInteger:=0} -eq 0 ] ; then 
         ### It's formely all number 
         StrTypeVar="Int" ; 
        fi
       ### end of if-${StrTypeVar:=None} == "None"
       ### here, still in "${IsTypePreamb:=False}" == "True"
       ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
       fi
       
       if [ ${StrTypeVar:=None} == "Int" ] ; then 
        StrLcTTpl=${StrLcTTpl//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=${StrVarNamedHold} ;} ; 
       elif [ ${StrTypeVar:=None} == "String" ] ; then 
        StrLcTTpl=${StrLcTTpl//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\" ;} ; 
       elif [ ${StrTypeVar:=None} == "Bool" ] ; then 
        StrLcTTpl=${StrLcTTpl//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\" ;} ; 
       ### end of N-clause of if ${StrTypeVar:=None} == "Int"
       ### here, still in "${IsTypePreamb:=False}" == "True"
       ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
       else
        ### Kept as String .
        StrLcTTpl=${StrLcTTpl//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\" ;} ;  
       ### end of if-${StrTypeVar:=None} == "Int"
       ### here, still in "${IsTypePreamb:=False}" == "True"
       ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
       fi  
      # end of if-${IsPreambulePolNtRespt:=True} == "True"
      ### After this ${IsPreambulePolNtRespt:=True} == "False"
      fi 
      
     ### end of else, second clause  of if "${IsTypePreamb:=False}" == "True"
     ### after this "${IsTypePreamb:=False}" == "False" 
     fi
   ### end of if-"${IsPreambule:=True}" == "True" 
   fi
   if [ ${IntDefautlType} -eq 0 ] ; then  
    StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ; 
   elif [ ${IntDefautlType} -eq 1 ] ; then  
    StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ; 
   elif [ ${IntDefautlType} -eq 2 ] ; then  
    StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ; 
   elif [ ${IntDefautlType} -eq 3 ] ; then  
    StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ; 
   elif [ ${IntDefautlType} -eq 4 ] ; then  
    StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ; 
   elif [ ${IntDefautlType} -eq 5 ] ; then  
    StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/} ; 
   fi
   
   StrLcTTpl=${StrLcTTpl//__START_TEST__/${ArrayTestSection[0]}} ; 
   StrLcTTpl=${StrLcTTpl//__END_TEST__/${ArrayTestSection[1]}} ; 
   ### Uses of Array BVTType 
   ### index of operation : 
   ### 0 -> if:fi,
   ### 1 -> if:elif,
   ### 2 -> elif:elif,
   ### 3 -> elif:else,
   ### 4 -> if:else,
   ### 5 -> else:fi
   ### Exception in case IntDefautlType=4 for Imbrication of if, we need to 
   ### suppress the StrDefaultEndTest or provide a return caracter to allow 
   ### to fill second declaration of BoolVarTest with state 
   ### IntDefautlType=4 , Supply a first level if/else 
   if [ ${IntDefautlType} -eq 1 ] ; then 
    StrLcTTpl=${StrLcTTpl//__END_MARK__/} ; 
   elif [ ${IntDefautlType} -eq 2 ] ; then 
    StrLcTTpl=${StrLcTTpl//__END_MARK__/} ; 
   elif [ ${IntDefautlType} -eq 3 ] ; then 
    StrLcTTpl=${StrLcTTpl//__END_MARK__/} ; 
   elif [ ${IntDefautlType} -eq 4 ] ; then 
    StrLcTTpl=${StrLcTTpl//__END_MARK__/} ; 
   else
    StrLcTTpl=${StrLcTTpl//__END_MARK__/${StrDefaultEndTest}} ;  
   fi 
   
   
   
   ### 
   ### Section We transform StrTestTemplate into 
   ### IF 
   ### ...
   ### FI 
   ### IF  
   ### ...
   ### ELIF 
   ### ELIF 
   ### ...
   ### ELSE, 
   ### ... --> See BVTType for all choice made by default. It's a 2 choice 
   ### method and don't forget, it cover only One test at the time, 
   ### Either to not execute it after parsing you can call BoolVarTest
   ### many time and glueing result_BVT1 + result_BVT2 + result_BVT3
   ### to form a complete 
   ### 
   ### if   +
   ### ...  +--> Made by BVTType=1 BoolVarTest Stored in Var1
   ### elif +
   ### ...
   ### elif +
   ### ...  +--> Made by BVTType=2 BoolVarTest Stored in Var2
   ### elif +
   ### ...
   ### else +
   ### ...  +--> Made by BVTType=5 BoolVarTest Stored in Var3
   ### fi   +
   ### And A new variable NewVarTEst=${Var1}${Var2}${Var3} will hold the entire 
   ### test ...
   ### Notice there is odd sequence where the last line of your test SHOULD
   ### END with FI, like BVTType=4 BoolVarTest
   ### with if-else marker. This Boolean test does include a TAG named __END_MARK__
   ### with help you changing it for a 'fi' or either a semi-colon ';' 
   ### See BVTConclude where is default is semi-colon ';', but may old
   ### value like BVTConclude='fi ;' , BVTConclude='fi'   
  
   local StrMsg="\nFunction ${__call_locality[1]}, Display Result:\n ${StrLcTTpl}\n" ; 
   VerbState=${IsDisplayIfStatement} VerbDev=/dev/stderr VerbMsg=${StrMsg} Verbosis
   echo -ne "${StrLcTTpl}" ; 

   
  }

   
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    GetVarReference ${__call_locality[1]} ; 
    echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
   eval $( __GetVarReferenceCompWord ) ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
   eval $( VTVValueEntry=${StrVarListTransfert} \
           VTVIsValueReAssign=True              \ 
           VTVIsValueToConvert=False            \
           VTVIsArrayStyleInsert=True           \
           ValueToVariable ) __main_StartServices 
  fi
  
 }

### End-of if-${versionBVT:=0.0.2}
fi 

### Unitary test command : unset BoolVarTest ; . /etc/init.d/Fnct.D/fnct_debian_lib BVTVarHold='' BVTVTVVar=BoolDisplayFnctD,StrUrlGetter,BoolEvalCmdExit,StrAppsPwdGenerator,IntDefaultPwdSize,IntDefaultFactor,IntRandomSeedFactor,StrPasswordTypeForm,IntPasswordType,IsAutoInstallPwgen,StrDebInstallMethod,StrDebianInstallerType,StrAptLineCmd,StrGdebiPackageName,StrGdebiDownloadPack,StrFnctDSvrBVTVC BVTVTFnct=__Display BVTBoolVarName=${BoolEvalCmdExit:=False} BVTBoolCase=False BVTBoolAssertion='' BVTIsPreambule=True BVTScopeTest=local BVTVTVVarA=BoolDisplayFnctD,StrUrlGetter,BoolEvalCmdExit,StrAppsPwdGenerator,IntDefaultPwdSize,IntDefaultFactor,IntRandomSeedFactor,StrPasswordTypeForm,IntPasswordType,IsAutoInstallPwgen,StrDebInstallMethod,StrDebianInstallerType,StrAptLineCmd,StrGdebiPackageName,StrGdebiDownloadPack,StrFnctDSvrBVTVC BVTVTFnctA=__Loop BVTIsValueToVar=True BVTIsValueToVarAssert=True BVTDisplayIf=True BoolVarTest



