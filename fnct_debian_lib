
#. /etc/init.d/fnct.d/fnct_lib

declare -a ArrayMetaList=( Install Archives ) ; 
declare -a ArrayCreator=( Debian Ubuntu Fedora Mint ) ;
declare -a ArrayPackageType=( DPKG APT YUM RPM ) ;
declare -a ArrayPackageAction=( install update remove fix compile certify verify ) ;


### Package Query function. 
### give by-package, many option at once. 
### 
### Single package:
### ex: GetPackage=flac PkgConfigQuery --cflags --libs
### 
### will output:
### 
### flac:--cflags:-I/usr/include/FLAC  
### flac:--libs:-lFLAC -lm  
### flac++:--cflags:-I/usr/include/FLAC++ -I/usr/include/FLAC  
### flac++:--libs:-lFLAC++ -lFLAC -lm  
### 
###
### Many Package : 
### ex: GetPackage=samplerate,flac PkgConfigQuery --cflags --libs 
### samplerate:--cflags: 
### samplerate:--libs:-lsamplerate  
### flac:--cflags:-I/usr/include/FLAC  
### flac:--libs:-lFLAC -lm  
### flac++:--cflags:-I/usr/include/FLAC++ -I/usr/include/FLAC  
### flac++:--libs:-lFLAC++ -lFLAC -lm  

function PkgConfigQuery()
{ 
  local ArrayArg=($*);
  local __call_locality=( PkgConfigQuery ) ;
	local Arg0=${ArrayArg[0]:=--start} ; 
	local ArrayArgFlag=( ${ArrayArg[@]:1} ) ; 
	local IntArgLen=${#ArrayArgFlag[@]} ;
	local StrPkgConfigApps=${PkgConfigQueryAppsName:=/usr/bin/pkg-config};
	local StrPkgConfigAppsOpt=${PkgConfigQueryAppsOption:=--list-all};

	local StrPackageList=${PkgConfigQueryGetPackage:=flac} ;
	local StrFlagList=${PkgConfigQueryFlagList:=--libs,--static,--short-errors,--libs-only-l,--libs-only-other,--libs-only-L,--cflags,--cflags-only-I,--cflags-only-other} ;
	local ArrayFlagTest=( ) ;
	function FilterPackageList()
	{
		local ArrayArg=( $* );
		local __call_locality=( FilterPackageList ) ;
		local StrGrepFilter=${FilterPackageListGrepFilter:=${CurrentPackage}}
		cut -d " " -f 1 | egrep -i "${StrGrepFilter}" | tr '[:cntrl:]' ' ' 
	}
	if [ ${IntArgLen:=0} -eq 0 ] ; then 
		ArrayFlagTest=( ${StrFlagList//,/ } ) ; 
	else
		ArrayFlagTest=( ${ArrayArgFlag[@]} ) ; 
	fi 
 
 	if [ "${Arg0:=--start}" == "--help" ] ; then 
			GetVarReference ${__call_locality[0]} ; 
	else
		local ArrayPackageListVar=( ${StrPackageList//,/ } ) ;
		for (( intAx=0 ; intAx <= ${#ArrayPackageListVar[@]}-1 ; intAx++ )) ; do 
			local CurrentPackage="${ArrayPackageListVar[${intAx}]}" ; 
		  local _A=( $( ${StrPkgConfigApps} ${StrPkgConfigAppsOpt} | FilterPackageListGrepFilter=${CurrentPackage} FilterPackageList ) );
		  local IntNbPackage=${#_A[@]} ;
		  if [ ${IntNbPackage:=0} -gt 0 ]; then
		      for ((x=0 ; x <= ${#_A[@]}-1 ; x++ )) ; do
		          for (( cx=0 ; cx <= ${#ArrayFlagTest[@]}-1 ; cx++ )) ; do
		              res=$( ${StrPkgConfigApps} ${_A[${x}]} ${ArrayFlagTest[${cx}]} );
		              echo -ne "${_A[${x}]}:${ArrayFlagTest[${cx}]}:${res}\n";
		          done;
		      done;
		  else
		      echo -ne "\n\n\tPackage Not Found\n" > /dev/stderr;
		  fi
		done 
	fi 
}

### Warning : 
### This version of pkg-config-all is aliased to pkg-config inside .bashrc of the user shell and following function 
### are also dependent of alias .
### cut -> to alias cut='/usr/bin/cut -d "'" "'" '
### pkg-config -> to alias pkg-config='pkg-config-all'
### 
### 
### 

function pkg-config-all()
{
	local __call_locality=( PkgConfigAll ) ; 
	local StrpackageName=${PkgConfigAllArrayName:=ArrayPackageName}	;
	local StrScopeType=${PkgConfigAllScoping:=declare -a}	;
	local StrCutCol=${PkgConfigAllCutAlias:=cut}	;
	local StrPkgConfig=${PkgConfigAllApps:=/usr/bin/pkg-config} ; 
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
 	if [ "${Arg0:=--startservices}" == "--help" ] ; then 
			GetVarReference pkg-config-all ; 
			echo -ne "Following switch are available:\n\n\t--startservices\tStart the application normally and output the package list\n\t--asarray\tStart The application and output the content into an Array, see varriable                               PkgConfigAllArrayName to change the name. This command need an eval braced                              to get the array being initialized.\n\n"
	else
		if [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
			eval "${StrPkgConfig} --list-all | ${StrCutCol} -f 1" ; 
		fi 
		if [ "${Arg0:=--startservices}" == "--asarray" ] ; then 
				local StrPackageList=$( ${StrPkgConfig} --list-all | eval "${StrCutCol} -f 1" | tr '[:cntrl:]' ' ' ) ; 
				echo -ne "${StrScopeType} ${StrpackageName}=( ${StrPackageList} )\n" ;
		fi
	fi
}


### Default Fast reference Helper. 
### Extract current Prefixed variables from your function and show it on stdout( screen output ). 
### The prefixed variable are indicated on decalation of __call_locality which usually had same name has 
### top function. 
### Desc : It actively look inside the function code and extract value prefixed with function name...
### was initially developped on $0, but change by creating subFunction, and some code may be reserved for private
### use or recurrent-code with recurrent variable name, may be show and alter your perception of functionality of 
### the design ...

### Example to implement the body-helper. 
### 
### function Helper()
### {
###  __call_locality=( Helper ) ; 
### 	local ArrayArg=( $* ) ; 
### 	local Arg0=${ArrayArg[0]}; 
###  local StrHelperInvolved=${HelperQuestionInvolved:=Nothing} ; ### <---1a 
### 	if [ "${Arg0:=--start}" == "--help" ] ; then 
###			GetVarReference ${__call_locality[0]} ; 
###  else	
###   ---> Normal Body event and code. 
###  
###   ... 
###  fi 
### }
### 
### Note, In case your Helper --help be tested, if it does not output only Prefixed var definition.
### retreive all your variable from your command and do like example StrHelperInvolved in 1a
### Create specific local variable and associate the content of your Prefixed variables, help get 
### better body definition and reduce complexity by reading it... 
### 


unset GetVarReference ;
function GetVarReference( )
{
	local ArrayArg=( $* ) ;

	function ParseInternalVar( )
	{
		local ArrayArg=( $* ) ;
		local __call_locality=( ParseInternalVar ) ;
		egrep -i ":=" |\
				sed -r 's/(^[\ \t]*)//g;s/=\$/ \$/g;s/;//g' |\
				cut -d ' ' -f 3- |\
				sed 's/\(:=\)/ /g;s/\${//g;s/}$//g;s/\(^[A-Za-z0-9=_]* \)/Variable \1,\n\tDefault Value:/g' | sed 's/[\}\{]//g' ;
	}
	function ParseLocalityVar()
	{
		local ArrayArg=( $* ) ;
		local __call_locality=( ParseLocalityVar ) ;
		egrep "__call_locality" | sed 's/[\)\(]/ /g;s/;//g' | cut -d ' ' -f 7 ;	
	}
	echo -ne "Help:\n\nFunction ${ArrayArg[0]}\nDefault Variable Value:\n";
	local CallLocalityInternalName=$( declare -f ${ArrayArg[0]} | ParseLocalityVar ) ;
	declare -f ${ArrayArg[0]} | egrep "${CallLocalityInternalName}" | ParseInternalVar ;
}


 ### GetOtherDate :
 ###
 ###
 ###	Full-length example : 
 ### Including Loop to create different day pattern
 ###
 ### hint:
 ### - Having to check 1 day before and 1 day after need to combine 
 ### settign GetOtherDateReferenceFormat="__INT__ day" , and not "__INT__ day ago", give you positive forward in time
 ### setting GetOtherDateIsLoop=True 
 ### setting GetOtherDateLoop=-1,1 ( tricky but work ) , create interleave between -1 to 1, so it's -1 day in futur, 0 day in futur and 1 day in futur... 
 
 ### GetOtherDateReferenceFormat="__INT__ day ago"  GetOtherDateFormat="%Y%m%d" GetOtherDateIsLoop=True GetOtherDateLoop=1,4 GetOtherDateVerbose=True  GetOtherDate
 ### Will display :
 ### 
 ### 20121010
 ### 20121011
 ### 20121012
 ###
 ### Short example :
 ### GetOtherDate
 ###
 ### Will display :
 ###
 ### 20121011
 ###
 ### GetOtherDateReferenceFormat="__INT__ day ago"
 ###
 ###
unset GetOtherDate ;

function GetOtherDate()
{
		local __call_locality=( GetOtherDate );
		local ArrayArg=( $* ) ; 
		
		function Verbosis()
		{
			local __call_locality=( Verbosis );
			local StrMsg=${VerbosisMsg:=__TEXT__} ; 
			local StrDevOut=${VerbosisDev:=/dev/stderr} ; 
			local ArrayArg=( $* ) ; 
			if [ ${ArrayArg[0]} == "True" ] ; then 
				echo -ne "${StrMsg}" > ${StrDevOut} ;
			fi
			
		}
		
		function DateFunc()
		{
			local __call_locality=( DateFunc ) ;
			local ArrayArg=( $* ) ; 
			eval """date +"${DateFuncFormat:=%Y%m%d}" -d '${DateFuncIndicator:=0 day}'""" ; 
		}
		
		local StrDateIndicatorFormat=${GetOtherDateReferenceFormat:='__INT__ day'}
		local StrDateIndicator=${StrDateIndicatorFormat/__INT__/${GetOtherDateReference:=0}}  ;
		local StrDateFormat=${GetOtherDateFormat:=%Y%m%d} ;
		local isLoop=${GetOtherDateIsLoop:=False} ;
		local LoopRange=${GetOtherDateLoop:=0,3} ;
		local ArrayRange=( ${LoopRange/,/ } ) ;
		local OperRange="<=" ;  
		local OperRangeIn="Intx++" ;
		local OperBaseStart=${ArrayRange[0]} ;
		local IsVerbose=${GetOtherDateVerbose=False} ;
		local IntEndLoop=$(( ${ArrayRange[$((${#ArrayRange[@]}-1))]} ));
		
		local Arg0=${ArrayArg[0]}; 
		
 	if [ "${Arg0:=--start}" == "--help" ] ; then 
			GetVarReference ${__call_locality[0]} ; 
	 else	 
	 	if [ "${isLoop:=False}" == "True" ] ; then 
				VerbosisMsg="ArrayRange, nb-element:${#ArrayRange[@]}, hold [ ${ArrayRange[@]} ]\n" Verbosis ${IsVerbose} ;
				if (( ${ArrayRange[0]} > ${IntEndLoop} )) ; then 
					OperRange=">=" ;
					OperRangeIn="Intx--" ; 
					OperBaseStart=${ArrayRange[$((${#ArrayRange[@]-1))}]} ;
				fi		
	 		VerbosisMsg="Looping from ${OperBaseStart} to ${IntEndLoop} \n" Verbosis ${IsVerbose} ;
	 		for (( Intx=${OperBaseStart} ;  Intx ${OperRange} ${IntEndLoop} ; ${OperRangeIn} )) ; do 
		 			StrDateIndicator="${StrDateIndicatorFormat/__INT__/${Intx}}" ; 
		 			DateFuncFormat=${StrDateFormat} DateFuncIndicator=${StrDateIndicator} DateFunc ;
	 		done
	 	else 
	 		DateFuncFormat=${StrDateFormat} DateFuncIndicator=${StrDateIndicator} DateFunc ;
			fi
 	fi 
}



function kill_cmd()    
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( kill_cmd ) ;  
	local IntDefaultKillSig=${kill_cmdDefaultSigInt:=-9} ;
	local StrColDisplayInSearch=${kill_cmdPsColList:=pid,command}
	local IntNbCol=$(( $( echo "${StrColDisplayInSearch}" | wc -m ) - $( echo "${StrColDisplayInSearch//,/}" | wc -m ) ))
	local IntIdPassToKiller=${kill_cmdColIdToKill:=${IntNbCol}} ; 
	if [ "${ArrayArg[0]}" = "--help" ] ; then 
		GetVarReference ${__call_locality[0]} ; 
	else
		for (( x=0 ; x <= ${#ArrayArg[@]}-1 ; x++ )) ; do 
			local cmd=${ArrayArg[${x}]} ; 
			local PsResult=$( ps -eo ${StrColDisplayInSearch} | egrep -i "${cmd}" | grep -v grep | cut -d ' ' -f ${IntIdPassToKiller} | tr '[:cntrl:]' ' ' )
			CmdEval=( kill ${IntDefaultKillSig} ${PsResult} ); 
			echo -ne "PsResult:\n\n${PsResult}\n\n" > /dev/stderr ;
			echo -ne "Command Eval:[ ${CmdEval} ]\n" > /dev/stderr ; 
		done 
	fi 
}



unset StartApps
function StartApps()
{ 
 local ArrayArg=( $* ) ; 
 local __call_locality=( StartApps ) ; 
 if [ "${ArrayArg[0]}" = "--help" ] ; then 
	GetVarReference ${__call_locality[0]} ; 
 else	 
	 local AppsRefresh=${StartAppsRefresh:=4} ; 
	 local Apps=${StartAppsCmd:=rezound --audio-method=jack} ; 
	 local ScanApps=${StartAppsScan:=rezound} ; 
		local StrAppsStopSig=/home/${USER}/stop_${ScanApps}
	 local IsStopSig
		IsStopSig=$( test -e ${StrAppsStopSig} && echo 1 );
	 while [ ${IsStopSig:=0} -eq 0 ] ; do 
		local isApps=$( ps -eo pid,command | grep -v egrep | egrep -ic "${ScanApps}" ) ; 
		if [ ${isApp:=0} -eq 0 ] ; then 
		 eval ${Apps} ; 
		fi ; 
		sleep ${AppsRefres} ; 
			IsStopSig=$( test -e ${StrAppsStopSig} && echo 1 ) ;
	 done ; 
		rm -f ${StrAppsStopSig} ;
		echo -ne "Exiting signal catch for Application ${Apps} to cancel respawing.\n" > /dev/stderr 
 fi
}

function Survey_kill_apps()    
{ 
    function KillApps()
    {
        local __call_locality=( KillApps ) ; 
        local ArrayArg=( $* ) ; 
        kill -9 $( ps -eo pid,command | egrep -i "${ArrayArg[0]}" | grep -v "egrep" | sed 's/^[\ \t]*//g' | cut -d " " -f 1 )
    }
    local __call_locality=( SurveyApps ) ; 
    local ArrayArg=( $* ) ; 
		if [ "${ArrayArg[0]}" = "--help" ] ; then 
		 GetVarReference Survey_kill_apps ; 
		else	 
		  local StrApps=${SurveyApps:=rezound} ; 
		  local IntDelay=${SurveyAppsRefresh:=4} ; 
		  while [ 1 ] ; do 
		      test -e /home/maxiste/kill_${StrApps} && \
		          rm -f /home/maxiste/kill_${StrApps} && \
		          KillApps ${StrApps} 
		      sleep ${IntDelay} ; 
		  done ; 
		fi
}



### Usefull for python installer using pip. 
### Happen more than once have to call pip with another gcc compiler while test failed to compile many source
### from Numpy numpy/linalg/lapack_litemodule.c and linalg/zlapack_lite.c failling or doing segmentation fault.
### Most of the time they can work compiling them direct from the shell but in bash script called from bash or
### python script like setup.py failed... 
### So I'm changing couple of variable and calling indivilually pip installer like this :
### Where cmd old followin value : cmd=( pip install __MODULE__ )
### eval $( DpkgGetInlineBuildFlags ) CC=/usr/bin/x86_64-linux-gnu-gcc-4.4 CXX=/usr/bin/x86_64-linux-gnu-g++-4.4 ${cmd[@]}
function DpkgGetInlineBuildFlags()
{
  local __call_locality=( DpkgGetInlineBuildFlags ) ;
  local ArrayArg=( $* ) ;
 	if [ "${ArrayArg[0]}" = "--help" ] ; then 
		GetVarReference ${__call_locality[0]} ; 
 	else	 
  	local CmdEval=( "cat" "${DpkgGetInlineBuildFlagsPath:=/etc/dpkg/}"${DpkgGetInlineBuildFlagsFile:=buildflags.conf} "|" """sed -e 's/^\(SET\ \)\([a-zA-Z]*FLAGS\)\([\t\ ]*\)/\2=/g'""" "|" tr """'[:cntrl:]\' ' '""" ) ;
  	eval "${CmdEval[@]}" ;
	fi 

}

function DebianAptSrcCompiler()
{
	local __call_locality=( DebianAptSrcCompiler ) ; 
	local ArrayArg=$( $* ) ; 
  local ArrayPackageName=( ${DebianAptSrcCompilerPackage//;/ } ) ;
	local CompilerVersion=${DebianAptSrcCompilerVersion:=4.4} ; 
	local StrAptProc=${DebianAptSrcCompilerPackageAptProc:=clean;install;build}
	local AddPatch=${DebianAptSrcCompilerPatch:=True} ;
	local ArrayAptSrcProc=( ${StrAptProc//;/ }  ) ; 
	local StrPatchOpt="" ; 
	local res_exec=0 ; 
	local StrPath=${DebianAptSrcCompilerPath:=/usr/local/src/apt} ;
 	if [ "${ArrayArg[0]}" = "--help" ] ; then 
		GetVarReference ${__call_locality[0]} ; 
 	else	 	
		if [ ${AddPatch:=True} == "True" ]; then 
			StrPatchOpt="-p" ;
		else
			StrPatchOpt="" ;
		fi 
		for Package in ${ArrayPackageName[@]} ; do 
			local old_dir=$( pwd )
			test ! -d ${StrPath}/${Package} && mkdir -p ${StrPath}/${Package} ;
			cd ${StrPath}/${Package} ; 
			apt-src update ;
			local UpdateState=$? ;
			if [ ${UpdateState:=0} -eq 0 ] ; then 
				echo -ne "\t\t----- Building -----\n\t\t\t${Package}\n\n" > /dev/stderr ; 
				for item in ${ArrayAptSrcProc[@]} ; do 
					echo -ne "\n\n\n\t\t----- APT-SRC STEP: -----\n\t\t\t${item}\n\n\n" > /dev/stderr ; 
					CC=${DebianAptSrcCompilerCBaseName:=/usr/bin/x86_64-linux-gnu-gcc-}${CompilerVersion} \
					CXX=${DebianAptSrcCompilerCXXBaseName:=/usr/bin/x86_64-linux-gnu-g++-}${CompilerVersion} \
					apt-src ${item} ${Package} ${StrPatchOpt} ; 
					res_exec=$? ; 
					echo -ne "\n\n\t\t-----------------\n\t\t Error Status: ${res_exec}\n\t\t-----------------\n\n" > /dev/stderr  ;  
				done ;
			else
				echo -ne "\n\n\t\t-------------------------------------------------------\n\t\t Error compilation/installation of ${Package}\n\t\t-------------------------------------------------------\n" > /dev/stderr 
			fi 
			cd ${old_dir}  ;
		done 
	fi
}

function find_edit_file()
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( find_edit_file ) ; 
	for file in ${ArrayArg[@]} ; do 
		find ./ -type f -iname "${file}" -exec gedit {} \; & 
	done ; 
}

### Usefult having clause with many compiler available and having h2xml or ctag path filtering to apply,
### having command like 
###
### -> h2xml /usr/include/math.h $( find /usr/include/ -type d -printf "-I%p " ) -c -o math_c.xml 
###	 Will reduce output of some treatment... 
###  ->>>
###  ->>>CompilerError: In file included from /usr/include/math.h:34,
###  ->>>                 from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/x86_64-linux-gnu/bits/huge_val.h:28:18: error: missing binary operator before token "("
###  ->>>/usr/include/x86_64-linux-gnu/bits/huge_val.h:30:20: error: missing binary operator before token "("
###  ->>>In file included from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/math.h:403:42: error: missing binary operator before token "("
###  ->>>In file included from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/math.h:30: error: '__BEGIN_DECLS' does not name a type
###  ->>>In file included from /usr/include/math.h:71,
###  ->>>                 from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: '__' was not declared in this scope
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: 'acos' was not declared in this scope
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: '__CONCAT' cannot be used as a function
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: expected primary-expression before ')' token
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: initializer expression list treated as compound expression
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: expected ',' or ';' before '(' token
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:57: error: redefinition of 'double __CONCAT'
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: 'double __CONCAT' previously defined here
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:57: error: 'asin' was not declared in this scope
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:57: error: expected primary-expression before ')' token

###
###
###

function FindFilterPathExclusion()    
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( FindFilterPathExclusion ) ; 
 	if [ "${ArrayArg[0]}" = "--help" ] ; then 
		GetVarReference ${__call_locality[0]} ; 
 	else	 

		### 
		### The chainning mechanism , if there is already used filter, passing thru this 
		### variable will add-it to current filter output. 
		local CurrentExlusion=${FindFilterPathKnowExclusion:=""} ; 
	
		###
		###
		###
		local SelectedPackagePath=${FindFilterPathName:="c++"} ; 

		### - Will tell to filter function if this segment should be considered as
		### first statement and in-middle statement... 
		### example, using FindFilterWithStartCond=True, for a clause for find to start adding -a ! -name "..." 
		### in first statement of if will give command like 
		### find -type d [ -a ! -name "c++/4.4" ] <--- current filter . 
		### will simply be rejected or some warning may issued from . 

		local StartFilterWithCondition=${FindFilterWithStartCond:=False};
		local StrFilterPattern="${FindFilterPattern:=NAME/VER}";
		### 	The FindFilterClause should be written like from Removing To adding
		###   ex: with find, having removing or excluding pattern start like -a ! -name or -o ! -iname ...
		###       and adding or positive filter will include -a name, -o name ... 
		###   and FindFilterClause should be written as : FindFilterClause="-a ! -name,-a name"
		local StrConditionPattern=${FindFilterClause:=! -name, -name}

		local StrTypeOfLogicForAnd=${FindFilterClauseAnd:=-a};
		local StrTypeOfLogicForOr=${FindFilterClauseAnd:=-o};
		local StrLogic=""
		### FindFilterLogicSetTo default choice : ( And / Or )
		### 
		###

		local DefaultLogic=${FindFilterLogicSetTo:=And}; 
		if [ "${DefaultLogic}" == "And" ] ; then
			StrLogic="${StrTypeOfLogicForAnd}" ;
		else
			StrLogic="${StrTypeOfLogicForOr}" ;
		fi 

		local ArrayClauseFilter ;
		for(( intx=1 ; intx <= 2 ; intx++ )) ; do 
			ArrayClauseFilter[${#ArrayClauseFilter[@]}]=$( echo "${StrConditionPattern}" | cut -d "," -f ${intx} ) ;
		done 
	

		local SelectedMajor=${FindFilterMajorVer:=4} ; 
		local SelectedMinor=${FindFilterMinorVer:=4} ; 
		local TypeClauseFilter=0 ;
		for (( intx=${FindFilterMinMajorVer:=0} ; intx <= ${FindFilterMaxMajorVer:=9} ; intx++ )) ; do 
			local StrCriteronFilter=${StrFilterPattern};
			local StrCriteronFilterPrefix="";
				StrCriteronFilter=${StrCriteronFilter/NAME/${SelectedPackagePath}} ;
				StrCriteronFilter=${StrCriteronFilter/VER/${SelectedMajor}.${intx}} ;

			if [ ${intx} -ne ${SelectedMinor:=0}  ] ; then 
				TypeClauseFilter=0 ;
				if [ "${StartFilterWithCondition}" == "True" ] ; then 
					StrCriteronFilterPrefix="${StrLogic} 1${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				else
					StrCriteronFilterPrefix="2${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				fi ;
			fi		

			if [ ${intx} -eq ${FindFilterMinMajorVer:=0} ] ; then 
				TypeClauseFilter=${TypeClauseFilter} ;
				if [ "${StartFilterWithCondition}" == "True" ] ; then 
					StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				else
					StrCriteronFilterPrefix="${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				fi ;
			else
				if [ "${StartFilterWithCondition}" == "False" ] ; then 
					StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				else
					StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				fi ;
			
			fi


			if [ ${intx} -eq ${SelectedMinor:=0} ] ; then 
				TypeClauseFilter=1 ;
				if [ "${StartFilterWithCondition}" == "True" ] ; then 
					StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} ${StrCriteronFilter}" ;
				else
					if [ ${intx} -eq ${FindFilterMinMajorVer:=0} ] ; then 
						StrCriteronFilterPrefix="${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
					else
						StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[1	]} \"${StrCriteronFilter}\"" ;				
					fi
				fi ;
			fi
			CurrentExlusion="${CurrentExlusion} ${StrCriteronFilterPrefix}" ;
		done
		echo -ne "${CurrentExlusion}" ; 
	fi 
}






### Yet Another Debian package Mangler and backup-management. 
### 
### It basically move actual Debian package from archive /var/cache/apt/archives
### some-where else like /media/COMST500GB/Linux-Debian/archives/Mint-12_x86-64...
### or some NFS mounted point or any mounted partition dedicated to save or backup... 
### - It create an index of the day, inside the Destination.
###  - The index file is in a new directory of the destination, calling it Destination/index
###  - The index file-name is named on the today date or on the day executed by the manager. 
###  - The index used to drop Package into destination are accounted and the index hold 
###  - the beginnign of the transfert. 
###  - Index day used can be changed thru PkgRepoMgmtReposIndexDay, but the time of the transaction
###    remain unchanged... look weird, but may have some goal .... 
###   - Variable PkgRepoMgmtReposIndex change the Index destination. 
### 
### The Action. 
### It's A loop inside the archives, a move to the destination and a link is done between them 
### - to remain somewhat active, or become inacessible if the mount is down... not bad for nfs
### mounting detection or lazy mount with economic transfert mode while having no reason
### to leave it mounted until you need to get some update or removing stuff. 
### If the management from APT, dpkg, gdebi remove the package, it give silent error to 
### remove something not being a file but link, but are not following the source... 
### Being serious with this action, PkgRepoMgmtReposBkpAct can change the Action. 
### 
### basically work like this :
### [ cmd1 __VIRG__ cmd2 ... ] 
### 
### cmd1 should include at least 
### __SRC__ tag , it transform it into proper destication  called __DEST__ 
### __FILE__ is critical and mandatory, it loop the command and turn __FILE__ into every item to be backuped 
### 
### - __VIRG__ tag is an hack, It's required when more then one command is called, it change in into ';' . 
### ex : PkgRepoMgmtReposBkpAct="scp  __SRC__/__FILE__ root@domainname:/__DEST__ __VIRG__ rm -f __SRC__/__FILE__" PackageRepositoryMgmt
### - transfert by scp a file from Debian packages from /var/cache/apt/archives and remove it. 
### 
### 
### ... So basically, this guys had a spade in hand and Spell it: 'I.B.M.' ;) from 1901, I should live long 
### enought to work there or know what they are doing... 
### 


unset PackageRepositoryMgmt ; 

function PackageRepositoryMgmt()
{
	
	local __call_locality=( PkgRepoMgmt ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
	local StrPathArchives=${PkgRepoMgmtPathArchives:=/var/cache/apt/archives} ; 
	local StrFindStringFormat=${PkgRepoMgmtStrFmt:="%f "} ;
	local StrPackageType=${PkgRepoMgmtFileFormat:=deb} ;
	local StrPathRepository=${PkgRepoMgmtRepository:=/media/COMST500GB/Linux-Debian/archives/Mint-12_x86-64} ;
	local StrPathReposIndex=${PkgRepoMgmtReposIndex:=/media/COMST500GB/Linux-Debian/archives/Mint-12_x86-64/index} ;
	local StrDefaultActionIndex=${PkgRepoMgmtReposIndexAction:="mkdir -p __PATH__"} ;
	local StrIndexTest=${PkgRepoMgmtReposIndexTest:=! -d} ;
	### Explained in GetOtherDate, GetOtherDateReference can be negative and report yesterday date too. and not null will
  ### give n-day after today... 	
	local IntDefaultDayIndexName=${PkgRepoMgmtReposIndexDay:=0} ;
	local StrBackupAction=${PkgRepoMgmtReposBkpAct:=mv __SRC__/__FILE__ __DEST__ __VIRG__ ln -s __DEST__/__FILE__ __SRC__/__FILE__} ;
	local StrTransactionStart=$( GetOtherDateFormat="%Y%m%d\ %H:%M:%S" GetOtherDate ) ; 
	local StrTodatDateTransfert=$( GetOtherDateReference=${IntDefaultDayIndexName} GetOtherDate ) ; 
	local StrIndexFile=${StrPathReposIndex}/${StrTodatDateTransfert};
	
	test ! -e ${StrIndexFile} && echo -ne "NEW TRANSACTION:${StrTransactionStart}\n" > ${StrIndexFile} ; 
	test -e ${StrIndexFile} && echo "COMMIT TRANSACTION:${StrTransactionStart}\n" >> ${StrIndexFile} ; 

	TestPathIndexName=${StrPathReposIndex} TestPathIndexTest=${StrIndexTest} TestPathIndexResultAction=${StrDefaultActionIndex} TestPathIndex ;
	
	function TestPathIndex()
	{
		local __call_locality=( TestPathIndex ) ;
		local ArrayArg=( $* ) ; 
		local StrPathTest=${TestPathIndexName:=/media/COMST500GB/Linux-Debian/archives/Mint-12_x86-64/index} ; 
		local StrTestType=${TestPathIndexTest:=! -d} ;
		local StrTestResultAction=${TestPathIndexResultAction:=mkdir -p __PATH__} ;
		test ${StrTestType} ${StrPathReposIndex} && ${StrTestResultAction//__PATH__/${StrPathReposIndex}} ;
	}	
	
	function GetPackageList()
	{
		local __call_locality=( GetPackageList ) ;
		local ArrayArg=( $* ) ; 
		local StrPathArchives=${GetPackageListPathArchives:=/var/cache/apt/archives} ; 
		local StrPackageType=${GetPackageListFormat:=deb} ;
		local StrDisplayOutput=${GetPackageListStringFormat:='%f '} ;
		local ArrayFileList=( $( find ${StrPathArchives} -maxdepth 1 -type f -iname "*.${StrPackageType}" -printf "${StrDisplayOutput}" ) ) ; 
		local IntLenFileList=${#ArrayFileList[@]} ;
		if [ ${IntLenFileList:=0} -gt 0 ] ; then 
			echo "${ArrayFileList[@]}" ; 
			return 0 ; 
		else
			echo "None" ;
			return 1 ; 
		fi
	}
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference PackageRepositoryMgmt ; 
	else 
			local ArrayFileList=( $( GetPackageListPathArchives=${StrPathArchives} GetPackageListFormat=${StrPackageType} GetPackageListStringFormat="${StrFindStringFormat}" GetPackageList ) )
			local Result=$? ; 
			if [ ${Result:=1} -eq 0 ] ; then 
				for (( intx=0 ; intx <= ${#ArrayFileList[@]}-1 ; intx++ )) ; do 
					local strfile="${ArrayFileList[${intx}]}" ;
					echo -ne "File: ${strfile}\n" > /dev/stderr ; 
					local StrLinkAction=${StrBackupAction};
					StrLinkAction=${StrLinkAction//__FILE__/${strfile}} ; 
					StrLinkAction=${StrLinkAction//__SRC__/${StrPathArchives}} ; 
					StrLinkAction=${StrLinkAction//__DEST__/${StrPathRepository}} ;
					StrLinkAction=${StrLinkAction//__VIRG__/;} ; 
					echo -ne "${strfile}\n" >> ${StrIndexFile} ; 
					echo -ne "Action:[ ${StrLinkAction} ]\n" > /dev/stderr ; 
					eval "${StrLinkAction}" ; 
					
				done 
			else
				echo -ne "ArrayFileList return Empty List\n" > /dev/stderr . 
			fi
	fi 
}

if [ ${VarFnctLib:=False} == "True" ] ; then

    Debian_DPKG_update_InstallList()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=Debian_DPKG_update_InstallList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      declare -a ArrayDPKGInstalled=( $( ${DebianProg:=dpkg} ${DebianProgQuery:=--get-selections} | awk 'BEGIN{}{printf("%s ",$1)}END{}' ) ) ; 
    }

    Debian_DPKG_update_ArchivesList()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=Debian_DPKG_update_ArchivesList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      declare -a ArrayArchiveDPKG=( $( find ${DefaultRootPath:=/var/cache/apt/archives/} -printf "%p " ) ) ; 
    }

    DebianDPKGProvideSubFunctionMember()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=DebianDPKGProvideSubFunctionMember __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __search_item()
      {
        #eval $( __InitFunc ) ;
        eval $( __call_localityLocalName=__search_item __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        if [ ${ArrayArg[1]} == ${ItemQuery:=update} ] ; then 
          return 0 ;
        fi
        return 1 ;
      }
      local Template="__CREATOR___PACKAGETYPE_____PACKAGEACTION___" ; 
      local StrCreator=${Creator:=${ArrayCreator[0]}} ;
      local StrPackageType=${PackageType:=${ArrayPackageType[0]}} ;
      local StrPackageAction=${PackageAction:=update} ;
      eval $( __in_for ArrayPackageAction __search_item ItemQuery=${StrPackageAction} ) ; 
      local ErrorStatement=$? ; 
      if [ ${ErrorStatement:=1} -eq 0 ] ; then 
        echo "__TODO__" ;  
      fi
    }

    MetaUpdateList()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=MetaUpdateList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __FuncUpdate()
      {
        #eval $( __InitFunc ) ;
        eval $( __call_localityLocalName=__FuncUpdate __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        local Template="__NODE____SECTION__List" ;
        Template=${Template/__SECTION__/${ArrayArg[0]}}
      } 
      eval $( __in_for ArrayMetaList __FuncUpdate ) ; 
    }

    function __get_col()    
    { 
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=__get_col __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      awk -vCol=${ArrayArg[0]} 'BEGIN{}{printf("%s ",$(Col));}END{}' ; 
    } ; 

    function UpdateDpkgGetSelection()
    {
      eval $( __call_localityLocalName=UpdateDpkgGetSelection __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      declare -a ArrayPackageCurrent=( $( dpkg --get-selections | __get_col 1 ) ) ; 
    }


    function get_listfile()    
    { 
      #eval $( __InitFunc get_listfile ) ;
      eval $( __call_localityLocalName=get_listfile __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __BaseEncode64()
      {
        #eval $( __InitFunc __BaseEncode64 ) ;
        eval $( __call_localityLocalName=__BaseEncode64 __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        base64 --wrap=0 ; 
      }
      function __IfTestFile()    
      { 
        #eval $( __InitFunc __IfTestFile ) ;
        eval $( __call_localityLocalName=__IfTestFile __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        if [ -f ${ArrayArg[0]} ] ; then 
          local StrStream=$( echo "${ArrayArg[0]}" | __BaseEncode64 ) ; 
          echo -ne "${StrStream} " ;
        fi 
      } ; 
      local ArrayFileList=( $( dpkg-query --listfiles ${ArrayArg[0]} ) ) ; 
      eval $( __in_for ArrayFileList __IfTestFile ) ; 
    } ; 

    function get_search()
    {
      #eval $( __InitFunc get_search ) ;
      eval $( __call_localityLocalName=get_search __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      eval $( __in_for ArrayPackageCurrent get_listfile ) ;
    }

    function get_package_by_file()
    {
      #eval $( __InitFunc get_package_by_file ) ;
      eval $( __call_localityLocalName=get_package_by_file __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function PostFilter()
      {
        #eval $( __InitFunc PostFilter ) ;
        eval $( __call_localityLocalName=PostFilter __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        awk -vGrepReturn=${GrepReturn} -f /etc/init.d/fnct.d/awk-script/DpKgQueryPackage.awk ; 
      }  
      local CmdEval=( ${Program:=apt-file} ${ProgramOption:=search} ${ProgramQuery:=lirc/lirc_client.h} ProgramQueryIs64=${ProgramQueryIs64:=false} "|" ${FilterProgram:=PostFilter} GrepReturn=${GrepReturn:=false} ${FilterProgramQuery:=""} ) ;
      echo "CmdLine:[${CmdEval[@]}]" ;
      #eval "${CmdEval[@]}" ; 
      eval "local IntResult=$( eval ${CmdEval[@]} )" ; 
      #echo "Return : ${IntResult}" ;
    }

    function AwkContentParsing()    
    { 
      #eval $( __InitFunc AwkContentParsing ) ; 
      eval $( __call_localityLocalName=AwkContentParsing __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __TinyDecode64()
      {
        #eval $( __InitFunc __TinyDecode64 ) ; 
        eval $( __call_localityLocalName=__TinyDecode64 __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        local StrBaseDecode=$( echo "${VarDecode64}" | base64 -d --wrap=0 2> /dev/null ) ; 
        local IntErrorReport=$? ;
        if [ ${IntErrorReport:=1} -eq 1 ] ; then 
          echo "${VarDecl:=local} ${VarName:=VarOut}=${VarDecode64}" ; 
        else
          echo "${VarDecl:=local} ${VarName:=VarOut}=${StrBaseDecode}" ; 
        fi 
      }
      eval $( __TinyDecode64 VarDecode64=${RecurrentTemplateSearch} VarName=StrRecurrentTemplateSearch VarDecl=${VarDecl} )  ;
      eval $( __TinyDecode64 VarDecode64=${StrQuerySearch} VarName=StrQuerySearch VarDecl=${VarDecl} )  ;
        
      
      local ProgramParserRecurrentTemplate=${StrReturnBase64DecodeTry} ;
      local CmdEval=( ${Program:=apt-file} ${ProgramOption:=search} ${StrQuerySearch} "|" ${ProgramParser:=awk} -vTemplateContent=${StrRecurrentTemplateSearch} -vVarNameOut=CmdEval -f /etc/init.d/fnct.d/awk-script/DpKgQueryPackage.awk ) ;
      echo "CmdLine:[${CmdEval[@]}]" ; 
    }

    function libsearch_AwkContentParsing()
    {
      #eval $( __InitFunc AwkContentParsing ) ; 
      eval $( __call_localityLocalName=libsearch_AwkContentParsing __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      local StrRecurrentTemplateSearch=$( echo "dpkg --get-selections | egrep -ic %s" | base64 --wrap=0 ) ;
      local StrQuerySearch=$( echo "lirc/lirc_client.h" | base64 --wrap=0 ) ; 
      AwkContentParsing RecurrentTemplateSearch=${StrRecurrentTemplateSearch} QuerySearch=${StrQuerySearch} ; 
      
    }

    __funcZenity_DpkgList() 
    { 
        eval $( __call_localityLocalName=__funcZenity_DpkgList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        
        ### This Cover-up the theory of problematic transfert of commune Variable name in external function
        ### being by definition to be treated ''AS'' the normal corpus of the definition of a script
        ### Where this example show a possibility that it does not... The WeFixIt by
        ### involve declaring this method inside this function by calling a declare-f and 
        ### renaming the function (incase of) and calling it inside the function like a 
        ### sub-function can be called and all variable within an external-function will 
        ### be accessible... 
        ### Noted by: Patrick Riendeau in 2003-2004 @vdl2 inc formelly know as Phéromone inc.
        ### and 2010... 
        
        eval """$( declare -f LinkFuncRetOkA_B  | sed 's/\\n/\\\\n/g;s/LinkFuncRetOkA_B/localLinkFuncRetOkA_B/g' )"""
        
        function DisplayEvalCmd()
        {
          echo -ne "in DisplayEvalCmd:\n\t\tCmdLine:${StrFuncName}:[ ${CmdEval[@]} ]\n" > /dev/stderr  ;  
        }
        
        function ExecEvalCmd()
        {
          echo -ne "in ExecEvalCmd:\n" > /dev/stderr ;  
          eval "${CmdEval[@]}" ;
        }

        function ZenityProgressBar()
        {
          eval $( __call_localityLocalName=ZenityProgressBar __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
          local IntRandomState=$(( ${RANDOM} % 20 )) ;
          local CmdEval=( zenity --progress --percentage=${IntRandomState} --text="Fetching Package List" --auto-kill --pulsate ) ;
          #DisplayEvalCmd ;
          #ExecEvalCmd ;
          LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }
        
        function ZenityListPackage()
        {
          eval $( __call_localityLocalName=ZenityProgressBar __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
          zenity --list --checklist --column "Installed" --column "Package Name" ;
          #DisplayEvalCmd
          #ExecEvalCmd ;
          LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }
        
        function DpkgSortedByInstall()
        {
         eval $( __call_localityLocalName=DpkgSortedByInstall __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
         local CmdEval=( "dpkg" "--get-selections" "|" "sort" "-k2" "-r" ) ;
         #DisplayEvalCmd ;
         #ExecEvalCmd ;
         LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }

        function SedFilterConversionDpkgToZenityList()
        {
          eval $( __call_localityLocalName=DpkgSortedByInstall __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
          #sed -r -f /etc/init.d/fnct.d/sed-script/FilterConversionDpkgToZenityList.sed ;
          local CmdEval=( "sed" "-r" "-f" "/etc/init.d/fnct.d/sed-script/FilterConversionDpkgToZenityList.sed" ) ;
          #DisplayEvalCmd ;
          #ExecEvalCmd ;
          LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }
        local CmdEval=( LFuncAction0=ZenityProgressBar LFuncAction1=DpkgSortedByInstall LinkFuncPipedA_B ) ;
        echo -ne "From Main Func:${StrFuncName}\n\n\tCmdEval:[ ${CmdEval[@]} ]\n" > /dev/stderr ;
        LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;

    }

    function get_list()  
    { 
      #eval $( __InitFunc get_list ) ; 
      eval $( __call_localityLocalName=get_list __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      local ArrayInfo=( $( find /usr/share/ -maxdepth 1 -type d -iname "man*" | tr '[:cntrl:]' ' ' ) ) ; 
      echo "${VarDecl:=local} ${ArrayName:=ArrayList}=( ${ArrayInfo[@]})" ; 
    } 
      
    function ffind()    
    { 
      #eval $( __InitFunc ffind ) ; 
      eval $( __call_localityLocalName=ffind __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      find ${ArrayArg[0]} -type f -iname "*man*" ; 
    } 

    function __ZenityProgressBar()    
    { 
      #eval $( __InitFunc ) ;  
      eval $( __call_localityLocalName=__ZenityProgressBar __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      zenity --progress --pulsate 
    } 

    function __wrap_bar_find()    
    { 
      #eval $( __InitFunc __wrap_bar_find ) ; 
      eval $( __call_localityLocalName=__wrap_bar_find __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      eval $( get_list ArrayName=ArrayOut VarDecl=local ) ;
      eval $( __in_for ArrayOut ffind ) | __ZenityProgressBar  ;
    }


    function __BuildDpkgShowFormat ()    
    { 
     #eval $( __InitFunc __BuildDpkgShowFormat ) ; 
     eval $( __call_localityLocalName=__BuildDpkgShowFormat __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
     local DefaultTagValue="__TAG__" ;
     if [ ${StructDpkgShowFormat:=__TAG__} == "__TAG__" ] ; then 
      declare -a StructDpkgShowFormat="${DefaultTagValue}" ;
     fi 
     StructDpkgShowFormat=( $( echo "${StructDpkgShowFormat}" | sed 's/'${DefaultTagValue}'/'${ArrayDPKG_QueryHeader[${ArrayArg[0]}]}${DefaultTagValue}'/g' ) ) 
    } 

    function __BuildDpkgShowFormatXml()
    {
      eval $( __InitFunc __BuildDpkgShowFormat ) ; 
      function __functor_show_header()
      {
        #eval $( __InitFunc __BuildDpkgShowFormat ) ; 
        eval $( __call_localityLocalName=__BuildDpkgShowFormatXml __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        echo -ne "\nStyle=${Style}\n" ;     
        echo -ne "${ArrayArg[2]}" ; 
        echo -ne "\nDstyle=${Dstyle}\n" ;
      }
      eval $( __in_for ${ArrayNameDPKGQuery=ArrayDPKG_QueryHeader} __functor_show_header CCode64=$( ) ) ;
    }

    compare_package()
    {
      local ArrayArg=( $* ) ; 
      function get_name()    
      { 
        eval $( __call_localityLocalName=compare_package __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        local str="${ArrayArg[0]}" ; 
        local ArrayPackage=( ${str/_/ } ) ; 
        echo -ne "${ArrayPackage[0]} " ;  
      } 
      
      function update_package_list()
      {
        eval $( __call_localityLocalName=update_package_list __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        ${DebianProg:=dpkg} ${DebianProgQuery:=--get-selections} | awk 'BEGIN{}{printf("%s ",$1)}END{}' ; 
      }
      
      function get_specific_search()
      {
        eval $( __call_localityLocalName=get_specific_search __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        apt-file search wxPython | awk 'BEGIN{}{intlength=split($1,Array,/:/); printf("%s\n",Array[1])}END{}' | sort -u | tr '[:cntrl:]' ' '  
      }
      
      function get_specific_python()
      {
        eval $( __call_localityLocalName=get_specific_python __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        find /var/cache/apt/archives/ -iname "*.deb" -printf "%f "
      }

      function __compare_package()    
      { 
        #local ArrayArg=( $* ) ; 
        eval $( __call_localityLocalName= __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        echo "Search for Package ${ArrayArg[0]} in Installed Package( ${#ArrayDPKGInstalled[@]} ) " ;      
        function search_package_name()    
        { 
          local ArrayArg=( $* ) ; 
          if [ "${ArrayArg[0]}" == "${ArrayArg[1]}" ] ; then 
            echo -ne "\tInstalled Package is in the list [ ${ArrayArg[0]} ]\n" ; 
            return 0 ; 
          fi
            ArrayDPKGUnInstalled[${#ArrayDPKGUnInstalled[@]}]="${ArrayArg[1]}";
            return 1 ; 
        } 
        eval $( __in_for ArrayDPKGInstalled search_package_name ${ArrayArg[0]} ) ; 
      }
      
      local ArrayPythonPackage=( $( ${ArrayArg[0]} ) ) ;
      echo -ne "\nPackage List Choosed from Function: ${ArrayArg[0]}\n\t[ ${ArrayPythonPackage[@]} ]\n" ;
      local ArrayDpkgPython=( $( eval $( __in_for ArrayPythonPackage get_name ) ) ) ;  
      local ArrayDPKGInstalled=( $( update_package_list ) ) ;    
      local ArrayDPKGUnInstalled ;
      eval $( __in_for ArrayDpkgPython __compare_package ) ;
      echo "declare -a ArrayDPKGUnInstalled=( ${ArrayDPKGUnInstalled[@]} )" ; 
    }

    function KeyAptSearch()    
    { 
     eval $( __call_localityLocalName=KAS __call_locality ); 
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=PackageArrayName FParamVarName=StrPackageArrayName FParamDefaultValue=ArrayPackage __fnctCreateLocalityFuncParam     ) ;
     
     function AptSearch()    
     { 
      eval $( __call_localityLocalName=AS __call_locality ); 
      echo -ne "Key: ${ArrayArg[0]}\n" ; 
      apt-file search ${ArrayArg[0]} ; 
     } ; 
     local CmdEval=( "eval" " $( " "__in_for" ${StrPackageArrayName:=""} "AptSearch" ")" ) ; 
     eval ${CmdEval[@]} ;
    }

    function dpkg-get-selections()
    {
     eval $( __call_localityLocalName=DPKG __call_locality ); 
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=BranchShow FParamVarName=StrBranchShow FParamDefaultValue=Left __fnctCreateLocalityFuncParam     ) ;
     
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName0 FParamVarName=ArrayCmdName[0] FParamDefaultValue=dpkg __fnctCreateLocalityFuncParam     ) ;
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName1 FParamVarName=ArrayCmdName[1] FParamDefaultValue="--get-selections" __fnctCreateLocalityFuncParam     ) ;
     
     eval local StrFuncColDisplay=\${${StrBranchShow}ColDisplay} ;
     
     function CommandCall()
     {
      eval $( __call_localityLocalName=CCall __call_locality ); 
      local CmdEval=( ${ArrayCmdName[@]} ) ;
      eval ${CmdEval[@]} ;
     }
     
     function RightColDisplay()
     {
      eval $( __call_localityLocalName=ColDisplay __call_locality ); 
      awk -vColName=${StrBranchShow:=""} -f /etc/init.d/fnct.d/awk-script/dpkg-col-display.awk 
     }
     
     function LeftColDisplay()
     {
      eval $( __call_localityLocalName=ColDisplay __call_locality ); 
      awk -vColName=${StrBranchShow:=""} -f /etc/init.d/fnct.d/awk-script/dpkg-col-display.awk 
     }
     
     local CmdEval=( ${CommandCall:=""} "|" ${StrFuncColDisplay:=""} ) ;
     eval ${CmdEval[@]} ;
    }

    function dpkg-set-selections()
    {
     eval $( __call_localityLocalName=DPKG __call_locality ); 
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=BranchShow FParamVarName=StrBranchShow FParamDefaultValue=Left __fnctCreateLocalityFuncParam     ) ;
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName0 FParamVarName=ArrayCmdName[0] FParamDefaultValue=dpkg __fnctCreateLocalityFuncParam     ) ;
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName1 FParamVarName=ArrayCmdName[1] FParamDefaultValue=--set-selections __fnctCreateLocalityFuncParam     ) ;
     
     function CommandCall()
     {
      eval $( __call_localityLocalName=CCall __call_locality ); 
      local CmdEval=( ${ArrayCmdName[@]} ) ;
      eval ${CmdEval[@]} 
     } 

    }
fi 



