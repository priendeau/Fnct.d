


 ###	Specification : 
 ###	- This following Draft-Specification, offer a decent explanation of doing a function with
 ###	appropriate control proned-protocolar development for scalarity-design . 
 ###	
 ### Example of definition of __call_locality:
 ###	function FuncNameThatIsUnderstandable()
	###	{
	###		local __call_locality=( FNTIU FuncNameThatIsUnderstandable ); 
 ###	                           |    |
 ###	                           |    +---> LongName to be used with GetVarReference, see (3)
 ###	                           |
 ###	                           +---> Short Name to be used to name Prefixed Variable, see (2)
 ###	
 ###	
 ###	Basic and Mandatory visibility and variable control 
 ###	
 ###	Since there is possible management with case switch, and index-pushing ArrayArg manage 
 ###	- called value after Function name was called :
 ###	 ex: Var1=value Var2=valueA;ValueB FuncNameThatIsUnderstandable --switches
 ###	----> Uses of --switches is almost important and should be controled from Arg0, see (1)
 ###	
 ###	Note on Function Behavior : There is almost only one switches used from command line telling 
 ###	which part is called , the actual embodinement after note (3) is an example of a called part.
 ###	- This example uses if-elif-else-fi statement, but a loop with pre-defined switches control
 ###	should end after is call. However uses of Prefixed-Var are infinite and might control
 ###	Behavior of a part into sub-derived part, but should stay in scope and definition of switches made. 
 ###	---> Later an round-up will convert all function from fnct_debian_lib into a Python parser that 
 ###	generate the same file here but with possibility to control everything and should generate a
 ###	stable meta-data file where this function should reflect it's present definition here. 
 ###	Note1: After seeing unworkable switches or switches entering in conflicts it's better to 
 ###	define value with possibilities to be useless or not used but preventing future version
 ###	to not work by calling contradictive switches. 
 ###	
 ###	
 ###	
 ###	
 ###	local ArrayArg=( $* ); ---> Really important line, all variable from outside are mangling inside
 ###	this Variable-ArrayArg, we do not uses $* alone since there is a possible alteration.
 ###	In Fact the declaration of ArrayArg should involve a read-only switch in final-draft. 
 ###	
 ###	Final Draft proposition of ArrayArg:
 ###	local -r ArrayArg=( $* ); *** Only if bash version accept it, which start to be effective from 
 ###	bash version 2.99 from FreeBsd transport to linux around 1997. 
 ###	
 ###	
 ###	*(1)
 ###	local Arg0=${ArrayArg[0]} ; ---> Allow uses of switches like --help, --list, --startservices, --get
 ###	---> Default switches and easy to do stuff , --help, --list, --startservices, --get
 ###	
 ###	
 ###	
 ###	*(2)
 ###	local StrSomeMeanFulName=${FNTIUDefinitionName}
 ###	
 ###	
 ###	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n" 
 ###	+---> Should be usefull to see default switches availables. 
 ###	
 ###	- First use in main body of a function 
 ### *(3)
 ###	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
	###  GetVarReference ${__call_locality[1]} ;  
	###	 echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	### elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
	###	 eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
	###	 echo -ne """${ArgGet}\n""" ; 			
	### elif [ "${Arg0:=--startservices}" == "--list" ] ; then } ---> Sequence to extract Prefixed-var and uses 
	###	 eval $( __GetVarReferenceList ) ;                     } of function call to accelerate external variable 
 ###	                                                       } transfert, ex : FuncNameThatIsUnderstandable --get $(  FuncNameThatIsUnderstandable --list | cut -d ' ' -f 1  ) *(4)
 ###	                                                       } will get the First Prefixed-variable value
 ###	 
 ###	 
	### elif    [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
 ###	 +--------------> Main Body <--------------+
 ###	else
 ###	 
 ###	...
 ###	fi 
 ###	
 ###	



 ### ValueParser :
 ### 
 ### Description: 
 ### - Aim to be a Value Parser with specific semantic to automatically create lists
 ### of variable with specific notation. It was designed to Create a Unique Variable,
 ### like StrValueParserInfo and evaluating the Variable with string-like specified with.
 ### 2 level of CSV, between type ( Profixed variable are VPCallLocalityName VPVarArgList VPScopeList VPValueList )
 ### are reserved to specify somes crucial information. 
 ### 
 ### VPCallLocalityName -> Under wichh prefix named variable are transfered from their calling name.
 ### Ex: Having Function with var __call_locality=( ValueTest ), mean all variable from incoming 
 ### function called with ValueTest(), like :
 ### var1=value1 var2=value2 ValueTest --opt , var1 and var2 must have theirs names starting by
 ### ValueTestvar1=value1 ValueTestvar2=value2 ... 
 ### 
 ### - Value parser will transform variable from ValueTestvar1 into Strvar1, Strvar2 if VPVarArgList
 ### is specified.
 ### 
 ### VPVarArgList -> Specify the list of name and their internal Prefix Type. 
 ### as said in VPCallLocalityName, variable have external and internal names. 
 ### Passing by will not directly convert by create a variable starting with specified prefix.
 ### Having :
 ### VPCallLocalityName=ValueTest VPVarArgList=Str:var1,Str:var2 
 ###  - inside function :ValueTest() will:
 ### get from extern name like ValueTestvar1=value1 ValueTestvar2=value2 , 
 ### will transfert the content into appropriate internal name: Strvar1, Strvar2 . 
 ### - This is purely a simple transfert, convertion, name mangling and linting ( like checking name of 
 ### var if they are not exceeding 32 chars are not yet show. )
 ### 
 ### VPScopeList -> Implicitly tell to ValueParser if the variable are created in local or global, telling
 ### also about lifetime of variable... Important when dealing with function and sub-function and sub-n-function. 
 ### 
 ### 
 ### 
 ###	Full-length example : 
 ### Including 
 ### 
 ### See StartCoproc, variable StrValueParserInfo hold the references and work well with triple-guillements.
 ### 
 ##
 ### eval $( eval """
 ###	VPCallLocalityName=${__call_locality[0]} 
 ###	VPVarArgList=Str:ProcName,
 ###	             Str:InWhile,
 ###	             Str:WhCond,
 ###	             Str:WhRetStat,
 ###	             Str:AppsName,
 ###	             Str:AppsPrVar,
 ###	             Str:AppsOpt
 ###	VPScopeList=ProcName:local,
 ###	             InWhile:local,
 ###	             WhCond:local,
 ###	             WhRetStat:local,
 ###	             AppsName:local,
 ###	             AppsPrVar:local,
 ###	             AppsOpt:local 
 ###	VPValueList=DefaultCoprocName:True:__VAR__ -ne 1:__VAR__=\$( __CMD__ ):GitHubCommit:GitHubCommitFilePath=/etc/init.d/Fnct.d:fnct_debian_lib
 ###	""" ValueParser )  ;
 ### 
 ### -Note Calling ValueParser with same string embedded in the value with following switches --varhelper, will transform this stream of variables
 ### - into helper like GetVarReference . Don't forget, what ValueParser showing or creating is not visible from GetVarReference. GetVarReference
 ### Function extract information from a 'declare -f ' statement and ValueParser is not creating inside the function the value, they are created 
 ### by using this function... Quite simple, almost dynamic, but not fully-dynamic... It's bash afterall... 
 ### Note : Sometimes more easy calling VPCallLocalityName=${__call_locality[0]} instead if re-writing the function names...
 ### Some will love $0 wich is the function name or the script name if this one is inside a shell-file-script. but personally,  I report a lot 
 ### of problems.  
 ### 
 ### 
 ### Comparaison : 
 ### 
 ### Following method are similar .
 ### 
 ### function ValueTest()
 ### {
	###  local ArrayArg=( $* ) ; 
	###  __call__locality=( ValueTest )	
 ###  StrValueTest=${ValueTestValue:=None} ; 
 ###  echo -ne """${StrValueTest}\n""" ; 
 ### } 
 ### 
 ### function ValueTest()
 ### {
	###  local ArrayArg=( $* ) ; 
	###  __call__locality=( ValueTest )	
 ###  local StrValueParserInfo="VPCallLocalityName=${__call_locality[0]} VPVarArgList=Str:Value VPScopeList=Value:local VPValueList=None" ; 
 ###  eval $( eval "${StrValueParserInfo} ValueParser " ) ;
 ###  echo -ne """${StrValueTest}\n""" ; 
 ### } 
 ###
 ### - It's eat more line if the number of variables are lower than 3 variables, but both function
 ### work on same way... Calling-function to see the result:
 ### 
 ###  ValueTestValue="This is a test" ValueTest
 ### 
 ### - Exception : Still unable to read new variable definition from command-line and only create 
 ### a Variable transfert blindly. 

 
unset ValueParser ;
function ValueParser()
{
		local __call_locality=( VP ValueParser );
		local ArrayArg=( $* ) ; 
		local Arg0=${ArrayArg[0]} ;
		
  local StrVarArgList=${VPVarArgList:=Str:AppsName,Str:AppsOpt} ; 
		local StrValueList=${VPValueList:=echo,__VALUE__} ; 
		local StrLocality=${VPCallLocalityName:=Default} ; 
		local StrScope=${VPScopeList:=AppsName:local,AppsOpt:local} ; 
		local StrDefaultScope=${VPScopeDefault:=local} ;
		local ArrayScope=( ${StrScope//,/ } ) ; 
		local ArrayVar=( ${StrVarArgList//,/ } ) ; 
		local ArrayValue=( ${StrValueList//:/ } ) ;
		local StrValueReturn="" ;
		local StrDebug=${VPDebug:=False}
		local ArrayScopeIndex=( "local" "declare -a" ) ;

		function GetScope()
		{
				local __call_locality=( GS GetScope );
				local ArrayArg=( $* ) ; 
				local Arg0=${ArrayArg[0]} ;
				local StrDebug=${GetScopeDebug:=False}
    eval $( BVTestVarName=StrReturn BVTestVarHold="0" BVTestBoolVarName=\${Arg0:=local} BVTestBoolCase="global" BVTestBoolAssertion="1" BoolVarTestVarCreation ) ;
				echo -ne "${StrReturn}" ; 

		}
		function VarInScopeList()
		{
			local __call_locality=( VISL VarInScopeList );
			local ArrayArg=( $* ) ; 
			local Arg0=${ArrayArg[0]} ;
			local StrDebug=${VISLDebug:=False} ;
			local StrValue=${VISLValue:=AppsName} ;
			local StrIsScoped=False ;
			local StrValueReturn="False" ;
			
   for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
				local ArrayValue=( ${ArrayArg[${intx}]//:/ } ) ;
				local StrSuffix=${ArrayValue[0]} ; 
				if [ "${StrSuffix}" == "${StrValue}" ] ; then 
					local StrScope=$( GetScope ${ArrayValue[1]} ) ; 
					StrIsScoped=True
					StrValueReturn="${StrIsScoped} ${StrScope} ${StrValue}" 
				fi 
			done 
			echo -ne "${StrValueReturn}" ; 
		}
 
 function VarReplace()
 {
		local __call_locality=( VR VarReplace ) ;
		local ArrayArg=( $* ) ; 
		local Arg0=${ArrayArg[0]};
  local ArrayScoceA=(  __suffix__:${StrVarSuffix} __value__:${AValue} __prefix__:${StrVarSuffixType} __locality__:${StrLocality} ) ; 
		local StrScoreResultParse ; 
  if [ "${AscopeType}" == "True" ] ; then 
   StrScoreResultParse= ${ArrayScopeIndex[${ArrayScopeTest[1]}]}
  else
   StrScoreResultParse = ${StrDefaultScope}
  fi 
  for (( intx=0 ; intx <= ${#ArrayScoceA[@]}-1 ; intx++ )) ; do 
   local ArrayIScope=( ${ArrayScoceA[${intx}]//:/ } ) 
   StrVarName=${StrVarName//${ArrayIScope[0]}/${ArrayIScope[1]}} ; 
  done 
		StrVarName=${StrVarName//__scope__/${StrScoreResultParse}} ;
  
 }
 
 function VarHelper()
 {
		local __call_locality=( VH VarHelper ) ;
		local ArrayArg=( $* ) ; 
		local Arg0=${ArrayArg[0]};
  local ArrayScope=( ${ArrayScope[@]//,/ } ) ; 
  local StrDebug=${MainDebug:=False} ;
  for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
		  local VarSeg=( ${ArrayArg[${intx}]//:/ } ) ; 
				local StrVarSuffixType="${VarSeg[0]}" ;
				local StrVarSuffix="${VarSeg[1]}" ;
				local StrVarName="Variable __locality____suffix__,\n\tDefault Value __value__\n\tInternal variable: __prefix____suffix__\n" ;
				
				local ArrayScopeTest=( $( Value=${StrVarSuffix} \
                              VarInScopeList        \
                              ${ArrayScope[@]}    ) ) ; 
				### __scope__ Tag is eclued, because it's the only one does not respect the
    ### the looping sequence, explicitly needs a of Scope test to dismiss between
    ### local scoping and global scoping. 
    
    StrVarSuffix=${StrVarSuffix}          \
    AValue=${ArrayValue[${intx}]}         \
    StrVarSuffixType=${StrVarSuffixType}  \
    StrLocality=${StrLocality}            \
    AscopeType=${ArrayScopeTest[0]}       \
    VarReplace                            ;
				StrValueReturn="${StrValueReturn} ${StrVarName}" ;
			done 
			echo -ne "${StrValueReturn}" ;
			
		}		
		function __main_StartServices()
		{
   local __call_locality=( Main __main_StartServices ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]};
			local ArrayScope=( ${ArrayScope[@]//,/ } ) ; 
			local StrDebug=${MainDebug:=False} ;
			for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
				local VarSeg=( ${ArrayArg[${intx}]//:/ } ) ; 
				local StrVarSuffixType="${VarSeg[0]}" ;
				local StrVarSuffix="${VarSeg[1]}" ;
				local StrVarName="__scope__ __prefix____suffix__=\${__locality____suffix__:=\${__locality____suffix__:=__value__}}" ;
				
				local ArrayScopeTest=( $( Value=${StrVarSuffix} \
                              VarInScopeList        \
                              ${ArrayScope[@]}    ) ) ; 
				
				StrVarSuffix=${StrVarSuffix}          \
    AValue=${ArrayValue[${intx}]}         \
    StrVarSuffixType=${StrVarSuffixType}  \
    StrLocality=${StrLocality}            \
    AscopeType=${ArrayScopeTest[0]}       \
    VarReplace                            ;
				StrValueReturn="${StrValueReturn} ${StrVarName} ; " ;
			done 
			echo -ne "${StrValueReturn}" ;
			
		}
		local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
		if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
		elif [ "${Arg0:=--startservices}" == "--varhelper"	] ; then 
			ArrayScope=${ArrayScope[@]// /,}      \
   StrVarSuffix=${StrVarSuffix}          \
   StrValueReturn=${StrValueReturn}      \
   StrDefaultScope=${StrDefaultScope}    \
   StrLocality=${StrLocality}            \
   VarHelper   ${ArrayVar[@]} ;
		elif [ "${Arg0:=--startservices}" == "--startservices"	] ; then 
			ArrayScope=${ArrayScope[@]// /,} \
   StrVarSuffix=${StrVarSuffix} \
   StrValueReturn=${StrValueReturn} \
   StrDefaultScope=${StrDefaultScope} \
   StrLocality=${StrLocality}  Main ${ArrayVar[@]} ; 
		fi 
	
}



unset __default_test ;
function __default_test()
{
	local ArrayArg=( $* ) ; 
	local __call_locality=( DT __default_test  ) ; 
 local Arg0=${ArrayArg[0]} ; 
	local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
	 GetVarReference ${__call_locality[1]} ;
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	else
		echo "__BODY__" > /dev/stderr ; 
	fi 
	
}


unset AddPValueStore
function AddPValueStore()
{
	local ArrayArg=( $* ) ; 
	local __call_locality=( APVS AddPValueStore  ) ; 
 local Arg0=${ArrayArg[0]} ; 
	local StrAction=${APVSAction:=add} ; 
	local StrFunction=${APVSFunction:=__default_test} ; 
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
	 GetVarReference ${__call_locality[1]} ;
		local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	else
		echo -ne "__BODY__\n" > /dev/stderr ; 
	fi 
}

### GetVarReference
unset GetVarReference
. ${FNCTDLIBPATH}/6403c722-28a6-11e3-98a2-001b3875b29c

### AnsiCodeTest 
unset AnsiCodeTest
. ${FNCTDLIBPATH}/6e063cbc-0ce2-11e3-8879-001b3875b29c 


### ZenityRadioOptionConfig, ZenityListOptionConfig, ZenityPrefixedVarBuilder 
unset ZenityRadioOptionConfig
unset ZenityListOptionConfig
unset ZenityPrefixedVarBuilder
. ${FNCTDLIBPATH}/50ccda66-2ebb-11e3-98a2-001b3875b29c

### GetStdPrefixName 
unset GetStdPrefixName ; 
. ${FNCTDLIBPATH}/69968204-0cf6-11e3-99bc-001b3875b29c 

### ZenityPythonInstaller 
unset ZenityPythonInstaller ; 
. ${FNCTDLIBPATH}/950966fa-0e67-11e3-98a2-001b3875b29c

### FileNameConversion
unset FileNameConversion ; 
. ${FNCTDLIBPATH}/877d7e9a-1001-11e3-98a2-001b3875b29c

### __GetVarReferenceCompWord
unset __GetVarReferenceCompWord ; 
. ${FNCTDLIBPATH}/023102e0-1833-11e3-98a2-001b3875b29c
### This is first pragma. BodyFunc Should manage it. 


### 
### Note, Existence of A-Range Boolean Purposes and B-Applied Boolean
### Variable. 
### 
### Def : A-Range Boolean Variable.
###  - Allow the Position between True and False Adding A WIDE-RANGE of 
### Information, Settled from Possibilities to Have at least 1 Data to 
### Fit inside a compound, the A-Range Boolean will be defined as:
### - Test 1:
### The AIsMoreFruitTo=False will leave a compound sentence as is:
### Sentence : The fruit are Grapes were all loved by children 
### 
### The AIsMoreFruitTo=True will Add-A-Range, this case being finite and
### unique the sentence will Have an addition:
### 
### Sentence : The fruit are Grapes ( and Banana ) were all loved by children 
### 
### See Answer to pattern inside BoolVarTestVarCreation to see similarities. 
### 
### 
### Def : B-Applied Boolean Variable.
### - Expected case to add some extra functionalities to common argument. 
### - See PackageRepositoryMgmt for example of PkgRepoMgmtAddPkgLst Boolean
### variable allowing to add a listing in case Package are backuped and 
### need a reference of status of package . 
### 
### 
### To Fellow M.Murgullescu, Interrupted course to supplied informations 
### to teacher about limitation of homo-erectus (also called Midget) . 
### INF101 College Rosemont and Pre-homo-sapiens-sapiens limitation in 
### learning problems. 
### -Interaction done silently by turn-based event and noticing only 
### on volume / ratio in comment on Any-Type defined from Pascal-Programmation.
### 
### - Teacher just supplied the answer in a case for an examen of 15% of the
### sum and give any other information thru course traversal. 

unset BoolVarTestVarCreation ; 
function BoolVarTestVarCreation()
{

### The main goal : 
### Will represent a correct view of this example into pattern . 
### 
###   local StrMultipleFileSelectionAttr="--multiple"
###   if [ "${StrZenityFSMultipleFile}" == "False" ] ; then 
###    StrMultipleFileSelectionAttr="" ; 
###   fi 
### 
### Into CommandLine Echo like pattern and  being evaluated to create following statement:
### - Having a variable A Holding a content. 
### - Having a Prefixed-Var named B holding either False Or True like ${Prefixed_Var_named_B:=False}
### - On Having Reverse position inside ${Prefixed_Var_named_B:=False}, content of variable A, should
### Be erased of asking to get alternative.
### 
### Answer to pattern, 
### 
### BVTestVarName=StrMultipleFileSelectionAttr BVTestVarHold="--multiple" BVTestBoolVarName=StrZenityFSMultipleFile BoolVarTestVarCreation 
### 
### Nominal purposes: 
### This is intended to supply a Boolean test and Value Association, done in one line, 
### it allow to generate a range of variable being Transited from Prefixed-Var and value
### passed in a query, which is sometimes had no value and give extra code that might trigger error. 
### 
### For a Generated example between command-line BoolVarTestVarCreation and Pre-fixed value, see 
### 
### BoolVarTestVarCreation for substitution of StrFileTmp from function ZenityShellEval()
### Note reference : f1161962-0ad8-11e3-b166-001b3875b29c  
### 
### 
###  Warning : 
###  Note reference : 7236e956-f6cf-11e5-98a2-001e4c8856d6
###  - Recurrent call in BoolVarTestVarCreation
###  and avoid uses of  ValueToVariable . 
###  While BoolVarTestVarCreation is a low-level call indirectly call
###  by ValueToVariable it's hard to define first will end having 
###  good sub-body to acheive a strict identity and be able to 
###  parse all variable before BoolVarTestVarCreation 'will' have to 
###  end a possible __main_start_services if this one is implemented 
###  with normal body-topology  .  So it's not recommended to use 
###  ValueToVariable inside BoolVarTestVarCreation has long there is 
###  a better mechanisms correcting this problems in bash of recurrent  
###  function call recurently a lower level function will simply loop
###  and not finishing the work . 
### 
### 
### 

### Factory Section 
 unset StrVarBoolTest StrDefaultBoolTest StrNotAsserted StrScopeType StrIfTestType StrIfStringOp IsPreambule StrDefaultEndTest IsTypePreamb StrVTRPrbTpl StrVTRPrbVar StrVTRPrbVTReg StrVTRPrbVTFnct IsTypeAssert StrVTRAsrtTpl StrVTRAsrtVar StrVTRAsrtVTReg StrVTRAsrtVTFnct StrKeyTestType IntDefautlType IsDisplayIfStatement StrIfPattern ArrayIfPattern ArrayAssertion StrTestTemplate IsPreambulePolNtRespt ;
 local __call_locality=( BVTest BoolVarTestVarCreation ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
### End of Factory Section.
 local ArrayTypeTest=( False True ) ;
 local ArrayPreambule=( ) ; 

 local StrVarNamed=${BVTestVarName:=StrAttrHold} ; 
 local StrVarNamedHold=${BVTestVarHold:=CONTENT} ; 
 ### Following variable Stand for Is-Preambule-Polish-Notation-Respect is respected ( 
 ### like allow cleaning content and validate output for easy-Integer respect instead 
 ### of having case like IntValue="0" so far is valuable, but fail in case and if test -> 
 ### if [ "0" -eq 0 ] ; then ; fi , will notice some problems. )
 local IsPreambulePolNtRespt=${BVTestIsPrmblPlNt:=True} ; 
 local StrVarBoolTest=${BVTestBoolVarName:=IsVarShould} ; 
 local StrDefaultBoolTest=${BVTestBoolCase:=False} ;
 local StrNotAsserted=${BVTestBoolAssertion:=\"\"} ;
 local StrScopeType=${BVTestScopeTest:=local} ;
 local StrIfTestType=${BVTestIfType:=String} ; 
 local StrIfStringOp=${BVTestIfOp:='=='} ;
 local IsPreambule=${BVTestIsPreambule:=True} ; 
 local StrDefaultEndTest=${BVTestConclude:=";"} ;
 ### Section ValueToVariable in Preambule 
 local IsTypePreamb=${BVTestIsValueToVar:=False} ;
 local StrVTRPrbTpl=${BVTestVTVTPL:=eval __TES__  __REGISTRY_PRE__ VTVValueEntry=__VAR_ENTRY_PRE__ ValueToVariable __TEE__ __FNCT_PRE__} ;
 local StrVTRPrbVar=${BVTestVTVVar:=IsVerbose,IsDebug} ;
 local StrVTRPrbVTReg=${BVTestVTReg:=VTVIsArrayStyleInsert=True VTVIsValueReAssign=True VTVIsValueToConvert=False} ;
 local StrVTRPrbVTFnct=${BVTestVTFnct:=__FNCT__} ;
 ### Section ValueToVariable in Assertion .
 local IsTypeAssert=${BVTestIsValueToVarAssert:=False};
 local StrVTRAsrtTpl=${BVTestVTVTPLA:=eval __TES__  __REGISTRY_ASRT__ VTVValueEntry=__VAR_ENTRY_ASRT__ ValueToVariable __TEE__ __FNCT_ASRT__} ;
 local StrVTRAsrtVar=${BVTestVTVVarA:=IsVerbose,IsDebug};
 local StrVTRAsrtVTReg=${BVTestVTRegA:=VTVIsArrayStyleInsert=True VTVIsValueReAssign=True VTVIsValueToConvert=False}
 local StrVTRAsrtVTFnct=${BVTestVTFnctA:=__FNCT__}
 local StrKeyTestType=${BVTestType:='if:fi,if:elif,elif:elif,elif:else,if:else,else:fi'} ;
 local IntDefautlType=${BVTestIdType:=0} ; 
 local IsDisplayIfStatement=${BVTestDisplayIf:=False} ; 
 
 local StrTestTemplate="""__PREAMBULE__
 __IF_PATTERN__  
  __ASSERTION__ 
  __END_TEST__ __END_MARK__""" ;

 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local VerboseState=${VerbState:=False} ;
		local ArrayArg=( $* ) ; 
		if [ "${VerboseState:=False}" == "True" ] ; then 
			echo -ne "VERBOSE:[ ${StrMsg} ]\n" > ${StrDevOut} ;
		fi
	}
 
 
 local ArrayTestType=( ${StrKeyTestType//,/ } ) ; 
 local ArrayTestSection=( ${ArrayTestType[${IntDefautlType}]//:/ } ) ; 
 
 ### Note : ArrayTestSection should test if value end with 'fi' and will require an extra semi-colon
 ### before adding element 'fi' --> 'else ... (;) fi ' 
 if [ ${ArrayTestSection[1]} == "fi" ] ; then 
  ArrayTestSection[1]="; ${ArrayTestSection[1]}" ; 
 fi 
 local ArrayTestType=( String File Test Int Shell ) ;
 local StrIfPattern ; 
 local ArrayIfPattern=(  ) ;
 ArrayIfPattern[0]="__START_TEST__ [ \"${StrVarBoolTest}\" __OP__ \"${StrDefaultBoolTest}\" ] " ;
 ArrayIfPattern[1]="__START_TEST__ [ \"__OP__ \"${StrDefaultBoolTest}\" ] " ;
 ArrayIfPattern[2]="__START_TEST__ \$( test \"__OP__ \"${StrDefaultBoolTest}\" ) " ;
 ArrayIfPattern[3]="__START_TEST__ [ ${StrVarBoolTest} __OP__ ${StrDefaultBoolTest} ] " ;
 ArrayIfPattern[4]="eval ${StrVarNamed} ; res=\$? ; __START_TEST__  [ \${res:=1} __OP__ ${StrDefaultBoolTest} ] " ;
 

 ###
 ### ArrayIfPattern, Loop and test to select proper 
 ### StrIfTestType and it's Operator StrIfStringOp.
 ###
 for (( intx=0 ; intx <= ${#ArrayTestType[@]}-1 ; intx++ )) ; do 
  if [ "${StrIfTestType}" == "${ArrayTestType[${intx}]}" ] ; then 
   StrIfPattern=${ArrayIfPattern[${intx}]//__OP__/${StrIfStringOp}} ; 
  fi 
 done 
 ArrayPreambule[0]="__SCOPE__ __VAR_NAME__=__VALUE__" ;
 local ArrayAssertion=( ) ; 
 local ArrayAssertion[0]="__ASRT_VAR__NAME__=__ASRT_VAR_VALUE__" ;
 ### Old Preambule : ${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\"" 
 ### Old Assertion : \${StrVarNamed}=\${StrNotAsserted} ; 
  
  if [ "${IsTypeAssert:=False}" == "True" ] ; then 
   StrTestTemplate=${StrTestTemplate//__ASSERTION__/${StrVTRAsrtTpl}} ;
   StrTestTemplate=${StrTestTemplate//__REGISTRY_ASRT__/${StrVTRAsrtVTReg}} ;
   StrTestTemplate=${StrTestTemplate//__VAR_ENTRY_ASRT__/${StrVTRAsrtVar}} ;
   StrTestTemplate=${StrTestTemplate//__TES__/\$(} ;
   StrTestTemplate=${StrTestTemplate//__TEE__/)} ;
     ### 2016-08-29, require a ';' at the end of a command or an error will occur after the preambule or near the end after assertion
   StrTestTemplate=${StrTestTemplate//__FNCT_ASRT__/${StrVTRAsrtVTFnct} } ;
  else
   StrTestTemplate=${StrTestTemplate//__ASSERTION__/${ArrayAssertion[0]}} ;
   StrTestTemplate=${StrTestTemplate//__ASRT_VAR__NAME__/${StrVarNamed}} ;
   StrTestTemplate=${StrTestTemplate//__ASRT_VAR_VALUE__/${StrNotAsserted}} ;
  fi 
  
  if [ "${IsPreambule:=True}" == "True" ] ; then 
    if [ "${IsTypePreamb:=False}" == "True" ] ; then 
     StrTestTemplate=${StrTestTemplate//__PREAMBULE__/${StrVTRPrbTpl}} ; 
     StrTestTemplate=${StrTestTemplate//__VAR_ENTRY_PRE__/${StrVTRPrbVar}} ; 
     StrTestTemplate=${StrTestTemplate//__REGISTRY_PRE__/${StrVTRPrbVTReg}} ; 
     StrTestTemplate=${StrTestTemplate//__TES__/\$(} ; 
     StrTestTemplate=${StrTestTemplate//__TEE__/)} ; 
     ### 2016-08-29, require a ';' at the end of a command or an error will occur after the preambule or near the end after assertion
     StrTestTemplate=${StrTestTemplate//__FNCT_PRE__/${StrVTRPrbVTFnct} ; } ; 
    else
     ### Missing, Initially we have defined here some Polish notation and we 
     ### don't have any test related to Integer, String and so forth... 
     if [ ${IsPreambulePolNtRespt:=True} == "True" ] ; then 
      ### To Qualify all test we do Made a First variable StrTypeVar ; Will hold the conclusion into
      ### following answer form ( Bool / Int / String ) ; 
      ### between String Test or Not 
      ### Test is made in this order : -> Do we discover something else than number inside the StrVarNamedHold
      ### First the copy made from StrVarNamedHold remove every number and test the value.
      ### Secondly ( might not be immediately ), Detecting 0L , or simply called Long not rationnal
      ### inside script but might be interresting . 
      ### Succedding to removing all number, counting the remaining char. 
      local StrVarHoldTest=${StrVarNamedHold} ; 
      local StrTypeVar=None ; 
      
      ### Because Boolean are Special case, are likely to be String with only 
      ### 2 type of answer, True/False, It's like old story of Coolege Programmation
      ### Introduction 101 at Rosemont Cegep in 1997-1999 using Pascal and pseudo-code.
      ### It does the same for Boolean, having to type it plain text True/False and 
      ### the lexer/parser inide should understand what is Boolean to what is not... 
      ### In This context, we have craft a singular one with filtering .
      
      ### Special Case, detection of Boolean are made with sed reduction of specific
      ### Sub-Group. Especially found nothing inside Regular Expression of O'Reilly 
      ### Pocket reference, but still only a Pocket Reference. 
      
      ### Bash Big Line, It's especially important to declare it correctly and allow 
      ### type definition rather to not filtering the input at start and have many
      ### messages having problems to handle variable. Especially in Bash is actor
      ### or builtin/function/shell script to generate error on type not correctly 
      ### handled. If the variable is designe as Integer and hold String-like 
      ### information, if you do notthing with that variable or called-it 
      ### future-design, it won't tell you problems until the day you start to use it.
      
      ### Before reducing everything to nil, do a Boolean Detection:
      StrVarHoldTest=$( echo ${StrVarHoldTest} | sed 's/[{'True','False'}]//g'  ) ; 
      local IntPolishBool=${#StrVarHoldTest};
      local IntPolisgString ;
      local IntPolishInteger ;
      if [ ${IntPolishBool:=0} -eq 0 ] ; then 
       ### It's a Boolean form notation 
       StrTypeVar="Bool" ;  
      fi 
      
      if [ ${StrTypeVar:=None} == "None" ] ; then 
       StrVarHoldTest=$( echo ${StrVarHoldTest} | sed 's/[0-9]//g' ) ;
       IntPolishInteger=${#StrVarHoldTest} ; 
      fi 
      
      if [ ${StrTypeVar:=None} == "None" ] ; then 
       StrVarHoldTest=$( echo ${StrVarHoldTest} |\
         sed 's/[A-Za-z\ ]//g'  |\
         tr '[:graph:]' ' '     |\
         tr '[:cntrl:]' ' '     |\
         tr '[:punct:]' ' '     |\
         tr '[:space:]' ' '     |\
         sed 's/ //g' ) ;
       IntPolisgString=${#StrVarHoldTest} ;
      fi 
      
      if [ ${StrTypeVar:=None} == "None" ] ; then 
       if [ ${IntPolishInteger:=0} -gt 0 ] ; then 
         ### it's not number 
         if [ ${IntPolisgString:=0} -eq 0 ] ; then 
          ### It own couple of extra char inside and should be see as String . 
          StrTypeVar="String" ; 
         fi 
       fi
      fi 
      if [ ${StrTypeVar:=None} == "None" ] ; then 
       if [ ${IntPolishInteger:=0} -eq 0 ] ; then 
        ### It's formely all number 
        StrTypeVar="Int" ; 
       fi
      fi
      
      if [ ${StrTypeVar:=None} == "Int" ] ; then 
       StrTestTemplate=${StrTestTemplate//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=${StrVarNamedHold} ;} ; 
      elif [ ${StrTypeVar:=None} == "String" ] ; then 
       StrTestTemplate=${StrTestTemplate//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\" ;} ; 
      elif [ ${StrTypeVar:=None} == "Bool" ] ; then 
       StrTestTemplate=${StrTestTemplate//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\" ;} ; 
      else
       ### Kept as String .
       StrTestTemplate=${StrTestTemplate//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\" ;} ;  
      fi  
     else 
      StrTestTemplate=${StrTestTemplate//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\" ;} ; 
     fi 
     
     
    fi 
  else
    ### This section exist only because BVTestIsPreambule=False allow to completely remove the 
    ### preambule. Having work around like using IntDefautlType=[1,2,3,4] can remove the 
    ### preambule and we are out of problem... Not so clean and some efforts are trying to 
    ### resolve 
    StrTestTemplate=${StrTestTemplate//__PREAMBULE__/} ; 
  fi
  if [ ${IntDefautlType} -eq 0 ] ; then  
   StrTestTemplate=${StrTestTemplate//__IF_PATTERN__/${StrIfPattern} ; then} ; 
  elif [ ${IntDefautlType} -eq 1 ] ; then  
   StrTestTemplate=${StrTestTemplate//__IF_PATTERN__/${StrIfPattern} ; then} ; 
  elif [ ${IntDefautlType} -eq 2 ] ; then  
   StrTestTemplate=${StrTestTemplate//__IF_PATTERN__/${StrIfPattern} ; then} ; 
  elif [ ${IntDefautlType} -eq 3 ] ; then  
   StrTestTemplate=${StrTestTemplate//__IF_PATTERN__/${StrIfPattern} ; then} ; 
  elif [ ${IntDefautlType} -eq 4 ] ; then  
   StrTestTemplate=${StrTestTemplate//__IF_PATTERN__/${StrIfPattern} ; then} ; 
  elif [ ${IntDefautlType} -eq 5 ] ; then  
   StrTestTemplate=${StrTestTemplate//__IF_PATTERN__/} ; 
  fi
  
  StrTestTemplate=${StrTestTemplate//__START_TEST__/${ArrayTestSection[0]}} ; 
  StrTestTemplate=${StrTestTemplate//__END_TEST__/${ArrayTestSection[1]}} ; 
  ### Uses of Array BVTestType 
  ### index of operation : 
  ### 0 -> if:fi,
  ### 1 -> if:elif,
  ### 2 -> elif:elif,
  ### 3 -> elif:else,
  ### 4 -> if:else,
  ### 5 -> else:fi
  ### Exception in case IntDefautlType=4 for Imbrication of if, we need to 
  ### suppress the StrDefaultEndTest or provide a return caracter to allow 
  ### to fill second declaration of BoolVarTestVarCreation with state 
  ### IntDefautlType=4 , Supply a first level if/else 
  if [ ${IntDefautlType} -eq 1 ] ; then 
   StrTestTemplate=${StrTestTemplate//__END_MARK__/} ; 
  elif [ ${IntDefautlType} -eq 2 ] ; then 
   StrTestTemplate=${StrTestTemplate//__END_MARK__/} ; 
  elif [ ${IntDefautlType} -eq 3 ] ; then 
   StrTestTemplate=${StrTestTemplate//__END_MARK__/} ; 
  elif [ ${IntDefautlType} -eq 4 ] ; then 
   StrTestTemplate=${StrTestTemplate//__END_MARK__/} ; 
  else
   StrTestTemplate=${StrTestTemplate//__END_MARK__/${StrDefaultEndTest}} ;  
  fi 
  
  
  
  ### 
  ### Section We transform StrTestTemplate into 
  ### IF 
  ### ...
  ### FI 
  ### IF  
  ### ...
  ### ELIF 
  ### ELIF 
  ### ...
  ### ELSE, 
  ### ... --> See BVTestType for all choice made by default. It's a 2 choice 
  ### method and don't forget, it cover only One test at the time, 
  ### Either to not execute it after parsing you can call BoolVarTestVarCreation
  ### many time and glueing result_BVT1 + result_BVT2 + result_BVT3
  ### to form a complete 
  ### 
  ### if   +
  ### ...  +--> Made by BVTestType=1 BoolVarTestVarCreation Stored in Var1
  ### elif +
  ### ...
  ### elif +
  ### ...  +--> Made by BVTestType=2 BoolVarTestVarCreation Stored in Var2
  ### elif +
  ### ...
  ### else +
  ### ...  +--> Made by BVTestType=5 BoolVarTestVarCreation Stored in Var3
  ### fi   +
  ### And A new variable NewVarTEst=${Var1}${Var2}${Var3} will hold the entire 
  ### test ...
  ### Notice there is odd sequence where the last line of your test SHOULD
  ### END with FI, like BVTestType=4 BoolVarTestVarCreation
  ### with if-else marker. This Boolean test does include a TAG named __END_MARK__
  ### with help you changing it for a 'fi' or either a semi-colon ';' 
  ### See BVTestConclude where is default is semi-colon ';', but may old
  ### value like BVTestConclude='fi ;' , BVTestConclude='fi' 
  
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
 
  local StrMsg="\nFunction ${__call_locality[1]}, Display Result:\n ${StrTestTemplate}\n" ; 
  VerbState=${IsDisplayIfStatement} VerbDev=/dev/stderr VerbMsg=${StrMsg} Verbosis
  echo -ne "${StrTestTemplate}" ; 
 fi
 
}

unset _BoolVarTestVarCreation ; 
function _BoolVarTestVarCreation()
{

### The main goal : 
### Will represent a correct view of this example into pattern . 
### 
###   local StrMultipleFileSelectionAttr="--multiple"
###   if [ "${StrZenityFSMultipleFile}" == "False" ] ; then 
###    StrMultipleFileSelectionAttr="" ; 
###   fi 
### 
### Into CommandLine Echo like pattern and  being evaluated to create following statement:
### - Having a variable A Holding a content. 
### - Having a Prefixed-Var named B holding either False Or True like ${Prefixed_Var_named_B:=False}
### - On Having Reverse position inside ${Prefixed_Var_named_B:=False}, content of variable A, should
### Be erased of asking to get alternative.
### 
### Answer to pattern, 
### 
### BVTestVarName=StrMultipleFileSelectionAttr BVTestVarHold="--multiple" BVTestBoolVarName=StrZenityFSMultipleFile BoolVarTestVarCreation 
### 
### Nominal purposes: 
### This is intended to supply a Boolean test and Value Association, done in one line, 
### it allow to generate a range of variable being Transited from Prefixed-Var and value
### passed in a query, which is sometimes had no value and give extra code that might trigger error. 
### 
### For a Generated example between command-line BoolVarTestVarCreation and Pre-fixed value, see 
### 
### BoolVarTestVarCreation for substitution of StrFileTmp from function ZenityShellEval()
### Note reference : f1161962-0ad8-11e3-b166-001b3875b29c  
### 
### 
###  Warning : 
###  Note reference : 7236e956-f6cf-11e5-98a2-001e4c8856d6
###  - Recurrent call in BoolVarTestVarCreation
###  and avoid uses of  ValueToVariable . 
###  While BoolVarTestVarCreation is a low-level call indirectly call
###  by ValueToVariable it's hard to define first will end having 
###  good sub-body to acheive a strict identity and be able to 
###  parse all variable before BoolVarTestVarCreation 'will' have to 
###  end a possible __main_start_services if this one is implemented 
###  with normal body-topology  .  So it's not recommended to use 
###  ValueToVariable inside BoolVarTestVarCreation has long there is 
###  a better mechanisms correcting this problems in bash of recurrent  
###  function call recurently a lower level function will simply loop
###  and not finishing the work . 
### 
### 
### 

### Factory Section 
 unset StrVarBoolTest StrDefaultBoolTest StrNotAsserted StrScopeType StrIfTestType StrIfStringOp IsPreambule StrDefaultEndTest IsTypePreamb StrVTRPrbTpl StrVTRPrbVar StrVTRPrbVTReg StrVTRPrbVTFnct IsTypeAssert StrVTRAsrtTpl StrVTRAsrtVar StrVTRAsrtVTReg StrVTRAsrtVTFnct StrKeyTestType IntDefautlType IsDisplayIfStatement StrIfPattern ArrayIfPattern ArrayAssertion StrTestTemplate IsPreambulePolNtRespt ;
 local __call_locality=( BVTest _BoolVarTestVarCreation ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
### End of Factory Section.
 local ArrayTypeTest=( False True ) ;
 local ArrayPreambule=( ) ; 

 local StrVarNamed=${BVTestVarName:=StrAttrHold} ; 
 local StrVarNamedHold=${BVTestVarHold:=CONTENT} ; 
 ### Following variable Stand for Is-Preambule-Polish-Notation-Respect is respected ( 
 ### like allow cleaning content and validate output for easy-Integer respect instead 
 ### of having case like IntValue="0" so far is valuable, but fail in case and if test -> 
 ### if [ "0" -eq 0 ] ; then ; fi , will notice some problems. )
 local IsPreambulePolNtRespt=${BVTestIsPrmblPlNt:=True} ; 
 local StrVarBoolTest=${BVTestBoolVarName:=IsVarShould} ; 
 local StrDefaultBoolTest=${BVTestBoolCase:=False} ;
 local StrNotAsserted=${BVTestBoolAssertion:=\"\"} ;
 local StrScopeType=${BVTestScopeTest:=local} ;
 local StrIfTestType=${BVTestIfType:=String} ; 
 local StrIfStringOp=${BVTestIfOp:='=='} ;
 local IsPreambule=${BVTestIsPreambule:=True} ; 
 local StrDefaultEndTest=${BVTestConclude:=";"} ;
 ### Section ValueToVariable in Preambule 
 local IsTypePreamb=${BVTestIsValueToVar:=False} ;
 local StrVTRPrbTpl=${BVTestVTVTPL:=eval __TES__  __REGISTRY_PRE__ VTVValueEntry=__VAR_ENTRY_PRE__ ValueToVariable __TEE__ __FNCT_PRE__} ;
 local StrVTRPrbVar=${BVTestVTVVar:=IsVerbose,IsDebug} ;
 local StrVTRPrbVTReg=${BVTestVTReg:=VTVIsArrayStyleInsert=True VTVIsValueReAssign=True VTVIsValueToConvert=False} ;
 local StrVTRPrbVTFnct=${BVTestVTFnct:=__FNCT__} ;
 ### Section ValueToVariable in Assertion .
 local IsTypeAssert=${BVTestIsValueToVarAssert:=False};
 local StrVTRAsrtTpl=${BVTestVTVTPLA:=eval __TES__  __REGISTRY_ASRT__ VTVValueEntry=__VAR_ENTRY_ASRT__ ValueToVariable __TEE__ __FNCT_ASRT__} ;
 local StrVTRAsrtVar=${BVTestVTVVarA:=IsVerbose,IsDebug};
 local StrVTRAsrtVTReg=${BVTestVTRegA:=VTVIsArrayStyleInsert=True VTVIsValueReAssign=True VTVIsValueToConvert=False}
 local StrVTRAsrtVTFnct=${BVTestVTFnctA:=__FNCT__}
 local StrKeyTestType=${BVTestType:='if:fi,if:elif,elif:elif,elif:else,if:else,else:fi'} ;
 local IntDefautlType=${BVTestIdType:=0} ; 
 local IsDisplayIfStatement=${BVTestDisplayIf:=False} ; 
 local StrVarListTransfert="StrTestTemplate,IsDisplayIfStatement,IntDefautlType,StrKeyTestType,StrVTRAsrtVTFnct,StrVTRAsrtVTReg,StrVTRAsrtVar,StrVTRAsrtTpl,IsTypeAssert,StrVTRPrbVTFnct,StrVTRPrbVTReg,StrVTRPrbVar,StrVTRPrbTpl,IsTypePreamb,StrDefaultEndTest,IsPreambule,StrIfStringOp,StrIfTestType,StrScopeType,StrNotAsserted,StrDefaultBoolTest,StrVarBoolTest,IsPreambulePolNtRespt,StrVarNamedHold,StrVarNamed"
 
 local StrTestTemplate=""" __PREAMBULE__ \
__IF_PATTERN__  \
__ASSERTION__ \
__END_TEST__ __END_MARK__ """ ;

 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsDisplayFormatted=${VerbFormated:=True} ;
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
     echo -ne "${StrMsg}\n" > ${StrDevOut} ;
   fi 
		fi
	}
 
 

 ArrayIfPattern[0]="""__START_TEST__ [ \"__VAR_BOOL_TEST__\" __OP__ \"__DEFAULT_BOOL_TEST__\" ] """ ;
 ArrayIfPattern[1]="""__START_TEST__ [ \"__OP__ \"__DEFAULT_BOOL_TEST__\" ] """ ;
 ArrayIfPattern[2]="""__START_TEST__ \$( test \"__OP__ \"__DEFAULT_BOOL_TEST__\" ) """ ;
 ArrayIfPattern[3]="""__START_TEST__ [ __VAR_BOOL_TEST__ __OP__ __DEFAULT_BOOL_TEST__ ] """ ;
 ArrayIfPattern[4]="""eval __VAR__NAMED__ ; res=\$? ; __START_TEST__  [ \${res:=1} __OP__ __DEFAULT_BOOL_TEST__ ] """ ;
 
 function __main_StartServices
 {
  local __call_locality=( Main __main_StartServices ) ;
  local ArrayArg=( $* ) ;
  local Arg0=${ArrayArg[0]};  
  ### 
  ### Getter Section, 
  ### Retrieving information from Main Function BoolVarTestVarCreation
  local ArrayTestType=( ${StrKeyTestType//,/ } ) ; 
  local ArrayTestSection=( ${ArrayTestType[${IntDefautlType}]//:/ } ) ; 
  
  ### Note : ArrayTestSection should test if value end with 'fi' and will require an extra semi-colon
  ### before adding element 'fi' --> 'else ... (;) fi ' 
  if [ "${ArrayTestSection[1]}" == "fi" ] ; then 
   ArrayTestSection[1]="; ${ArrayTestSection[1]}" ; 
  fi 
  local ArrayTestType=( String File Test Int Shell ) ;
  local ArrayIfPattern=(  ) ;
  local ATestType=( $( _BoolVarTestVarCreation --get ArrayTestType[@] ) ) ; 

  ### Other variable required ;
  local StrCurrentIfPatrn ;  
  local StrLcTTpl=${StrTestTemplate} ; 
  local StrIfPattern ; 
  
  local ArrayPreambule=( ) ; 
  ArrayPreambule[0]="__SCOPE__ __VAR_NAME__=__VALUE__" ;
  
  local ArrayAssertion=( ) ; 
  ArrayAssertion[0]="__ASRT_VAR__NAME__=__ASRT_VAR_VALUE__" ;
  
  ###
  ### ArrayIfPattern, Loop and test to select proper 
  ### StrIfTestType and it's Operator StrIfStringOp.
  ###
  for (( intx=0 ; intx <= ${#ATestType[@]}-1 ; intx++ )) ; do 
   if [ "${StrIfTestType}" == "${ATestType[${intx}]}" ] ; then 
    StrCurrentIfPatrn=$( _BoolVarTestVarCreation --get ArrayIfPattern[${intx}] )
    
    StrIfPattern=${StrCurrentIfPatrn//__OP__/${StrIfStringOp}} ; 
   fi 
  done 
  StrIfPattern=${StrIfPattern//__VAR_BOOL_TEST__/$( _BoolVarTestVarCreation --get StrVarBoolTest )} ;
  StrIfPattern=${StrIfPattern//__DEFAULT_BOOL_TEST__/$( _BoolVarTestVarCreation --get StrDefaultBoolTest )} ;
  StrIfPattern=${StrIfPattern//__VAR__NAMED__/$( _BoolVarTestVarCreation --get StrVarNamed )} ;


  ### Old Preambule : ${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\"" 
  ### Old Assertion : \${StrVarNamed}=\${StrNotAsserted} ; 
  
  if [ "${IsTypeAssert:=False}" == "True" ] ; then 
   StrLcTTpl=${StrLcTTpl//__ASSERTION__/${StrVTRAsrtTpl}} ;
   StrLcTTpl=${StrLcTTpl//__REGISTRY_ASRT__/${StrVTRAsrtVTReg}} ;
   StrLcTTpl=${StrLcTTpl//__VAR_ENTRY_ASRT__/${StrVTRAsrtVar}} ;
   StrLcTTpl=${StrLcTTpl//__TES__/\$(} ;
   StrLcTTpl=${StrLcTTpl//__TEE__/)} ;
     ### 2016-08-29, require a ';' at the end of a command or an error will occur 
     ### after the preambule or near the end after assertion
   StrLcTTpl=${StrLcTTpl//__FNCT_ASRT__/${StrVTRAsrtVTFnct} } ;
  else
   StrLcTTpl=${StrLcTTpl//__ASSERTION__/${ArrayAssertion[0]}} ;
   StrLcTTpl=${StrLcTTpl//__ASRT_VAR__NAME__/${StrVarNamed}} ;
   StrLcTTpl=${StrLcTTpl//__ASRT_VAR_VALUE__/${StrNotAsserted}} ;
  fi 
  
  if [ "${IsPreambule:=True}" == "False" ] ; then 
   ### This section exist only because BVTestIsPreambule=False allow to completely remove the 
   ### preambule. Having work around like using IntDefautlType=[1,2,3,4] can remove the 
   ### preambule and we are out of problem... Not so clean and some efforts are trying to 
   ### resolve 
   StrLcTTpl=${StrLcTTpl//__PREAMBULE__/} ; 
  else
    if [ "${IsTypePreamb:=False}" == "True" ] ; then 
     StrLcTTpl=${StrLcTTpl//__PREAMBULE__/${StrVTRPrbTpl}} ; 
     StrLcTTpl=${StrLcTTpl//__VAR_ENTRY_PRE__/${StrVTRPrbVar}} ; 
     StrLcTTpl=${StrLcTTpl//__REGISTRY_PRE__/${StrVTRPrbVTReg}} ; 
     StrLcTTpl=${StrLcTTpl//__TES__/\$(} ; 
     StrLcTTpl=${StrLcTTpl//__TEE__/)} ; 
     ### 2016-08-29, require a ';' at the end of a command or an error will occur 
     ### after the preambule or near the end after assertion
     StrLcTTpl=${StrLcTTpl//__FNCT_PRE__/${StrVTRPrbVTFnct} ; } ; 
    ### Second clause of if-"${IsTypePreamb:=False}" == "True"
    ### here stil in "${IsPreambule:=True}" == "True"
    else
     ### Missing, Initially we have defined here some Polish notation and we 
     ### don't have any test related to Integer, String and so forth... 
     if [ ${IsPreambulePolNtRespt:=True} == "False" ] ; then 
      StrLcTTpl=${StrLcTTpl//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\" ;} ; 
      ### end of second clause of if [ ${IsPreambulePolNtRespt:=True} == "True"
      ### here, still in "${IsTypePreamb:=False}" == "True"
      ### here, on side of ${IsPreambulePolNtRespt:=True} == "False"
     ### Reverted condition to  put least part of code first. 
     else 
      ### To Qualify all test we do Made a First variable StrTypeVar ; Will hold 
      ### the conclusion into
      ### following answer form ( Bool / Int / String ) ; 
      ### between String Test or Not 
      ### Test is made in this order : -> Do we discover something else than number 
      ### inside the StrVarNamedHold
      ### First the copy made from StrVarNamedHold remove every number and test the 
      ### value.
      ### Secondly ( might not be immediately ), Detecting 0L , or simply called 
      ### Long not rationnal
      ### inside script but might be interresting . 
      ### Succedding to removing all number, counting the remaining char. 
      local StrVarHoldTest=${StrVarNamedHold} ; 
      local StrTypeVar="None" ; 
      
      ### Because Boolean are Special case, are likely to be String with only 
      ### 2 type of answer, True/False, It's like old story of Coolege Programmation
      ### Introduction 101 at Rosemont Cegep in 1997-1999 using Pascal and pseudo-code.
      ### It does the same for Boolean, having to type it plain text True/False and 
      ### the lexer/parser inide should understand what is Boolean to what is not... 
      ### In This context, we have craft a singular one with filtering .
      
      ### Special Case, detection of Boolean are made with sed reduction of specific
      ### Sub-Group. Especially found nothing inside Regular Expression of O'Reilly 
      ### Pocket reference, but still only a Pocket Reference. 
      
      ### Bash Big Line, It's especially important to declare it correctly and allow 
      ### type definition rather to not filtering the input at start and have many
      ### messages having problems to handle variable. Especially in Bash is actor
      ### or builtin/function/shell script to generate error on type not correctly 
      ### handled. If the variable is designe as Integer and hold String-like 
      ### information, if you do notthing with that variable or called-it 
      ### future-design, it won't tell you problems until the day you start to use it.
      
      ### Before reducing everything to nil, do a Boolean Detection:
      ### Since migration to Mint 17.3 and bash : 2016-09-02
      ### version:( GNU bash, version 4.3.11(1)-release (x86_64-pc-linux-gnu) )
      ### the sed behavior is not working like mint 12/13 .
      ### the Sed forma syntax : 
      ###   echo "${StrVarHoldTest}" | sed 's/[{'True','False'}]//g'
      ###   for simply taking out False and True reducing the Variable to Nothing and hold 
      ###   less than 0 charlong it simply not working in this version .
      StrVarHoldTest=$( echo "${StrVarHoldTest}" | sed 's/True//g;s/False//g'  ) ; 
      local IntPolishBool=${#StrVarHoldTest};
      local IntPolisgString ;
      local IntPolishInteger ;
      if [ ${IntPolishBool:=0} -eq 0 ] ; then 
       ### It's a Boolean form notation 
       StrTypeVar="Bool" ;  
       ### end of if-${IntPolishBool:=0} -eq 0
       ### here, still in "${IsTypePreamb:=False}" == "True"
       ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
      fi 
      
      ### If previous test did not transform the result into Bool.
      if [ "${StrTypeVar:=None}" == "None" ] ; then 
       StrVarHoldTest=$( echo ${StrVarHoldTest} | sed 's/[0-9]//g' ) ;
       IntPolishInteger=${#StrVarHoldTest} ; 
       StrTypeVar="Int"
       ### end of if-"${StrTypeVar:=None}" == "None"
       ### here, still in "${IsTypePreamb:=False}" == "True"
       ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
      fi 
      
      ### If previous test did not transform the result into Int.
      if [ "${StrTypeVar:=None}" == "None" ] ; then 
       StrVarHoldTest=$( echo ${StrVarHoldTest} | sed 's/[A-Za-z\ ]//g'  | tr '[:graph:]' ' ' | tr '[:cntrl:]' ' ' | tr '[:punct:]' ' ' | tr '[:space:]' ' ' | sed 's/ //g' ) ;
       IntPolisgString=${#StrVarHoldTest} ;
       StrTypeVar="String"
       ### end of if-"${StrTypeVar:=None}" == "None" 
       ### here, still in "${IsTypePreamb:=False}" == "True"
       ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
      fi 
      
      ### If previous test did not transform the result into String.
      if [ "${StrTypeVar:=None}" == "None" ] ; then 
       if [ ${IntPolishInteger:=0} -gt 0 ] ; then 
         ### it's not number 
         if [ ${IntPolisgString:=0} -eq 0 ] ; then 
          ### It own couple of extra char inside and should be see as String . 
          StrTypeVar="String" ; 
         fi 
       fi
      ### end of if-"${StrTypeVar:=None}" == "None"
      ### here, still in "${IsTypePreamb:=False}" == "True"
      ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
      fi 
      
      if [ ${StrTypeVar:=None} == "None" ] ; then 
       if [ ${IntPolishInteger:=0} -eq 0 ] ; then 
        ### It's formely all number 
        StrTypeVar="Int" ; 
       fi
      ### end of if-${StrTypeVar:=None} == "None"
      ### here, still in "${IsTypePreamb:=False}" == "True"
      ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
      fi
      
      if [ ${StrTypeVar:=None} == "Int" ] ; then 
       StrLcTTpl=${StrLcTTpl//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=${StrVarNamedHold} ;} ; 
      elif [ ${StrTypeVar:=None} == "String" ] ; then 
       StrLcTTpl=${StrLcTTpl//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\" ;} ; 
      elif [ ${StrTypeVar:=None} == "Bool" ] ; then 
       StrLcTTpl=${StrLcTTpl//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\" ;} ; 
      ### end of N-clause of if ${StrTypeVar:=None} == "Int"
      ### here, still in "${IsTypePreamb:=False}" == "True"
      ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
      else
       ### Kept as String .
       StrLcTTpl=${StrLcTTpl//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\" ;} ;  
      ### end of if-${StrTypeVar:=None} == "Int"
      ### here, still in "${IsTypePreamb:=False}" == "True"
      ### here, still in ${IsPreambulePolNtRespt:=True} == "True"
      fi  
     # end of if-${IsPreambulePolNtRespt:=True} == "True"
     ### After this ${IsPreambulePolNtRespt:=True} == "False"
     fi 
     
    ### end of else, second clause  of if "${IsTypePreamb:=False}" == "True"
    ### after this "${IsTypePreamb:=False}" == "False" 
    fi
  ### end of if-"${IsPreambule:=True}" == "True" 
  fi
  if [ ${IntDefautlType} -eq 0 ] ; then  
   StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ; 
  elif [ ${IntDefautlType} -eq 1 ] ; then  
   StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ; 
  elif [ ${IntDefautlType} -eq 2 ] ; then  
   StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ; 
  elif [ ${IntDefautlType} -eq 3 ] ; then  
   StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ; 
  elif [ ${IntDefautlType} -eq 4 ] ; then  
   StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/${StrIfPattern} ; then} ; 
  elif [ ${IntDefautlType} -eq 5 ] ; then  
   StrLcTTpl=${StrLcTTpl//__IF_PATTERN__/} ; 
  fi
  
  StrLcTTpl=${StrLcTTpl//__START_TEST__/${ArrayTestSection[0]}} ; 
  StrLcTTpl=${StrLcTTpl//__END_TEST__/${ArrayTestSection[1]}} ; 
  ### Uses of Array BVTestType 
  ### index of operation : 
  ### 0 -> if:fi,
  ### 1 -> if:elif,
  ### 2 -> elif:elif,
  ### 3 -> elif:else,
  ### 4 -> if:else,
  ### 5 -> else:fi
  ### Exception in case IntDefautlType=4 for Imbrication of if, we need to 
  ### suppress the StrDefaultEndTest or provide a return caracter to allow 
  ### to fill second declaration of BoolVarTestVarCreation with state 
  ### IntDefautlType=4 , Supply a first level if/else 
  if [ ${IntDefautlType} -eq 1 ] ; then 
   StrLcTTpl=${StrLcTTpl//__END_MARK__/} ; 
  elif [ ${IntDefautlType} -eq 2 ] ; then 
   StrLcTTpl=${StrLcTTpl//__END_MARK__/} ; 
  elif [ ${IntDefautlType} -eq 3 ] ; then 
   StrLcTTpl=${StrLcTTpl//__END_MARK__/} ; 
  elif [ ${IntDefautlType} -eq 4 ] ; then 
   StrLcTTpl=${StrLcTTpl//__END_MARK__/} ; 
  else
   StrLcTTpl=${StrLcTTpl//__END_MARK__/${StrDefaultEndTest}} ;  
  fi 
  
  
  
  ### 
  ### Section We transform StrTestTemplate into 
  ### IF 
  ### ...
  ### FI 
  ### IF  
  ### ...
  ### ELIF 
  ### ELIF 
  ### ...
  ### ELSE, 
  ### ... --> See BVTestType for all choice made by default. It's a 2 choice 
  ### method and don't forget, it cover only One test at the time, 
  ### Either to not execute it after parsing you can call BoolVarTestVarCreation
  ### many time and glueing result_BVT1 + result_BVT2 + result_BVT3
  ### to form a complete 
  ### 
  ### if   +
  ### ...  +--> Made by BVTestType=1 BoolVarTestVarCreation Stored in Var1
  ### elif +
  ### ...
  ### elif +
  ### ...  +--> Made by BVTestType=2 BoolVarTestVarCreation Stored in Var2
  ### elif +
  ### ...
  ### else +
  ### ...  +--> Made by BVTestType=5 BoolVarTestVarCreation Stored in Var3
  ### fi   +
  ### And A new variable NewVarTEst=${Var1}${Var2}${Var3} will hold the entire 
  ### test ...
  ### Notice there is odd sequence where the last line of your test SHOULD
  ### END with FI, like BVTestType=4 BoolVarTestVarCreation
  ### with if-else marker. This Boolean test does include a TAG named __END_MARK__
  ### with help you changing it for a 'fi' or either a semi-colon ';' 
  ### See BVTestConclude where is default is semi-colon ';', but may old
  ### value like BVTestConclude='fi ;' , BVTestConclude='fi'   
 
  local StrMsg="\nFunction ${__call_locality[1]}, Display Result:\n ${StrLcTTpl}\n" ; 
  VerbState=${IsDisplayIfStatement} VerbDev=/dev/stderr VerbMsg=${StrMsg} Verbosis
  echo -ne "${StrLcTTpl}" ; 

  
 }

  
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVValueEntry=${StrVarListTransfert} \
          VTVIsValueReAssign=True              \ 
          VTVIsValueToConvert=False            \
          VTVIsArrayStyleInsert=True           \
          ValueToVariable ) __main_StartServices 
 fi
 
}

##################################                 ########################
################################## In Prototyping  ########################
################################## Start           ########################

unset PropertyLibName
function PropertyLibName()
{
	local __call_locality=( PLN PropertyLibName ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]};
	local StrAction=${PLNAction:=Add} ; 
	local StrLibName=${PLNLib:=NONE} ; 
	local StrOutArrayRef=${PLNArrayRef:=ArrayLibName} ;
	local ArrayActionType=( Add Delete Test Show ) ; 
	
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
	
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local ArrayArg=( $* ) ; 
		local Arg0=${ArrayArg[0]};
					
	}
	
	
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  StrAction=${StrAction}           \ 
  StrLibName=${StrLibName}         \
  StrOutArrayRef=${StrOutArrayRef} \
  __main_StartServices       ${Arg0} ; 
 fi
	
}
##################################                 ########################
################################## In Prototyping  ########################
################################## End             ########################


##################################                 ########################
################################## In Prototyping  ########################
################################## Start           ########################

 ###
 ### function BodyFunc()
 ### - Like BoolVarTestVarCreation, is defined to create on-demand if-pattern based on True Statement-Initial affectation and 
 ### residual False statement as Assertive condition being another mechanism or either a branch this function BodyFunc
 ### will manage the switch condition from Arg0, know to be the Operator for finite and unique action. Actual Action are 
 ### Getter, List, Helper and StartServices. __Future__ view predict uses of Setter where it's actually tweaked with external
 ### Subset of command within Bash whole-list of command. Developped has Micro-Architecture expansion require several
 ### analysis and may depend of another compromised information related to Data. Data used from Setter Will stay out of the
 ### code and actual Pre-fixed Variable are unique Start-up information where ultimately all information will migrate to None after
 ### uniformisation and expansion of Exception into proper design. 
 ###
 ###
 ### BodyFunc Goal :
 ### To create an [ if / elif / n-elif / fi ] command from finite action required inside need of fnct_debian_lib to be wise information
 ### discovery . Wise-Discovery is not part of the function-type itself, but any coumpound will have Serious Notation and 
 ### minimal helper.  Actually it will cover Finite action of Listing Prefixed-Var or Transport-Layer signature and Getter will 
 ### extract entry from this Transport Layer, know to be actual Prefixed-Var. 
 ###
 ### BodyFunc and Expanded Entry inside Finite action, StartServices uses : 
 ### - Since Getter, Helper and List are simple finite action, a function body from this lib are the core of evolving multi-party-actor
 ### involving many sub-derivate. Example: 
 ### Inside PackageRepositoryMgmt, uses of GetOtherDate is crutial to leave a valid-footprint inside and index based on File-system
 ### information deposition. 
 ###
 ### - The StartServices being a function with Tiny Prefixed-Var internally be a Inter-transport-Layer, it should result into calling a 
 ### possible function inside the Function Body or Any good compound from this Lib with awarness of calling correctly any Pre-fixed
 ### var. 
 ### Exception in Internal design from Function to Sub-Function Transport-Layer this mechanism is not regulated, but will not work if 
 ### variable are not transfered. 
 ###
 ### Facility in External transport connection of BodyFunc. 
 ### - The prefixed-variable BFStackVariableList will accept a language operator known to be '+' sign to allow any conversion 
 ### from good appelation of working function inside fnct_debian_lib by calling it and extracting variable. uses of GetOtherDate will
 ### be use inside the example. 
 ###
 ### BFStackVariableList=$( GetOtherDate --list | sed 's/\([a-zA-Z]*\)/\1+,/g;s/\ //g;s/+,+,/+/g'  ) BF*=... BodyFunc 
 ###
 ### Will shorten the transfert mechanism from Outgoing Transport-Connection into automated StackList adding sequence, and 
 ### will also offer Glueing technique for several descendant  uses of BoolVarTestVarCreation / Function_from_fnct_debian_lib, and 
 ### BodyFunc, with consideration had possibilty to be a fixed if-elif-fi topology . 
 ###



function BodyFunc()
{
 local __call_locality=( BF BodyFunc ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]};

 local StrHelpCmd="GetVarReference ${__call_locality[1]} ;  echo -ne \"${StrSwitchMessages}\" > /dev/stderr ; " ;
 local StrGetCmd=" eval \"\"\"local ArgGet=\${\${ArrayArg[1]}}\"\"\" ;  echo -ne \"\"\"\${ArgGet}\n\"\"\" ; "
 local StrListCmd="eval \$( __GetVarReferenceList ) ;" ;
 local StrStartServicesCmd="__main_StartServices" ;
 local StrDefineHelp=${BFHelpSwRules:=Help:--help:__HELP__:StrHelpCmd} ;
 local StrDefineGet=${BFGetSwRules:=Get:--get:__GET__:StrGetCmd} ;
 local StrDefineList=${BFListSwRules:=List:--list:__LIST__:StrListCmd} ;
 local StrDefineStartServices=${BFStartServicesSwRules:=StartServices:--startservices:__ApplicationMain__:StrStartServicesCmd} ;
 local StrVarConvertOp=${BFVarTransfertOp:=+} ; 
 local StrUUIDBoolRegistration=${BFBoolUUIDRegistered:=False} ; 
 local StrUUIDRegister=${BFUUID:=""} ; 
 local StrUUIDFormat=${BFUUIDFmt:=XXXXXXXX_XXXX_XXXX_XXXX_XXXXXXXXXXXX} ; 
 ### planning to register an UUID, will imply a transformation of the dashes to pass the lexer. 
 local StrUUIDRegistered="" ;

 if [ "${StrUUIDBoolRegistration}" == "True" ] ; then 
  if [ "${StrUUIDRegister}" == "" ] ; then 
   ### Situation of Blank registration and not yet registered Mechanism. 
    echo -ne "Asked for registration and missing UUID\n " ; 
    StrUUIDRegistered="${StrUUIDFormat}" ; 
  else
   ### This situation will imply implementation of post stored UUID into
   ### local data ( database / file, in memory, from collected info )
   ### and merely had only the UUID lexer to change dashes for underscore.  
   ### A test situation that will always return an error is to use
   ### BodyFunc with BFUUID=$( uuidgen -t ) or $( uuidgen -r ) which
   ### will not exist in 11 or 22 years before having an old candidate
   ### stored being revamp from data collection . 
   StrUUIDRegistered=${StrUUIDRegister//-/_} ; 
   ### ... 
  fi
 elif [ "${StrUUIDBoolRegistration}" == "False" ] ; then 
  if [ "${StrUUIDRegister}" != "" ] ; then 
   StrUUIDRegistered=${StrUUIDRegister//-/_} ; 
  fi
 fi
 ### removing dash and changing it for underscore. 
 

   
 ###
 ### The Prefixed-var BFVarTransfertOp:
 ### - To reduce rewriting, using the Operator '+' inside the Prefixed-Var BFStartServicesSwRules using rule like
 ### BFStackVariableList=Var1+ will transform Var1=Value by Var1=${Var1} inside Template __Stack_Variable__
 ### - Assuming BodyFunc is mangling the bottom of a function inside fnct_debian_lib into protocolar function creation
 ### with self verification ability like transfert mechanism and assignation possibility.
 ###
 local StrStackVar=${BFStackVariableList:=StrFileTmp=+,StrTitle="A title",IntSleep=+,Size=IntFontSize,IsEditField=+,IntWidth=+,IntHeight=+,IntDefaultModeExec=+} ;
 local ArrayServicesSwitches=( ${StrDefineHelp} ${StrDefineGet} ${StrDefineList}  ${StrDefineStartServices} )
 
 local StrPatternIf="""if [ \"${Arg0:=--startservices}\" == \"--help\"	] ; then 
 __HELP__${StrUUIDRegistered} 
elif [ \"${Arg0:=--startservices}\" == \"--get\" ] ; then 
 __GET__${StrUUIDRegistered} 
elif [ \"${Arg0:=--startservices}\" == \"--list\" ] ; then 
 __LIST__${StrUUIDRegistered} 
elif [ \"${Arg0:=--startservices}\" == \"--startservices\" ] ; then 
  __Stack_Variable__${StrUUIDRegistered} 
  __ApplicationMain__${StrUUIDRegistered} ; """ ;

echo -ne "###BodyFunc Pattern\n\n###Based on UUID Registered: (${StrUUIDRegistered})\n\n###--------------------------------------------------\n${StrPatternIf}\n###--------------------------------------------------\n"
}

##################################                 ########################
################################## In Prototyping  ########################
################################## End             ########################


 ### ValueToVariable :
 ###
 ###
 ###	Full-length example : 
 ### Including 1 example :
 ###
 ### $> 
 ### 
 ### - It Open Windows from Zenity with parameter for Text-info in editable
 ### mode.
 ### 
 ### It Open by default a uuid-like temporary file. There is no actual was
 ### to modify the name, but assuming the implementation of ZenityShellEval
 ### imply a limited acces to shell, you might recuper information from shell
 ### or futur adding to transfert a name or simple renaming the uuid-like
 ### file-name... This is to prevent auto-execution of a script from 
 ### canned-design by playing with without having all clearly create your 
 ### shell script and/or having fully pseudo-code explained and having 
 ### confirmation of your design work... 

unset ValueToVariable
function ValueToVariable( )
{
  ### To steve, Network admin from college rosemont... Was probably the Network survey
  ### from TELUS, already studied as police **Back-Office Administration**, was the guys behing the 
  ### 35th mondial of Work-fair including 2 student building stage for computer 
  ### contest... During he drive he was asking couple of question behind this (probably ValueToVariable)
  ### about something "gellyide" it's mind about double dot... 
  ### It should not be used to separate item in an array... There probably a transforming action
  ### allowed by Bash I answer, but it's really far in future and try under Slackware did never
  ### work... I think... this was in 1999. 
  
 local ArrayArg=( $* ) ;
 local __call_locality=( VTV ValueToVariable ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]}  
 
 local StrValueParser=${VTVValueEntry:=StrTest}
 local IsEntryInComaSep=${VTVIsArrayStyleInsert:=False} ; 
 local IsValueSimpleConvert=${VTVIsValueToConvert:=True} ;
 local IsValueToAssignSame=${VTVIsValueReAssign:=False} ;
 local IsValueIndTransform=${VTVIsTransformed:=False} ;
 local IsValueTransScript=${VTVIsTransHadScript:=False} ;
 local IsDisplayDebug=${VTVIsDebugDisplay:=False} ; 
 local StrDefaultTransScript=${VTVITransformScript:=None} ;
 local StrDefaultTransform=${VTVDefaultTransform:='s/([SIB][tnos][tro][a-zA-Z0-9]+)/\\$\{\1\}/g'} ;
 local StrAppsName=${VTVAppsName:=/bin/sed} ; 
 local StrAppsOpt=${VTVAppsOpt:=-r} ;
 local StrDefaultSedScript='s/([SIBA][tnosr][tror]*[a-zA-Z0-9]+)/\$\{\1\}/g' ;
 local StrDefaultAssignScript='s/([SIBA][tnosr][tror]*[a-zA-Z0-9]+)/\1=\$\{\1\}/g' ;

 local StrAppsAction=${VTVAppsAction:='None'} ; 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n" ;

 function __Action()
 {
  local __call_locality=(  Action __Action ) ;
  local Arg0=${ArrayArg[0]} ;
  local ArrayArg=( $* ) ;
  
  eval $( BVTestVarName=StrParsedVar \
  BVTestVarHold=\${StrValueParser} \
  BVTestBoolVarName="\${IsEntryInComaSep}" \
  BVTestBoolAssertion="\${StrValueParser//,/ }" \
  BVTestBoolCase=True \
  BoolVarTestVarCreation )
  local CmdLine="echo \"${StrParsedVar}\" | ${StrAppsName} ${StrAppsOpt} '${StrAppsAction}'" ; 
  if [ ${IsDisplayDebug} == "True" ] ; then
   echo -ne "CmdLine:\n[ ${CmdLine} ]\n" > /dev/stderr ; 
  fi 
  eval ${CmdLine} ; 
  
 }
 
 function __main_StartServices()
 {
  local ArrayVarTest=( IsValueSimpleConvert:StrDefaultSedScript IsValueToAssignSame:StrDefaultAssignScript IsValueTransScript:StrDefaultTransform ) ; 
  for item in ${ArrayVarTest[@]} ; do 
   local ArraySubItem=( ${item//:/ } ) ; 
   eval $( BVTestVarName=StrAppsAction \
   BVTestVarHold=\${StrAppsAction} \
   BVTestBoolVarName="\${${ArraySubItem[0]}}" \
   BVTestBoolAssertion="\${${ArraySubItem[1]}}" \
   BVTestBoolCase=True \
   BoolVarTestVarCreation ) 
  done  
  if [ ${IsDisplayDebug} == "True" ] ; then
   echo -ne "StrAppsName : ${StrAppsName}\nStrAppsOpt : ${StrAppsOpt}\nStrAppsAction : ${StrAppsAction}\n" > /dev/stderr ; 
  fi 
  StrAppsName=${StrAppsName}           \
  StrAppsOpt=${StrAppsOpt}             \
  StrAppsAction=${StrAppsAction}       \
  IsEntryInComaSep=${IsEntryInComaSep} \
  StrValueParser=${StrValueParser}     \
  __Action ; 
 }

 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  IsValueSimpleConvert=${IsValueSimpleConvert}     \
  IsValueToAssignSame=${IsValueToAssignSame}       \
  IsValueIndTransform=${IsValueIndTransform}       \
  IsValueTransScript=${IsValueTransScript}         \
  StrDefaultTransScript=${StrDefaultTransScript}   \
  StrDefaultTransform=${StrDefaultTransform}       \
  StrAppsName=${StrAppsName}                       \
  StrAppsOpt=${StrAppsOpt}                         \
  StrDefaultSedScript=${StrDefaultSedScript}       \
  StrDefaultAssignScript=${StrDefaultAssignScript} \
  StrAppsAction=${StrAppsAction}                     \
  StrValueParser=${StrValueParser}                 \
  IsDisplayDebug=${IsDisplayDebug}                 \
  IsEntryInComaSep=${IsEntryInComaSep}             \
  __main_StartServices                             ; 
 fi

}


### 
### function WrapPathIntegration()
###
### As Path Accessor in some internal development and first integrated to 
### md_cd command to transform its call :
### -> from ( md_cd __PATH__ ) in to 
### -> prefixed_var=__PATH__ md_cd 
###
### -- Allowing addition of --startservices to set a possible cumulation of informations
### -- Allowing addition of --get , --list . 
### -- Implicitly develop a filter for relativistic path added to the command and 
### or adding default mechanism to filter and inform of explicit action like 
### disallowing uses of relativistic path or inversly disallow uses of absolut
### path...  [ /ekivk/-ly /kt/ the /nt/ /ntnt/ /kn/ ]

###
### WrapPathIntegration
### Will also allow a third-party function being [kc]rafted depending of ListToArray
### this one will also possible to not use it by specifying your own function 
### thru WPIListTransformFunc and its method to call it internally. Using the
### function WPILstFuncCall .
### Helper own its own example of calling the internal function: 
###
### see: (pre-note, not the official pre-fixed var are definied here )
###
###
###  Function WrapPathIntegration
###  Default Variable Value:
###  Variable WPIPathList ,
###  	Default Value:''
###  Variable WPIListTransformFunc ,
###  	Default Value:ListToArray
###  Variable WPIListCSV ,
###  	Default Value:','
###  Variable WPILstFuncCall ,
###   
###      +---------------------------------------------------------------+
###  	   | Default Value:LTAComma='__CSV__' LTAEntry=__LIST__ __FNCT__   |
###      +---------------------------------------------------------------+
###
###
###  Variable WPIVerbose ,
###  	Default Value:False
###
### By Default, LTAComma and LTAEntry are provided by default and should not 
### interfer with your own function. Despite having few report based before the
### Fnct.D appear, it's idea to own at least the required TAG such __CSV__ and 
### __LIST__ is mandatory if you do collect information thru the command-line.
### Some other thinking may developt a in file data-collection or from Database
### query to extract your data, but initially provided a in-hand and in-command
### line provider is essential. Some may forget the uses of concept of 
### Comma separeted value like passing a full-length Base64 Line like precedent
### development of __fnctCreateLocalityFuncParam with uses of FParamBase64 
### to identifie the variable as Base64 codec and having extra accessor 
### decoding and encoding... All rejected for getter and setter problems near
### 2011/2012 after discovering a development problems in uses of variable
### parsing and be unable to acheive a better algorith. 
### 
### Note: ed0719fe-e959-11e5-98a2-001e4c8856d6
### Evolution of Variable with pre-designed called like ValueToVariable
### and presence of unified Getter .
### While some effort toward __fnctCreateLocalityFuncParam owning ability
### to interpret uses of __call_locality , predecessor from old_fnct.D does
### owning specificity of variable . Today having unified call of variable 
### thru uses of Array called __call_locality( Member-call Function-Name ), 
### the function __GetVarReferenceList and apparatus :
### 
### eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
### echo -ne """${ArgGet}\n""" ;
### 
### found in '--get' , filter from Arg0 does report information about 
### value inside the function and allow them having different action. 
### - Totally Unified the declaration of Inside-member like Verbosis 
### exemple in WPI, show:
### 
### IsVerbose=${WPIVerbose:=False} ;
### 
### - Presence of variable formating and will be inserted inside 
### __GetVarReferenceList action because it start with Is or Bool,
### or Array or Str or even Int. 
###
### While Uses of Base64 is not definied Here, a presence of 
### Variable like WPIBase64=True/False will let other function 
### query them with this form :
### __FUNCTION__ --get WPIBase64 
### and if this report thru, we guess we can start thinking using 
### this way to enable codec... This improve speed and reduce code .
### Known to be heavy old __fnctCreateLocalityFuncParam, and 
### __call_locality as Function not Array does pump +/- 200 line 
### of code per call... Having discovered a problem, in calling 
### sequence, or problems between Real Unix/Solarix uses of function
### accepting dot ( . )  inside function name it's not scheduled in 
### bash anymore and did not comment anything over this choice... 
### Its purely  acknowledgible  ... 
### 
### Because Sets of main new function __GetVarReferenceList, GetVarReference, 
### ValueToVariable , It start to unravel a steady way to respect some decent 
### coding adding <Plus> in way to affirm passthru of pre-fixed variable does 
### work and does not leak. 
### GetVarReference being glued inside ZenityEditFile Idiom integrity test leave
### a bad breath in home-made third-party eavesdroping ... Free development
### is also subject to be altered and being hack directly to github server 
### and prone development should depend of at least a codec to infirm in safe
### test being done because some arbitrary code are summed, and ZenityEditFile
### had property to affirm if a today code work or not after testing the 
### integrity. Which is bad in auto-development tool observed being able to 
### alter sub-set of code but not really helping in development. Based on 
### CRAN statistics tools, comming alone this auto-development widget is only
### to let beleive there is work toward a project, while real project path look
### like heratic. Time is something we spend on and it's not counted when it's
### afformentionned finited goal. 
### 
### Resume in, some part are fixed for good, some other like ValueToVariable
### are not finished but give good result and will continue to help the loosed 
### development left as example on what to not follow, help definition of standing
### component inside a function rather to implement lost variable and nestled 
### function . 
### 
### 
### 





### Dedicated for md_cd
### While ValueToVariable is under verification, an alternative is deployed to 
### allow function MdCd  from this Fnct.D project to work with Path Listed 
### from normal unix like command calling and be decoyed and parsed into a 
### prefixed-variable. Some effort toward ValueToVariable was defined but not 
### yet ported or tested. Somes effort in the past are mildly report some exception
### between different version of bash and all test are not concluent at this step.
### 
### But for sure, MdCd should join back fnct_debian_lib by integrating it's lock 
### mechanism that prevent many acces at the time. A Wonderfull effort to allow 
### contigous interaction like Unicity lock or permanent survey. Theses type of 
### mechanism avoid accessing to a file index storing precious data and rewrite
### them to prevent visible trace of temporary path being made, being used and 
### wipe before a Main or higher process open the file and did not report presence 
### of that action. A big problem in HAL, access in time is Heavy and action in 
### local are slowed while important process are using it to detect presence of 
### alteration. Just install usb-image-creator of gtk-usb-imagewriter are slow
### updating re-formated disk . 
### 


function WrapPathIntegration()
{
	local __call_locality=( WPI WrapPathIntegration ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} 
 local StrEntryListPath=${WPIPathList:=''} ;
 local StrListFnct=${WPIListTransformFunc:=ListToArray}
 local StrCommaValue=${WPIListCSV:=','} ;
 local IsPathIncludeSemantic=${WPIPathSemantic:=True} ; 
 local StrListArgCall=${WPILstFuncCall:=LTAComma=\'__CSV__\' LTAMatchRelative=__REG__ LTASemanticTag=__TAG__ LTAEntry=__LIST__ __FNCT__}  ;
 local IsVerbose=${WPIVerbose:=False} ; 
 local StrFilterRelativePath=${WPIRelativeMatch:='^[\.]+[\/]?[A-Za-z0-9_]+|^\w+[\/]?'}
 local StrSemanticPathTag=${WPISemanticTag:=R,A}

	function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local VerboseState=${VerbState:=False} ;
		local ArrayArg=( $* ) ; 
		if [ "${VerbState:=False}" == "True" ] ; then 
			echo -ne "VERBOSE:[ ${StrMsg} ]\n" > ${StrDevOut} ;
		fi
	}
  
 function ListToArray()
 {
		local __call_locality=( LTA ListToArray ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ;
  local StrCommaConverted=${LTAComma//\'/} ;
  local StrDebugMsg="\tIn Func:${__call_locality[1]}\n\t\tContent of LTAEntry:[${LTAEntry}]\n\t\tContent of LTAComma:[${LTAComma}]\n\t\tContent of StrCommaConverted:[${StrCommaConverted}]\n\t\tContent of IsPathIncludeSemantic:[${IsPathIncludeSemantic}]" ; 
  VerbState=${IsVerbose} VerbMsg=${StrDebugMsg} Verbosis ; 
  local StrEntryFilter="\"${LTAEntry//${StrCommaConverted}/\" \"}\"" ;
  local StrFilterRelative=${LTAMatchRelative:='^[\.]+[\/]?[A-Za-z0-9_]+|^\w+[\/]?'} ; 
  local StrTagSemList=${LTASemanticTag:=R,A}
  
  ### According to arbitrary value 
  ###             R -> Relative Path and 
  ###             A -> Absolut Path 
  ### These values are stocked into an array where value 0 and 1 are pointing 
  ### on linear correspondance. 
  ### Array[0] -> point on value R
  ### Array[1] -> point on value A .
  ### Why it's important to developt a regular expression matchin Value 0 on 
  ### Array[0] of transformed LTASemanticTag or WPISemanticTag because 
  ### for a positive match like finding
  ### ./path or ../path or path/other_path will report 1 count by the egrep .
  ### After hiting once it is associate to 0 and if there is no hit, associate
  ### to an Absolut path . 
  ### About LTASemanticTag, it taking value from WPISemanticTag, if information
  ### are specified from WrapPathIntegration ( like WPISemanticTag=R,A WrapPathIntegration)
  ### it is automatically reported inside Section 2 of __main_StartServices .
  ### It basically developt StrCmd, parsing __TAG__ and adding the definition or
  ### Ordered information about Semantic . Being added to section 3 of __main_StartServices
  ### Thru ValueToVariable
  
  local ArrayPathSemantic=( ${StrTagSemList/,/ } ) ; 
  
  
  local StrPath ; 
  local ArrayLocalList=( ${StrEntryFilter} ) ;
  local IntResultRelative=1 ;
  local StrCmdSem ;
  for (( i=0 ; i <= (( ${#ArrayLocalList[@]} -1 )) ; i++ )) ; do 
   local StrPath=${ArrayLocalList[${i}]} ; 
   local IntFilterTest=1  ; 
   local IntResultRelative=-1 ;
   
   if [ ${IsPathIncludeSemantic:=True} == "True" ] ; then 
    StrCmdSem="echo ${StrPath} | egrep -c -E \"${StrFilterRelative}\"" ; 
    IntFilterTest=$( eval ${StrCmdSem} ) ;
    if [ ${IntFilterTest:=-1} -eq 1 ] ; then
     IntResultRelative=0 ;
    else
     IntResultRelative=1 ;
    fi
    #test ${IntFilterTest:=1} -eq 1 && IntResultRelative=1 ;
    #test ${IntFilterTest:=1} -eq 0 && IntResultRelative=0 ;
    StrDebugMsg="\tIn Func:${__call_locality[1]}\n\t\tContent of StrPath:[${StrPath}]\n\t\tRegExp StrFilterRelative Filter:[${StrFilterRelative}]\n\t\tContent of IntFilterTest:[${IntFilterTest}]\n\t\tContent of IntResultRelative:[${IntResultRelative}]" ;  
    VerbState=${IsVerbose} VerbMsg=${StrDebugMsg} Verbosis ; 
    StrDebugMsg="\tIn Func:${__call_locality[1]}\n\t\tPath Semantic Tag:[${ArrayPathSemantic[${IntResultRelative}]}]" ; 
    VerbState=${IsVerbose} VerbMsg=${StrDebugMsg} Verbosis ; 
    
    ArrayLocalList[${i}]="${ArrayPathSemantic[${IntResultRelative}]}:${StrPath}" ; 
   else 
    ArrayLocalList[${i}]="${StrPath}" ; 
   fi 
  done 
  StrDebugMsg="\tIn Func:${__call_locality[1]}\n\t\tContent of StrEntryFilter:[${StrEntryFilter}]" ; 
  VerbState=${IsVerbose} VerbMsg=${StrDebugMsg} Verbosis ; 
  echo -ne "${ArrayLocalList[@]}" ; 
 }
 
 function __main_StartServices()
 {
  ###
  ### Section 1
  ###
  local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ;
  local StrCmd=${StrListArgCall//__CSV__/\'${StrCommaValue}\'} ;

  ###
  ### Section 2
  ###
  StrEntryListPath=${StrEntryListPath//}
  StrCmd=${StrCmd//__LIST__/${StrEntryListPath}} ;
  StrCmd=${StrCmd//__FNCT__/${StrListFnct}} ;
  StrCmd=${StrCmd//__TAG__/${StrSemanticPathTag}} ;
  StrCmd=${StrCmd//__REG__/${StrFilterRelativePath}} ;
  
  local StrDebugMsg="In Func:${__call_locality[1]}\n\tContent of StrCmd:[${StrCmd}]" ; 
  VerbState=${IsVerbose} VerbMsg=${StrDebugMsg} Verbosis ; 
  
  ###
  ### Section 3
  ###
  local ArrayPath=( $( \
       eval $( VTVIsArrayStyleInsert=True \
       VTVIsValueReAssign=True \
       VTVIsValueToConvert=False \
       VTVValueEntry=IsVerbose,IsPathIncludeSemantic ValueToVariable ) ${StrCmd} ) ) ;  
                       
  StrDebugMsg="In Func:${__call_locality[1]}\n\tContent of ArrayPath :[${ArrayPath[@]}]"
  
  VerbState=${IsVerbose} VerbMsg=${StrDebugMsg} Verbosis ; 
 }

  ###
  ### Section 4
  ###
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;	
	else
  eval $( VTVIsArrayStyleInsert=True \
          VTVIsValueReAssign=True \
          VTVIsValueToConvert=False \
          VTVValueEntry=StrEntryListPath,StrListFnct,StrCommaValue,StrListArgCall,IsVerbose,IsPathIncludeSemantic,StrSemanticPathTag,StrFilterRelativePath ValueToVariable ) __main_StartServices 
	fi 
 
 
 
}


### Note: MakeLink
### - While I'm making rezound work without linking libsoundtouch.0 to 
### libsoundtouch.1 and linking libaudiofile.so.1 with libaudiofile.so.0 for 
### installing the rezound_0.12.3beta-2.3_amd64.deb from dpkg --install
### it report error but does installing the debian package... Between this 
### work-around and compiling the rezound_0.12.3 from launchpad distribution it 
### come with many error or untelled warning to add inside the Makefile.am... 
### Having it compiling from my github 
### ( https://github.com/priendeau/Technical-PorteFolio/tree/master/C/rezound/rezound-0.12.3beta ) 
### it may occurs sometimes correction I did not add and are blind to actual 
### repository... re-linking one-by-one erronous file and working file I do need to 
### do a tiny MakeLink function where the SRC location is stored inside 
### MLLocationRoot and may call make after linking with prefixed variable 
### MLMainActionAfterLink ... 

unset MakeLink
function MakeLink() 
{ 
 local ArrayArg=( $* );
 local __call_locality=( ML MakeLink );
 local Arg0=${ArrayArg[0]} ;
 local StrRootOrigin=${MLLocationRoot:=/home/maxiste/github/Technical-PorteFolio/C/rezound/rezound-0.12.3beta/src} ;
 local StrAction=${MLMainActionAfterLink:=make} ;
 local StrFileSearch=${MLFileSearch:=None.cpp} ;
 local StrAliasFind=${MLAliasFind:=find -type f -iname } ;
 local IsMake=${MLDoPostAction:=True} ;
 local IsRenameDest=${MLBoolReplaceDest:=True} ; 
 local StrLinkApps=${MLLinkApps:=/bin/ln} ; 
 local StrLinkOpt=${MLLinkopt:=-s} ; 
 local StrLinkFormat=${MLLinkFormat:=__LINK__ __OPT__ __SRC__ __DEST__} ;
 local StrDebugLink=${MLLinkDisplayDebug:=False} ;
 local StrMoveSuffix=${MLMoveSuffixName:=-old} ; 
 
 function __Link()
 {
		local __call_locality=( _L __Link ) ;
		local ArrayArg=( $* ) ; 
  local StrVarSrc=${StrRootOrigin}/${StrFile} ;
  local StrEval=${StrLinkFormat} ; 
  
  local StrFileReplace=$( echo "${StrFile}" | sed 's/\(\.[a-z]*\)/${StrMoveSuffix}\1/g' ) ; 

          
  StrEval=${StrEval//__LINK__/${StrLinkApps}} ;
  StrEval=${StrEval//__OPT__/${StrLinkOpt}} ; 
  StrEval=${StrEval//__SRC__/${StrVarSrc}} ; 
  StrEval=${StrEval//__DEST__/${StrFile}}
  if [ ${StrDebugLink} == "False" ] ; then 
   eval $( BVTestVarName=StrToMove \
           BVTestVarHold='' \
           BVTestBoolVarName=\${IsRenameDest} \
           BVTestBoolCase=True \
           BVTestBoolAssertion='$( mv ${StrFile} ${StrFileReplace} )' \
           BVTestScopeTest=local \
           BoolVarTestVarCreation ) ;   
   eval "${StrEval}" ;
  else
   echo -ne "Eval:[ ${StrEval} ]\n" > /dev/stderr ; 
  fi
  
 }
 
 function __PostAction()
 {
		local __call_locality=( __PA __PostAction ) ;
		local ArrayArg=( $* ) ; 
  
  eval $( BVTestVarName=StrRecurrent \
          BVTestVarHold='' \
          BVTestBoolVarName=\${IsMake} \
          BVTestBoolCase=True \
          BVTestBoolAssertion='$( ${StrAction} )' \
          BVTestScopeTest=local \
          BoolVarTestVarCreation ) ; 
  
 }
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local ArrayArg=( $* ) ; 
  eval alias find='${StrAliasFind}';
  local StrFile=$( find ${StrFileSearch} );
		local Arg0=${ArrayArg[0]};
  if [ "${StrFile:=None}" != "None" ] ; then 
   StrFile=${StrFile//\.\//} ; 
   local ArrayLayerVar=( StrRootOrigin,StrFile,StrLinkApps,StrLinkFormat,StrLinkOpt,StrDebugLink,IsRenameDest,StrMoveSuffix IsMake,StrAction ) ;
   local ArrayFunction=( __Link __PostAction )
   for (( intx=0 ; intx <= ${#ArrayLayerVar[@]}-1; intx++ )) ; do 
    eval $( VTVIsArrayStyleInsert=True \
    VTVValueEntry=${ArrayLayerVar[${intx}]} \
    VTVIsValueReAssign=True \
    VTVIsValueToConvert=False \
    VTVIsArrayStyleInsert=True \
    ValueToVariable ) ${ArrayFunction[${intx}]} ; 
   done
  else
   echo -ne "Can not continue linking, no existing file:\n\tResult:${StrFile:=None}\n\tQuery:${StrFileSearch}\n" > /dev/stderr ; 
  fi 

  unalias find ;
 }
 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n" ;
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrRootOrigin,IsMake,StrAction,StrFileSearch,StrAliasFind,StrLinkFormat,StrLinkApps,StrLinkOpt,StrDebugLink,IsRenameDest,StrMoveSuffix \
  VTVIsValueReAssign=True \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StartServices
 fi

 
}

### ************************************************************************
### **** Exception                                                      ****
### ************************************************************************
### This is just a Fast-loader, reconverting ArrayArg[n] taked from inline 
### command, this also what will create ZenityRadioOptionConfig, 
### ZenityListOptionConfig, ZenityPrefixedVarBuilder suite, a series of 
### fast-loader, to manage more easily pre-fixed variables... 

function FMakeLink() 
{ 
 local __call_locality=(FML FMakeLink);
 local ArrayArg=( $* );
 local Arg0=${ArrayArg[0]} ;
 MLDoPostAction=False MLLinkDisplayDebug=True MLFileSearch=${Arg0} MakeLink;
 MLDoPostAction=True MLLinkDisplayDebug=False MLFileSearch=${Arg0} MakeLink
}


unset AutoChown ;
function AutoChown()    
{ 
	local __call_locality=( AC AutoChown ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]};
 local StrUser=${ACUser:=maxiste.maxiste} ; 
 local IntSleep=${ACSleep:=30} ; 
 local IsPathRecurr=${ACRecurrent:=True} ; 
 local StrApps=${ACChownApps:=chown} ; 
 local IsLoop=${ACLooping:=True}
 local StrPathList=${ACPathList:=Path1:Path2} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local ArrayArg=( $* ) ; 
		local Arg0=${ArrayArg[0]};
  local ArrayPath=( ${StrPathList//:/ } ) ; 
  
  eval $( BVTestVarName=StrRecurrent BVTestVarHold='-R' BVTestBoolVarName=\${IsPathRecurr} BVTestBoolCase=False BVTestBoolAssertion='' BVTestScopeTest=local BoolVarTestVarCreation ) ; 
  eval $( BVTestVarName=IntXWh BVTestVarHold='1' BVTestBoolVarName='\${IsLoop}' BVTestBoolCase=False BVTestBoolAssertion='0' BVTestScopeTest=local BoolVarTestVarCreation ) ; 
  
  while [ ${IntXWh} -eq 1 ] ; do 
    for (( x=0 ; x <= ${#ArrayPath[@]}-1 ; x++ )) ; do 
     local StrPathName=${ArrayPath[${x}]} ; 
     chown ${StrUser} ${StrPathName} ${StrRecurrent} ; 
    done ; 
    if [ "${IsLoop}" == "False" ] ; then 
     IntXWh=0 ; 
    fi 
   sleep ${IntSleep} ; 
  
  done
 }
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  StrUser=${StrUser}               \
  IntSleep=${IntSleep}             \
  StrOutArrayRef=${StrOutArrayRef} \
  IsPathRecurr=${IsPathRecurr}     \
  StrApps=${StrApps}               \
  StrPathList=${StrPathList}       \
  IsLoop=${IsLoop}                 \
  __main_StartServices             ; 
  
 fi
 
 
}
 ### ZenityShellEval :
 ###
 ###
 ###	Full-length example : 
 ### Including 1 example :
 ###
 ### $> ZenityShellEval (Enter)
 ### 
 ### - It Open Windows from Zenity with parameter for Text-info in editable
 ### mode.
 ### 
 ### It Open by default a uuid-like temporary file. There is no actual was
 ### to modify the name, but assuming the implementation of ZenityShellEval
 ### imply a limited acces to shell, you might recuper information from shell
 ### or futur adding to transfert a name or simple renaming the uuid-like
 ### file-name... This is to prevent auto-execution of a script from 
 ### canned-design by playing with without having all clearly create your 
 ### shell script and/or having fully pseudo-code explained and having 
 ### confirmation of your design work... 
 ### 
 ### - Like ZenityShellEval, will reach first stage-maturity fast enought,
 ### it's possible the followed function will move into fnct_lib or fnct_lib_tool,
 ### being a method to control chuck of information like descendant script lib
 ### where fnct_debian_lib should descent from:
 ### 
 ### Level1 : ( fnct_lib or fnct_lib_tool )
 ###     |
 ###     +-----------> fnct_debian_lib ( Second Level )
 ###                          |
 ###                          +----------> { _sub_PackageRepository
 ###                                         _sub_Git
 ###                                         _sub_ssh_handler        } ( Third level and specialized chunk )
 ### 
 ### Where fnct_lib shall have all mandatory function being Really Essential.
 ### Where fnct_lib_tool shall have all common tools to create code and Interract
 ### with UX ( User Experience. )
 ### 
 ### Note: UX, like HP-UX, for Home-Profesionnal User-eXperience, and not UX for Unix/*nix 
 ### 
 ### Example of code for ZenityShellEval
 ### 
 ### Assuming you are looking to link fastly unpacked .deb from File-manager into
 ### Unusual path and wanting to link against correct uses nvidia-driver to 
 ### possibly manage a fake instance of CUDA from not-wished Capable-Card like 
 ### Geforce 7000M, where it can exist at leat 4 to 8 node of CUDA GPU which is
 ### not enought because minimal number of node are 16 and higher and willing 
 ### to create so-cheap demo card around 1999-2002 in displaced time-and-space
 ### 
 ### - So having to find all nvidia .so lib, it should be linked inside 
 ### /usr/lib/nvidia-304.84 which is your memory having merely remember the 
 ### automated design from version 295.xx . 
 ### Following that you bring into /usr/lib/lib*.so.1, /usr/lib/lib*.so.[3-5]
 ### all other linked lib found inside /usr/lib/nvidia-304.84,
 ### 
 ### In Other term it's
 ### Also seed to uses X from Xorg with the nouveau driver and wich to use 
 ### the entire GPU memory location and VDPAU reserved operation for GPUing.
 ### Like a package allowing to store image into GPU memory card... Having
 ### feeling many slice of superposed image is just a matrix canonical-form
 ### of code assembly to re-interpret into real execution... 
 ### 
 ### the sample to put inside the Zenity Text-Info in editable mode :
 ### 
 ### ----------------------------- SAMPLE ----------------------------- 
 ### 
 ### function test_expr()
 ### {
 ###   local __call_locality=( Filter __filter ) ;
 ###   local Arg0=${ArrayArg[0]} ;
 ###   local ArrayArg=( $* ) ; 
 ###   local StrPath=/usr/local/src/apt/nvidia-304 ;
 ###   function __filter()
 ###   {
 ###     local __call_locality=( Filter __filter ) ;
 ###     local Arg0=${ArrayArg[0]} ;
 ###     local ArrayArg=( $* ) ; 
 ###     local StrFilterGrep=${FilterGrep:='lib32'} ;
 ###     local StrTaillingSearch={FilterTrSearch:=[:cntrl:]};
 ###     local StrTaillingRepl=${FilterTrReplace:=' '} ;
 ###     grep -v "${StrFilterGrep}" | tr '${StrTaillingSearch}' '${StrTaillingRepl}' ; 
 ###   }
 ###   local AF=( $( find ${StrPath} -type f -iname "*.so*" | __filter ) ) ; 
 ###   for (( x=0 ; x<= ${#AF[@]}-1; x++ )) ; do 
 ###    item=${AF[${x}]} ; 
 ###    local _file=( ${item//\// }  ) ; 
 ###    local file="${_file[$((${#_file[@]}-1))]}" ;
 ###    echo ln -s ${item} $(pwd)/${file} ; 
 ###   done
 ### }
 ### test_expr ; 
 ### ----------------------------- SAMPLE ----------------------------- 
 ### 
 ### You hit Enter or OK from the Window 'Shell Evaluation command', and 
 ### Should not give you an error, if so the same code reapear and you 
 ### have to find yourself the error if ZenityShellEval was not executed
 ### from allowed Terminal or Windows-shell . 
 ### If you do executed it from, you can read error and seemlesly seek for 
 ### error... 
 ### 
 ### - Later example might have support for error like puting into warning 
 ### Windows, error. And possibly conversion between uuid-like file into 
 ### finite name... 
 ### 
 ### PS: Hint:
 ###  - Using AutoChown will also let use execute the script with your own
 ### user and group, and might allow you to put it elsewhere like into 
 ### localized-execution section..... 
 ### 
 ### 
 
 

unset ZenityShellEval ;
function ZenityShellEval()    
{ 
	local __call_locality=( ZSE ZenityShellEval ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]}              ;
 local IntSleep=${ZSESleepInterval:=5}  ;
 local IntFontSize=${ZSEFontSize:=12}   ; 
 local IsEditField=${ZSEEditable:=True} ; 
 local IsAddFootPrint=${ZSEAddFootPrint:=True} ; 
 local StrTitle=${ZSEZenityTitle:='Shell Evaluation command'} ;
 local StrFileName=${ZSEFileName:=None} ;
 local StrDateFormat=${ZSEDateFormat:=%Y%m%d-%H:%M:%S,%s}
 local IntDefaultModeExec=${ZSEChmodFileExec:=775} ;
 local StrFilePath=${ZSEPathStorage:=./} ; 
 local IntWidth=${ZSEWindowWidth:=640} ;
 local IntHeight=${ZSEWindowHeight:=400} ;
 local IsLoopOnSucc=${ZSELoopOnSucc:=True} ; 
 local IsCheckSumOnly=${ZSECheckSumTest:=False} ; 
 local TmpUUIDEdit=$( GetUIDRegister=True GetUAppsRegisterName=${__call_locality[1]} GetUUID )
 ### Note: f1161962-0ad8-11e3-b166-001b3875b29c 
 ### 
 ### Title : Variable Forwarding Example in BoolVarTestVarCreation & mutation 
 ### of BoolVarTestVarCreation from True/False test into None
 ### 
 ### BoolVarTestVarCreation for substitution of StrFileTmp has unidirectionnaly
 ### a uuid-like file name into Pre-fixed Var ZSEFileName:=None for 
 ### affectation inside StrFileName=None, where if this one != None, will 
 ### get the parameter Name Being passed inside StrFileTmp. 
 ### 
 ### - Had consequence:
 ###  - if the file does not exist, an echo > StrFileTmp will be done . 
 ###  - if the file exist, content will be open by Zenity in text-info --editable
 ###  - Selected filename supplied, content will be overwritted and there is 
 ###  no protection mechanism and no verification against file-permission
 ###    - To this, a workaround will store all code generated from this application
 ###    - into sub-directory being made by the command and store-it inside user
 ###      respective home location which is safe and Pre-fixable into 
 ###      your specification, and not-warrented to be correct but designable. 
 ###  
 ### 
 ### - If the variable ZSEFileName is untouched, the content of StrFileTmp will
 ### hold value 'None' and belong to parsed BoolVarTestVarCreation it should 
 ### get it's uuid-like filename, see generated command from parameter below
 ### 
 ### Command : BVTestVarName=StrFileTmp BVTestVarHold='${StrFileName}' BVTestBoolVarName=\${StrFileName} BVTestBoolCase=None BVTestBoolAssertion='$( uuidgen -t )' BVTestScopeTest=local BoolVarTestVarCreation
 ### 
 ### generated code:
 ### local StrFileTmp="${StrFileName}" ; 
 ### if [ "${StrFileName}" == "None" ] ; then 
 ###  StrFileTmp=$( uuidgen -t ) ; 
 ### fi
 ### 
 ### Which is making sense. 
 ### 
 ### Also Note f1161962-0ad8-11e3-b166-001b3875b29c introduce explanation on mutation of BoolVarTestVarCreation from True/False test into None and moving uuid-file-id variable inside BVTestBoolAssertion
 ### 
 ### 
 eval $( BVTestVarName=StrFileTmp \
         BVTestVarHold='${StrFilePath}/${StrFileName}' \
         BVTestBoolVarName=\${StrFileName} \
         BVTestBoolCase=None \
         BVTestBoolAssertion='${StrFilePath}/$( uuidgen -t )' \
         BVTestScopeTest=local \
         BoolVarTestVarCreation ) ; 
 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 

	function __main_Editor()
 {
		local __call_locality=( Editor __main_Editor ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ;
  test ! -e ${StrFileTmp} && echo "" > ${StrFileTmp} ; 
  
  local res=1 ; 
  local shell_res=0 ; 
  local shell_quit=0 ; 
  eval $( BVTestVarName=StrEditableAttr \
          BVTestVarHold='--editable' \
          BVTestBoolVarName=\${IsEditField} \
          BVTestBoolCase=False \
          BVTestBoolAssertion='' \
          BVTestScopeTest=local \
          BoolVarTestVarCreation ) ; 
  
  test ! -e ${StrFileTmp} && echo -ne "\n\nNote: New FileName : ${StrFileTmp} \n\n" > /dev/stderr ; 
  test ! -e ${StrFileTmp} && echo -ne "\n\n### FileName: ${StrFileTmp}\n\n" > ${StrFileTmp} ; 
  test -e ${StrFileTmp} && echo -ne "\n\nRe-opening File : ${StrFileTmp} \n\n" > /dev/stderr ; 
  
  ### Copy File into Local HOME/path and removing the header and avoid to overwrite the initial 
  ### Protected file 
  local IntNbLineInFile=$( wc -l ${StrFileTmp} | cut -d ' ' -f1  ) ; 
  local IntNbLineNoHeader=$(( ${IntNbLineInFile} - 9 ))
  test -e ${StrFileTmp} && tail -n ${IntNbLineNoHeader} ${StrFileTmp} > ${HOME}/${TmpUUIDEdit} 
  while [ ${res} -eq 1 -a ${shell_quit} -eq 0 ] ; do 
   CmdEval=$( zenity \
              --text-info ${StrEditableAttr} \
              --font=${IntFontSize} \
              --filename=${HOME}/${TmpUUIDEdit} \
              --title="${StrTitle}" \
              --width=${IntWidth} \
              --height=${IntHeight} ) ; 
   res=$? ; 
   if [ ${res} -ne 1 ] ; then 
    ### 
    ### FootPrint Section
    ###
    ###
      function _NoFootPrint()
      {
        echo -ne "###\n### No FootPrint Added, see Prefixed-Var ZSEAddFootPrint from ZenityShellEval\n###\n###\n###\n###\n###\n###\n###\n###\n###\n" ; 
      }
      function _FootPrint()
      {
        local StrUUID=$( uuidgen -t ) ; 
        local StrSha1Sum=$( echo "${CmdEval}" | sha1sum | cut -d ' ' -f 1)
        local StrSize=$( echo "${CmdEval}" | wc -c ) ; 
        local StrNbWord=$( echo "${CmdEval}" | wc -w ) ; 
        local StrDateConfirm=$( GODFormat='${StrDateFormat}' GetOtherDate )
        echo -ne "###\n### FootPrint Added, see Prefixed-Var ZSEAddFootPrint from ZenityShellEval\n###\n\n###File:${StrFileTmp}\n###UUID-TIME-MARKER:${StrUUID}\n###Date: ${StrDateConfirm}\n###Sha1Sum: ${StrSha1Sum}\n### Size:${StrSize}\n### NbWord: ${StrNbWord}\n\n" ; 
      }
      function _DetectFootPrint()
      {
       local IntFootPrintDetection=$( echo -ne "${CmdEval}" | head -n 11 | egrep -ic "FootPrint" ) ;
       eval $( BVTestVarName=StrFootPrintMark BVTestVarHold='$( StrDateFormat=${StrDateFormat} CmdEval=${CmdEval} _FootPrint )' BVTestBoolVarName=\${IsAddFootPrint} BVTestBoolCase=False BVTestBoolAssertion='$( _NoFootPrint )' BVTestScopeTest=local BoolVarTestVarCreation ) ;
      }
      
      eval $( BVTestVarName=StrFootPrintMark BVTestVarHold='$( StrDateFormat=${StrDateFormat} CmdEval=${CmdEval} _FootPrint )' BVTestBoolVarName=\${IsAddFootPrint} BVTestBoolCase=False BVTestBoolAssertion='$( _NoFootPrint )' BVTestScopeTest=local BoolVarTestVarCreation ) ;       
      
    ###
    ### End FootPrint
    ###
    
    
    echo """${StrFootPrintMark}\n${CmdEval}""" > ${StrFileTmp} ; 
    chmod 775 ${StrFileTmp} ; 
    . ${StrFileTmp} ; 
    shell_res=$?
    if [ ${shell_res} -eq 1 ] ; then 
     echo -ne "\n\n\tUser Shell evaluation reported error\n\n" > /dev/stderr ; 
     res=1 ; 
     shell_res=1 ; 
    fi 
   else 
    echo -ne "\n\n\tUser cancel the test.\n\n" > /dev/stderr ; 
    shell_quit=1 ; 
   fi ; 
   sleep ${IntSleep} ; 
   test ${res} -eq 0 -a ${shell_res} -eq 0 && eval $( BVTestVarName=res BVTestVarHold='0' BVTestBoolVarName=\${IsLoopOnSucc} BVTestBoolCase=False BVTestBoolAssertion='1' BVTestScopeTest=local BoolVarTestVarCreation ) ; 
  done
  echo -ne "\n\tQuitting Function :${__call_locality[1]}\n\n" > /dev/stderr ;  
  echo -ne "\n\tRemoving temporary UUID Holder : \n\tFile: ${HOME}/${TmpUUIDEdit}\n\n" > /dev/stderr ; 
  rm -f ${HOME}/${TmpUUIDEdit}
 }
 
 function __main_CheckSum()
 {
		local __call_locality=( CheckSum __main_CheckSum ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ;
  local CheckSumFile=$( cat ${StrFilePath}/${StrFileName} | grep -v "^###" | sha1sum | cut -d ' ' -f 1  ) ; 
  local CheckSumIdentity=$( cat ${StrFilePath}/${StrFileName} | grep "^###Sha1Sum:" | cut -d ' ' -f 2  | sed 's/[\ \t]//g' ) ;
  echo -ne "File: ${CheckSumFile}\nFootprint: ${CheckSumIdentity}\n" > /dev/stderr ; 
  if [ ${CheckSumFile} == ${CheckSumIdentity} ] ; then 
   echo -ne "file-shasum:${StrFilePath}/${StrFileName}:MATCH\n" ; 
  else
   echo -ne "file-shasum:${StrFilePath}/${StrFileName}:FAILED\n" ; 
  fi 
 }

 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  if [ "${IsCheckSumOnly}" == "True" ] ; then 
   StrFilePath=${StrFilePath} StrFileName=${StrFileName} __main_CheckSum ; 
  else
  eval $( VTVValueEntry=StrFileTmp,StrTitle,StrDateFormat,IntSleep,IntFontSize,IsEditField,IntWidth,IntHeight,IntDefaultModeExec,IsEditField,IsAddFootPrint,IsLoopOnSucc,IsCheckSumOnly\
          VTVIsValueReAssign=True \
          VTVIsValueToConvert=False \
          VTVIsArrayStyleInsert=True \
          ValueToVariable ) __main_Editor 
  fi


 }
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
		eval $( __GetVarReferenceCompWord ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrFileTmp,StrTitle,StrDateFormat,IntSleep,IntFontSize,IsEditField,IntWidth,IntHeight,IntDefaultModeExec,IsAddFootPrint,IsLoopOnSucc,IsCheckSumOnly \
  VTVIsValueReAssign=True \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StartServices
 fi


}



 ### StartCoproc :
 ###
 ###
 ###	Full-length example : 
 ### Including 
 ###
 ###
 ###
 ###
 ###
 ###
 ###
 ###
 ###


unset StartCoproc
function StartCoproc()
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( StartCoproc ) ; 
 local Arg0=${ArrayArg[0]} ; 
 ### Prototype model, 
 ### - Require . /etc/init.d/Fnct.d/_sub_Git to work. 
	### coproc git_fnct_debian { while [ ${res:=0} -ne 1  ] ; do res=$( GitHubCommitFilePath=/etc/init.d/Fnct.d  GitHubCommit fnct_debian_lib ) ; sleep 5 ; done ; }
	local StrValueParserInfo="""
	VPCallLocalityName=${__call_locality[0]} 
	VPVarArgList=Str:ProcName,
	             Str:InWhile,
	             Str:WhCond,
	             Str:WhRetStat,
	             Str:AppsName,
	             Str:AppsPrVar,
	             Str:AppsOpt
	VPScopeList=ProcName:local,
	             InWhile:local,
	             WhCond:local,
	             WhRetStat:local,
	             AppsName:local,
	             AppsPrVar:local,
	             AppsOpt:local,
	VPValueList=DefaultCoprocName:True:__VAR__ -ne 1:__VAR__=\$( __CMD__ ):GitHubCommit:GitHubCommitFilePath=${FNCTDLIBPATH}:fnct_debian_lib
	""" ;
	
	eval $( eval "${StrValueParserInfo} ValueParser " ) ;
	local EvalCoprocCmd=( ${StrAppsPrVar} ${StrAppsName} ${StrAppsOpt} ) ; 
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
	local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${Arg0:=--startservices}" == "--help" ] ; then 
		GetVarReference StartCoproc ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		eval ${StrValueParserInfo} ValueParser --varhelper
		echo -ne "--asarray\tStart The application and output the content into an Array, see varriable                               PkgConfigAllArrayName to change the name. This command need an eval braced                              to get the array being initialized.\n\n"
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
		echo ""
		### Prog To create a coprocess 
		#if [ ${StrInWhile} ]
	fi
}


### Package Query function. 
### give by-package, many option at once. 
### 
### Single package:
### ex: GetPackage=flac PkgConfigQuery --cflags --libs
### 
### will output:
### 
### flac:--cflags:-I/usr/include/FLAC  
### flac:--libs:-lFLAC -lm  
### flac++:--cflags:-I/usr/include/FLAC++ -I/usr/include/FLAC  
### flac++:--libs:-lFLAC++ -lFLAC -lm  
### 
###
### Many Package : 
### ex: GetPackage=samplerate,flac PkgConfigQuery --cflags --libs 
### samplerate:--cflags: 
### samplerate:--libs:-lsamplerate  
### flac:--cflags:-I/usr/include/FLAC  
### flac:--libs:-lFLAC -lm  
### flac++:--cflags:-I/usr/include/FLAC++ -I/usr/include/FLAC  
### flac++:--libs:-lFLAC++ -lFLAC -lm  


function PkgConfigQuery()
{ 
	local ArrayArg=( $* );
	local __call_locality=( PkgQuery ) ;
	local Arg0=${ArrayArg[0]:=--start} ; 
	local ArrayArgFlag=( ${ArrayArg[@]:1} ) ; 
	local IntArgLen=${#ArrayArgFlag[@]} ;
	local StrValueParserInfo="VPCallLocalityName=${__call_locality[0]} VPVarArgList=Str:AppsName,Str:AppsOpt,Str:FlagList,Str:PackageList VPScopeList=AppsName:local,AppsOpt:local,FlagList:local,PackageList:local VPValueList=/usr/bin/pkg-config:--list-all:--libs,--static,--short-errors,--libs-only-l,--libs-only-other,--libs-only-L,--cflags,--cflags-only-I,--cflags-only-other:flac" ;
	
	### Replaced by ValueParser
	#local StrPkgConfigApps=${PkgConfigQueryAppsName:=/usr/bin/pkg-config};
	#local StrPkgConfigAppsOpt=${PkgConfigQueryAppsOption:=--list-all};
	eval $( eval "${StrValueParserInfo} ValueParser " ) ;
	
	#echo -ne "StrAppsName : ${StrAppsName}\n" > /dev/stderr ;
	#echo -ne "StrAppsOpt  : ${StrAppsOpt}\n" > /dev/stderr ;
	#echo -ne "StrFlagList  : ${StrFlagList}\n" > /dev/stderr ;
	#echo -ne "StrPackageList  : ${StrPackageList}\n" > /dev/stderr ;
	
	#local StrPackageList=${PkgConfigQueryGetPackage:=flac} ;
	#local StrFlagList=${PkgConfigQueryFlagList:=--libs,--static,--short-errors,--libs-only-l,--libs-only-other,--libs-only-L,--cflags,--cflags-only-I,--cflags-only-other} ;
	local ArrayFlagTest=( ) ;
	function FilterPackageList()
	{
		local ArrayArg=( $* );
		local __call_locality=( FilterPackageList ) ;
		local StrGrepFilter=${FilterPackageListGrepFilter:=${CurrentPackage}}
		cut -d " " -f 1 | egrep -i "${StrGrepFilter}" | tr '[:cntrl:]' ' ' 
	}

		#local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 
 	if [ "${Arg0:=--start}" == "--help" ] ; then 
			GetVarReference PkgConfigQuery ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
			eval ${StrValueParserInfo} ValueParser --varhelper ;
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	else
		if [ ${IntArgLen:=0} -eq 0 ] ; then 
			ArrayFlagTest=( ${StrFlagList//,/ } ) ; 
		else
			ArrayFlagTest=( ${ArrayArgFlag[@]} ) ; 
		fi 		
		local ArrayPackageListVar=( ${StrPackageList//,/ } ) ;
		for (( intAx=0 ; intAx <= ${#ArrayPackageListVar[@]}-1 ; intAx++ )) ; do 
			local CurrentPackage="${ArrayPackageListVar[${intAx}]}" ; 
		  local _A=( $( ${StrAppsName} ${StrAppsOpt} | FilterPackageListGrepFilter=${CurrentPackage} FilterPackageList ) );
		  local IntNbPackage=${#_A[@]} ;
		  if [ ${IntNbPackage:=0} -gt 0 ]; then
		      for ((x=0 ; x <= ${#_A[@]}-1 ; x++ )) ; do
		          for (( cx=0 ; cx <= ${#ArrayFlagTest[@]}-1 ; cx++ )) ; do
		              res=$( ${StrAppsName} ${_A[${x}]} ${ArrayFlagTest[${cx}]} );
		              echo -ne "${_A[${x}]}:${ArrayFlagTest[${cx}]}:${res}\n";
		          done;
		      done;
		  else
		      echo -ne "\n\n\tPackage Not Found\n" > /dev/stderr;
		  fi
		done 
	fi 
}

### Warning : 
### This version of pkg-config-all is aliased to pkg-config inside .bashrc of the user shell and following function 
### are also dependent of alias .
### cut -> to alias cut='/usr/bin/cut -d "'" "'" '
### pkg-config -> to alias pkg-config='pkg-config-all'
### 
### 
### 


function pkg-config-all()
{
	local __call_locality=( PkgConfigAll ) ; 
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
	local StrValueParserInfo="VPCallLocalityName=${__call_locality[0]} VPVarArgList=Str:ArrayName,Int:Scoping,Str:CutAlias,Str:AppsName,Str:AppsOpt VPScopeList=ArrayName:local,Scoping:local,CutAlias:local,AppsName:local,AppsOpt:local VPValueList=ArrayPackageName:1:cut:/usr/bin/pkg-config:--list-all ValueParser" ;
	
	eval $( eval "${StrValueParserInfo} ValueParser " ) ;
	### ValueParser replace following value.
	#local StrpackageName=${PkgConfigAllArrayName:=ArrayPackageName}	;
	#local IntScoping=${PkgConfigAllScoping:=1}	;
	#local StrCutAlias=${PkgConfigAllCutAlias:=cut}	;
	#local StrPkgConfig=${PkgConfigAllApps:=/usr/bin/pkg-config} ; 
	echo -ne "Var StrAppsName: ${StrAppsName}\nVar StrAppsOpt: ${StrAppsOpt}\n" > /dev/stderr ;
	function Main()
	{
		local ArrayScopingType=( "local" "declare -a");
		if [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
			eval "${StrAppsName} --list-all | ${StrCutAlias} -f 1" ; 
		elif [ "${Arg0:=--startservices}" == "--asarray" ] ; then 
				local StrPackageList=$( ${StrAppsName} ${StrAppsOpt} | eval "${StrCutAlias} -f 1" | tr '[:cntrl:]' ' ' ) ; 
				echo -ne "${ArrayScopingType[${IntScoping}]} ${StrArrayName}=( ${StrPackageList} )\n" ;
		fi
	}
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 	if [ "${Arg0:=--startservices}" == "--help" ] ; then 
		GetVarReference pkg-config-all ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		eval ${StrValueParserInfo} --varhelper
		echo -ne "Following switch are available:\n\n\t--startservices\tStart the application normally and output the package list\n\t--asarray\tStart The application and output the content into an Array, see varriable                               PkgConfigAllArrayName to change the name. This command need an eval braced                              to get the array being initialized.\n\n"
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	else
		Arg0=${Arg0} StrAppsName=${StrAppsName} StrCutAlias=${StrCutAlias} StrAppsOpt=${StrAppsOpt} IntScoping=${IntScoping} StrArrayName=${StrArrayName} Main
	fi
}


function ObjFindFunction()
{
 local ArrayArg=( $* )	;
 local __call_locality=( ObjFindFunction ) ; 
 local Arg0=( ${ArrayArg[0]} ) ; 
 
	local StrDllFunctionFind=${ObjFindFunctionDllList:=iolog_unlink,GetUserDetailsType,GetCommandDetailsType}  ; 
	local dllFunction=( ${StrDllFunctionFind//,/ } ) ; 
	local StrObjDumpFlagsSet=${ObjFindFunctionFlagSet:=--dynamic-syms;--syms}
	local StrObjDumpApps=${ObjFindFunctionObjApps:=objdump} ;
	
	local ArrayInspecType=( ${StrObjDumpFlagsSet//;/ } ) ; 
	local StrPathStartFind=${ObjFindFunctionPath:=./} ;
	local StrDllSuffix=${ObjFindFunctionDllSearch:=*.so} ;
	local StrUniqueIDType=${ObjFindFunctionUUIDType:=--time} ;
	local StrUniqueIDTypeApps=${ObjFindFunctionUUIDType:=uuidgen} ;
	local StrPrintfFormat=${ObjFindFunctionPrintfFormat:="%h/%f"} ;
	
	function GetUniqueUUID()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( GetUniqueUUID ) ; 
		local StrUUIDFlags=${GetUniqueUUIDFlags:=--time} ; 
		local StrUUIDApps=${GetUniqueUUIDApps:=uuidgen} ; 
		
		eval """ local StrUUID=$( ${StrUUIDApps} ${StrUUIDFlags}  ) """ ;
		echo -ne "${StrUUID}" ; 
	} ; 
	function GetFindList()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( GetFindList ) ; 
		local StrStartPath=${GetFindListStartPath:=./} ; 
		local StrInameSuffix=${GetFindListNamePatter:=*.so} ; 
		local StrPrintfFormat=${GetFindListPrintfFormat:="%h/%f"} ; 
		
		find ${StrPathStartFind} -type f -iname "${StrInameSuffix}" -printf "${StrPrintfFormat}" ; 
	}
	function DllSearch()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( DllSearch ) ; 
		StrDllInspectApps=${DllSearchApps:=objdump} ; 
		StrDllInspectFlagsInArg=${DllSearchFlags:=--dynamic-syms} ; 
		StrDllInspectFlags=${StrDllInspectFlagsInArg//,/ } ;
		StrFileSearch=${DllSearchFileName:=None} ; 
		StrDllFunctionName=${DllSearchFunctionName:=none} ; 
		eval """ ${StrDllInspectApps} ${StrDllInspectFlags} ${StrFileSearch} | egrep -ic "${StrDllFunctionName}" """ ; 
		
	}
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
	
	if [ "${Arg0:=--startservices}" == "--help" ] ; then 
	 GetVarReference ${__call_locality[0]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	else
		local ArrayDll=( $( GetFindListStartPath=${StrPathStartFind} GetFindListNamePatter=${StrDllSuffix} GetFindListPrintfFormat=${StrPrintfFormat} ) ) ; 
		for StrdllFunction in ${dllFunction[@]}; do 
			for (( intx=0 ; intx <= ${#ArrayDll[@]}-1 ; intx++ )) ; do 
				item="${ArrayDll[${intx}]}" ; 
				for DllTypeInspect in ${ArrayInspecType[@]} ; do 
					local UUID_T=$( GetUniqueUUIDApps=${StrUniqueIDTypeApps} GetUniqueUUIDFlags=${StrUniqueIDType} GetUniqueUUID ) ;  
					isDllfunction=$( DllSearchApps=${StrObjDumpApps} DllSearchFlags=${DllTypeInspect} DllSearchFileName=${item} DllSearchFunctionName=${StrdllFunction} DllSearch ) ; 
					dllState=${isDllfunction:=0} ; 
					echo -ne "PKID:${UUID_T}:found:${dllState}:DllInpectMeth:${DllTypeInspect}:Function:${StrdllFunction}:dllName:${item}\n" ; 
				done ; 
			done ; 
		done
	fi
	
 
}

### Default Fast reference Helper. 
### Extract current Prefixed variables from your function and show it on stdout( screen output ). 
### The prefixed variable are indicated on decalation of __call_locality which usually had same name has 
### top function. 
### Desc : It actively look inside the function code and extract value prefixed with function name...
### was initially developped on $0, but change by creating subFunction, and some code may be reserved for private
### use or recurrent-code with recurrent variable name, may be show and alter your perception of functionality of 
### the design ...

### Example to implement the body-helper. 
### 
### function Helper()
### {
###  __call_locality=( Helper ) ; 
### 	local ArrayArg=( $* ) ; 
### 	local Arg0=${ArrayArg[0]}; 
###  local StrHelperInvolved=${HelperQuestionInvolved:=Nothing} ; ### <---1a 
### 	if [ "${Arg0:=--start}" == "--help" ] ; then 
###			GetVarReference ${__call_locality[0]} ; 
###  else	
###   ---> Normal Body event and code. 
###  
###   ... 
###  fi 
### }
### 
### Note, In case your Helper --help be tested, if it does not output only Prefixed var definition.
### retreive all your variable from your command and do like example StrHelperInvolved in 1a
### Create specific local variable and associate the content of your Prefixed variables, help get 
### better body definition and reduce complexity by reading it... 
### 



unset __GetVarReferenceList ;
function __GetVarReferenceList( )
{
		echo -ne """eval ${__call_locality[1]} --help 2> /dev/null | egrep -i \"^Variable\" | cut -d ' ' -f 2 | tr '[:cntrl:]' ' '""" ; 
}


unset DefaultConfigure ;
function DefaultConfigure()
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( DefConfigure ) ; 
	local StrDefaultAction=${DefConfigureAction:=--start-services} ;
	local Arg0=${ArrayArg[0]:=${StrDefaultAction}}; 
	local StrLD='${DefConfigureLD:=${LD} -laudiofile}' ; 
	local StrLDFLAGS='${DefConfigureLDFLAGS:=${LDFLAGS}}' ; 
	local StrCXX=${DefConfigureCXX:=\${CXX}} ; 
	local StrCC=${DefConfigureCC:=\${CC}} ; 
	local StrCPP=${DefConfigureCPP:=\${CPP}} ; 
	local StrCFLAGS=${DefConfigureCFLAGS:=\${CFLAGS}} ;
	local StrCPPFLAGS=${DefConfigureCPPFLAGS:=\${CPPFLAGS}} ; 
	local StrCXXFLAGS=${DefConfigureCXXFLAGS:=\${CXXFLAGS}} ; 
	local StrNewConfigureOptFile=${DefConfigureOptFile:=${HOME}/.DefConfigureOption} ; 
	local StrNameConfigure=${DefConfigureName:=default} ;
	
	local CmdEval=( ./configure  ) ;
	
	function GetNameConfigureOption()
	{
			local ArrayArg=( $* ) ; 
			local __call_locality=( GetConfOpt ) ; 
			local Arg0=${ArrayArg[0]}; 
			local StrNameOption=${GetConfOptName:=default} ;
			local StrOptionFile=${GetConfOptFile:=${HOME}/.DefConfigureOption} ;
			local StrGrepSep=${GetConfOptSep:=:} ;
			local StrGrepPattern=${GetConfOptGrepPattern:=__PATTERN____SEP__} ;
			local StrGrepForm="${StrGrepPattern//__PATTERN__/${StrNameOption}}";
			StrGrepForm=${StrGrepForm//__SEP__/${StrGrepSep}} ; 
			local StrContent=$( cat ${StrOptionFile} | egrep -i ${StrGrepForm} | head -n 1 | cut -d ':' -f 2- ) ; 
			echo -ne "${StrContent}" ; 
	}
	local StrConfigureContentTest="" ;
	test -e ${StrOptionFile} && local StrConfigureContentTest=$( GetConfOptName=${StrNameConfigure} GetConfOptFile=${StrNewConfigureOptFile} GetNameConfigureOption ) ; 
	local StrConfigureContent=${StrConfigureContentTest:=--help} ; 
	#local StrConfigContent=$( test -e ${StrNewConfigureOptFile} && local CmdEval=( ./configure  ) ) ; 
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
	local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${ArrayArg[0]}" = "--help" ] ; then 
		GetVarReference DefaultConfigure ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	elif [ "${ArrayArg[0]}" == "${StrDefaultAction}" ] ; then 
		CmdEval=( ${CmdEval[@]} ${StrConfigureContent} ) ; 
		echo -ne "Configure option extracted: \n\t${CmdEval[@]}\n\n" > /dev/stderr ; 
		#eval """${CmdEval[@]}""" ; 
	elif [ "${ArrayArg[0]}" == "--add" ] ; then 
		echo -ne """Adding Configure Option Name:${StrNameOption}:\n\t\t\t${ArrayArg[@]:1:}\n""" > /dev/stderr ; 
		local StrExportSream="""${StrNameConfigure}:__configure__ ${ArrayArg[@]:1:} LD=\"${StrLD}\" LDFLAGS=\"${StrLDFLAGS}\" CXX=\"${StrCXX}\" CC=\"${StrCC}\" CPP=\"${StrCPP}\" CFLAGS=\"${StrCFLAGS}\" CPPFLAGS=\"${StrCPPFLAGS}\" CXXFLAGS=\"${StrCXXFLAGS}\" ${ArrayArg[@]:1:}""" ; 
		StrExportSream=${StrExportSream//__configure__/${StrNameOption}} ;
		echo -ne "Configure Command:\n\t${StrExportSream}\n" > /dev/stderr ; 
		#echo -ne "${StrExportSream//__configure__/${StrNameOption}}\n" >> ${StrNewConfigureOptFile} ; 
	elif [ "${ArrayArg[0]}" == "--update" ] ; then 
		echo -ne """Updating Configure Option:\n\t\t${ArrayArg[@]:1:}\n""" > /dev/stderr ; 
	elif [ "${ArrayArg[0]}" == "--remove" ] ; then 
		echo -ne """Removing Configure Option:\n\t\t${ArrayArg[@]:1:}\n""" > /dev/stderr ; 
	else
		echo -ne """Arg0 No option specified\n""" > /dev/stderr ; 
	fi

	
}

 ### IsPathName :
 ###
 ###
 ###	Full-length example : 
 ### Including 2 main definition
 ###
 ### - Return value:
 ### if the test success, it report number of element retain in grep filter. 
 ###  - it also return 0 in case of sucess and 1 if fail. 
 ### example: 
 ###
 ### - Return True on a test on Arg0 to be a path with appropriate sematic for current path. 
 ### IsPathName ./avfsd 
 ### -> return 0 
 ###
 ### IsPathNameAction=CurrentPath IsPathName ./avfsd 
 ### -> return 0 
 ###
 ### IsPathName /avfsd 
 ### -> return 1 # This is not a current path specified. 
 ###
 ### IsPathName IsPathNameAction=IsRootPath avfsd 
 ### -> return 1 # This is not a Rooted-path name.
 ###
 ### IsPathName IsPathNameAction=IsRootPath /avfsd 
 ### -> return 0 .
 ###
 ###


unset IsPathName 
function IsPathName()
{
		local __call_locality=( IsPathName );
		local ArrayArg=( $* ) ;
		local Arg0=${ArrayArg[0]}; 
		local ArgActionList=${IsPathNameActLst:=CurrentPath,IsRootPath}
		local RegActionList=${IsPathNameReglst:="^\.+\/"__SEP__"^\/"} ; 
		local StrAction=${IsPathNameAction:=CurrentPath} ; 
		local IntReturnValue=0 ; 
		local IntReturnState=0 ; 
		
		local ArrayActionList=( ${ArgActionList//,/ } ) ; 
		local ArrayRegExp=( ${RegActionList//__SEP__/ } ) ; 
		
		#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
		if [ "${ArrayArg[0]}" = "--help" ] ; then 
			IntReturnState=0 ;
			GetVarReference ${__call_locality[0]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
		else
			for(( intx=0 ; intx <= ${#ArrayActionList[@]]}-1 ; intx++ )) ; do 
			 local StrReg="${ArrayRegExp[${intx}]}" ;
			 local StrMainAction=${ArrayActionList[${intx}]} ; 
			 if [ "${StrAction}" == "${StrMainAction}" ] ; then 
					IntReturnValue=$( echo "${Arg0}" | egrep -ice "${StrReg}"	 2&>1 /dev/null ) ; 
			 fi 
			done 
		 if [ ${IntReturnValue:=0} -gt 0 ] ; then 
				IntReturnState=0 ;
			else
				IntReturnState=1 ;
			fi 
			
		fi 
		return ${IntReturnState} ;  
}



 ### GetOtherDate :
 ###
 ###
 ###	Full-length example : 
 ### Including Loop to create different day pattern
 ###
 ### hint:
 ### - Having to check 1 day before and 1 day after need to combine 
 ### settign GODReferenceFormat="__INT__ day" , and not "__INT__ day ago", give you positive forward in time
 ### setting GODIsLoop=True 
 ### setting GODLoop=-1,1 ( tricky but work ) , create interleave between -1 to 1, so it's -1 day in futur, 0 day in futur and 1 day in futur... 
 
 ### GODReferenceFormat="__INT__ day ago"  GODFormat="%Y%m%d" GODIsLoop=True GODLoop=1,4 GODVerbose=True  GetOtherDate
 ### Will display :
 ### 
 ### 20121010
 ### 20121011
 ### 20121012
 ###
 ### Short example :
 ### GetOtherDate
 ###
 ### Will display :
 ###
 ### 20121011
 ###
 ### GODReferenceFormat="__INT__ day ago"
 ###
 ###


unset GetOtherDate ;
function GetOtherDate()
{
		local __call_locality=( GOD GetOtherDate );
		local ArrayArg=( $* ) ; 
		local Arg0=${ArrayArg[0]}; 
		local StrDateUnitPattern=${GODDateUnitPatrn:=__DATEUNIT__};
		local StrDateUnitReference=${GODDateUnit:="day"};
		local StrDateFormat=${GODFormat:=%Y%m%d} ;
		local StrDateIndicatorFormat=${GODReferenceFormat:=__INT__ ${StrDateUnitPattern}};
  local IntDayDiff=${GODReference:=0} ; 
		local StrDateApps=${GODMainApp:=/bin/date} ; 
		local isLoop=${GODIsLoop:=False} ;
		local LoopRange=${GODLoop:=0,3} ;
		local IsVerbose=${GODVerbose:=False} ;
		local StrNameHelper="A way to get a date already marshalled" 
		
  		
		function Verbosis()
		{
			local __call_locality=( Verbosis Verbosis );
			local StrMsg=${VerbosisMsg:=__TEXT__} ; 
			local StrDevOut=${VerbosisDev:=/dev/stderr} ; 
			local ArrayArg=( $* ) ; 
			if [ "${VerboseState:=False}" == "True" ] ; then 
				echo -ne "VERBOSE:[ ${StrMsg} ]\n" > ${StrDevOut} ;
			fi
			
		}
		
		function DateFunc()
		{
			local __call_locality=( DateFunc DateFunc ) ;
			local ArrayArg=( $* ) ; 
			local StrEval="""${DateFuncApp} +"${DateFuncFormat:=%Y%m%d}" -d '${DateFuncIndicator}'""" ; 
			if [ "${DateFuncVerbose:=False}" == "True" ] ; then 
			 VerbosisMsg=${StrEval} VerboseState=${IsVerbose} Verbosis ;
			fi 
			eval ${StrEval}
		}
		
		### First Step, applying Incremental Unit to application Date:
		local StrDateIndicator=${StrDateIndicatorFormat} ;
		StrDateIndicator=${StrDateIndicator/${StrDateUnitPattern}/${StrDateUnitReference}} ;
		if [ "${isLoop:=False}" == "False" ] ; then 
			StrDateIndicator=${StrDateIndicator/__INT__/${IntDayDiff:=0}} 
		fi
		### Temporary debug removed after found the bug.
		### local StrDbg="Content of StrDateIndicator: [${StrDateIndicator}]\nContent of StrDateUnitReference: [${StrDateUnitReference}]" ; 
		### VerbosisMsg=${StrDbg} VerboseState=${IsVerbose} Verbosis ;
			
		#local StrDateIndicator=${StrDateIndicatorFormat/__INT__/${IntDayDiff:=0}}  ;
		#StrDateIndicator=${StrDateIndicator/${StrDateUnitPattern}/${StrDateUnitReference}} ;
		
		local ArrayRange=( ${LoopRange/,/ } ) ;
		local OperRange="<=" ;  
		local OperRangeIn="Intx++" ;
		local OperBaseStart=${ArrayRange[0]} ;
		local IntEndLoop=$(( ${ArrayRange[$((${#ArrayRange[@]}-1))]} ));
		

		#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  
 	if [ "${Arg0:=--start}" == "--help" ] ; then 
			GVRIsName=True StrNameHelper=${StrNameHelper} GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
	 else	 
	 	if [ "${isLoop:=False}" == "True" ] ; then 
	 	 local StrDebugMsg="ArrayRange, nb-element:${#ArrayRange[@]}, hold [ ${ArrayRange[@]} ]\n" ;
				VerbosisMsg=${StrDebugMsg} VerboseState=${IsVerbose} Verbosis  ;
				if (( ${ArrayRange[0]} > ${IntEndLoop} )) ; then 
					OperRange=">=" ;
					OperRangeIn="Intx--" ; 
					OperBaseStart=${ArrayRange[$((${#ArrayRange[@]-1))}]} ;
				fi		
				local StrDebugMsg="Looping from ${OperBaseStart} to ${IntEndLoop} \n" ;
	 		VerbosisMsg=${StrDebugMsg} VerboseState=${IsVerbose} Verbosis  ;
	 		for (( Intx=${OperBaseStart} ;  Intx ${OperRange} ${IntEndLoop} ; ${OperRangeIn} )) ; do 
		 			#StrDateIndicator="${StrDateIndicatorFormat/__INT__/${Intx}}" ; 
		 			local StrDateParsed=${StrDateIndicator};
		 			StrDateParsed=${StrDateParsed/__INT__/${Intx}} ;
		 			DateFuncVerbose=${IsVerbose} \
		 			DateFuncApp=${StrDateApps} \
		 			DateFuncFormat=${StrDateFormat} \
		 			DateFuncIndicator=${StrDateParsed} DateFunc ;
	 		done
	 	else 
 			DateFuncApp=${StrDateApps} \
 			DateFuncFormat=${StrDateFormat} \
	 		DateFuncIndicator=${StrDateIndicator} DateFunc ;
			fi
 	fi 
}



unset kill_cmd ; 
function kill_cmd()    
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( kill_cmd ) ;  
	local IntDefaultKillSig=${kill_cmdDefaultSigInt:=-9} ;
	local StrColDisplayInSearch=${kill_cmdPsColList:=pid,command}
	local IntNbCol=$(( $( echo "${StrColDisplayInSearch}" | wc -m ) - $( echo "${StrColDisplayInSearch//,/}" | wc -m ) ))
	local IntIdPassToKiller=${kill_cmdColIdToKill:=${IntNbCol}} ; 
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
	if [ "${ArrayArg[0]}" = "--help" ] ; then 
		GetVarReference ${__call_locality[0]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	else
		for (( x=0 ; x <= ${#ArrayArg[@]}-1 ; x++ )) ; do 
			local cmd=${ArrayArg[${x}]} ; 
			local PsResult=$( ps -eo ${StrColDisplayInSearch} | egrep -i "${cmd}" | grep -v grep | cut -d ' ' -f ${IntIdPassToKiller} | tr '[:cntrl:]' ' ' )
			CmdEval=( kill ${IntDefaultKillSig} ${PsResult} ); 
			echo -ne "PsResult:\n\n${PsResult}\n\n" > /dev/stderr ;
			echo -ne "Command Eval:[ ${CmdEval} ]\n" > /dev/stderr ; 
		done 
	fi 
}




unset StartApps
function StartApps()
{ 
 local ArrayArg=( $* ) ; 
 local __call_locality=( StartApps ) ; 
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${ArrayArg[0]}" = "--help" ] ; then 
		GetVarReference ${__call_locality[0]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 else	 
	 local AppsRefresh=${StartAppsRefresh:=4} ; 
	 local Apps=${StartAppsCmd:=rezound --audio-method=jack} ; 
	 local ScanApps=${StartAppsScan:=rezound} ; 
		local StrAppsStopSig=/home/${USER}/stop_${ScanApps}
	 local IsStopSig
		IsStopSig=$( test -e ${StrAppsStopSig} && echo 1 );
	 while [ ${IsStopSig:=0} -eq 0 ] ; do 
		local isApps=$( ps -eo pid,command | grep -v egrep | egrep -ic "${ScanApps}" ) ; 
		if [ ${isApp:=0} -eq 0 ] ; then 
		 eval ${Apps} ; 
		fi ; 
		sleep ${AppsRefres} ; 
			IsStopSig=$( test -e ${StrAppsStopSig} && echo 1 ) ;
	 done ; 
		rm -f ${StrAppsStopSig} ;
		echo -ne "Exiting signal catch for Application ${Apps} to cancel respawing.\n" > /dev/stderr 
 fi
}



function Survey_kill_apps()    
{ 
    function KillApps()
    {
        local __call_locality=( KillApps ) ; 
        local ArrayArg=( $* ) ; 
        kill -9 $( ps -eo pid,command | egrep -i "${ArrayArg[0]}" | grep -v "egrep" | sed 's/^[\ \t]*//g' | cut -d " " -f 1 )
    }
    local __call_locality=( SurveyApps ) ; 
    local ArrayArg=( $* ) ; 
		#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
		if [ "${ArrayArg[0]}" = "--help" ] ; then 
		 GetVarReference Survey_kill_apps ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
		else	 
		  local StrApps=${SurveyApps:=rezound} ; 
		  local IntDelay=${SurveyAppsRefresh:=4} ; 
		  while [ 1 ] ; do 
		      test -e /home/maxiste/kill_${StrApps} && \
		          rm -f /home/maxiste/kill_${StrApps} && \
		          KillApps ${StrApps} 
		      sleep ${IntDelay} ; 
		  done ; 
		fi
}



### Usefull for python installer using pip. 
### Happen more than once have to call pip with another gcc compiler while test failed to compile many source
### from Numpy numpy/linalg/lapack_litemodule.c and linalg/zlapack_lite.c failling or doing segmentation fault.
### Most of the time they can work compiling them direct from the shell but in bash script called from bash or
### python script like setup.py failed... 
### So I'm changing couple of variable and calling indivilually pip installer like this :
### Where cmd old followin value : cmd=( pip install __MODULE__ )
### eval $( DpkgGetInlineBuildFlags ) CC=/usr/bin/x86_64-linux-gnu-gcc-4.4 CXX=/usr/bin/x86_64-linux-gnu-g++-4.4 ${cmd[@]}

unset DpkgGetInlineBuildFlags ; 
function DpkgGetInlineBuildFlags()
{
  local __call_locality=( DpkgGetInlineBuildFlags ) ;
  local ArrayArg=( $* ) ;
		#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 	if [ "${ArrayArg[0]}" = "--help" ] ; then 
			GetVarReference ${__call_locality[0]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
 	else	 
  	local CmdEval=( "cat" "${DpkgGetInlineBuildFlagsPath:=/etc/dpkg/}"${DpkgGetInlineBuildFlagsFile:=buildflags.conf} "|" """sed -e 's/^\(SET\ \)\([a-zA-Z]*FLAGS\)\([\t\ ]*\)/\2=/g'""" "|" tr """'[:cntrl:]\' ' '""" ) ;
  	eval "${CmdEval[@]}" ;
	fi 

}


unset fast_dpkg_build ; 
function fast_dpkg_build()    
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( FDB ) ; 
	local StrOptionDpkgBuild=${FDBDpkgBuildOpt:=} ;
	local StrOptionDpkgInst=${FDBDpkgInstOpt:=} ;
	for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
		local StrPackage=${ArrayArg[${intx}]} ; 
		cd /usr/local/src/apt/ ; 
		md_cd $(pwd)/${StrPackage} ; 
		cd ${StrPackage} ; 
		local IntBuild=0 ; 
		apt-src install ${StrOptionDpkgInst} -p ${StrPackage} && apt-src ${StrOptionDpkgBuild} -p build ${StrPackage} && IntBuild=1 ; 
		echo -ne "\n\n\tBuild Status\n\t\titem : ${StrPackage}\n\t\tStatus: ${IntBuild}\n\n" ; 
		dpkg --install $( find ./ -type f -iname "*.deb" -printf "%p " ) ; 
	done ; 
}



unset DebianAptSrcCompiler ; 
function DebianAptSrcCompiler()
{
	local __call_locality=( DebianAptSrcCompiler ) ; 
	local ArrayArg=$( $* ) ; 
 local ArrayPackageName=( ${DebianAptSrcCompilerPackage//;/ } ) ;
	local CompilerVersion=${DebianAptSrcCompilerVersion:=4.4} ; 
	local StrAptProc=${DebianAptSrcCompilerPackageAptProc:=clean;install;build}
	local AddPatch=${DebianAptSrcCompilerPatch:=True} ;
	local ArrayAptSrcProc=( ${StrAptProc//;/ }  ) ; 
	local StrPatchOpt="" ; 
	local res_exec=0 ; 
	local StrPath=${DebianAptSrcCompilerPath:=/usr/local/src/apt} ;
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${ArrayArg[0]}" = "--help" ] ; then 
  GetVarReference ${__call_locality[0]} ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ; 			
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( __GetVarReferenceList ) ;
 else	 	
  if [ ${AddPatch:=True} == "True" ]; then 
   StrPatchOpt="-p" ;
  else
   StrPatchOpt="" ;
  fi 
 for Package in ${ArrayPackageName[@]} ; do 
  local old_dir=$( pwd )
  test ! -d ${StrPath}/${Package} && mkdir -p ${StrPath}/${Package} ;
  cd ${StrPath}/${Package} ; 
  apt-src update ;
  local UpdateState=$? ;
  if [ ${UpdateState:=0} -eq 0 ] ; then 
   echo -ne "\t\t----- Building -----\n\t\t\t${Package}\n\n" > /dev/stderr ; 
   for item in ${ArrayAptSrcProc[@]} ; do 
    echo -ne "\n\n\n\t\t----- APT-SRC STEP: -----\n\t\t\t${item}\n\n\n" > /dev/stderr ; 
    CC=${DebianAptSrcCompilerCBaseName:=/usr/bin/x86_64-linux-gnu-gcc-}${CompilerVersion} \
    CXX=${DebianAptSrcCompilerCXXBaseName:=/usr/bin/x86_64-linux-gnu-g++-}${CompilerVersion} \
    apt-src ${item} ${Package} ${StrPatchOpt} ; 
    res_exec=$? ; 
    echo -ne "\n\n\t\t-----------------\n\t\t Error Status: ${res_exec}\n\t\t-----------------\n\n" > /dev/stderr  ;  
   done ;
   else
    echo -ne "\n\n\t\t-------------------------------------------------------\n\t\t Error compilation/installation of ${Package}\n\t\t-------------------------------------------------------\n" > /dev/stderr 
   fi 
   cd ${old_dir}  ;
  done 
  fi
}

 ### AptRebuild :
 ### - Use script apt-src to commonly clean and build a debian source packages
 ###  being installed as source and it's ready to compile. This function uses 
 ###  the prefixed variable AptRebuildCommand to select any new order wanted to
 ###  pass to the function. 
 ###    - Commonly AptRebuildCommand is owning 'clean,build' but affecting it with 
 ###  other task like install and build can be substitued to this Common Task. 
 ###
 ###	Full-length example : 
 ### AptRebuildCommand=install,build AptRebuild libots-dev
 ###
 ### hint:
 ###  - switch '--help' is available for this function. 
 ### 
 ### 
 ### 
 
 ### Fixing a Predefined Association of Tag and Variable Name using the GetVarReference structure. 
 ### AptRebuild, may own it's own purposes by assigning to AptRebuildTagVar other variable and 
 ### other Tag inside AptRebuildTag prefixed var. meaning it can support 
 ###
 ###  following call : 
 ###    NewVar=Value AptRebuildTagVar=NewVar,Option,Package,StrAppsName,StrAppsOptExtr AptRebuildTag=__OTHERTAG__,__OPTION__,__PACKAGE__,__APPS__,__APPSOPT__ AptRebuild <package-module>, and will automatically parse the Variable NewVar into ${NewVar} (in this case it exist and will not overwrite the affected value.) into the Tag __OTHERTAG__. 
 ### 
 ###  This also need to change the AptRebuildExec Tag order to let it evaluate correctly. 
 ### 
 ### Use of Pre-Fixed Variable AptRebuildExec and AptRebuildTag. 
 ### 
 ### Description:
 ### - While this function is quite restricted, it's a mechanism that feed definition and will
 ### ultimately execute the sequence. Having a strong role inside AptRebuildCommand. the code 
 ### is structured like 1-finite loop of instruction and have to parse the commandline 
 ### defined inside AptRebuildExec and having others application being substitued you can
 ### create a virtual other command working inside this type of loop. 
 ### 
 ###  AptRebuildCommand hold 2 item : clean,build 
 ###  - where this variable fix the first command to own instruction for 'clean' and 'build' . 
 ###  - The Argument List after the  AptRebuild are the complete loop whitin First Fixed Element,
 ###  Variable -> Tag and execution . The case is tweaky, assuming eth0 and wlan0 are ultimately
 ###  the source being analysed with other condition , This one will pre-used eth0 and wlan0, 
 ###  to use the Forced Variable Package to hold eth0 or wlan0. This mean Package and 
 ### 
 ###  AptRebuildApps hold usually apt-src but in other case it may hold network-topology application
 ### being used. One popular, ifconfig. 
 ###  - In many uses ifconfig may also depend os some fixed instruction. like seeing the interface
 ### eth0 and wlan0 to verify both information. 
 ### 
 ### give as parameter : AptRebuildCommand=eth0,wlan0  AptRebuildApps=ifconfig 
 ### 
 ### AptRebuildExec and AptRebuildTag are also the order you want to use pre-defined 
 ### VAR -> __TAG__ substitution and the way the command exit depend of working example.
 ### 
 ### And there is 2 finite hard-fixed value to not remove because it hold in a double-loop value
 ### from iteration 
 ### for A ( Argument[ 0 - 15+ ] )
 ### 			 for B ( AptRebuildCommand ) 
 ### 					--- Parsing Level and Substitution Level --- 
 ### 
 ### - Also some basic prefixed value also own it's priority .
 ### AptRebuildAppsOption -> Internally used as StrAppsOptExtr will use the tag you defined but 
 ### need to be reflected inside the Tag-Loop Association. It will use 
 ### AptRebuildTag=__OPTION__,__PACKAGE__,__OTHEROPTION__ and use tag __OTHEROPTION__ is definied inside 
 ### AptRebuildTagVar, like :
 ### AptRebuildTagVar=Option,Package,StrAppsOptExtr AptRebuildTag=__OPTION__,__PACKAGE__,__OTHEROPTION__
 ### and commandline inside AptRebuildExec should reflect an __OTHEROPTION__ tag. 
 ### 
 ### AptRebuildApps -> Internally used as StrApps will own have to define it's own Tag too. 
 ### 
 ### 
 ### example : ifconfig eth0 -apr 
 ###  - To Set NOARP to your local ethernet card. 
 ###  
 ###  - And AptRebuildTag will look like this : 
 ###   AptRebuildCmdExec=False \
 ###   AptRebuildApps=ifconfig \
 ###   AptRebuildCommand=eth0,wlan0 \
 ###   AptRebuildAppsOption=-arp \
 ###   AptRebuildTag=__OPTION__,__PACKAGE__,__APPS__,__OTHEROPTION__ \
 ###   AptRebuildTagVar=Option,Package,StrAppsName,StrAppsOptExtr \
 ###   AptRebuildExec=__APPS__,__OPTION__,__OTHEROPTION__,__PACKAGE__  AptRebuild -v 
 ### 
 ### Will give a sequence to set -arp and verbosis to internet working interface:
 ### 
 ### AptRebuildCmdExec=False AptRebuildApps=ifconfig AptRebuildCommand=eth0,wlan0 AptRebuildAppsOption=-arp AptRebuildTag=__OPTION__,__PACKAGE__,__APPS__,__OTHEROPTION__ AptRebuildTagVar=Option,Package,StrAppsName,StrAppsOptExtr AptRebuildExec=__APPS__,__OPTION__,__OTHEROPTION__,__PACKAGE__  AptRebuild -v
 ### - Output
 ### 
 ###  	Processing eth0
 ### 
 ### CommandLine:[ ifconfig eth0 -arp -v ]
 ### 	Processing wlan0
 ### 
 ### CommandLine:[ ifconfig wlan0 -arp -v ]
 ### 
 ###  just by setting AptRebuildCmdExec=False to True will allow executing the sequence. 
 ### 
 ### 
 ### ... Just a good candidate for automation and generating corpus definition in variable transfert and
 ### Variable substitution. 
 

 ### AptSrcChange :
 ### 
 ### - Function AptSrcSourceChange, change the default /etc/apt/source.list and restitute it
 ### after coming back from the application apt-src. 
 ### -Note : apt-src is dependant from packages apt-src, and need to be installed with apt, dpkg
 ### and/or synaptic. 
 ### - It voluntary change the source.list until it was more convenient to alter the content
 ### of this file by replacing only debian information for package retrevial into debian-source
 ### package. It also change the type of architecture and it's convenient to leave and/or 
 ### adapt other application dependant from /etc/apt/source.list . 
 ### 
 ###  exemple : 
 ###   - synaptic depend from /etc/apt/source.list  
 ### using AptSrcChangeApps=synaptic AptSrcChange 
 ###  - and will load automatically synaptic after doing a change inside /etc/apt/source.list .  
 ###  - it will not do an automatic update. Like apt-src need to run periodically apt-src update
 ### to update it's cache, synaptic has this example show there is no update available as external 
 ### switch and the condition are not yet defined to supply a function for automatic-update. 
 ### ... while python module from apt and dpkg can re-update and write the cache it was not supply 
 ### here. 
 ### 
 ### 


 
unset AptSrcChange
function AptSrcChange()
{
 local __call_locality=( AptSrc ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ; 
 local IntUUID=$( uuidgen -t ) ; 
 local StrUUID="/tmp/${IntUUID}" ; 
 local StrApps=${AptSrcChangeApps:=/usr/bin/apt-src} ; 
 local StrAptSourceList=${AptSrcChangeFile:=/etc/apt/sources.list} ; 
 local StrAptSourceSave=${AptSrcChangeSave:=/etc/apt/sources.list.save} ; 
 local StrTagSearch=${AptSrcChangeTagSearch:=deb} ;
 local StrTagAdd=${AptSrcChangeTagChange:=deb-src} ;
 local StrDefaultArch=${AptSrcChangeArch:=amd64} ;
 local StrDefaultURI=${AptSrcChangeURIType:=http}
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${Arg0}" = "--help" ] ; then 
  GetVarReference ${__call_locality[0]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
		else	
  cp ${StrAptSourceList} ${StrAptSourceSave} ; 
  cat ${StrAptSourceList} | sed 's/^${StrTagSearch} ${StrDefaultURI}/${StrTagAdd} [ arch=${StrDefaultArch} ] ${StrDefaultURI}/g' > ${StrUUID} ; 
  cp ${StrUUID} ${StrAptSourceList} ; 
  echo -ne "\n\tUUID: ${StrUUID}\n" > /dev/stderr ; 
  if [ "${StrApps}" == "/usr/bin/apt-src" ]  ;then 
   # doing extra update 
   eval "${StrApps} update" ; 
  fi 
  eval "${StrApps} ${ArrayArg[@]}" ; 
  cp ${StrAptSourceSave} ${StrAptSourceList}
 fi
}

unset AptRebuild ; 
function AptRebuild()    
{ 
	local __call_locality=( AptRebuild ) ; 
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
	local StrCSVSep=${AptRebuildCSV:=,} ; 
	local StrAppsName=${AptRebuildApps:=apt-src} ; 
	local StrAppsOptExtr=${AptRebuildAppsOption:=-p} ; 
	local StrCmdLine=${AptRebuildExec:=__APPS__,__OPTION__,__APPSOPT__,__PACKAGE__} ; 
	local StrCmdTag=${AptRebuildTag:=__OPTION__,__PACKAGE__,__APPS__,__APPSOPT__}
	local StrCmdTagVar=${AptRebuildTagVar:=Option,Package,StrAppsName,StrAppsOptExtr}
	local IsShowDebug=${AptRebuildShowDebug:=False} ;
	local IsCmdExec=${AptRebuildCmdExec:=True} ;
	local StrCmdOption=${AptRebuildCommand:=clean,build} ; 
	cmdline=( ${StrCmdLine//${StrCSVSep}/ } ) ; 
	
	local ArrayTag=( ${StrCmdTag//${StrCSVSep}/ } ) ; 
	local ArrayOption=( ${StrCmdOption//${StrCSVSep}/ } ) ; 
	local ArrayOptionVar=( ${StrCmdTagVar//${StrCSVSep}/ } )
	
	
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
	if [ "${Arg0}" = "--help" ] ; then 
		GetVarReference ${__call_locality[0]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	else	 
		for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
			Package=${ArrayArg[${intx}]} ; 
			for (( intAx=0 ; intAx <= ${#ArrayOption[@]}-1 ; intAx++ )) ; do
				local Option=${ArrayOption[${intAx}]} ;
				echo -ne "\tProcessing ${Option}\n" > /dev/stderr
				local CmdExec=( ${cmdline[@]} ) ; 
				
				for (( intCx=0 ; intCx <= ${#ArrayOptionVar[@]}-1 ; intCx++ )) ; do 
					local tagName=${ArrayTag[intCx]} ; 
					local varName=${ArrayOptionVar[intCx]} ; 
					eval """local NewVarValue=\${${varName}}""" ; 
					if [ "${IsShowDebug}" == "True" ] ; then 
						echo -ne "\t\ttagName: ${tagName}\n\t\tvarName: ${varName}\n\t\tValue: ${NewVarValue}\n" > /dev/stderr ; 
					fi
					eval """CmdExec=( ${CmdExec[@]//${tagName}/${NewVarValue}} )""" ; 
				done 
				echo -ne "\nCommandLine:[ ${CmdExec[@]} ]\n" > /dev/stderr ; 
				if [ ${IsCmdExec:=True} == "True" ] ; then 
					eval ${CmdExec[@]} ; 
			  fi
			done
		done
	fi 
}



function find_edit_file()
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( FEF find_edit_file ) ; 
	local StrPath=${FEFDefaultPath:=./} ;
	local StrAppsFind=${FEFAppsFind:=/usr/bin/find} ;
	local StrEditor=${FEFEditorApps:=/usr/bin/gedit} ;
	local StrFindFilterOpt=${FEFFindFilter:=-iname \"__FILE__\"} ;

		#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 	if [ "${ArrayArg[0]}" = "--help" ] ; then 
			GetVarReference find_edit_file ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
 	else	
		for file in ${ArrayArg[@]} ; do 
			local StrFilterInFind=${StrFindFilterOpt//__FILE__/${file}}
			eval "${StrAppsFind} ${StrPath} -type f ${StrFilterInFind} -exec ${StrEditor} {} \;" & 
		done ; 
	fi
}

### Usefult having clause with many compiler available and having h2xml or ctag path filtering to apply,
### having command like 
###
### -> h2xml /usr/include/math.h $( find /usr/include/ -type d -printf "-I%p " ) -c -o math_c.xml 
###	 Will reduce output of some treatment... 
###  ->>>
###  ->>>CompilerError: In file included from /usr/include/math.h:34,
###  ->>>                 from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/x86_64-linux-gnu/bits/huge_val.h:28:18: error: missing binary operator before token "("
###  ->>>/usr/include/x86_64-linux-gnu/bits/huge_val.h:30:20: error: missing binary operator before token "("
###  ->>>In file included from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/math.h:403:42: error: missing binary operator before token "("
###  ->>>In file included from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/math.h:30: error: '__BEGIN_DECLS' does not name a type
###  ->>>In file included from /usr/include/math.h:71,
###  ->>>                 from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: '__' was not declared in this scope
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: 'acos' was not declared in this scope
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: '__CONCAT' cannot be used as a function
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: expected primary-expression before ')' token
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: initializer expression list treated as compound expression
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: expected ',' or ';' before '(' token
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:57: error: redefinition of 'double __CONCAT'
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: 'double __CONCAT' previously defined here
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:57: error: 'asin' was not declared in this scope
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:57: error: expected primary-expression before ')' token

###
###
###


unset FindFilterPathExclusion
function FindFilterPathExclusion()    
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( FindFilterPathExclusion ) ; 
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 	if [ "${ArrayArg[0]}" = "--help" ] ; then 
			GetVarReference ${__call_locality[0]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
 	else	 

		### 
		### The chainning mechanism , if there is already used filter, passing thru this 
		### variable will add-it to current filter output. 
		local CurrentExlusion=${FindFilterPathKnowExclusion:=""} ; 
	
		###
		###
		###
		local SelectedPackagePath=${FindFilterPathName:="c++"} ; 

		### - Will tell to filter function if this segment should be considered as
		### first statement and in-middle statement... 
		### example, using FindFilterWithStartCond=True, for a clause for find to start adding -a ! -name "..." 
		### in first statement of if will give command like 
		### find -type d [ -a ! -name "c++/4.4" ] <--- current filter . 
		### will simply be rejected or some warning may issued from . 

		local StartFilterWithCondition=${FindFilterWithStartCond:=False};
		local StrFilterPattern="${FindFilterPattern:=NAME/VER}";
		### 	The FindFilterClause should be written like from Removing To adding
		###   ex: with find, having removing or excluding pattern start like -a ! -name or -o ! -iname ...
		###       and adding or positive filter will include -a name, -o name ... 
		###   and FindFilterClause should be written as : FindFilterClause="-a ! -name,-a name"
		local StrConditionPattern=${FindFilterClause:=! -name, -name}

		local StrTypeOfLogicForAnd=${FindFilterClauseAnd:=-a};
		local StrTypeOfLogicForOr=${FindFilterClauseAnd:=-o};
		local StrLogic=""
		### FindFilterLogicSetTo default choice : ( And / Or )
		### 
		###

		local DefaultLogic=${FindFilterLogicSetTo:=And}; 
		if [ "${DefaultLogic}" == "And" ] ; then
			StrLogic="${StrTypeOfLogicForAnd}" ;
		else
			StrLogic="${StrTypeOfLogicForOr}" ;
		fi 

		local ArrayClauseFilter ;
		for(( intx=1 ; intx <= 2 ; intx++ )) ; do 
			ArrayClauseFilter[${#ArrayClauseFilter[@]}]=$( echo "${StrConditionPattern}" | cut -d "," -f ${intx} ) ;
		done 
	

		local SelectedMajor=${FindFilterMajorVer:=4} ; 
		local SelectedMinor=${FindFilterMinorVer:=4} ; 
		local TypeClauseFilter=0 ;
		for (( intx=${FindFilterMinMajorVer:=0} ; intx <= ${FindFilterMaxMajorVer:=9} ; intx++ )) ; do 
			local StrCriteronFilter=${StrFilterPattern};
			local StrCriteronFilterPrefix="";
				StrCriteronFilter=${StrCriteronFilter/NAME/${SelectedPackagePath}} ;
				StrCriteronFilter=${StrCriteronFilter/VER/${SelectedMajor}.${intx}} ;

			if [ ${intx} -ne ${SelectedMinor:=0}  ] ; then 
				TypeClauseFilter=0 ;
				if [ "${StartFilterWithCondition}" == "True" ] ; then 
					StrCriteronFilterPrefix="${StrLogic} 1${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				else
					StrCriteronFilterPrefix="2${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				fi ;
			fi		

			if [ ${intx} -eq ${FindFilterMinMajorVer:=0} ] ; then 
				TypeClauseFilter=${TypeClauseFilter} ;
				if [ "${StartFilterWithCondition}" == "True" ] ; then 
					StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				else
					StrCriteronFilterPrefix="${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				fi ;
			else
				if [ "${StartFilterWithCondition}" == "False" ] ; then 
					StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				else
					StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				fi ;
			
			fi


			if [ ${intx} -eq ${SelectedMinor:=0} ] ; then 
				TypeClauseFilter=1 ;
				if [ "${StartFilterWithCondition}" == "True" ] ; then 
					StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} ${StrCriteronFilter}" ;
				else
					if [ ${intx} -eq ${FindFilterMinMajorVer:=0} ] ; then 
						StrCriteronFilterPrefix="${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
					else
						StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[1	]} \"${StrCriteronFilter}\"" ;				
					fi
				fi ;
			fi
			CurrentExlusion="${CurrentExlusion} ${StrCriteronFilterPrefix}" ;
		done
		echo -ne "${CurrentExlusion}" ; 
	fi 
}


unset acquire_lan_ifconfig
function acquire_lan_ifconfig()
{
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ; 
 local __call_locality=( AWI ) ; 
 local StrDefaultCard=${AWICardName:=wlan0} ;
 local StrAppsNetConf=${AWIAppsIfconf:=/sbin/ifconfig} ; 
 local StrAwkFilter=${AWIAwkScript:=${FNCTDLIBPATH}/awk-script/ifconfig_tag_detection.awk} ; 
 local StrTagNameList=${AWIAwkTagInspect:=HWaddr,inet addr,inet6\ addr};
 
 function IfconfigGetter()
 {
  local ArrayArg=( $* ) ; 
  local __call_locality=( IfconfigGetter ) ;
  local StrOptGetter=${IfconfigGetterAddr:=local} ; 
  local StrApps=${IfconfigGetterApps:=/sbin/ifconfig} ; 
  $( eval ${StrApps} ${StrOptGetter} | tr '[:cntrl:]' ' ' | sed 's/[\ ]\+/ /g' ) ; 
 }
 function GetIpaddr()
 {
  local ArrayArg=( $* ) ; 
  local __call_locality=( GetIpaddr ) ;
  local StrAddr=${GetIpaddrAddr:=local} ; 
  local StrAppsIfconfig=${GetIpaddrAppsIfconfig:=/sbin/ifconfig} ;
  local StrAwkFilter=${GetIpaddrFilterMatch:=/etc/init.d/Fnct.D/awk-script/ifconfig_tag_detection.awk} ;   
  local StrTagList=${GetIpaddrTagList:=HWaddr,inet addr,inet6\ addr} ; 
  local StrTagCleanFilter=${StrTagList//\\ / } ;
  local StrReturn=$( IfconfigGetterApps=${StrAppsIfconfig} IfconfigGetterAddr=${StrAddr} IfconfigGetter awk -vTagName="${StrTagCleanFilter}"  -f StrAwkFilter ) ; 
  
 }
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
	if [ "${Arg0:=--start-services}" = "--help" ] ; then 
		GetVarReference acquire_lan_ifconfig ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	elif [ "${Arg0:=--start-services}" == "--start-services" ] ; then 
  GetIpaddrTagList=${StrTagNameList} \
  GetIpaddrAppsIfconfig=${StrAppsNetConf} \
  GetIpaddrAddr=${StrDefaultCard} \
  GetIpaddr ; 
 fi 
}


unset GetBuildFlagsList
function GetBuildFlagsList( )
{
		local ArrayArg=( $* ) ; 
		local __call_locality=( ZPI ) ;  
		dpkg-buildflags --list | tr '[:cntrl:]' ' ' 
} 


unset GetZenityText ; 
function GetZenityText()
{
	local ArrayArg=( $* ) ; 
	local __call_locality=( GZT GetZenityText ) ;  
	local Arg0=${ArrayArg[0]} ;
	local StrTypeUI=${GZTUiType:=--entry}
	local StrApps=${GZTUiApps:=/usr/bin/zenity} ;
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
	if [ "${Arg0:=--startservices}" == "--help" ] ; then 
		GetVarReference ${__call_locality[1]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	else
		eval ${StrApps} ${StrTypeUI} ${ArrayArg[@]} ;
	fi 
}



unset GetZenityTextEntry ; 
function GetZenityTextEntry()
{
	local ArrayArg=( $* ) ; 
	local __call_locality=( GZTE GetZenityTextEntry ) ;  
	local Arg0=${ArrayArg[0]} ;
	local IntWidth=${GZTEWidth:=640}
	local IntHeight=${GZTEHeight:=275}
	local StrTitle="""${GZTETitle:="Pip installation Try-up"}""" ; 
	local StrQuestion="""${GZTETextQuestion:="Installation Package to install (test)"}""" ; 
	local StrReturn ;
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
		if [ "${Arg0:=--startservices}" == "--help" ] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
		else
			local CmdEval=( """local StrReturn=\$( GetZenityText --width=${IntWidth}  --height=${IntHeight} --title="${StrTitle}" --text="${StrQuestion}" ) """ ); 
			echo -ne "\n\nCmdEval : ${CmdEval[@]}\n\n" > /dev/stderr ; 
		fi 
		echo -ne "StrReturn return: ${StrReturn}\n" > /dev/stderr ; 
		echo -ne "${StrReturn}" ; 
}



unset zenity_pip_installer ; 
function zenity_pip_installer()    
{ 
	
		local ArrayArg=( $* ) ; 
		local __call_locality=( ZPI ) ;  
		local pkg_res=0 ; 
		function GetItemFlags()
		{
			local ArrayArg=( $* ) ; 
			local __call_locality=( GIF ) ;  
			dpkg-buildflags --get ${ArrayArg[0]} ;
		}
		
		while [ ${pkg_res:=0} -eq 0 ] ; do 
		local ADDFLAGS="" ; 
		local package=$( GetZenityTextEntry ) ; 

		for Item in $( GetBuildFlagsList ) ; do 
			local newFlags=$( GetItemFlags ${Item} ) ;
			ADDFLAGS="${ADDFLAGS} ${Item}=\"${newFlags}\"" ; 
		done  ; 
		echo -ne "ADDFLAGS:\n${ADDFLAGS}\n" ; 
		if [ ${package:=none} != "none"  ] ; then 
			eval ${ADDFLAGS} pip install ${package} ; 
		else 
			echo -ne "\n\n\t\tError reporting package: ${package:=none}\n\n" ; 
			sleep 10 ; 
			pkg_res=1 ;  
		fi ; 
		done ; 
}

unset ZenityContentListing ; 
function ZenityContentListing( )
{
	local __call_locality=( ZCL ZenityContentListing ) ; 
	local ArrayArg=( $* ) ; 
 local Arg0=( ${ArrayArg[0]} ) ;

 local StrTitle=${ZCLTitle:="Select a user for __APPS__"} ;
	local StrCol0=${ZCLCol0:="selection"} ;
	local StrCol1=${ZCLCol1:="user"} ; 
 local StrDefaultCSV=${ZCLCSV:=':'} ;
 local IntDefaultColExtr=${ZCLColExtr:=1} ;
 local StrFileInfo=${ZCLFilePasswd:=/etc/passwd} ;
	local StrRegSearch=${ZCLRegSearch:="\/bin\/bash"} ;
	local BoolShowUserSelection=${ZCLSUS:=False} ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n" ;
  
 ### Uses current variable 
 ### StrRegSearch,StrFileInfo,StrDefaultCSV,IntDefaultColExtr
 ### 
 function ZenityFilter()
	{
  local __call_locality=( ZF ZenityFilter ) ; 
  local ArrayArg=( $* ) ; 
  local Arg0=( ${ArrayArg[0]} ) ;			
  egrep -i ${StrRegSearch} \
  ${StrFileInfo} | \
    /usr/bin/cut \
    -d ${StrDefaultCSV} \
    -f ${IntDefaultColExtr} |\
       sed  's/\(^[a-zA-Z0-9]*\)/FALSE \1/g' ; 
	}
	
 ### Uses current variable 
 ### StrTitle,StrCol0,StrCol1,StrDefaultCSV,StrFileInfo,StrRegSearch,IntDefaultColExtr,StrUser,BoolShowUserSelection,,,
 ### 
 function GetPwdUser()
	{
  local __call_locality=( GPU GetPwdUser ) ; 
  local ArrayArg=( $* ) ; 
  local Arg0=( ${ArrayArg[0]} ) ;		
  local StrUserSelection=$( zenity \
  --list \
  --title "${StrTitle}" \
  --column="${StrCol0}" \
  --column="${StrCol1}" \
  --radiolist $( StrDefaultCSV=${StrDefaultCSV} \
                 StrFileInfo=${StrFileInfo} \
                 StrRegSearch=${StrRegSearch} \
                 IntDefaultColExtr=${IntDefaultColExtr} \
                 ZenityFilter ) ) ;
		StrUserSelection=${StrUserSelection:=${StrUser}} ; 
		if [ "${BoolShowUserSelection}" == "True" ] ; then 
			echo -ne "User selected: ${StrUserSelection}\n" > /dev/stderr ; 
		fi 
		echo "${StrUserSelection}" ; 
	}

 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ; 
		local Arg0=${ArrayArg[0]} ; 
		local ArrayArg=( $* ) ; 
  
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrRegSearch,StrFileInfo,StrDefaultCSV,IntDefaultColExtr,StrTitle,StrCol0,StrCol1,StrDefaultCSV,StrFileInfo,StrRegSearch,IntDefaultColExtr,StrUser,BoolShowUserSelection \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) GetPwdUser
  
 }
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrTitle,StrCol0,StrDefaultCSV,IntDefaultColExtr,StrFileInfo,StrRegSearch,BoolShowUserSelection \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StartServices
	fi
 
}


unset GkSuZenityLoader ; 
function GkSuZenityLoader()
{
	local __call_locality=( GSZL GkSuZenityLoader ) ; 
	local ArrayArg=( $* ) ; 
 local Arg0=( ${ArrayArg[0]} ) ;

	local StrUser=${GSZLUser:=none}
	local StrApps=${GSZLApps:=/usr/local/bin/idlex}
	local StrAppsOpt=${GSZLAppsOpt:=''} ;
	local StrTitle=${GSZLTitle:="Select a user for Idlex"} ;
	local StrFileInfo=${GSZLFile:=/etc/passwd} ;
	local StrCol0=${GSZLCol0:="selection"} ;
	local StrCol1=${GSZLCol1:="user"} ;
	local StrRegSearch=${GSZLRegSearch:="\/bin\/bash"}
	local StrDefaultCSV=${GSZLCSV:=':'} ;
	local IntDefaultColExtr=${GSZLColExtr:=1} ;
	local BoolShowUserSelection=${GSZLSUS:=False} ;
 local BoolUpdateLdconfig=${GSZLUpdadeLdconfig:=True} ;
 local StrLdConfigUser=${GSZLLdconfigUser:=root} ;
 local StrLdconfigGreeting=${GSZLLdconfigGreeting:='\n\nHint\nLoading ldconfig on need if some module require to be loaded from ldconfig ( ex: from pip installation or easy_setup.py ) It can be accessible thru Prefixed-var GSZLUpdadeLdconfig=True from GkSuZenityLoader.\n\n'}
	local BoolShowFGSZ=${GSZShowFuncGSZ:=True} ; 
   
 function NotificationLdConfig()
 {
		local __call_locality=( NLC NotificationLdConfig ) ; 
		local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ;
  
  local StrTextNotification=${NLCNotifyText:=You will be prompted for password to load __APPS__ with __APPS__ user allowed: __USER__} 
  local StrUser=${NLCAppsUser:=root} ; 
  local StrApps=${NLCAppsName:=ldconfig} ; 
  local StrTagUser=${NLCTagUser:=__USER__} ;
  local StrTagApps=${NLCTagApps:=__APPS__} ;
  StrTextNotification=${StrTextNotification//${StrTagUser}/${StrUser}} ;
  StrTextNotification=${StrTextNotification//${StrTagApps}/${StrApps}} ;
  
  zenity --notification --text="${StrTextNotification}" ; 
 }
 
 function ScreenDisplayLdconfigHint()
 {
		local __call_locality=( SDLH ScreenDisplayLdconfigHint ) ; 
		local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ;
  
  echo -ne "${StrLdconfigGreeting}" > /dev/stderr ; 
 }
 
 function LdconfigNotification()
 {
		local __call_locality=( LN LdconfigNotification ) ; 
		local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ;
  NotificationLdConfig ; gksu --user ${StrLdConfigUser} ldconfig
 }
 
	function Loader()
	{
		local __call_locality=( Loader Loader ) ; 
		local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ; 
  eval $( BVTestVarName=StrAppsLd \ 
          BVTestVarHold='StrLdconfigGreeting='${StrLdconfigGreeting}' ScreenDisplayLdconfigHint' \
          BVTestBoolVarName=\${BoolUpdateLdconfig} \
          BVTestBoolCase=True \
          BVTestBoolAssertion='LdconfigNotification' \
          BVTestScopeTest=local \
          BoolVarTestVarCreation ) ; 
  eval $( BVTestVarName=StrLdConfigLoad \
          BVTestVarHold='$( eval ${StrAppsLd} )' \
          BVTestBoolVarName=\${BoolUpdateLdconfig} \
          BVTestBoolCase=True BVTestBoolAssertion='$( eval ${StrAppsLd} )' \
          BVTestScopeTest=local \
          BoolVarTestVarCreation ) ; 
		gksu --user ${StrUser} ${StrApps} ${StrAppsOpt} 
	}
 
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
 
  #local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;   
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  if [ "${StrUser:=none}" ==  "none" ] ; then 
   StrUser=$( ZCLCSV=${StrDefaultCSV} \
      ZCLColExtr=${IntDefaultColExtr} \
      ZCLFilePasswd=${StrFileInfo} \
      ZCLTitle=${StrTitle} \
      ZCLCol0=${StrCol0} \
      ZCLCol1=${StrCol1} \
      ZCLRegSearch=${StrRegSearch} \
      ZCLSUS=${BoolShowUserSelection} ZenityContentListing ) ; 
  fi 
  if [ "${StrUser:=none}" == "none" ] ; then 
   echo -ne "Warning Invalid user: ${StrUser}\n" > /dev/stderr ; 
  else
   StrUser=${StrUser}                         \
   StrApps=${StrApps}                         \
   StrAppsOpt=${StrAppsOpt}                   \
   StrLdConfigUser=${StrLdConfigUser}         \
   BoolUpdateLdconfig=${BoolUpdateLdconfig}   \
   StrLdconfigGreeting='${StrLdconfigGreeting}' \ 
   Loader ;
  fi 
  
 }
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
			StrUser=${StrUser}                       \
   StrApps=${StrApps}                       \
   StrAppsOpt=${StrAppsOpt}                 \
   StrLdConfigUser=${StrLdConfigUser}       \
   BoolUpdateLdconfig=${BoolUpdateLdconfig} \
   __main_StartServices
	fi
}

unset UUIDHelper 
function UUIDHelper()
{
	local __call_locality=( UUIDH UUIDHelper ) ;
	local StrDefaultSwitches=${UUIDHSwitches:=-t}
 local StrDefaultApps=${UUIDHApps:=/usr/bin/uuidgen} ;
 local IsVerbosis=${UUIDHVerbose:=False} ; 
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
	#local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  local CmdEval="${StrDefaultApps} ${StrDefaultSwitches}"	; 
  if [ "${IsVerbosis:=False}" == "True" ] ; then
   echo -ne "UUIDHelper:\n__main_StartServices:\nCMD:[${CmdEval}]\n" > /dev/stderr ; 
  fi 
  eval "${CmdEval}" ; 
 }
  
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;	
	else
  eval $( VTVIsArrayStyleInsert=True VTVIsValueReAssign=True VTVIsValueToConvert=False \
  VTVValueEntry=IsVerbosis,StrDefaultSwitches,StrDefaultApps ValueToVariable ) __main_StartServices 
	fi 
} 


 ### Notice : ca66ef20-e187-11e5-98a2-001e4c8856d6
 ### In near future, usues of GetUUID will be subject to a permanent survery this one 
 ### will be called, both a mechanism of storage, view and cleaning will be hook to this
 ### function, aka MD_CD. MD_CD have possibility to store creation date of path. wheres 
 ### some successive development will lead to read the file and or media invested for 
 ### storage of this information. This will also appear inside GetUUID and integrity
 ### test of the helper will reveal to start the storage. Future definition will start
 ### testing if GetUHelperName is UUIDHelper to start the storage and collection of information.
 ### This notice did not mention if new development will imply uses of sqlite for MD_CD
 ### data storage and shallow not mention if this GetUUID will either get one two storage 
 ### method. A basic work based on file collection will start be will probably move to 
 ### sqlite to render data parsible thru other tools to observe uses of this function. 
 ### 
 ### Notice : 282b59c0-e188-11e5-98a2-001e4c8856d6
 ### Will also invite to uses the Helper directly if some other alternative are inquirying 
 ### the uses of UUID. Goal of GetUUID is also to aggregate a function UUIDRegistration 
 ### which uses of BodyFunct will depend on. Other alternative like ShortRegistration of 
 ### Pattern, variable-set will also own it's registration . 

unset GetUUID 
function GetUUID ()
{
	local __call_locality=( GetU GetUUID ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
	local BoolTimeBased=${GetUTimeBased:=True}
 local BoolLoop=${GetULoop:=False} ;
 local IntSeqLoop=${GetUSeq:=1} ; 
 local StrGetHelperName=${GetUHelperName:=UUIDHelper} ;
 local StrUUIDHelperStream=${GetUHelper:=UUIDHApps= UUIDHSwitches= __HELPERNAME__} ; 
 local TypeAppsName=${GetUAppsDef:=__HELPERNAME__ --get UUIDHApps}
 local StrUUIDActionName=${GetUActionFunc:=UUIDNoLoop,UUIDLoop} ;
 local IsVerbosis=${GetUVerbosis:=False} ;
 local IsUUIDDbCreation=${GetUDBCreation:=False};
 local IsUUIDDbImport=${GetUDbImport:=False};
 local StrDbURI=${GetUDBPath:=/var/cache/fnct.D/db/sqlite/GetUUID.sqlite}
 local StrDbSchema=${GetUDBSchema:=/etc/init.d/Fnct.D/getUUID.schema}
 local BoolCallRegistered=${GetUIDRegister:=False}; 
 local StrAppsRegister=${GetUAppsRegisterName:=None};
 local StrUUIDIndexName=${GetUIDName=.GetUUID};
 local StrAppsNameCall=${TypeAppsName//__HELPERNAME__/${StrGetHelperName}} ; 
 local StrAppsName=$( ${StrAppsNameCall} ) ; 

 function ApplicationRegistrationIndex()
 {
	 local __call_locality=( ARI ApplicationRegistrationIndex ) ;
	 local ArrayArg=( $* ) ; 
	 local Arg0=${ArrayArg[0]} ;
 
  
 }

	function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local VerboseState=${VerbState:=False} ;
		local ArrayArg=( $* ) ; 
		if [ "${VerbState:=False}" == "True" ] ; then 
			echo -ne "VERBOSE:[ ${StrMsg} ]\n" > ${StrDevOut} ;
		fi
	}
 ArrayMsg[1]="UUID StrAppsName: ${StrAppsName}" ; 
 VerbState=${IsVerbosis} VerbMsg=${ArrayMsg[1]} Verbosis;

 StrUUIDHelperStream=${StrUUIDHelperStream//__HELPERNAME__/${StrGetHelperName}} ;
 StrUUIDHelperStream=${StrUUIDHelperStream//UUIDHApps=/UUIDHApps=${StrAppsName}} ; 
 
	#local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 
 function UUIDNoLoop()
 {
   #eval $( ${StrUUIDHelper} ) ;
   local StrMsg="UUID HELPER: ${StrUUIDHelper}" ;
   VerbState=${IsVerbosis} VerbMsg=${StrMsg} Verbosis;
   eval ${StrUUIDHelper} ;
 }
 
 function UUIDLoop()
 {
  local ArrayMsg=( ) ;
  ArrayMsg[0]="UUID LOOPSEQ: ${IntSeqLoop}";
  ArrayMsg[1]="UUID HELPER: ${StrUUIDHelper}\n" ;
  
  VerbState=${IsVerbosis} VerbMsg=${ArrayMsg[0]} Verbosis;
  for (( intX=0 ; intX <= $(( ${IntSeqLoop}-1 )) ; intX++ )) ; do
   VerbState=${IsVerbosis} VerbMsg=${ArrayMsg[1]} Verbosis;
   eval ${StrUUIDHelper} ;
  done 
 }
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  local IntUUIDHelperIndex=0 ;
  local StrUUIDOption="" ;
  local StrUUIDHelper=""
  local StrAction=""
  local ArrayMsg=( ) ;
  ### Array conversion from StrUUIDActionName, using string delimiter char ',' ; 
  local ArrayUUIDAction=( ${StrUUIDActionName//,/ } ) ; 
  local IntUUIDActionIndex=0 ; 

  if [ "${BoolTimeBased:=True}" == "True" ] ; then 
   StrUUIDOption="-t"
  else 
   StrUUIDOption="-r"
  fi 
  StrUUIDHelper=${StrUUIDHelperStream} ; 
  StrUUIDHelper=${StrUUIDHelper//UUIDHSwitches=/UUIDHSwitches=${StrUUIDOption}}  ;
  #StrUUIDHelper=$( eval ${StrUUIDHelperStream} ) ; 
  ArrayMsg[1]="UUID __main_StartServices: content of StrUUIDHelper:[${StrUUIDHelper}]" ; 
  VerbState=${IsVerbosis} VerbMsg=${ArrayMsg[1]} Verbosis;
  #echo -ne "[UUID __main_StartServices: content of StrUUIDHelper:[${StrUUIDHelper}]]\n" > /dev/stderr 

  if [ "${BoolLoop:=False}" == "True" ] ; then 
   IntUUIDHelperIndex=1 ;
   IntUUIDActionIndex=1 ; 
  else 
   IntUUIDHelperIndex=0 ; 
   IntUUIDActionIndex=0 ; 
  fi 
  StrAction=${ArrayUUIDAction[${IntUUIDActionIndex}]} ; 
  ArrayMsg[2]="UUID ACTION: ${StrAction}" ; 
  VerbState=${IsVerbosis} VerbMsg=${ArrayMsg[2]} Verbosis;
  #echo -ne "[UUID ACTION: ${StrAction}]\n" > /dev/stderr  ;
  eval $( VTVIsArrayStyleInsert=True \
          VTVIsValueReAssign=True \
          VTVIsValueToConvert=False \
          VTVValueEntry=IsVerbosis,StrAction,StrUUIDHelper,IntSeqLoop ValueToVariable ) ${StrAction} ; 
 } 
 
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;	
	else
  eval $( VTVIsArrayStyleInsert=True \
          VTVIsValueReAssign=True \
          VTVIsValueToConvert=False \
          VTVValueEntry=IsVerbosis,BoolTimeBased,BoolLoop,IntSeqLoop,StrGetHelperName,StrUUIDHelperStream,StrUUIDActionName ValueToVariable ) __main_StartServices 
	fi 

}


### Function : GetMplayerStream()
### 
### - Filter out selected stream from Firefox browser on Ubuntu/Mint and kill active stream to get only the 
### http - stream url and load itself with mplayer... Assuming the Browser openning the stream with mplayer...
### 
### Initial idea : ps -eo pid,command | egrep -i "mplayer" | egrep "http:\/\/" | awk 'BEGIN{stream="";}{printf("%s %s\n",$1,$(NF)) ; system(sprintf("kill -9 %s",$1)); stream=$(NF); }END{ system(sprintf("mplayer -ao alsa -cache 3072 %s",stream)) }'
### ... but how ingeneer see a tire over a Tree for child use... 
### 
### 

unset GetMplayerStream
function GetMplayerStream()
{
	local ArrayArg=( $* ) ; 
	local __call_locality=( GetMplayerStream ) ;
	local StrAwkPath=${GetMplayerStreamAwkPath:=/etc/init.d/Fnct.D/awk-script/} ;
	local StrAwkScriptName=${GetMplayerStreamScriptName:=MplayerStreamTransfert.awk}
	local StrAwkApps=${GetMplayerStreamAwkApps:=/usr/bin/awk} ;
	local StrGrepApps=${GetMplayerStreamGrepApps:=/bin/egrep};
	local StrGrepOpt=${GetMplayerStreamGrepOpt:=-i};
	local StrPsOpt=${GetMplayerStreamPsOpt:=-eo pid,command};

	local StrPsApps=${GetMplayerStreamPsApps:=/bin/ps};
	local StrUrlGrep=${GetMplayerStreamUrlGrep:="http:\/\/"};
	local StrPlayerName=${GetMplayerStream:=mplayer};
	local Arg0=${ArrayArg[0]} ;
	
	function GetStreamFromPs()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( GetStreamFromPs ) ;
		local StrAppsName=${GetStreamFromPsApps:=/bin/ps} ;
		local StrAppsOpt=${GetStreamFromPsOpt:=-eo pid,command} ;
		local StrFilterAppsName=${GetStreamFromPsFName:=egrep} ;
		local StrFilterAppsOpt=${GetStreamFromPsFNOpt:=-i} ;
		local StrUrlFilter=${GetStreamFromPsUrlFilter:="http:\/\/"} ;
		local StrPlayerFilter=${GetStreamFromPsUrlPlayerName:=mplayer} ;

		${StrAppsName} ${StrAppsOpt} | ${StrFilterAppsName} ${StrFilterAppsOpt} "${StrPlayerFilter}" | ${StrFilterAppsName} ${StrUrlFilter} ; 
	}
	
	function AwkScript()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( AwkScript ) ;
		local StrAwkPath=${AwkScriptAwkPath} ;
		local StrAwkScriptName=${AwkScriptScriptName} ;
		local StrAwkApps=${AwkScriptApps} ;
		${StrAwkApps} -f ${StrAwkPath}/${StrAwkScriptName}
	}

	#local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
	local cmdline=( ) ;
	local cmdline[0]="GetStreamFromPsUrlPlayerName=\"${StrPlayerName}\" GetStreamFromPsUrlFilter=\"${StrUrlGrep}\" GetStreamFromPsFName=\"${StrGrepApps}\" GetStreamFromPsFNOpt=\"${StrGrepOpt}\" GetStreamFromPsApps=\"${StrPsApps}\" GetStreamFromPsOpt=\"${StrPsOpt}\" GetStreamFromPs";
	local cmdline[1]="AwkScriptApps=\"${StrAwkApps}\" AwkScriptAwkPath=\"${StrAwkPath}\" AwkScriptScriptName=\"${StrAwkScriptName}\" AwkScript" ; 
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[0]} ;
			#echo -ne "Following switch are available:\n\n\t--startservices\tStart the application normally and output the package list\n\t--debug\tExpose result to be executed.\n\n" > /dev/stderr ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	elif [ "${Arg0:=--startservices}" == "debug"	] ; then 
		echo -ne "CmdLine[0]:${cmdline[0]} \nCmdLine[1]:${cmdline[1]}\n" > /dev/stderr ;
	else
		echo -ne "CmdLine[0]:${cmdline[0]} \nCmdLine[1]:${cmdline[1]}\n" > /dev/stderr ;		
	fi	
}
 
### Late-Homework for old duty... 
### Preceding some specific moment in a traveller when he have to know when the plane is going to leave , 
### I was messing around faulty compilation and try to find 
### way to randomize startup a bit and lib loading to see if it's anomalies in process or simply stack 
### hacking... See Hacking The art of exploitation from No Starch press...  
### Initial Setup on how collecting information and how generate fast random number was heavy and may
### collide whith the function FaultyProcess, rendering too much work from High-heavy precesing awk-sed-grep
### line at every ';' was also slowing this baby pentium-mmx from college Rosemont also... 


unset BuildOnFaultCompiler
function BuildOnFaultCompiler()
{
	local ArrayArg=( $* )
	local __call_locality=( BOFC ) ; 
	local StrAppsLib=${BOFCLib:=/sbin/ldconfig} ;
	local StrAppsLibOpt=${BOFCLibOpt:=-f,/etc/ld.so.conf} ;
	local StrAppsAppsFault=${BOFCAppsFault:=make} ;
	local StrAppsAppsFaultOpt=${BOFCAppsFaultOpt:=''} ;
	local IntRandomSize=${BOFCRandomSeedLevel:=20} ;
	local Arg0=${ArrayArg[0]:=--startservices}
	
	function InitLib()
	{
		local ArrayArg=( $* )
		local __call_locality=( InitLib ) ; 
		local StrApps=${InitLibInitApps:=/sbin/ldconfig} ;
		local StrAppsOpt={InitLibInitAppsOpt:=-f,/etc/ld.so.conf} ;
		local ArrayAppsOpt=${StrAppsOpt//,/ } ; 
		### ldconfig -f /etc/ld.so.conf ; 
		eval "${StrApps} ${ArrayAppsOpt[@]}" ; 
	}
	function FaultyProcess()
	{
		local ArrayArg=( $* )
		local __call_locality=( FaultyProcess ) ; 
		local StrApps=${FaultyProcessInitApps:=make} ;
		local StrAppsOpt=${FaultyProcessAppsOpt} ;
		local ArrayAppsOpt=${FaultyProcessAppsOpt[@]//,/ } ;
		eval "${StrApps} ${ArrayAppsOpt[@]}" > /dev/stderr  ; 
		return $? ; 
	}

	function Start()
	{
		local res=1 ; 
		local IntRandSize=${IntRandomSize} ; 
		local StrStarHeaderLine="********************************************************************************" ;
		local StrHeader="__StrStarHeaderLine__\n\n\tBuild Failed , sleeping __IntRand__\n\n__StrStarHeaderLine__\n" ;
		echo -ne "StartWhile\n" > /dev/stderr ;
		while [ ${res} -ne 0 ] ; do 
			local ArrayRandom=(  ) ; 
			local EndRand=$(( ( ${RANDOM} % ${IntRandSize} ) )) ; 
			local IndexRand=$(( ${RANDOM} % ${IntRandSize} )) ; 
			echo -ne "IntRandSize: ${IntRandSize}\nEndRand:${EndRand}\n" > /dev/stderr ; 
			sleep 5 ; 
			echo -ne "StartFor\n" > /dev/stderr ;
			for (( intx=0 ; intx <= ${EndRand} ; intx++ )) ; do 
				echo -ne "." > /dev/stderr ;
				local RandBaseMul=$(( ( ${IntRandSize} *  ( ${RANDOM} % 10 ) ) + 1 )) ; 
				local IntRandNum=$(( ${RANDOM} % ${RandBaseMul} )) ;
				ArrayRandom[${intx}]=${IntRandNum} ; 
			done ; 
			echo -ne "\n" > /dev/stderr ;
			local IntRand=${ArrayRandom[${IndexRand}]} ; 
			echo -ne "IntRand:${IntRand}\n" > /dev/stderr ; 
			echo -ne "StartInitLib:1\n" > /dev/stderr ;
			InitLibInitApps=${StrAppsLib} InitLibInitAppsOpt=${StrAppsLibOpt} InitLib ; 
			echo -ne "StartFaultyProcess\n" > /dev/stderr ;
			FaultyProcessInitApps=${StrAppsAppsFault} FaultyProcessAppsOpt=${StrAppsAppsFaultOpt} FaultyProcess
			res=$?  ;
			echo -ne "res return [${res}]\n" > /dev/stderr ; 
			echo -ne "StartIf\n" > /dev/stderr ;
			if [ ${res:=0} -ne 0 ] ; then 
				local StrDisplayHeader=${StrHeader//__StrStarHeaderLine__/${StrStarHeaderLine}} ;
				StrDisplayHeader=${StrHeader//__IntRand__/${IntRand}} ;
				echo -ne ${StrDisplayHeader} > /dev/stderr ; 
				echo -ne "StartInitSleepRandom\n" > /dev/stderr ;
				sleep ${IntRand} ; 
				echo -ne "StartInitLib:2\n" > /dev/stderr ;
				InitLib ;
			fi ; 
		done 

	}
	
	#local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;

	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference BuildOnFaultCompiler ;
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	else
		StrAppsLib=${StrAppsLib} StrAppsLibOpt=${StrAppsLibOpt} StrAppsLibOpt=${StrAppsLibOpt} StrAppsAppsFault=${StrAppsAppsFault} StrAppsAppsFaultOpt=${StrAppsAppsFaultOpt} IntRandomSize=${IntRandomSize} Start ; 
	fi 
} 



unset RoundRobinSwapRealloc
function RoundRobinSwapRealloc()
{
	local __call__locality=( RRSR ) ;
	local ArrayArg=( $* ) ;
	local Arg0=${ArrayArg[0]} ; 
	
	local Str=${RRSR:=}
	
	function GetSwapList()
	{
		local __call__locality=( GSL ) ;
		local ArrayArg=( $* ) ;
		ArrayListSwap=( $( swapon -s | cut -d ' ' -f 1  | grep -v "Filename" | tr '[:cntrl:]' ' ' ) ) ; 
		
	}
	function Start()
	{
		local __call__locality=( Start ) ;
		local ArrayArg=( $* ) ;
		
	}
	#local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
	
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference RoundRobinSwapRealloc ;
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	elif [ "${Arg0:=--startservices}" == "--swaptorealloc"	] ; then 
		GetSwapList ;
	else
		 Start ; 
	fi 
}


### Loading External Lib
. /etc/init.d/Fnct.D/_sub_PackageRepository


########### ###################################################################
########### 
########### End of normal Devlopment, upcoming devlopment or missing code from 
########### old lib Devlopment was put after, Enabling it on call of 
########### /etc/init.d/Fnct.D/fnct_debian_lib imply having VarFnctLib=True 
########### before
########### 
########### like :
########### VarFnctLib=True /etc/init.d/Fnct.D/fnct_debian_lib . 
########### 
########### Warning Not supported and may cause problems. 
########### 
########### ###################################################################


if [ ${VarFnctLib:=False} == "True" ] ; then

    Debian_DPKG_update_InstallList()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=Debian_DPKG_update_InstallList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      declare -a ArrayDPKGInstalled=( $( ${DebianProg:=dpkg} ${DebianProgQuery:=--get-selections} | awk 'BEGIN{}{printf("%s ",$1)}END{}' ) ) ; 
    }

    Debian_DPKG_update_ArchivesList()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=Debian_DPKG_update_ArchivesList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      declare -a ArrayArchiveDPKG=( $( find ${DefaultRootPath:=/var/cache/apt/archives/} -printf "%p " ) ) ; 
    }

    DebianDPKGProvideSubFunctionMember()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=DebianDPKGProvideSubFunctionMember __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __search_item()
      {
        #eval $( __InitFunc ) ;
        eval $( __call_localityLocalName=__search_item __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        if [ ${ArrayArg[1]} == ${ItemQuery:=update} ] ; then 
          return 0 ;
        fi
        return 1 ;
      }
      local Template="__CREATOR___PACKAGETYPE_____PACKAGEACTION___" ; 
      local StrCreator=${Creator:=${ArrayCreator[0]}} ;
      local StrPackageType=${PackageType:=${ArrayPackageType[0]}} ;
      local StrPackageAction=${PackageAction:=update} ;
      eval $( __in_for ArrayPackageAction __search_item ItemQuery=${StrPackageAction} ) ; 
      local ErrorStatement=$? ; 
      if [ ${ErrorStatement:=1} -eq 0 ] ; then 
        echo "__TODO__" ;  
      fi
    }

    MetaUpdateList()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=MetaUpdateList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __FuncUpdate()
      {
        #eval $( __InitFunc ) ;
        eval $( __call_localityLocalName=__FuncUpdate __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        local Template="__NODE____SECTION__List" ;
        Template=${Template/__SECTION__/${ArrayArg[0]}}
      } 
      eval $( __in_for ArrayMetaList __FuncUpdate ) ; 
    }

    function __get_col()    
    { 
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=__get_col __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      awk -vCol=${ArrayArg[0]} 'BEGIN{}{printf("%s ",$(Col));}END{}' ; 
    } ; 

    function UpdateDpkgGetSelection()
    {
      eval $( __call_localityLocalName=UpdateDpkgGetSelection __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      declare -a ArrayPackageCurrent=( $( dpkg --get-selections | __get_col 1 ) ) ; 
    }


    function get_listfile()    
    { 
      #eval $( __InitFunc get_listfile ) ;
      eval $( __call_localityLocalName=get_listfile __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __BaseEncode64()
      {
        #eval $( __InitFunc __BaseEncode64 ) ;
        eval $( __call_localityLocalName=__BaseEncode64 __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        base64 --wrap=0 ; 
      }
      function __IfTestFile()    
      { 
        #eval $( __InitFunc __IfTestFile ) ;
        eval $( __call_localityLocalName=__IfTestFile __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        if [ -f ${ArrayArg[0]} ] ; then 
          local StrStream=$( echo "${ArrayArg[0]}" | __BaseEncode64 ) ; 
          echo -ne "${StrStream} " ;
        fi 
      } ; 
      local ArrayFileList=( $( dpkg-query --listfiles ${ArrayArg[0]} ) ) ; 
      eval $( __in_for ArrayFileList __IfTestFile ) ; 
    } ; 

    function get_search()
    {
      #eval $( __InitFunc get_search ) ;
      eval $( __call_localityLocalName=get_search __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      eval $( __in_for ArrayPackageCurrent get_listfile ) ;
    }

    function get_package_by_file()
    {
      #eval $( __InitFunc get_package_by_file ) ;
      eval $( __call_localityLocalName=get_package_by_file __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function PostFilter()
      {
        #eval $( __InitFunc PostFilter ) ;
        eval $( __call_localityLocalName=PostFilter __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        awk -vGrepReturn=${GrepReturn} -f /etc/init.d/Fnct.D/awk-script/DpKgQueryPackage.awk ; 
      }  
      local CmdEval=( ${Program:=apt-file} ${ProgramOption:=search} ${ProgramQuery:=lirc/lirc_client.h} ProgramQueryIs64=${ProgramQueryIs64:=false} "|" ${FilterProgram:=PostFilter} GrepReturn=${GrepReturn:=false} ${FilterProgramQuery:=""} ) ;
      echo "CmdLine:[${CmdEval[@]}]" ;
      #eval "${CmdEval[@]}" ; 
      eval "local IntResult=$( eval ${CmdEval[@]} )" ; 
      #echo "Return : ${IntResult}" ;
    }

    function AwkContentParsing()    
    { 
      #eval $( __InitFunc AwkContentParsing ) ; 
      eval $( __call_localityLocalName=AwkContentParsing __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __TinyDecode64()
      {
        #eval $( __InitFunc __TinyDecode64 ) ; 
        eval $( __call_localityLocalName=__TinyDecode64 __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        local StrBaseDecode=$( echo "${VarDecode64}" | base64 -d --wrap=0 2> /dev/null ) ; 
        local IntErrorReport=$? ;
        if [ ${IntErrorReport:=1} -eq 1 ] ; then 
          echo "${VarDecl:=local} ${VarName:=VarOut}=${VarDecode64}" ; 
        else
          echo "${VarDecl:=local} ${VarName:=VarOut}=${StrBaseDecode}" ; 
        fi 
      }
      eval $( __TinyDecode64 VarDecode64=${RecurrentTemplateSearch} VarName=StrRecurrentTemplateSearch VarDecl=${VarDecl} )  ;
      eval $( __TinyDecode64 VarDecode64=${StrQuerySearch} VarName=StrQuerySearch VarDecl=${VarDecl} )  ;
        
      
      local ProgramParserRecurrentTemplate=${StrReturnBase64DecodeTry} ;
      local CmdEval=( ${Program:=apt-file} ${ProgramOption:=search} ${StrQuerySearch} "|" ${ProgramParser:=awk} -vTemplateContent=${StrRecurrentTemplateSearch} -vVarNameOut=CmdEval -f /etc/init.d/Fnct.D/awk-script/DpKgQueryPackage.awk ) ;
      echo "CmdLine:[${CmdEval[@]}]" ; 
    }

    function libsearch_AwkContentParsing()
    {
      #eval $( __InitFunc AwkContentParsing ) ; 
      eval $( __call_localityLocalName=libsearch_AwkContentParsing __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      local StrRecurrentTemplateSearch=$( echo "dpkg --get-selections | egrep -ic %s" | base64 --wrap=0 ) ;
      local StrQuerySearch=$( echo "lirc/lirc_client.h" | base64 --wrap=0 ) ; 
      AwkContentParsing RecurrentTemplateSearch=${StrRecurrentTemplateSearch} QuerySearch=${StrQuerySearch} ; 
      
    }

    __funcZenity_DpkgList() 
    { 
        eval $( __call_localityLocalName=__funcZenity_DpkgList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        
        ### This Cover-up the theory of problematic transfert of commune Variable name in external function
        ### being by definition to be treated ''AS'' the normal corpus of the definition of a script
        ### Where this example show a possibility that it does not... The WeFixIt by
        ### involve declaring this method inside this function by calling a declare-f and 
        ### renaming the function (incase of) and calling it inside the function like a 
        ### sub-function can be called and all variable within an external-function will 
        ### be accessible... 
        ### Noted by: Patrick Riendeau in 2003-2004 @vdl2 inc formelly know as Phromone inc.
        ### and 2010... 
        
        eval """$( declare -f LinkFuncRetOkA_B  | sed 's/\\n/\\\\n/g;s/LinkFuncRetOkA_B/localLinkFuncRetOkA_B/g' )"""
        
        function DisplayEvalCmd()
        {
          echo -ne "in DisplayEvalCmd:\n\t\tCmdLine:${StrFuncName}:[ ${CmdEval[@]} ]\n" > /dev/stderr  ;  
        }
        
        function ExecEvalCmd()
        {
          echo -ne "in ExecEvalCmd:\n" > /dev/stderr ;  
          eval "${CmdEval[@]}" ;
        }

        function ZenityProgressBar()
        {
          eval $( __call_localityLocalName=ZenityProgressBar __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
          local IntRandomState=$(( ${RANDOM} % 20 )) ;
          local CmdEval=( zenity --progress --percentage=${IntRandomState} --text="Fetching Package List" --auto-kill --pulsate ) ;
          #DisplayEvalCmd ;
          #ExecEvalCmd ;
          LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }
        
        function ZenityListPackage()
        {
          eval $( __call_localityLocalName=ZenityProgressBar __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
          zenity --list --checklist --column "Installed" --column "Package Name" ;
          #DisplayEvalCmd
          #ExecEvalCmd ;
          LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }
        
        function DpkgSortedByInstall()
        {
         eval $( __call_localityLocalName=DpkgSortedByInstall __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
         local CmdEval=( "dpkg" "--get-selections" "|" "sort" "-k2" "-r" ) ;
         #DisplayEvalCmd ;
         #ExecEvalCmd ;
         LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }

        function SedFilterConversionDpkgToZenityList()
        {
          eval $( __call_localityLocalName=DpkgSortedByInstall __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
          #sed -r -f /etc/init.d/Fnct.D/sed-script/FilterConversionDpkgToZenityList.sed ;
          local CmdEval=( "sed" "-r" "-f" "/etc/init.d/Fnct.D/sed-script/FilterConversionDpkgToZenityList.sed" ) ;
          #DisplayEvalCmd ;
          #ExecEvalCmd ;
          LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }
        local CmdEval=( LFuncAction0=ZenityProgressBar LFuncAction1=DpkgSortedByInstall LinkFuncPipedA_B ) ;
        echo -ne "From Main Func:${StrFuncName}\n\n\tCmdEval:[ ${CmdEval[@]} ]\n" > /dev/stderr ;
        LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;

    }

    function get_list()  
    { 
      #eval $( __InitFunc get_list ) ; 
      eval $( __call_localityLocalName=get_list __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      local ArrayInfo=( $( find /usr/share/ -maxdepth 1 -type d -iname "man*" | tr '[:cntrl:]' ' ' ) ) ; 
      echo "${VarDecl:=local} ${ArrayName:=ArrayList}=( ${ArrayInfo[@]})" ; 
    } 
      
    function ffind()    
    { 
      #eval $( __InitFunc ffind ) ; 
      eval $( __call_localityLocalName=ffind __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      find ${ArrayArg[0]} -type f -iname "*man*" ; 
    } 

    function __ZenityProgressBar()    
    { 
      #eval $( __InitFunc ) ;  
      eval $( __call_localityLocalName=__ZenityProgressBar __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      zenity --progress --pulsate 
    } 

    function __wrap_bar_find()    
    { 
      #eval $( __InitFunc __wrap_bar_find ) ; 
      eval $( __call_localityLocalName=__wrap_bar_find __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      eval $( get_list ArrayName=ArrayOut VarDecl=local ) ;
      eval $( __in_for ArrayOut ffind ) | __ZenityProgressBar  ;
    }


    function __BuildDpkgShowFormat ()    
    { 
     #eval $( __InitFunc __BuildDpkgShowFormat ) ; 
     eval $( __call_localityLocalName=__BuildDpkgShowFormat __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
     local DefaultTagValue="__TAG__" ;
     if [ ${StructDpkgShowFormat:=__TAG__} == "__TAG__" ] ; then 
      declare -a StructDpkgShowFormat="${DefaultTagValue}" ;
     fi 
     StructDpkgShowFormat=( $( echo "${StructDpkgShowFormat}" | sed 's/'${DefaultTagValue}'/'${ArrayDPKG_QueryHeader[${ArrayArg[0]}]}${DefaultTagValue}'/g' ) ) 
    } 

    function __BuildDpkgShowFormatXml()
    {
      eval $( __InitFunc __BuildDpkgShowFormat ) ; 
      function __functor_show_header()
      {
        #eval $( __InitFunc __BuildDpkgShowFormat ) ; 
        eval $( __call_localityLocalName=__BuildDpkgShowFormatXml __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        echo -ne "\nStyle=${Style}\n" ;     
        echo -ne "${ArrayArg[2]}" ; 
        echo -ne "\nDstyle=${Dstyle}\n" ;
      }
      eval $( __in_for ${ArrayNameDPKGQuery=ArrayDPKG_QueryHeader} __functor_show_header CCode64=$( ) ) ;
    }

    compare_package()
    {
      local ArrayArg=( $* ) ; 
      function get_name()    
      { 
        eval $( __call_localityLocalName=compare_package __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        local str="${ArrayArg[0]}" ; 
        local ArrayPackage=( ${str/_/ } ) ; 
        echo -ne "${ArrayPackage[0]} " ;  
      } 
      
      function update_package_list()
      {
        eval $( __call_localityLocalName=update_package_list __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        ${DebianProg:=dpkg} ${DebianProgQuery:=--get-selections} | awk 'BEGIN{}{printf("%s ",$1)}END{}' ; 
      }
      
      function get_specific_search()
      {
        eval $( __call_localityLocalName=get_specific_search __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        apt-file search wxPython | awk 'BEGIN{}{intlength=split($1,Array,/:/); printf("%s\n",Array[1])}END{}' | sort -u | tr '[:cntrl:]' ' '  
      }
      
      function get_specific_python()
      {
        eval $( __call_localityLocalName=get_specific_python __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        find /var/cache/apt/archives/ -iname "*.deb" -printf "%f "
      }

      function __compare_package()    
      { 
        #local ArrayArg=( $* ) ; 
        eval $( __call_localityLocalName= __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        echo "Search for Package ${ArrayArg[0]} in Installed Package( ${#ArrayDPKGInstalled[@]} ) " ;      
        function search_package_name()    
        { 
          local ArrayArg=( $* ) ; 
          if [ "${ArrayArg[0]}" == "${ArrayArg[1]}" ] ; then 
            echo -ne "\tInstalled Package is in the list [ ${ArrayArg[0]} ]\n" ; 
            return 0 ; 
          fi
            ArrayDPKGUnInstalled[${#ArrayDPKGUnInstalled[@]}]="${ArrayArg[1]}";
            return 1 ; 
        } 
        eval $( __in_for ArrayDPKGInstalled search_package_name ${ArrayArg[0]} ) ; 
      }
      
      local ArrayPythonPackage=( $( ${ArrayArg[0]} ) ) ;
      echo -ne "\nPackage List Choosed from Function: ${ArrayArg[0]}\n\t[ ${ArrayPythonPackage[@]} ]\n" ;
      local ArrayDpkgPython=( $( eval $( __in_for ArrayPythonPackage get_name ) ) ) ;  
      local ArrayDPKGInstalled=( $( update_package_list ) ) ;    
      local ArrayDPKGUnInstalled ;
      eval $( __in_for ArrayDpkgPython __compare_package ) ;
      echo "declare -a ArrayDPKGUnInstalled=( ${ArrayDPKGUnInstalled[@]} )" ; 
    }

    function KeyAptSearch()    
    { 
     eval $( __call_localityLocalName=KAS __call_locality ); 
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=PackageArrayName FParamVarName=StrPackageArrayName FParamDefaultValue=ArrayPackage __fnctCreateLocalityFuncParam     ) ;
     
     function AptSearch()    
     { 
      eval $( __call_localityLocalName=AS __call_locality ); 
      echo -ne "Key: ${ArrayArg[0]}\n" ; 
      apt-file search ${ArrayArg[0]} ; 
     } ; 
     local CmdEval=( "eval" " $( " "__in_for" ${StrPackageArrayName:=""} "AptSearch" ")" ) ; 
     eval ${CmdEval[@]} ;
    }

    function dpkg-get-selections()
    {
     eval $( __call_localityLocalName=DPKG __call_locality ); 
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=BranchShow FParamVarName=StrBranchShow FParamDefaultValue=Left __fnctCreateLocalityFuncParam     ) ;
     
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName0 FParamVarName=ArrayCmdName[0] FParamDefaultValue=dpkg __fnctCreateLocalityFuncParam     ) ;
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName1 FParamVarName=ArrayCmdName[1] FParamDefaultValue="--get-selections" __fnctCreateLocalityFuncParam     ) ;
     
     eval local StrFuncColDisplay=\${${StrBranchShow}ColDisplay} ;
     
     function CommandCall()
     {
      eval $( __call_localityLocalName=CCall __call_locality ); 
      local CmdEval=( ${ArrayCmdName[@]} ) ;
      eval ${CmdEval[@]} ;
     }
     
     function RightColDisplay()
     {
      eval $( __call_localityLocalName=ColDisplay __call_locality ); 
      awk -vColName=${StrBranchShow:=""} -f /etc/init.d/Fnct.D/awk-script/dpkg-col-display.awk 
     }
     
     function LeftColDisplay()
     {
      eval $( __call_localityLocalName=ColDisplay __call_locality ); 
      awk -vColName=${StrBranchShow:=""} -f /etc/init.d/Fnct.D/awk-script/dpkg-col-display.awk 
     }
     
     local CmdEval=( ${CommandCall:=""} "|" ${StrFuncColDisplay:=""} ) ;
     eval ${CmdEval[@]} ;
    }

    function dpkg-set-selections()
    {
     eval $( __call_localityLocalName=DPKG __call_locality ); 
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=BranchShow FParamVarName=StrBranchShow FParamDefaultValue=Left __fnctCreateLocalityFuncParam     ) ;
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName0 FParamVarName=ArrayCmdName[0] FParamDefaultValue=dpkg __fnctCreateLocalityFuncParam     ) ;
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName1 FParamVarName=ArrayCmdName[1] FParamDefaultValue=--set-selections __fnctCreateLocalityFuncParam     ) ;
     
     function CommandCall()
     {
      eval $( __call_localityLocalName=CCall __call_locality ); 
      local CmdEval=( ${ArrayCmdName[@]} ) ;
      eval ${CmdEval[@]} 
     } 

    }
fi 



