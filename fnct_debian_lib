


 ###	Specification : 
 ###	- This following Draft-Specification, offer a decent explanation of doing a function with
 ###	appropriate control proned-protocolar development for scalarity-design . 
 ###	
 ### Example of definition of __call_locality:
 ###	function FuncNameThatIsUnderstandable()
	###	{
	###		local __call_locality=( FNTIU FuncNameThatIsUnderstandable ); 
 ###	                           |    |
 ###	                           |    +---> LongName to be used with GetVarReference, see (3)
 ###	                           |
 ###	                           +---> Short Name to be used to name Prefixed Variable, see (2)
 ###	
 ###	
 ###	Basic and Mandatory visibility and variable control 
 ###	
 ###	Since there is possible management with case switch, and index-pushing ArrayArg manage 
 ###	- called value after Function name was called :
 ###	 ex: Var1=value Var2=valueA;ValueB FuncNameThatIsUnderstandable --switches
 ###	----> Uses of --switches is almost important and should be controled from Arg0, see (1)
 ###	
 ###	Note on Function Behavior : There is almost only one switches used from command line telling 
 ###	which part is called , the actual embodinement after note (3) is an example of a called part.
 ###	- This example uses if-elif-else-fi statement, but a loop with pre-defined switches control
 ###	should end after is call. However uses of Prefixed-Var are infinite and might control
 ###	Behavior of a part into sub-derived part, but should stay in scope and definition of switches made. 
 ###	---> Later an round-up will convert all function from fnct_debian_lib into a Python parser that 
 ###	generate the same file here but with possibility to control everything and should generate a
 ###	stable meta-data file where this function should reflect it's present definition here. 
 ###	Note1: After seeing unworkable switches or switches entering in conflicts it's better to 
 ###	define value with possibilities to be useless or not used but preventing future version
 ###	to not work by calling contradictive switches. 
 ###	
 ###	
 ###	
 ###	
 ###	local ArrayArg=( $* ); ---> Really important line, all variable from outside are mangling inside
 ###	this Variable-ArrayArg, we do not uses $* alone since there is a possible alteration.
 ###	In Fact the declaration of ArrayArg should involve a read-only switch in final-draft. 
 ###	
 ###	Final Draft proposition of ArrayArg:
 ###	local -r ArrayArg=( $* ); *** Only if bash version accept it, which start to be effective from 
 ###	bash version 2.99 from FreeBsd transport to linux around 1997. 
 ###	
 ###	
 ###	*(1)
 ###	local Arg0=${ArrayArg[0]} ; ---> Allow uses of switches like --help, --list, --startservices, --get
 ###	---> Default switches and easy to do stuff , --help, --list, --startservices, --get
 ###	
 ###	
 ###	
 ###	*(2)
 ###	local StrSomeMeanFulName=${FNTIUDefinitionName}
 ###	
 ###	
 ###	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n" 
 ###	+---> Should be usefull to see default switches availables. 
 ###	
 ###	- First use in main body of a function 
 ### *(3)
 ###	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
	###  GetVarReference ${__call_locality[1]} ;  
	###	 echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	### elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
	###	 eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
	###	 echo -ne """${ArgGet}\n""" ; 			
	### elif [ "${Arg0:=--startservices}" == "--list" ] ; then } ---> Sequence to extract Prefixed-var and uses 
	###	 eval $( __GetVarReferenceList ) ;                     } of function call to accelerate external variable 
 ###	                                                       } transfert, ex : FuncNameThatIsUnderstandable --get $(  FuncNameThatIsUnderstandable --list | cut -d ' ' -f 1  ) *(4)
 ###	                                                       } will get the First Prefixed-variable value
 ###	 
 ###	 
	### elif    [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
 ###	 +--------------> Main Body <--------------+
 ###	else
 ###	 
 ###	...
 ###	fi 
 ###	
 ###	



 ### ValueParser :
 ### 
 ### Description: 
 ### - Aim to be a Value Parser with specific semantic to automatically create lists
 ### of variable with specific notation. It was designed to Create a Unique Variable,
 ### like StrValueParserInfo and evaluating the Variable with string-like specified with.
 ### 2 level of CSV, between type ( Profixed variable are VPCallLocalityName VPVarArgList VPScopeList VPValueList )
 ### are reserved to specify somes crucial information. 
 ### 
 ### VPCallLocalityName -> Under wichh prefix named variable are transfered from their calling name.
 ### Ex: Having Function with var __call_locality=( ValueTest ), mean all variable from incoming 
 ### function called with ValueTest(), like :
 ### var1=value1 var2=value2 ValueTest --opt , var1 and var2 must have theirs names starting by
 ### ValueTestvar1=value1 ValueTestvar2=value2 ... 
 ### 
 ### - Value parser will transform variable from ValueTestvar1 into Strvar1, Strvar2 if VPVarArgList
 ### is specified.
 ### 
 ### VPVarArgList -> Specify the list of name and their internal Prefix Type. 
 ### as said in VPCallLocalityName, variable have external and internal names. 
 ### Passing by will not directly convert by create a variable starting with specified prefix.
 ### Having :
 ### VPCallLocalityName=ValueTest VPVarArgList=Str:var1,Str:var2 
 ###  - inside function :ValueTest() will:
 ### get from extern name like ValueTestvar1=value1 ValueTestvar2=value2 , 
 ### will transfert the content into appropriate internal name: Strvar1, Strvar2 . 
 ### - This is purely a simple transfert, convertion, name mangling and linting ( like checking name of 
 ### var if they are not exceeding 32 chars are not yet show. )
 ### 
 ### VPScopeList -> Implicitly tell to ValueParser if the variable are created in local or global, telling
 ### also about lifetime of variable... Important when dealing with function and sub-function and sub-n-function. 
 ### 
 ### 
 ### 
 ###	Full-length example : 
 ### Including 
 ### 
 ### See StartCoproc, variable StrValueParserInfo hold the references and work well with triple-guillements.
 ### 
 ##
 ### eval $( eval """
 ###	VPCallLocalityName=${__call_locality[0]} 
 ###	VPVarArgList=Str:ProcName,
 ###	             Str:InWhile,
 ###	             Str:WhCond,
 ###	             Str:WhRetStat,
 ###	             Str:AppsName,
 ###	             Str:AppsPrVar,
 ###	             Str:AppsOpt
 ###	VPScopeList=ProcName:local,
 ###	             InWhile:local,
 ###	             WhCond:local,
 ###	             WhRetStat:local,
 ###	             AppsName:local,
 ###	             AppsPrVar:local,
 ###	             AppsOpt:local 
 ###	VPValueList=DefaultCoprocName:True:__VAR__ -ne 1:__VAR__=\$( __CMD__ ):GitHubCommit:GitHubCommitFilePath=/etc/init.d/Fnct.d:fnct_debian_lib
 ###	""" ValueParser )  ;
 ### 
 ### -Note Calling ValueParser with same string embedded in the value with following switches --varhelper, will transform this stream of variables
 ### - into helper like GetVarReference . Don't forget, what ValueParser showing or creating is not visible from GetVarReference. GetVarReference
 ### Function extract information from a 'declare -f ' statement and ValueParser is not creating inside the function the value, they are created 
 ### by using this function... Quite simple, almost dynamic, but not fully-dynamic... It's bash afterall... 
 ### Note : Sometimes more easy calling VPCallLocalityName=${__call_locality[0]} instead if re-writing the function names...
 ### Some will love $0 wich is the function name or the script name if this one is inside a shell-file-script. but personally,  I report a lot 
 ### of problems.  
 ### 
 ### 
 ### Comparaison : 
 ### 
 ### Following method are similar .
 ### 
 ### function ValueTest()
 ### {
	###  local ArrayArg=( $* ) ; 
	###  __call__locality=( ValueTest )	
 ###  StrValueTest=${ValueTestValue:=None} ; 
 ###  echo -ne """${StrValueTest}\n""" ; 
 ### } 
 ### 
 ### function ValueTest()
 ### {
	###  local ArrayArg=( $* ) ; 
	###  __call__locality=( ValueTest )	
 ###  local StrValueParserInfo="VPCallLocalityName=${__call_locality[0]} VPVarArgList=Str:Value VPScopeList=Value:local VPValueList=None" ; 
 ###  eval $( eval "${StrValueParserInfo} ValueParser " ) ;
 ###  echo -ne """${StrValueTest}\n""" ; 
 ### } 
 ###
 ### - It's eat more line if the number of variables are lower than 3 variables, but both function
 ### work on same way... Calling-function to see the result:
 ### 
 ###  ValueTestValue="This is a test" ValueTest
 ### 
 ### - Exception : Still unable to read new variable definition from command-line and only create 
 ### a Variable transfert blindly. 

 
unset ValueParser ;
function ValueParser()
{
		local __call_locality=( VP ValueParser );
		local ArrayArg=( $* ) ; 
		local Arg0=${ArrayArg[0]} ;
		
  local StrVarArgList=${VPVarArgList:=Str:AppsName,Str:AppsOpt} ; 
		local StrValueList=${VPValueList:=echo,__VALUE__} ; 
		local StrLocality=${VPCallLocalityName:=Default} ; 
		local StrScope=${VPScopeList:=AppsName:local,AppsOpt:local} ; 
		local StrDefaultScope=${VPScopeDefault:=local} ;
		local ArrayScope=( ${StrScope//,/ } ) ; 
		local ArrayVar=( ${StrVarArgList//,/ } ) ; 
		local ArrayValue=( ${StrValueList//:/ } ) ;
		local StrValueReturn="" ;
		local StrDebug=${VPDebug:=False}
		local ArrayScopeIndex=( "local" "declare -a" ) ;

		function GetScope()
		{
				local __call_locality=( GS GetScope );
				local ArrayArg=( $* ) ; 
				local Arg0=${ArrayArg[0]} ;
				local StrDebug=${GetScopeDebug:=False}
    eval $( BVTestVarName=StrReturn BVTestVarHold="0" BVTestBoolVarName=\${Arg0:=local} BVTestBoolCase="global" BVTestBoolAssertion="1" BoolVarTestVarCreation ) ;
				echo -ne "${StrReturn}" ; 

		}
		function VarInScopeList()
		{
			local __call_locality=( VISL VarInScopeList );
			local ArrayArg=( $* ) ; 
			local Arg0=${ArrayArg[0]} ;
			local StrDebug=${VISLDebug:=False} ;
			local StrValue=${VISLValue:=AppsName} ;
			local StrIsScoped=False ;
			local StrValueReturn="False" ;
			
   for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
				local ArrayValue=( ${ArrayArg[${intx}]//:/ } ) ;
				local StrSuffix=${ArrayValue[0]} ; 
				if [ "${StrSuffix}" == "${StrValue}" ] ; then 
					local StrScope=$( GetScope ${ArrayValue[1]} ) ; 
					StrIsScoped=True
					StrValueReturn="${StrIsScoped} ${StrScope} ${StrValue}" 
				fi 
			done 
			echo -ne "${StrValueReturn}" ; 
		}
 
 function VarReplace()
 {
		local __call_locality=( VR VarReplace ) ;
		local ArrayArg=( $* ) ; 
		local Arg0=${ArrayArg[0]};
  local ArrayScoceA=(  __suffix__:${StrVarSuffix} __value__:${AValue} __prefix__:${StrVarSuffixType} __locality__:${StrLocality} ) ; 
		local StrScoreResultParse ; 
  if [ "${AscopeType}" == "True" ] ; then 
   StrScoreResultParse= ${ArrayScopeIndex[${ArrayScopeTest[1]}]}
  else
   StrScoreResultParse = ${StrDefaultScope}
  fi 
  for (( intx=0 ; intx <= ${#ArrayScoceA[@]}-1 ; intx++ )) ; do 
   local ArrayIScope=( ${ArrayScoceA[${intx}]//:/ } ) 
   StrVarName=${StrVarName//${ArrayIScope[0]}/${ArrayIScope[1]}} ; 
  done 
		StrVarName=${StrVarName//__scope__/${StrScoreResultParse}} ;
  
 }
 
 function VarHelper()
 {
		local __call_locality=( VH VarHelper ) ;
		local ArrayArg=( $* ) ; 
		local Arg0=${ArrayArg[0]};
  local ArrayScope=( ${ArrayScope[@]//,/ } ) ; 
  local StrDebug=${MainDebug:=False} ;
  for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
		  local VarSeg=( ${ArrayArg[${intx}]//:/ } ) ; 
				local StrVarSuffixType="${VarSeg[0]}" ;
				local StrVarSuffix="${VarSeg[1]}" ;
				local StrVarName="Variable __locality____suffix__,\n\tDefault Value __value__\n\tInternal variable: __prefix____suffix__\n" ;
				
				local ArrayScopeTest=( $( Value=${StrVarSuffix} \
                              VarInScopeList        \
                              ${ArrayScope[@]}    ) ) ; 
				### __scope__ Tag is eclued, because it's the only one does not respect the
    ### the looping sequence, explicitly needs a of Scope test to dismiss between
    ### local scoping and global scoping. 
    
    StrVarSuffix=${StrVarSuffix}          \
    AValue=${ArrayValue[${intx}]}         \
    StrVarSuffixType=${StrVarSuffixType}  \
    StrLocality=${StrLocality}            \
    AscopeType=${ArrayScopeTest[0]}       \
    VarReplace                            ;
				StrValueReturn="${StrValueReturn} ${StrVarName}" ;
			done 
			echo -ne "${StrValueReturn}" ;
			
		}		
		function __main_StartServices()
		{
   local __call_locality=( Main __main_StartServices ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]};
			local ArrayScope=( ${ArrayScope[@]//,/ } ) ; 
			local StrDebug=${MainDebug:=False} ;
			for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
				local VarSeg=( ${ArrayArg[${intx}]//:/ } ) ; 
				local StrVarSuffixType="${VarSeg[0]}" ;
				local StrVarSuffix="${VarSeg[1]}" ;
				local StrVarName="__scope__ __prefix____suffix__=\${__locality____suffix__:=\${__locality____suffix__:=__value__}}" ;
				
				local ArrayScopeTest=( $( Value=${StrVarSuffix} \
                              VarInScopeList        \
                              ${ArrayScope[@]}    ) ) ; 
				
				StrVarSuffix=${StrVarSuffix}          \
    AValue=${ArrayValue[${intx}]}         \
    StrVarSuffixType=${StrVarSuffixType}  \
    StrLocality=${StrLocality}            \
    AscopeType=${ArrayScopeTest[0]}       \
    VarReplace                            ;
				StrValueReturn="${StrValueReturn} ${StrVarName} ; " ;
			done 
			echo -ne "${StrValueReturn}" ;
			
		}
		local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
		if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
		elif [ "${Arg0:=--startservices}" == "--varhelper"	] ; then 
			ArrayScope=${ArrayScope[@]// /,}      \
   StrVarSuffix=${StrVarSuffix}          \
   StrValueReturn=${StrValueReturn}      \
   StrDefaultScope=${StrDefaultScope}    \
   StrLocality=${StrLocality}            \
   VarHelper   ${ArrayVar[@]} ;
		elif [ "${Arg0:=--startservices}" == "--startservices"	] ; then 
			ArrayScope=${ArrayScope[@]// /,} \
   StrVarSuffix=${StrVarSuffix} \
   StrValueReturn=${StrValueReturn} \
   StrDefaultScope=${StrDefaultScope} \
   StrLocality=${StrLocality}  Main ${ArrayVar[@]} ; 
		fi 
	
}



unset __default_test ;
function __default_test()
{
	local ArrayArg=( $* ) ; 
	local __call_locality=( DT __default_test  ) ; 
 local Arg0=${ArrayArg[0]} ; 
	local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
	 GetVarReference ${__call_locality[1]} ;
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	else
		echo "__BODY__" > /dev/stderr ; 
	fi 
	
}


unset AddPValueStore
function AddPValueStore()
{
	local ArrayArg=( $* ) ; 
	local __call_locality=( APVS AddPValueStore  ) ; 
 local Arg0=${ArrayArg[0]} ; 
	local StrAction=${APVSAction:=add} ; 
	local StrFunction=${APVSFunction:=__default_test} ; 
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
	 GetVarReference ${__call_locality[1]} ;
		local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	else
		echo -ne "__BODY__\n" > /dev/stderr ; 
	fi 
}

### GetVarReference
unset GetVarReference
. /etc/init.d/Fnct.d/6403c722-28a6-11e3-98a2-001b3875b29c

### AnsiCodeTest 
unset AnsiCodeTest
. /etc/init.d/Fnct.d/6e063cbc-0ce2-11e3-8879-001b3875b29c 


### ZenityRadioOptionConfig, ZenityListOptionConfig, ZenityPrefixedVarBuilder 
unset ZenityRadioOptionConfig
unset ZenityListOptionConfig
unset ZenityPrefixedVarBuilder
. /etc/init.d/Fnct.d/50ccda66-2ebb-11e3-98a2-001b3875b29c

### GetStdPrefixName 
unset GetStdPrefixName ; 
. /etc/init.d/Fnct.d/69968204-0cf6-11e3-99bc-001b3875b29c 

### ZenityPythonInstaller 
unset ZenityPythonInstaller ; 
. /etc/init.d/Fnct.d/950966fa-0e67-11e3-98a2-001b3875b29c

### FileNameConversion
unset FileNameConversion ; 
. /etc/init.d/Fnct.d/877d7e9a-1001-11e3-98a2-001b3875b29c

### __GetVarReferenceCompWord
unset __GetVarReferenceCompWord ; 
. /etc/init.d/Fnct.d/023102e0-1833-11e3-98a2-001b3875b29c
### This is first pragma. BodyFunc Should manage it. 


### 
### Note, Existence of A-Range Boolean Purposes and B-Applied Boolean
### Variable. 
### 
### Def : A-Range Boolean Variable.
###  - Allow the Position between True and False Adding A WIDE-RANGE of 
### Information, Settled from Possibilities to Have at least 1 Data to 
### Fit inside a compound, the A-Range Boolean will be defined as:
### - Test 1:
### The AIsMoreFruitTo=False will leave a compound sentence as is:
### Sentence : The fruit are Grapes were all loved by children 
### 
### The AIsMoreFruitTo=True will Add-A-Range, this case being finite and
### unique the sentence will Have an addition:
### 
### Sentence : The fruit are Grapes ( and Banana ) were all loved by children 
### 
### See Answer to pattern inside BoolVarTestVarCreation to see similarities. 
### 
### 
### Def : B-Applied Boolean Variable.
### - Expected case to add some extra functionalities to common argument. 
### - See PackageRepositoryMgmt for example of PkgRepoMgmtAddPkgLst Boolean
### variable allowing to add a listing in case Package are backuped and 
### need a reference of status of package . 
### 
### 
### To Fellow M.Murgullescu, Interrupted course to supplied informations 
### to teacher about limitation of homo-erectus (also called Midget) . 
### INF101 College Rosemont and Pre-homo-sapiens-sapiens limitation in 
### learning problems. 
### -Interaction done silently by turn-based event and noticing only 
### on volume / ratio in comment on Any-Type defined from Pascal-Programmation.
### 
### - Teacher just supplied the answer in a case for an examen of 15% of the
### sum and give any other information thru course traversal. 



unset BoolVarTestVarCreation ; 
function BoolVarTestVarCreation()
{

### The main goal : 
### Will represent a correct view of this example into pattern . 
### 
###   local StrMultipleFileSelectionAttr="--multiple"
###   if [ "${StrZenityFSMultipleFile}" == "False" ] ; then 
###    StrMultipleFileSelectionAttr="" ; 
###   fi 
### 
### Into CommandLine Echo like pattern and  being evaluated to create following statement:
### - Having a variable A Holding a content. 
### - Having a Prefixed-Var named B holding either False Or True like ${Prefixed_Var_named_B:=False}
### - On Having Reverse position inside ${Prefixed_Var_named_B:=False}, content of variable A, should
### Be erased of asking to get alternative.
### 
### Answer to pattern, 
### 
### BVTestVarName=StrMultipleFileSelectionAttr BVTestVarHold="--multiple" BVTestBoolVarName=StrZenityFSMultipleFile BoolVarTestVarCreation 
### 
### Nominal purposes: 
### This is intended to supply a Boolean test and Value Association, done in one line, 
### it allow to generate a range of variable being Transited from Prefixed-Var and value
### passed in a query, which is sometimes had no value and give extra code that might trigger error. 
### 
### For a Generated example between command-line BoolVarTestVarCreation and Pre-fixed value, see 
### 
### BoolVarTestVarCreation for substitution of StrFileTmp from function ZenityShellEval()
### Note reference : f1161962-0ad8-11e3-b166-001b3875b29c  
### 
### 

 unset ArrayTypeTest StrVarNamed StrVarNamedHold StrVarBoolTest StrDefaultBoolTest StrNotAsserted StrScopeType StrIfTestType StrIfStringOp IsDisplayIfStatement ; 
	local __call_locality=( BVTest BoolVarTestVarCreation ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
 local ArrayTypeTest=( False True ) ;
 local StrVarNamed=${BVTestVarName:=StrAttrHold} ; 
 local StrVarNamedHold=${BVTestVarHold:=CONTENT} ; 
 local StrVarBoolTest=${BVTestBoolVarName:=IsVarShould} ; 
 local StrDefaultBoolTest=${BVTestBoolCase:=False} ;
 local StrNotAsserted=${BVTestBoolAssertion:=\"\"} ;
 local StrScopeType=${BVTestScopeTest:=local} ;
 local StrIfTestType=${BVTestIfType:=String} ; 
 local StrIfStringOp=${BVTestIfOp:===} ;
 local IsDisplayIfStatement=${BVTestDisplayIf:=False} ; 
 
 local ArrayTestType=( String File Test Int Shell ) ;
 local StrIfPattern ; 
 local ArrayIfPattern=(  ) ;
 ArrayIfPattern[0]="if [ \"${StrVarBoolTest}\" __OP__ \"${StrDefaultBoolTest}\" ] " ;
 ArrayIfPattern[1]="if [ \"__OP__ \"${StrDefaultBoolTest}\" ] " ;
 ArrayIfPattern[2]="if \$( test \"__OP__ \"${StrDefaultBoolTest}\" ) " ;
 ArrayIfPattern[3]="if [ ${StrVarBoolTest} __OP__ ${StrDefaultBoolTest} ] " ;
 ArrayIfPattern[4]="eval ${StrVarNamed} ; res=\$? ; if  [ \${res:=1} __OP__ ${StrDefaultBoolTest} ] " ;
 

 ###
 ### ArrayIfPattern, Loop and test to select proper 
 ### StrIfTestType and it's Operator StrIfStringOp.
 ###
 for (( intx=0 ; intx <= ${#ArrayTestType[@]}-1 ; intx++ )) ; do 
  if [ "${StrIfTestType}" == "${ArrayTestType[${intx}]}" ] ; then 
   StrIfPattern=${ArrayIfPattern[${intx}]//__OP__/${StrIfStringOp}} ; 
  fi 
 done 
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 
 local StrTestTemplate=""" 
  ${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\" ;
  __IF_PATTERN__ ; then
    ${StrVarNamed}=${StrNotAsserted} ;
  fi
  """
  StrTestTemplate=${StrTestTemplate//__IF_PATTERN__/${StrIfPattern}} ; 
  
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  echo -ne "${StrTestTemplate}" ; 
  if [ "${IsDisplayIfStatement}" == "True" ] ; then 
   echo -ne "\nFunction ${__call_locality[1]}, Display Result:\n ${StrTestTemplate}\n" > /dev/stderr ; 
  fi 
 fi
 
}


##################################                 ########################
################################## In Prototyping  ########################
################################## Start           ########################

unset PropertyLibName
function PropertyLibName()
{
	local __call_locality=( PLN PropertyLibName ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]};
	local StrAction=${PLNAction:=Add} ; 
	local StrLibName=${PLNLib:=NONE} ; 
	local StrOutArrayRef=${PLNArrayRef:=ArrayLibName} ;
	local ArrayActionType=( Add Delete Test Show ) ; 
	
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
	
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local ArrayArg=( $* ) ; 
		local Arg0=${ArrayArg[0]};
					
	}
	
	
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  StrAction=${StrAction}           \ 
  StrLibName=${StrLibName}         \
  StrOutArrayRef=${StrOutArrayRef} \
  __main_StartServices       ${Arg0} ; 
 fi
	
}
##################################                 ########################
################################## In Prototyping  ########################
################################## End             ########################


##################################                 ########################
################################## In Prototyping  ########################
################################## Start           ########################

 ###
 ### function BodyFunc()
 ### - Like BoolVarTestVarCreation, is defined to create on-demand if-pattern based on True Statement-Initial affectation and 
 ### residual False statement as Assertive condition being another mechanism or either a branch this function BodyFunc
 ### will manage the switch condition from Arg0, know to be the Operator for finite and unique action. Actual Action are 
 ### Getter, List, Helper and StartServices. __Future__ view predict uses of Setter where it's actually tweaked with external
 ### Subset of command within Bash whole-list of command. Developped has Micro-Architecture expansion require several
 ### analysis and may depend of another compromised information related to Data. Data used from Setter Will stay out of the
 ### code and actual Pre-fixed Variable are unique Start-up information where ultimately all information will migrate to None after
 ### uniformisation and expansion of Exception into proper design. 
 ###
 ###
 ### BodyFunc Goal :
 ### To create an [ if / elif / n-elif / fi ] command from finite action required inside need of fnct_debian_lib to be wise information
 ### discovery . Wise-Discovery is not part of the function-type itself, but any coumpound will have Serious Notation and 
 ### minimal helper.  Actually it will cover Finite action of Listing Prefixed-Var or Transport-Layer signature and Getter will 
 ### extract entry from this Transport Layer, know to be actual Prefixed-Var. 
 ###
 ### BodyFunc and Expanded Entry inside Finite action, StartServices uses : 
 ### - Since Getter, Helper and List are simple finite action, a function body from this lib are the core of evolving multi-party-actor
 ### involving many sub-derivate. Example: 
 ### Inside PackageRepositoryMgmt, uses of GetOtherDate is crutial to leave a valid-footprint inside and index based on File-system
 ### information deposition. 
 ###
 ### - The StartServices being a function with Tiny Prefixed-Var internally be a Inter-transport-Layer, it should result into calling a 
 ### possible function inside the Function Body or Any good compound from this Lib with awarness of calling correctly any Pre-fixed
 ### var. 
 ### Exception in Internal design from Function to Sub-Function Transport-Layer this mechanism is not regulated, but will not work if 
 ### variable are not transfered. 
 ###
 ### Facility in External transport connection of BodyFunc. 
 ### - The prefixed-variable BFStackVariableList will accept a language operator known to be '+' sign to allow any conversion 
 ### from good appelation of working function inside fnct_debian_lib by calling it and extracting variable. uses of GetOtherDate will
 ### be use inside the example. 
 ###
 ### BFStackVariableList=$( GetOtherDate --list | sed 's/\([a-zA-Z]*\)/\1+,/g;s/\ //g;s/+,+,/+/g'  ) BF*=... BodyFunc 
 ###
 ### Will shorten the transfert mechanism from Outgoing Transport-Connection into automated StackList adding sequence, and 
 ### will also offer Glueing technique for several descendant  uses of BoolVarTestVarCreation / Function_from_fnct_debian_lib, and 
 ### BodyFunc, with consideration had possibilty to be a fixed if-elif-fi topology . 
 ###



function BodyFunc()
{
 local __call_locality=( BF BodyFunc ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]};

 local StrHelpCmd="GetVarReference ${__call_locality[1]} ;  echo -ne \"${StrSwitchMessages}\" > /dev/stderr ; " ;
 local StrGetCmd=" eval \"\"\"local ArgGet=\${\${ArrayArg[1]}}\"\"\" ;  echo -ne \"\"\"\${ArgGet}\n\"\"\" ; "
 local StrListCmd="eval \$( __GetVarReferenceList ) ;" ;
 local StrStartServicesCmd="__main_StartServices" ;
 local StrDefineHelp=${BFHelpSwRules:=Help:--help:__HELP__:StrHelpCmd} ;
 local StrDefineGet=${BFGetSwRules:=Get:--get:__GET__:StrGetCmd} ;
 local StrDefineList=${BFListSwRules:=List:--list:__LIST__:StrListCmd} ;
 local StrDefineStartServices=${BFStartServicesSwRules:=StartServices:--startservices:__ApplicationMain__:StrStartServicesCmd} ;
 local StrVarConvertOp=${BFVarTransfertOp:=+} ; 
 ###
 ### The Prefixed-var BFVarTransfertOp:
 ### - To reduce rewriting, using the Operator '+' inside the Prefixed-Var BFStartServicesSwRules using rule like
 ### BFStackVariableList=Var1+ will transform Var1=Value by Var1=${Var1} inside Template __Stack_Variable__
 ### - Assuming BodyFunc is mangling the bottom of a function inside fnct_debian_lib into protocolar function creation
 ### with self verification ability like transfert mechanism and assignation possibility.
 ###
 local StrStackVar=${BFStackVariableList:=StrFileTmp=+,StrTitle="A title",IntSleep=+,Size=IntFontSize,IsEditField=+,IntWidth=+,IntHeight=+,IntDefaultModeExec=+} ;
 local ArrayServicesSwitches=( ${StrDefineHelp} ${StrDefineGet} ${StrDefineList}  ${StrDefineStartServices} )
 
 local StrPatternIf="""if [ \"${Arg0:=--startservices}\" == \"--help\"	] ; then 
 __HELP__ 
elif [ \"${Arg0:=--startservices}\" == \"--get\" ] ; then 
 __GET__ 
elif [ \"${Arg0:=--startservices}\" == \"--list\" ] ; then 
 __LIST__ 
elif [ \"${Arg0:=--startservices}\" == \"--startservices\" ] ; then 
  __Stack_Variable__ 
  __ApplicationMain__ ; """ ;

echo -ne "BodyFunc Pattern\n\n--------------------------------------------------\n${StrPatternIf}\n--------------------------------------------------\n"
}

##################################                 ########################
################################## In Prototyping  ########################
################################## End             ########################


 ### ValueToVariable :
 ###
 ###
 ###	Full-length example : 
 ### Including 1 example :
 ###
 ### $> 
 ### 
 ### - It Open Windows from Zenity with parameter for Text-info in editable
 ### mode.
 ### 
 ### It Open by default a uuid-like temporary file. There is no actual was
 ### to modify the name, but assuming the implementation of ZenityShellEval
 ### imply a limited acces to shell, you might recuper information from shell
 ### or futur adding to transfert a name or simple renaming the uuid-like
 ### file-name... This is to prevent auto-execution of a script from 
 ### canned-design by playing with without having all clearly create your 
 ### shell script and/or having fully pseudo-code explained and having 
 ### confirmation of your design work... 

unset ValueToVariable
function ValueToVariable( )
{
 local ArrayArg=( $* ) ;
 local __call_locality=( VTV ValueToVariable ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]}  
 
 
 local IsValueSimpleConvert=${VTVIsValueToConvert:=True} ;
 local IsValueToAssignSame=${VTVIsValueReAssign:=False} ;
 local IsValueIndTransform=${VTVIsTransformed:=False} ;
 local IsValueTransScript=${VTVIsTransHadScript:=False} ;
 local StrDefaultTransScript=${VTVITransformScript:=None} ;
 local StrDefaultTransform=${VTVDefaultTransform:=(s/[SIB][tno][tro][a-zA-Z]+)/\$\{\1\}/g} ;
 local StrAppsName=${VTVAppsName:=sed} ; 
 local StrAppsOpt=${VTVAppsOpt:=-r} ;
 local StrDefaultSedScript='s/([SIB][tno][tro][a-zA-Z]+)/\$\{\1\}/g' ;
 local StrDefaultAssignScript='s/([SIB][tno][tro][a-zA-Z]+)/\1=\$\{\1\}/g' ;
 function __main_StartServices()
 {
  local __call_locality=( Main __main_StartServices ) ;
  local Arg0=${ArrayArg[0]} ;
  local ArrayArg=( $* ) ;
  eval ${StrAppsName} ${StrAppsOpt} '' 
 }

 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  IsValueSimpleConvert=${IsValueSimpleConvert}     \
  IsValueToAssignSame=${IsValueToAssignSame}       \
  IsValueIndTransform=${IsValueIndTransform}       \
  IsValueTransScript=${IsValueTransScript}         \
  StrDefaultTransScript=${StrDefaultTransScript}   \
  StrDefaultTransform=${StrDefaultTransform}       \
  StrAppsName=${StrAppsName}                       \
  StrAppsOpt=${StrAppsOpt}                         \
  StrDefaultSedScript=${StrDefaultSedScript}       \
  StrDefaultAssignScript=${StrDefaultAssignScript} \
  __main_StartServices                             ; 
 fi

}

unset AutoChown ;
function AutoChown()    
{ 
	local __call_locality=( AC AutoChown ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]};
 local StrUser=${ACUser:=maxiste.maxiste} ; 
 local IntSleep=${ACSleep:=30} ; 
 local IsPathRecurr=${ACRecurrent:=True} ; 
 local StrApps=${ACChownApps:=chown} ; 
 local IsLoop=${ACLooping:=True}
 local StrPathList=${ACPathList:=Path1:Path2} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local ArrayArg=( $* ) ; 
		local Arg0=${ArrayArg[0]};
  local ArrayPath=( ${StrPathList//:/ } ) ; 
  
  eval $( BVTestVarName=StrRecurrent BVTestVarHold='-R' BVTestBoolVarName=\${IsPathRecurr} BVTestBoolCase=False BVTestBoolAssertion='' BVTestScopeTest=local BoolVarTestVarCreation ) ; 
  eval $( BVTestVarName=IntXWh BVTestVarHold='1' BVTestBoolVarName='\${IsLoop}' BVTestBoolCase=False BVTestBoolAssertion='0' BVTestScopeTest=local BoolVarTestVarCreation ) ; 
  
  while [ ${IntXWh} -eq 1 ] ; do 
    for (( x=0 ; x <= ${#ArrayPath[@]}-1 ; x++ )) ; do 
     local StrPathName=${ArrayPath[${x}]} ; 
     chown ${StrUser} ${StrPathName} ${StrRecurrent} ; 
    done ; 
    if [ "${IsLoop}" == "False" ] ; then 
     IntXWh=0 ; 
    fi 
   sleep ${IntSleep} ; 
  
  done
 }
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  StrUser=${StrUser}               \
  IntSleep=${IntSleep}             \
  StrOutArrayRef=${StrOutArrayRef} \
  IsPathRecurr=${IsPathRecurr}     \
  StrApps=${StrApps}               \
  StrPathList=${StrPathList}       \
  IsLoop=${IsLoop}                 \
  __main_StartServices             ; 
  
 fi
 
 
}
 ### ZenityShellEval :
 ###
 ###
 ###	Full-length example : 
 ### Including 1 example :
 ###
 ### $> ZenityShellEval (Enter)
 ### 
 ### - It Open Windows from Zenity with parameter for Text-info in editable
 ### mode.
 ### 
 ### It Open by default a uuid-like temporary file. There is no actual was
 ### to modify the name, but assuming the implementation of ZenityShellEval
 ### imply a limited acces to shell, you might recuper information from shell
 ### or futur adding to transfert a name or simple renaming the uuid-like
 ### file-name... This is to prevent auto-execution of a script from 
 ### canned-design by playing with without having all clearly create your 
 ### shell script and/or having fully pseudo-code explained and having 
 ### confirmation of your design work... 
 ### 
 ### - Like ZenityShellEval, will reach first stage-maturity fast enought,
 ### it's possible the followed function will move into fnct_lib or fnct_lib_tool,
 ### being a method to control chuck of information like descendant script lib
 ### where fnct_debian_lib should descent from:
 ### 
 ### Level1 : ( fnct_lib or fnct_lib_tool )
 ###     |
 ###     +-----------> fnct_debian_lib ( Second Level )
 ###                          |
 ###                          +----------> { _sub_PackageRepository
 ###                                         _sub_Git
 ###                                         _sub_ssh_handler        } ( Third level and specialized chunk )
 ### 
 ### Where fnct_lib shall have all mandatory function being Really Essential.
 ### Where fnct_lib_tool shall have all common tools to create code and Interract
 ### with UX ( User Experience. )
 ### 
 ### Note: UX, like HP-UX, for Home-Profesionnal User-eXperience, and not UX for Unix/*nix 
 ### 
 ### Example of code for ZenityShellEval
 ### 
 ### Assuming you are looking to link fastly unpacked .deb from File-manager into
 ### Unusual path and wanting to link against correct uses nvidia-driver to 
 ### possibly manage a fake instance of CUDA from not-wished Capable-Card like 
 ### Geforce 7000M, where it can exist at leat 4 to 8 node of CUDA GPU which is
 ### not enought because minimal number of node are 16 and higher and willing 
 ### to create so-cheap demo card around 1999-2002 in displaced time-and-space
 ### 
 ### - So having to find all nvidia .so lib, it should be linked inside 
 ### /usr/lib/nvidia-304.84 which is your memory having merely remember the 
 ### automated design from version 295.xx . 
 ### Following that you bring into /usr/lib/lib*.so.1, /usr/lib/lib*.so.[3-5]
 ### all other linked lib found inside /usr/lib/nvidia-304.84,
 ### 
 ### In Other term it's
 ### Also seed to uses X from Xorg with the nouveau driver and wich to use 
 ### the entire GPU memory location and VDPAU reserved operation for GPUing.
 ### Like a package allowing to store image into GPU memory card... Having
 ### feeling many slice of superposed image is just a matrix canonical-form
 ### of code assembly to re-interpret into real execution... 
 ### 
 ### the sample to put inside the Zenity Text-Info in editable mode :
 ### 
 ### ----------------------------- SAMPLE ----------------------------- 
 ### 
 ### function test_expr()
 ### {
 ###   local __call_locality=( Filter __filter ) ;
 ###   local Arg0=${ArrayArg[0]} ;
 ###   local ArrayArg=( $* ) ; 
 ###   local StrPath=/usr/local/src/apt/nvidia-304 ;
 ###   function __filter()
 ###   {
 ###     local __call_locality=( Filter __filter ) ;
 ###     local Arg0=${ArrayArg[0]} ;
 ###     local ArrayArg=( $* ) ; 
 ###     local StrFilterGrep=${FilterGrep:='lib32'} ;
 ###     local StrTaillingSearch={FilterTrSearch:=[:cntrl:]};
 ###     local StrTaillingRepl=${FilterTrReplace:=' '} ;
 ###     grep -v "${StrFilterGrep}" | tr '${StrTaillingSearch}' '${StrTaillingRepl}' ; 
 ###   }
 ###   local AF=( $( find ${StrPath} -type f -iname "*.so*" | __filter ) ) ; 
 ###   for (( x=0 ; x<= ${#AF[@]}-1; x++ )) ; do 
 ###    item=${AF[${x}]} ; 
 ###    local _file=( ${item//\// }  ) ; 
 ###    local file="${_file[$((${#_file[@]}-1))]}" ;
 ###    echo ln -s ${item} $(pwd)/${file} ; 
 ###   done
 ### }
 ### test_expr ; 
 ### ----------------------------- SAMPLE ----------------------------- 
 ### 
 ### You hit Enter or OK from the Window 'Shell Evaluation command', and 
 ### Should not give you an error, if so the same code reapear and you 
 ### have to find yourself the error if ZenityShellEval was not executed
 ### from allowed Terminal or Windows-shell . 
 ### If you do executed it from, you can read error and seemlesly seek for 
 ### error... 
 ### 
 ### - Later example might have support for error like puting into warning 
 ### Windows, error. And possibly conversion between uuid-like file into 
 ### finite name... 
 ### 
 ### PS: Hint:
 ###  - Using AutoChown will also let use execute the script with your own
 ### user and group, and might allow you to put it elsewhere like into 
 ### localized-execution section..... 
 ### 
 ### 
 
 

unset ZenityShellEval ;
function ZenityShellEval()    
{ 
	local __call_locality=( ZSE ZenityShellEval ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]}              ;
 local IntSleep=${ZSESleepInterval:=5}  ;
 local IntFontSize=${ZSEFontSize:=12}   ; 
 local IsEditField=${ZSEEditable:=True} ; 
 local IsAddFootPrint=${ZSEAddFootPrint:=True} ; 
 local StrTitle=${ZSEZenityTitle:='Shell Evaluation command'} ;
 local StrFileName=${ZSEFileName:=None} ;
 local StrDateFormat=${ZSEDateFormat:=%Y%m%d-%H:%M:%S,%s}
 local IntDefaultModeExec=${ZSEChmodFileExec:=775} ;
 local StrFilePath=${ZSEPathStorage:=./} ; 
 local IntWidth=${ZSEWindowWidth:=640} ;
 local IntHeight=${ZSEWindowHeight:=400} ;
 local IsLoopOnSucc=${ZSELoopOnSucc:=True} ; 
 local IsCheckSumOnly=${ZSECheckSumTest:=False} ; 
 
 ### Note: f1161962-0ad8-11e3-b166-001b3875b29c 
 ### 
 ### Title : Variable Forwarding Example in BoolVarTestVarCreation & mutation 
 ### of BoolVarTestVarCreation from True/False test into None
 ### 
 ### BoolVarTestVarCreation for substitution of StrFileTmp has unidirectionnaly
 ### a uuid-like file name into Pre-fixed Var ZSEFileName:=None for 
 ### affectation inside StrFileName=None, where if this one != None, will 
 ### get the parameter Name Being passed inside StrFileTmp. 
 ### 
 ### - Had consequence:
 ###  - if the file does not exist, an echo > StrFileTmp will be done . 
 ###  - if the file exist, content will be open by Zenity in text-info --editable
 ###  - Selected filename supplied, content will be overwritted and there is 
 ###  no protection mechanism and no verification against file-permission
 ###    - To this, a workaround will store all code generated from this application
 ###    - into sub-directory being made by the command and store-it inside user
 ###      respective home location which is safe and Pre-fixable into 
 ###      your specification, and not-warrented to be correct but designable. 
 ###  
 ### 
 ### - If the variable ZSEFileName is untouched, the content of StrFileTmp will
 ### hold value 'None' and belong to parsed BoolVarTestVarCreation it should 
 ### get it's uuid-like filename, see generated command from parameter below
 ### 
 ### Command : BVTestVarName=StrFileTmp BVTestVarHold='${StrFileName}' BVTestBoolVarName=\${StrFileName} BVTestBoolCase=None BVTestBoolAssertion='$( uuidgen -t )' BVTestScopeTest=local BoolVarTestVarCreation
 ### 
 ### generated code:
 ### local StrFileTmp="${StrFileName}" ; 
 ### if [ "${StrFileName}" == "None" ] ; then 
 ###  StrFileTmp=$( uuidgen -t ) ; 
 ### fi
 ### 
 ### Which is making sense. 
 ### 
 ### Also Note f1161962-0ad8-11e3-b166-001b3875b29c introduce explanation on mutation of BoolVarTestVarCreation from True/False test into None and moving uuid-file-id variable inside BVTestBoolAssertion
 ### 
 ### 
 eval $( BVTestVarName=StrFileTmp \
         BVTestVarHold='${StrFilePath}/${StrFileName}' \
         BVTestBoolVarName=\${StrFileName} \
         BVTestBoolCase=None \
         BVTestBoolAssertion='${StrFilePath}/$( uuidgen -t )' \
         BVTestScopeTest=local \
         BoolVarTestVarCreation ) ; 
 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 

	function __main_Editor()
 {
		local __call_locality=( Editor __main_Editor ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ;
  test ! -e ${StrFileTmp} && echo "" > ${StrFileTmp} ; 
  
  local res=1 ; 
  local shell_res=0 ; 
  local shell_quit=0 ; 
  eval $( BVTestVarName=StrEditableAttr \
          BVTestVarHold='--editable' \
          BVTestBoolVarName=\${IsEditField} \
          BVTestBoolCase=False \
          BVTestBoolAssertion='' \
          BVTestScopeTest=local \
          BoolVarTestVarCreation ) ; 
  
  
  while [ ${res} -eq 1 -a ${shell_quit} -eq 0 ] ; do 
   CmdEval=$( zenity \
              --text-info ${StrEditableAttr} \
              --font=${IntFontSize} \
              --filename=${StrFileTmp} \
              --title="${StrTitle}" \
              --width=${IntWidth} \
              --height=${IntHeight} ) ; 
   res=$? ; 
   if [ ${res} -ne 1 ] ; then 
    ### 
    ### FootPrint Section
    ###
    ###
      function _NoFootPrint()
      {
        echo -ne "###\n### No FootPrint Added, see Prefixed-Var ZSEAddFootPrint from ZenityShellEval\n###\n###\n###\n###\n###\n###\n###\n###\n###\n" ; 
      }
      function _FootPrint()
      {
        local StrUUID=$( uuidgen -t ) ; 
        local StrSha1Sum=$( echo "${CmdEval}" | sha1sum | cut -d ' ' -f 1)
        local StrSize=$( echo "${CmdEval}" | wc -c ) ; 
        local StrNbWord=$( echo "${CmdEval}" | wc -w ) ; 
        local StrDateConfirm=$( GetOtherDateFormat='${StrDateFormat}' GetOtherDate )
        echo -ne "###\n### FootPrint Added, see Prefixed-Var ZSEAddFootPrint from ZenityShellEval\n###\n\n###File:${StrFileTmp}\n###UUID-TIME-MARKER:${StrUUID}\n###Date: ${StrDateConfirm}\n###Sha1Sum: ${StrSha1Sum}\n### Size:${StrSize}\n### NbWord: ${StrNbWord}\n\n" ; 
      }
      function _DetectFootPrint()
      {
       local IntFootPrintDetection=$( echo -ne "${CmdEval}" | head -n 11 | egrep -ic "FootPrint" ) ;
       eval $( BVTestVarName=StrFootPrintMark BVTestVarHold='$( StrDateFormat=${StrDateFormat} CmdEval=${CmdEval} _FootPrint )' BVTestBoolVarName=\${IsAddFootPrint} BVTestBoolCase=False BVTestBoolAssertion='$( _NoFootPrint )' BVTestScopeTest=local BoolVarTestVarCreation ) ;
      }
      
      eval $( BVTestVarName=StrFootPrintMark BVTestVarHold='$( StrDateFormat=${StrDateFormat} CmdEval=${CmdEval} _FootPrint )' BVTestBoolVarName=\${IsAddFootPrint} BVTestBoolCase=False BVTestBoolAssertion='$( _NoFootPrint )' BVTestScopeTest=local BoolVarTestVarCreation ) ;       
      
    ###
    ### End FootPrint
    ###
    
    
    echo """${StrFootPrintMark}\n${CmdEval}""" > ${StrFileTmp} ; 
    chmod 775 ${StrFileTmp} ; 
    . ${StrFileTmp} ; 
    shell_res=$?
    if [ ${shell_res} -eq 1 ] ; then 
     echo -ne "\n\n\tUser Shell evaluation reported error\n\n" > /dev/stderr ; 
     res=1 ; 
     shell_res=1 ; 
    fi 
   else 
    echo -ne "\n\n\tUser cancel the test.\n\n" > /dev/stderr ; 
    shell_quit=1 ; 
   fi ; 
   sleep ${IntSleep} ; 
   test ${res} -eq 0 -a ${shell_res} -eq 0 && eval $( BVTestVarName=res BVTestVarHold='0' BVTestBoolVarName=\${IsLoopOnSucc} BVTestBoolCase=False BVTestBoolAssertion='1' BVTestScopeTest=local BoolVarTestVarCreation ) ; 
  done
  echo -ne "\n\tQuitting Function :${__call_locality[1]}\n\n" > /dev/stderr ;  
 }
 function __main_CheckSum()
 {
		local __call_locality=( CheckSum __main_CheckSum ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ;
  local CheckSumFile=$( cat ${StrFilePath}/${StrFileName} | grep -v "^###" | sha1sum | cut -d ' ' -f 1  ) ; 
  local CheckSumIdentity=$( cat ${StrFilePath}/${StrFileName} | grep "^###Sha1Sum:" | cut -d ' ' -f 2  | sed 's/[\ \t]//g' ) ;
  echo -ne "File: ${CheckSumFile}\nFootprint: ${CheckSumIdentity}\n" > /dev/stderr ; 
  if [ ${CheckSumFile} == ${CheckSumIdentity} ] ; then 
   echo -ne "file-shasum:${StrFilePath}/${StrFileName}:MATCH\n" ; 
  else
   echo -ne "file-shasum:${StrFilePath}/${StrFileName}:FAILED\n" ; 
  fi 
 }

 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  if [ "${IsCheckSumOnly}" == "True" ] ; then 
   StrFilePath=${StrFilePath} StrFileName=${StrFileName} __main_CheckSum ; 
  else
   StrFileTmp=${StrFileTmp}                 \
   StrTitle=${StrTitle}                     \
   StrDateFormat=${StrDateFormat}           \
   IntSleep=${IntSleep}                     \
   IntFontSize=${IntFontSize}               \
   IsEditField=${IsEditField}               \
   IntWidth=${IntWidth}                     \
   IntHeight=${IntHeight}                   \
   IntDefaultModeExec=${IntDefaultModeExec} \
   IsEditField=${IsEditField}               \
   IsAddFootPrint=${IsAddFootPrint}         \
   IsLoopOnSucc=${IsLoopOnSucc}             \
   IsCheckSumOnly=${IsCheckSumOnly}         \
   __main_Editor                            ; 
  fi


 }
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
		eval $( __GetVarReferenceCompWord ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
   StrFileTmp=${StrFileTmp}                 \
   StrTitle=${StrTitle}                     \
   StrDateFormat=${StrDateFormat}           \
   IntSleep=${IntSleep}                     \
   IntFontSize=${IntFontSize}               \
   IsEditField=${IsEditField}               \
   IntWidth=${IntWidth}                     \
   IntHeight=${IntHeight}                   \
   IntDefaultModeExec=${IntDefaultModeExec} \
   IsEditField=${IsEditField}               \
   IsAddFootPrint=${IsAddFootPrint}         \
   IsLoopOnSucc=${IsLoopOnSucc}             \
   IsCheckSumOnly=${IsCheckSumOnly}         \
   __main_StartServices                     ; 
 fi


}



 ### StartCoproc :
 ###
 ###
 ###	Full-length example : 
 ### Including 
 ###
 ###
 ###
 ###
 ###
 ###
 ###
 ###
 ###


unset StartCoproc
function StartCoproc()
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( StartCoproc ) ; 
 local Arg0=${ArrayArg[0]} ; 
 ### Prototype model, 
 ### - Require . /etc/init.d/Fnct.d/_sub_Git to work. 
	### coproc git_fnct_debian { while [ ${res:=0} -ne 1  ] ; do res=$( GitHubCommitFilePath=/etc/init.d/Fnct.d  GitHubCommit fnct_debian_lib ) ; sleep 5 ; done ; }
	local StrValueParserInfo="""
	VPCallLocalityName=${__call_locality[0]} 
	VPVarArgList=Str:ProcName,
	             Str:InWhile,
	             Str:WhCond,
	             Str:WhRetStat,
	             Str:AppsName,
	             Str:AppsPrVar,
	             Str:AppsOpt
	VPScopeList=ProcName:local,
	             InWhile:local,
	             WhCond:local,
	             WhRetStat:local,
	             AppsName:local,
	             AppsPrVar:local,
	             AppsOpt:local,
	VPValueList=DefaultCoprocName:True:__VAR__ -ne 1:__VAR__=\$( __CMD__ ):GitHubCommit:GitHubCommitFilePath=/etc/init.d/Fnct.d:fnct_debian_lib
	""" ;
	
	eval $( eval "${StrValueParserInfo} ValueParser " ) ;
	local EvalCoprocCmd=( ${StrAppsPrVar} ${StrAppsName} ${StrAppsOpt} ) ; 
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
	local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${Arg0:=--startservices}" == "--help" ] ; then 
		GetVarReference StartCoproc ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		eval ${StrValueParserInfo} ValueParser --varhelper
		echo -ne "--asarray\tStart The application and output the content into an Array, see varriable                               PkgConfigAllArrayName to change the name. This command need an eval braced                              to get the array being initialized.\n\n"
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
		echo ""
		### Prog To create a coprocess 
		#if [ ${StrInWhile} ]
	fi
}


### Package Query function. 
### give by-package, many option at once. 
### 
### Single package:
### ex: GetPackage=flac PkgConfigQuery --cflags --libs
### 
### will output:
### 
### flac:--cflags:-I/usr/include/FLAC  
### flac:--libs:-lFLAC -lm  
### flac++:--cflags:-I/usr/include/FLAC++ -I/usr/include/FLAC  
### flac++:--libs:-lFLAC++ -lFLAC -lm  
### 
###
### Many Package : 
### ex: GetPackage=samplerate,flac PkgConfigQuery --cflags --libs 
### samplerate:--cflags: 
### samplerate:--libs:-lsamplerate  
### flac:--cflags:-I/usr/include/FLAC  
### flac:--libs:-lFLAC -lm  
### flac++:--cflags:-I/usr/include/FLAC++ -I/usr/include/FLAC  
### flac++:--libs:-lFLAC++ -lFLAC -lm  


function PkgConfigQuery()
{ 
	local ArrayArg=( $* );
	local __call_locality=( PkgQuery ) ;
	local Arg0=${ArrayArg[0]:=--start} ; 
	local ArrayArgFlag=( ${ArrayArg[@]:1} ) ; 
	local IntArgLen=${#ArrayArgFlag[@]} ;
	local StrValueParserInfo="VPCallLocalityName=${__call_locality[0]} VPVarArgList=Str:AppsName,Str:AppsOpt,Str:FlagList,Str:PackageList VPScopeList=AppsName:local,AppsOpt:local,FlagList:local,PackageList:local VPValueList=/usr/bin/pkg-config:--list-all:--libs,--static,--short-errors,--libs-only-l,--libs-only-other,--libs-only-L,--cflags,--cflags-only-I,--cflags-only-other:flac" ;
	
	### Replaced by ValueParser
	#local StrPkgConfigApps=${PkgConfigQueryAppsName:=/usr/bin/pkg-config};
	#local StrPkgConfigAppsOpt=${PkgConfigQueryAppsOption:=--list-all};
	eval $( eval "${StrValueParserInfo} ValueParser " ) ;
	
	#echo -ne "StrAppsName : ${StrAppsName}\n" > /dev/stderr ;
	#echo -ne "StrAppsOpt  : ${StrAppsOpt}\n" > /dev/stderr ;
	#echo -ne "StrFlagList  : ${StrFlagList}\n" > /dev/stderr ;
	#echo -ne "StrPackageList  : ${StrPackageList}\n" > /dev/stderr ;
	
	#local StrPackageList=${PkgConfigQueryGetPackage:=flac} ;
	#local StrFlagList=${PkgConfigQueryFlagList:=--libs,--static,--short-errors,--libs-only-l,--libs-only-other,--libs-only-L,--cflags,--cflags-only-I,--cflags-only-other} ;
	local ArrayFlagTest=( ) ;
	function FilterPackageList()
	{
		local ArrayArg=( $* );
		local __call_locality=( FilterPackageList ) ;
		local StrGrepFilter=${FilterPackageListGrepFilter:=${CurrentPackage}}
		cut -d " " -f 1 | egrep -i "${StrGrepFilter}" | tr '[:cntrl:]' ' ' 
	}

		#local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 
 	if [ "${Arg0:=--start}" == "--help" ] ; then 
			GetVarReference PkgConfigQuery ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
			eval ${StrValueParserInfo} ValueParser --varhelper ;
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	else
		if [ ${IntArgLen:=0} -eq 0 ] ; then 
			ArrayFlagTest=( ${StrFlagList//,/ } ) ; 
		else
			ArrayFlagTest=( ${ArrayArgFlag[@]} ) ; 
		fi 		
		local ArrayPackageListVar=( ${StrPackageList//,/ } ) ;
		for (( intAx=0 ; intAx <= ${#ArrayPackageListVar[@]}-1 ; intAx++ )) ; do 
			local CurrentPackage="${ArrayPackageListVar[${intAx}]}" ; 
		  local _A=( $( ${StrAppsName} ${StrAppsOpt} | FilterPackageListGrepFilter=${CurrentPackage} FilterPackageList ) );
		  local IntNbPackage=${#_A[@]} ;
		  if [ ${IntNbPackage:=0} -gt 0 ]; then
		      for ((x=0 ; x <= ${#_A[@]}-1 ; x++ )) ; do
		          for (( cx=0 ; cx <= ${#ArrayFlagTest[@]}-1 ; cx++ )) ; do
		              res=$( ${StrAppsName} ${_A[${x}]} ${ArrayFlagTest[${cx}]} );
		              echo -ne "${_A[${x}]}:${ArrayFlagTest[${cx}]}:${res}\n";
		          done;
		      done;
		  else
		      echo -ne "\n\n\tPackage Not Found\n" > /dev/stderr;
		  fi
		done 
	fi 
}

### Warning : 
### This version of pkg-config-all is aliased to pkg-config inside .bashrc of the user shell and following function 
### are also dependent of alias .
### cut -> to alias cut='/usr/bin/cut -d "'" "'" '
### pkg-config -> to alias pkg-config='pkg-config-all'
### 
### 
### 


function pkg-config-all()
{
	local __call_locality=( PkgConfigAll ) ; 
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
	local StrValueParserInfo="VPCallLocalityName=${__call_locality[0]} VPVarArgList=Str:ArrayName,Int:Scoping,Str:CutAlias,Str:AppsName,Str:AppsOpt VPScopeList=ArrayName:local,Scoping:local,CutAlias:local,AppsName:local,AppsOpt:local VPValueList=ArrayPackageName:1:cut:/usr/bin/pkg-config:--list-all ValueParser" ;
	
	eval $( eval "${StrValueParserInfo} ValueParser " ) ;
	### ValueParser replace following value.
	#local StrpackageName=${PkgConfigAllArrayName:=ArrayPackageName}	;
	#local IntScoping=${PkgConfigAllScoping:=1}	;
	#local StrCutAlias=${PkgConfigAllCutAlias:=cut}	;
	#local StrPkgConfig=${PkgConfigAllApps:=/usr/bin/pkg-config} ; 
	echo -ne "Var StrAppsName: ${StrAppsName}\nVar StrAppsOpt: ${StrAppsOpt}\n" > /dev/stderr ;
	function Main()
	{
		local ArrayScopingType=( "local" "declare -a");
		if [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
			eval "${StrAppsName} --list-all | ${StrCutAlias} -f 1" ; 
		elif [ "${Arg0:=--startservices}" == "--asarray" ] ; then 
				local StrPackageList=$( ${StrAppsName} ${StrAppsOpt} | eval "${StrCutAlias} -f 1" | tr '[:cntrl:]' ' ' ) ; 
				echo -ne "${ArrayScopingType[${IntScoping}]} ${StrArrayName}=( ${StrPackageList} )\n" ;
		fi
	}
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 	if [ "${Arg0:=--startservices}" == "--help" ] ; then 
		GetVarReference pkg-config-all ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		eval ${StrValueParserInfo} --varhelper
		echo -ne "Following switch are available:\n\n\t--startservices\tStart the application normally and output the package list\n\t--asarray\tStart The application and output the content into an Array, see varriable                               PkgConfigAllArrayName to change the name. This command need an eval braced                              to get the array being initialized.\n\n"
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	else
		Arg0=${Arg0} StrAppsName=${StrAppsName} StrCutAlias=${StrCutAlias} StrAppsOpt=${StrAppsOpt} IntScoping=${IntScoping} StrArrayName=${StrArrayName} Main
	fi
}


function ObjFindFunction()
{
 local ArrayArg=( $* )	;
 local __call_locality=( ObjFindFunction ) ; 
 local Arg0=( ${ArrayArg[0]} ) ; 
 
	local StrDllFunctionFind=${ObjFindFunctionDllList:=iolog_unlink,GetUserDetailsType,GetCommandDetailsType}  ; 
	local dllFunction=( ${StrDllFunctionFind//,/ } ) ; 
	local StrObjDumpFlagsSet=${ObjFindFunctionFlagSet:=--dynamic-syms;--syms}
	local StrObjDumpApps=${ObjFindFunctionObjApps:=objdump} ;
	
	local ArrayInspecType=( ${StrObjDumpFlagsSet//;/ } ) ; 
	local StrPathStartFind=${ObjFindFunctionPath:=./} ;
	local StrDllSuffix=${ObjFindFunctionDllSearch:=*.so} ;
	local StrUniqueIDType=${ObjFindFunctionUUIDType:=--time} ;
	local StrUniqueIDTypeApps=${ObjFindFunctionUUIDType:=uuidgen} ;
	local StrPrintfFormat=${ObjFindFunctionPrintfFormat:="%h/%f"} ;
	
	function GetUniqueUUID()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( GetUniqueUUID ) ; 
		local StrUUIDFlags=${GetUniqueUUIDFlags:=--time} ; 
		local StrUUIDApps=${GetUniqueUUIDApps:=uuidgen} ; 
		
		eval """ local StrUUID=$( ${StrUUIDApps} ${StrUUIDFlags}  ) """ ;
		echo -ne "${StrUUID}" ; 
	} ; 
	function GetFindList()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( GetFindList ) ; 
		local StrStartPath=${GetFindListStartPath:=./} ; 
		local StrInameSuffix=${GetFindListNamePatter:=*.so} ; 
		local StrPrintfFormat=${GetFindListPrintfFormat:="%h/%f"} ; 
		
		find ${StrPathStartFind} -type f -iname "${StrInameSuffix}" -printf "${StrPrintfFormat}" ; 
	}
	function DllSearch()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( DllSearch ) ; 
		StrDllInspectApps=${DllSearchApps:=objdump} ; 
		StrDllInspectFlagsInArg=${DllSearchFlags:=--dynamic-syms} ; 
		StrDllInspectFlags=${StrDllInspectFlagsInArg//,/ } ;
		StrFileSearch=${DllSearchFileName:=None} ; 
		StrDllFunctionName=${DllSearchFunctionName:=none} ; 
		eval """ ${StrDllInspectApps} ${StrDllInspectFlags} ${StrFileSearch} | egrep -ic "${StrDllFunctionName}" """ ; 
		
	}
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
	
	if [ "${Arg0:=--startservices}" == "--help" ] ; then 
	 GetVarReference ${__call_locality[0]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	else
		local ArrayDll=( $( GetFindListStartPath=${StrPathStartFind} GetFindListNamePatter=${StrDllSuffix} GetFindListPrintfFormat=${StrPrintfFormat} ) ) ; 
		for StrdllFunction in ${dllFunction[@]}; do 
			for (( intx=0 ; intx <= ${#ArrayDll[@]}-1 ; intx++ )) ; do 
				item="${ArrayDll[${intx}]}" ; 
				for DllTypeInspect in ${ArrayInspecType[@]} ; do 
					local UUID_T=$( GetUniqueUUIDApps=${StrUniqueIDTypeApps} GetUniqueUUIDFlags=${StrUniqueIDType} GetUniqueUUID ) ;  
					isDllfunction=$( DllSearchApps=${StrObjDumpApps} DllSearchFlags=${DllTypeInspect} DllSearchFileName=${item} DllSearchFunctionName=${StrdllFunction} DllSearch ) ; 
					dllState=${isDllfunction:=0} ; 
					echo -ne "PKID:${UUID_T}:found:${dllState}:DllInpectMeth:${DllTypeInspect}:Function:${StrdllFunction}:dllName:${item}\n" ; 
				done ; 
			done ; 
		done
	fi
	
 
}

### Default Fast reference Helper. 
### Extract current Prefixed variables from your function and show it on stdout( screen output ). 
### The prefixed variable are indicated on decalation of __call_locality which usually had same name has 
### top function. 
### Desc : It actively look inside the function code and extract value prefixed with function name...
### was initially developped on $0, but change by creating subFunction, and some code may be reserved for private
### use or recurrent-code with recurrent variable name, may be show and alter your perception of functionality of 
### the design ...

### Example to implement the body-helper. 
### 
### function Helper()
### {
###  __call_locality=( Helper ) ; 
### 	local ArrayArg=( $* ) ; 
### 	local Arg0=${ArrayArg[0]}; 
###  local StrHelperInvolved=${HelperQuestionInvolved:=Nothing} ; ### <---1a 
### 	if [ "${Arg0:=--start}" == "--help" ] ; then 
###			GetVarReference ${__call_locality[0]} ; 
###  else	
###   ---> Normal Body event and code. 
###  
###   ... 
###  fi 
### }
### 
### Note, In case your Helper --help be tested, if it does not output only Prefixed var definition.
### retreive all your variable from your command and do like example StrHelperInvolved in 1a
### Create specific local variable and associate the content of your Prefixed variables, help get 
### better body definition and reduce complexity by reading it... 
### 



unset __GetVarReferenceList ;
function __GetVarReferenceList( )
{
		echo -ne """eval ${__call_locality[1]} --help 2> /dev/null | egrep -i \"^Variable\" | cut -d ' ' -f 2 | tr '[:cntrl:]' ' '""" ; 
}


unset DefaultConfigure ;
function DefaultConfigure()
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( DefConfigure ) ; 
	local StrDefaultAction=${DefConfigureAction:=--start-services} ;
	local Arg0=${ArrayArg[0]:=${StrDefaultAction}}; 
	local StrLD='${DefConfigureLD:=${LD} -laudiofile}' ; 
	local StrLDFLAGS='${DefConfigureLDFLAGS:=${LDFLAGS}}' ; 
	local StrCXX=${DefConfigureCXX:=\${CXX}} ; 
	local StrCC=${DefConfigureCC:=\${CC}} ; 
	local StrCPP=${DefConfigureCPP:=\${CPP}} ; 
	local StrCFLAGS=${DefConfigureCFLAGS:=\${CFLAGS}} ;
	local StrCPPFLAGS=${DefConfigureCPPFLAGS:=\${CPPFLAGS}} ; 
	local StrCXXFLAGS=${DefConfigureCXXFLAGS:=\${CXXFLAGS}} ; 
	local StrNewConfigureOptFile=${DefConfigureOptFile:=${HOME}/.DefConfigureOption} ; 
	local StrNameConfigure=${DefConfigureName:=default} ;
	
	local CmdEval=( ./configure  ) ;
	
	function GetNameConfigureOption()
	{
			local ArrayArg=( $* ) ; 
			local __call_locality=( GetConfOpt ) ; 
			local Arg0=${ArrayArg[0]}; 
			local StrNameOption=${GetConfOptName:=default} ;
			local StrOptionFile=${GetConfOptFile:=${HOME}/.DefConfigureOption} ;
			local StrGrepSep=${GetConfOptSep:=:} ;
			local StrGrepPattern=${GetConfOptGrepPattern:=__PATTERN____SEP__} ;
			local StrGrepForm="${StrGrepPattern//__PATTERN__/${StrNameOption}}";
			StrGrepForm=${StrGrepForm//__SEP__/${StrGrepSep}} ; 
			local StrContent=$( cat ${StrOptionFile} | egrep -i ${StrGrepForm} | head -n 1 | cut -d ':' -f 2- ) ; 
			echo -ne "${StrContent}" ; 
	}
	local StrConfigureContentTest="" ;
	test -e ${StrOptionFile} && local StrConfigureContentTest=$( GetConfOptName=${StrNameConfigure} GetConfOptFile=${StrNewConfigureOptFile} GetNameConfigureOption ) ; 
	local StrConfigureContent=${StrConfigureContentTest:=--help} ; 
	#local StrConfigContent=$( test -e ${StrNewConfigureOptFile} && local CmdEval=( ./configure  ) ) ; 
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
	local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${ArrayArg[0]}" = "--help" ] ; then 
		GetVarReference DefaultConfigure ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	elif [ "${ArrayArg[0]}" == "${StrDefaultAction}" ] ; then 
		CmdEval=( ${CmdEval[@]} ${StrConfigureContent} ) ; 
		echo -ne "Configure option extracted: \n\t${CmdEval[@]}\n\n" > /dev/stderr ; 
		#eval """${CmdEval[@]}""" ; 
	elif [ "${ArrayArg[0]}" == "--add" ] ; then 
		echo -ne """Adding Configure Option Name:${StrNameOption}:\n\t\t\t${ArrayArg[@]:1:}\n""" > /dev/stderr ; 
		local StrExportSream="""${StrNameConfigure}:__configure__ ${ArrayArg[@]:1:} LD=\"${StrLD}\" LDFLAGS=\"${StrLDFLAGS}\" CXX=\"${StrCXX}\" CC=\"${StrCC}\" CPP=\"${StrCPP}\" CFLAGS=\"${StrCFLAGS}\" CPPFLAGS=\"${StrCPPFLAGS}\" CXXFLAGS=\"${StrCXXFLAGS}\" ${ArrayArg[@]:1:}""" ; 
		StrExportSream=${StrExportSream//__configure__/${StrNameOption}} ;
		echo -ne "Configure Command:\n\t${StrExportSream}\n" > /dev/stderr ; 
		#echo -ne "${StrExportSream//__configure__/${StrNameOption}}\n" >> ${StrNewConfigureOptFile} ; 
	elif [ "${ArrayArg[0]}" == "--update" ] ; then 
		echo -ne """Updating Configure Option:\n\t\t${ArrayArg[@]:1:}\n""" > /dev/stderr ; 
	elif [ "${ArrayArg[0]}" == "--remove" ] ; then 
		echo -ne """Removing Configure Option:\n\t\t${ArrayArg[@]:1:}\n""" > /dev/stderr ; 
	else
		echo -ne """Arg0 No option specified\n""" > /dev/stderr ; 
	fi

	
}

 ### IsPathName :
 ###
 ###
 ###	Full-length example : 
 ### Including 2 main definition
 ###
 ### - Return value:
 ### if the test success, it report number of element retain in grep filter. 
 ###  - it also return 0 in case of sucess and 1 if fail. 
 ### example: 
 ###
 ### - Return True on a test on Arg0 to be a path with appropriate sematic for current path. 
 ### IsPathName ./avfsd 
 ### -> return 0 
 ###
 ### IsPathNameAction=CurrentPath IsPathName ./avfsd 
 ### -> return 0 
 ###
 ### IsPathName /avfsd 
 ### -> return 1 # This is not a current path specified. 
 ###
 ### IsPathName IsPathNameAction=IsRootPath avfsd 
 ### -> return 1 # This is not a Rooted-path name.
 ###
 ### IsPathName IsPathNameAction=IsRootPath /avfsd 
 ### -> return 0 .
 ###
 ###


unset IsPathName 
function IsPathName()
{
		local __call_locality=( IsPathName );
		local ArrayArg=( $* ) ;
		local Arg0=${ArrayArg[0]}; 
		local ArgActionList=${IsPathNameActLst:=CurrentPath,IsRootPath}
		local RegActionList=${IsPathNameReglst:="^\.+\/"__SEP__"^\/"} ; 
		local StrAction=${IsPathNameAction:=CurrentPath} ; 
		local IntReturnValue=0 ; 
		local IntReturnState=0 ; 
		
		local ArrayActionList=( ${ArgActionList//,/ } ) ; 
		local ArrayRegExp=( ${RegActionList//__SEP__/ } ) ; 
		
		#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
		if [ "${ArrayArg[0]}" = "--help" ] ; then 
			IntReturnState=0 ;
			GetVarReference ${__call_locality[0]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
		else
			for(( intx=0 ; intx <= ${#ArrayActionList[@]]}-1 ; intx++ )) ; do 
			 local StrReg="${ArrayRegExp[${intx}]}" ;
			 local StrMainAction=${ArrayActionList[${intx}]} ; 
			 if [ "${StrAction}" == "${StrMainAction}" ] ; then 
					IntReturnValue=$( echo "${Arg0}" | egrep -ice "${StrReg}"	 2&>1 /dev/null ) ; 
			 fi 
			done 
		 if [ ${IntReturnValue:=0} -gt 0 ] ; then 
				IntReturnState=0 ;
			else
				IntReturnState=1 ;
			fi 
			
		fi 
		return ${IntReturnState} ;  
}



 ### GetOtherDate :
 ###
 ###
 ###	Full-length example : 
 ### Including Loop to create different day pattern
 ###
 ### hint:
 ### - Having to check 1 day before and 1 day after need to combine 
 ### settign GetOtherDateReferenceFormat="__INT__ day" , and not "__INT__ day ago", give you positive forward in time
 ### setting GetOtherDateIsLoop=True 
 ### setting GetOtherDateLoop=-1,1 ( tricky but work ) , create interleave between -1 to 1, so it's -1 day in futur, 0 day in futur and 1 day in futur... 
 
 ### GetOtherDateReferenceFormat="__INT__ day ago"  GetOtherDateFormat="%Y%m%d" GetOtherDateIsLoop=True GetOtherDateLoop=1,4 GetOtherDateVerbose=True  GetOtherDate
 ### Will display :
 ### 
 ### 20121010
 ### 20121011
 ### 20121012
 ###
 ### Short example :
 ### GetOtherDate
 ###
 ### Will display :
 ###
 ### 20121011
 ###
 ### GetOtherDateReferenceFormat="__INT__ day ago"
 ###
 ###


unset GetOtherDate ;
function GetOtherDate()
{
		local __call_locality=( GetOtherDate GetOtherDate );
		local ArrayArg=( $* ) ; 
		
		function Verbosis()
		{
			local __call_locality=( Verbosis );
			local StrMsg=${VerbosisMsg:=__TEXT__} ; 
			local StrDevOut=${VerbosisDev:=/dev/stderr} ; 
			local ArrayArg=( $* ) ; 
			if [ ${ArrayArg[0]} == "True" ] ; then 
				echo -ne "${StrMsg}" > ${StrDevOut} ;
			fi
			
		}
		
		function DateFunc()
		{
			local __call_locality=( DateFunc ) ;
			local ArrayArg=( $* ) ; 
			eval """date +"${DateFuncFormat:=%Y%m%d}" -d '${DateFuncIndicator:=0 day}'""" ; 
		}
		
		local StrDateIndicatorFormat=${GetOtherDateReferenceFormat:='__INT__ day'}
		local StrDateIndicator=${StrDateIndicatorFormat/__INT__/${GetOtherDateReference:=0}}  ;
		local StrDateFormat=${GetOtherDateFormat:=%Y%m%d} ;
		local isLoop=${GetOtherDateIsLoop:=False} ;
		local LoopRange=${GetOtherDateLoop:=0,3} ;
		local ArrayRange=( ${LoopRange/,/ } ) ;
		local OperRange="<=" ;  
		local OperRangeIn="Intx++" ;
		local OperBaseStart=${ArrayRange[0]} ;
		local IsVerbose=${GetOtherDateVerbose=False} ;
		local IntEndLoop=$(( ${ArrayRange[$((${#ArrayRange[@]}-1))]} ));
		
		local Arg0=${ArrayArg[0]}; 
		#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
		
 	if [ "${Arg0:=--start}" == "--help" ] ; then 
			GetVarReference ${__call_locality[0]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
	 else	 
	 	if [ "${isLoop:=False}" == "True" ] ; then 
				VerbosisMsg="ArrayRange, nb-element:${#ArrayRange[@]}, hold [ ${ArrayRange[@]} ]\n" Verbosis ${IsVerbose} ;
				if (( ${ArrayRange[0]} > ${IntEndLoop} )) ; then 
					OperRange=">=" ;
					OperRangeIn="Intx--" ; 
					OperBaseStart=${ArrayRange[$((${#ArrayRange[@]-1))}]} ;
				fi		
	 		VerbosisMsg="Looping from ${OperBaseStart} to ${IntEndLoop} \n" Verbosis ${IsVerbose} ;
	 		for (( Intx=${OperBaseStart} ;  Intx ${OperRange} ${IntEndLoop} ; ${OperRangeIn} )) ; do 
		 			StrDateIndicator="${StrDateIndicatorFormat/__INT__/${Intx}}" ; 
		 			DateFuncFormat=${StrDateFormat} DateFuncIndicator=${StrDateIndicator} DateFunc ;
	 		done
	 	else 
	 		DateFuncFormat=${StrDateFormat} DateFuncIndicator=${StrDateIndicator} DateFunc ;
			fi
 	fi 
}



unset kill_cmd ; 
function kill_cmd()    
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( kill_cmd ) ;  
	local IntDefaultKillSig=${kill_cmdDefaultSigInt:=-9} ;
	local StrColDisplayInSearch=${kill_cmdPsColList:=pid,command}
	local IntNbCol=$(( $( echo "${StrColDisplayInSearch}" | wc -m ) - $( echo "${StrColDisplayInSearch//,/}" | wc -m ) ))
	local IntIdPassToKiller=${kill_cmdColIdToKill:=${IntNbCol}} ; 
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
	if [ "${ArrayArg[0]}" = "--help" ] ; then 
		GetVarReference ${__call_locality[0]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	else
		for (( x=0 ; x <= ${#ArrayArg[@]}-1 ; x++ )) ; do 
			local cmd=${ArrayArg[${x}]} ; 
			local PsResult=$( ps -eo ${StrColDisplayInSearch} | egrep -i "${cmd}" | grep -v grep | cut -d ' ' -f ${IntIdPassToKiller} | tr '[:cntrl:]' ' ' )
			CmdEval=( kill ${IntDefaultKillSig} ${PsResult} ); 
			echo -ne "PsResult:\n\n${PsResult}\n\n" > /dev/stderr ;
			echo -ne "Command Eval:[ ${CmdEval} ]\n" > /dev/stderr ; 
		done 
	fi 
}




unset StartApps
function StartApps()
{ 
 local ArrayArg=( $* ) ; 
 local __call_locality=( StartApps ) ; 
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${ArrayArg[0]}" = "--help" ] ; then 
		GetVarReference ${__call_locality[0]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 else	 
	 local AppsRefresh=${StartAppsRefresh:=4} ; 
	 local Apps=${StartAppsCmd:=rezound --audio-method=jack} ; 
	 local ScanApps=${StartAppsScan:=rezound} ; 
		local StrAppsStopSig=/home/${USER}/stop_${ScanApps}
	 local IsStopSig
		IsStopSig=$( test -e ${StrAppsStopSig} && echo 1 );
	 while [ ${IsStopSig:=0} -eq 0 ] ; do 
		local isApps=$( ps -eo pid,command | grep -v egrep | egrep -ic "${ScanApps}" ) ; 
		if [ ${isApp:=0} -eq 0 ] ; then 
		 eval ${Apps} ; 
		fi ; 
		sleep ${AppsRefres} ; 
			IsStopSig=$( test -e ${StrAppsStopSig} && echo 1 ) ;
	 done ; 
		rm -f ${StrAppsStopSig} ;
		echo -ne "Exiting signal catch for Application ${Apps} to cancel respawing.\n" > /dev/stderr 
 fi
}



function Survey_kill_apps()    
{ 
    function KillApps()
    {
        local __call_locality=( KillApps ) ; 
        local ArrayArg=( $* ) ; 
        kill -9 $( ps -eo pid,command | egrep -i "${ArrayArg[0]}" | grep -v "egrep" | sed 's/^[\ \t]*//g' | cut -d " " -f 1 )
    }
    local __call_locality=( SurveyApps ) ; 
    local ArrayArg=( $* ) ; 
		#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
		if [ "${ArrayArg[0]}" = "--help" ] ; then 
		 GetVarReference Survey_kill_apps ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
		else	 
		  local StrApps=${SurveyApps:=rezound} ; 
		  local IntDelay=${SurveyAppsRefresh:=4} ; 
		  while [ 1 ] ; do 
		      test -e /home/maxiste/kill_${StrApps} && \
		          rm -f /home/maxiste/kill_${StrApps} && \
		          KillApps ${StrApps} 
		      sleep ${IntDelay} ; 
		  done ; 
		fi
}



### Usefull for python installer using pip. 
### Happen more than once have to call pip with another gcc compiler while test failed to compile many source
### from Numpy numpy/linalg/lapack_litemodule.c and linalg/zlapack_lite.c failling or doing segmentation fault.
### Most of the time they can work compiling them direct from the shell but in bash script called from bash or
### python script like setup.py failed... 
### So I'm changing couple of variable and calling indivilually pip installer like this :
### Where cmd old followin value : cmd=( pip install __MODULE__ )
### eval $( DpkgGetInlineBuildFlags ) CC=/usr/bin/x86_64-linux-gnu-gcc-4.4 CXX=/usr/bin/x86_64-linux-gnu-g++-4.4 ${cmd[@]}

unset DpkgGetInlineBuildFlags ; 
function DpkgGetInlineBuildFlags()
{
  local __call_locality=( DpkgGetInlineBuildFlags ) ;
  local ArrayArg=( $* ) ;
		#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 	if [ "${ArrayArg[0]}" = "--help" ] ; then 
			GetVarReference ${__call_locality[0]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
 	else	 
  	local CmdEval=( "cat" "${DpkgGetInlineBuildFlagsPath:=/etc/dpkg/}"${DpkgGetInlineBuildFlagsFile:=buildflags.conf} "|" """sed -e 's/^\(SET\ \)\([a-zA-Z]*FLAGS\)\([\t\ ]*\)/\2=/g'""" "|" tr """'[:cntrl:]\' ' '""" ) ;
  	eval "${CmdEval[@]}" ;
	fi 

}


unset fast_dpkg_build ; 
function fast_dpkg_build()    
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( FDB ) ; 
	local StrOptionDpkgBuild=${FDBDpkgBuildOpt:=} ;
	local StrOptionDpkgInst=${FDBDpkgInstOpt:=} ;
	for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
		local StrPackage=${ArrayArg[${intx}]} ; 
		cd /usr/local/src/apt/ ; 
		md_cd $(pwd)/${StrPackage} ; 
		cd ${StrPackage} ; 
		local IntBuild=0 ; 
		apt-src install ${StrOptionDpkgInst} -p ${StrPackage} && apt-src ${StrOptionDpkgBuild} -p build ${StrPackage} && IntBuild=1 ; 
		echo -ne "\n\n\tBuild Status\n\t\titem : ${StrPackage}\n\t\tStatus: ${IntBuild}\n\n" ; 
		dpkg --install $( find ./ -type f -iname "*.deb" -printf "%p " ) ; 
	done ; 
}



unset DebianAptSrcCompiler ; 
function DebianAptSrcCompiler()
{
	local __call_locality=( DebianAptSrcCompiler ) ; 
	local ArrayArg=$( $* ) ; 
 local ArrayPackageName=( ${DebianAptSrcCompilerPackage//;/ } ) ;
	local CompilerVersion=${DebianAptSrcCompilerVersion:=4.4} ; 
	local StrAptProc=${DebianAptSrcCompilerPackageAptProc:=clean;install;build}
	local AddPatch=${DebianAptSrcCompilerPatch:=True} ;
	local ArrayAptSrcProc=( ${StrAptProc//;/ }  ) ; 
	local StrPatchOpt="" ; 
	local res_exec=0 ; 
	local StrPath=${DebianAptSrcCompilerPath:=/usr/local/src/apt} ;
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${ArrayArg[0]}" = "--help" ] ; then 
  GetVarReference ${__call_locality[0]} ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ; 			
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( __GetVarReferenceList ) ;
 else	 	
  if [ ${AddPatch:=True} == "True" ]; then 
   StrPatchOpt="-p" ;
  else
   StrPatchOpt="" ;
  fi 
 for Package in ${ArrayPackageName[@]} ; do 
  local old_dir=$( pwd )
  test ! -d ${StrPath}/${Package} && mkdir -p ${StrPath}/${Package} ;
  cd ${StrPath}/${Package} ; 
  apt-src update ;
  local UpdateState=$? ;
  if [ ${UpdateState:=0} -eq 0 ] ; then 
   echo -ne "\t\t----- Building -----\n\t\t\t${Package}\n\n" > /dev/stderr ; 
   for item in ${ArrayAptSrcProc[@]} ; do 
    echo -ne "\n\n\n\t\t----- APT-SRC STEP: -----\n\t\t\t${item}\n\n\n" > /dev/stderr ; 
    CC=${DebianAptSrcCompilerCBaseName:=/usr/bin/x86_64-linux-gnu-gcc-}${CompilerVersion} \
    CXX=${DebianAptSrcCompilerCXXBaseName:=/usr/bin/x86_64-linux-gnu-g++-}${CompilerVersion} \
    apt-src ${item} ${Package} ${StrPatchOpt} ; 
    res_exec=$? ; 
    echo -ne "\n\n\t\t-----------------\n\t\t Error Status: ${res_exec}\n\t\t-----------------\n\n" > /dev/stderr  ;  
   done ;
   else
    echo -ne "\n\n\t\t-------------------------------------------------------\n\t\t Error compilation/installation of ${Package}\n\t\t-------------------------------------------------------\n" > /dev/stderr 
   fi 
   cd ${old_dir}  ;
  done 
  fi
}

 ### AptRebuild :
 ### - Use script apt-src to commonly clean and build a debian source packages
 ###  being installed as source and it's ready to compile. This function uses 
 ###  the prefixed variable AptRebuildCommand to select any new order wanted to
 ###  pass to the function. 
 ###    - Commonly AptRebuildCommand is owning 'clean,build' but affecting it with 
 ###  other task like install and build can be substitued to this Common Task. 
 ###
 ###	Full-length example : 
 ### AptRebuildCommand=install,build AptRebuild libots-dev
 ###
 ### hint:
 ###  - switch '--help' is available for this function. 
 ### 
 ### 
 ### 
 
 ### Fixing a Predefined Association of Tag and Variable Name using the GetVarReference structure. 
 ### AptRebuild, may own it's own purposes by assigning to AptRebuildTagVar other variable and 
 ### other Tag inside AptRebuildTag prefixed var. meaning it can support 
 ###
 ###  following call : 
 ###    NewVar=Value AptRebuildTagVar=NewVar,Option,Package,StrAppsName,StrAppsOptExtr AptRebuildTag=__OTHERTAG__,__OPTION__,__PACKAGE__,__APPS__,__APPSOPT__ AptRebuild <package-module>, and will automatically parse the Variable NewVar into ${NewVar} (in this case it exist and will not overwrite the affected value.) into the Tag __OTHERTAG__. 
 ### 
 ###  This also need to change the AptRebuildExec Tag order to let it evaluate correctly. 
 ### 
 ### Use of Pre-Fixed Variable AptRebuildExec and AptRebuildTag. 
 ### 
 ### Description:
 ### - While this function is quite restricted, it's a mechanism that feed definition and will
 ### ultimately execute the sequence. Having a strong role inside AptRebuildCommand. the code 
 ### is structured like 1-finite loop of instruction and have to parse the commandline 
 ### defined inside AptRebuildExec and having others application being substitued you can
 ### create a virtual other command working inside this type of loop. 
 ### 
 ###  AptRebuildCommand hold 2 item : clean,build 
 ###  - where this variable fix the first command to own instruction for 'clean' and 'build' . 
 ###  - The Argument List after the  AptRebuild are the complete loop whitin First Fixed Element,
 ###  Variable -> Tag and execution . The case is tweaky, assuming eth0 and wlan0 are ultimately
 ###  the source being analysed with other condition , This one will pre-used eth0 and wlan0, 
 ###  to use the Forced Variable Package to hold eth0 or wlan0. This mean Package and 
 ### 
 ###  AptRebuildApps hold usually apt-src but in other case it may hold network-topology application
 ### being used. One popular, ifconfig. 
 ###  - In many uses ifconfig may also depend os some fixed instruction. like seeing the interface
 ### eth0 and wlan0 to verify both information. 
 ### 
 ### give as parameter : AptRebuildCommand=eth0,wlan0  AptRebuildApps=ifconfig 
 ### 
 ### AptRebuildExec and AptRebuildTag are also the order you want to use pre-defined 
 ### VAR -> __TAG__ substitution and the way the command exit depend of working example.
 ### 
 ### And there is 2 finite hard-fixed value to not remove because it hold in a double-loop value
 ### from iteration 
 ### for A ( Argument[ 0 - 15+ ] )
 ### 			 for B ( AptRebuildCommand ) 
 ### 					--- Parsing Level and Substitution Level --- 
 ### 
 ### - Also some basic prefixed value also own it's priority .
 ### AptRebuildAppsOption -> Internally used as StrAppsOptExtr will use the tag you defined but 
 ### need to be reflected inside the Tag-Loop Association. It will use 
 ### AptRebuildTag=__OPTION__,__PACKAGE__,__OTHEROPTION__ and use tag __OTHEROPTION__ is definied inside 
 ### AptRebuildTagVar, like :
 ### AptRebuildTagVar=Option,Package,StrAppsOptExtr AptRebuildTag=__OPTION__,__PACKAGE__,__OTHEROPTION__
 ### and commandline inside AptRebuildExec should reflect an __OTHEROPTION__ tag. 
 ### 
 ### AptRebuildApps -> Internally used as StrApps will own have to define it's own Tag too. 
 ### 
 ### 
 ### example : ifconfig eth0 -apr 
 ###  - To Set NOARP to your local ethernet card. 
 ###  
 ###  - And AptRebuildTag will look like this : 
 ###   AptRebuildCmdExec=False \
 ###   AptRebuildApps=ifconfig \
 ###   AptRebuildCommand=eth0,wlan0 \
 ###   AptRebuildAppsOption=-arp \
 ###   AptRebuildTag=__OPTION__,__PACKAGE__,__APPS__,__OTHEROPTION__ \
 ###   AptRebuildTagVar=Option,Package,StrAppsName,StrAppsOptExtr \
 ###   AptRebuildExec=__APPS__,__OPTION__,__OTHEROPTION__,__PACKAGE__  AptRebuild -v 
 ### 
 ### Will give a sequence to set -arp and verbosis to internet working interface:
 ### 
 ### AptRebuildCmdExec=False AptRebuildApps=ifconfig AptRebuildCommand=eth0,wlan0 AptRebuildAppsOption=-arp AptRebuildTag=__OPTION__,__PACKAGE__,__APPS__,__OTHEROPTION__ AptRebuildTagVar=Option,Package,StrAppsName,StrAppsOptExtr AptRebuildExec=__APPS__,__OPTION__,__OTHEROPTION__,__PACKAGE__  AptRebuild -v
 ### - Output
 ### 
 ###  	Processing eth0
 ### 
 ### CommandLine:[ ifconfig eth0 -arp -v ]
 ### 	Processing wlan0
 ### 
 ### CommandLine:[ ifconfig wlan0 -arp -v ]
 ### 
 ###  just by setting AptRebuildCmdExec=False to True will allow executing the sequence. 
 ### 
 ### 
 ### ... Just a good candidate for automation and generating corpus definition in variable transfert and
 ### Variable substitution. 
 

 ### AptSrcChange :
 ### 
 ### - Function AptSrcSourceChange, change the default /etc/apt/source.list and restitute it
 ### after coming back from the application apt-src. 
 ### -Note : apt-src is dependant from packages apt-src, and need to be installed with apt, dpkg
 ### and/or synaptic. 
 ### - It voluntary change the source.list until it was more convenient to alter the content
 ### of this file by replacing only debian information for package retrevial into debian-source
 ### package. It also change the type of architecture and it's convenient to leave and/or 
 ### adapt other application dependant from /etc/apt/source.list . 
 ### 
 ###  exemple : 
 ###   - synaptic depend from /etc/apt/source.list  
 ### using AptSrcChangeApps=synaptic AptSrcChange 
 ###  - and will load automatically synaptic after doing a change inside /etc/apt/source.list .  
 ###  - it will not do an automatic update. Like apt-src need to run periodically apt-src update
 ### to update it's cache, synaptic has this example show there is no update available as external 
 ### switch and the condition are not yet defined to supply a function for automatic-update. 
 ### ... while python module from apt and dpkg can re-update and write the cache it was not supply 
 ### here. 
 ### 
 ### 


 
unset AptSrcChange
function AptSrcChange()
{
 local __call_locality=( AptSrc ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ; 
 local IntUUID=$( uuidgen -t ) ; 
 local StrUUID="/tmp/${IntUUID}" ; 
 local StrApps=${AptSrcChangeApps:=/usr/bin/apt-src} ; 
 local StrAptSourceList=${AptSrcChangeFile:=/etc/apt/sources.list} ; 
 local StrAptSourceSave=${AptSrcChangeSave:=/etc/apt/sources.list.save} ; 
 local StrTagSearch=${AptSrcChangeTagSearch:=deb} ;
 local StrTagAdd=${AptSrcChangeTagChange:=deb-src} ;
 local StrDefaultArch=${AptSrcChangeArch:=amd64} ;
 local StrDefaultURI=${AptSrcChangeURIType:=http}
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${Arg0}" = "--help" ] ; then 
  GetVarReference ${__call_locality[0]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
		else	
  cp ${StrAptSourceList} ${StrAptSourceSave} ; 
  cat ${StrAptSourceList} | sed 's/^${StrTagSearch} ${StrDefaultURI}/${StrTagAdd} [ arch=${StrDefaultArch} ] ${StrDefaultURI}/g' > ${StrUUID} ; 
  cp ${StrUUID} ${StrAptSourceList} ; 
  echo -ne "\n\tUUID: ${StrUUID}\n" > /dev/stderr ; 
  if [ "${StrApps}" == "/usr/bin/apt-src" ]  ;then 
   # doing extra update 
   eval "${StrApps} update" ; 
  fi 
  eval "${StrApps} ${ArrayArg[@]}" ; 
  cp ${StrAptSourceSave} ${StrAptSourceList}
 fi
}

unset AptRebuild ; 
function AptRebuild()    
{ 
	local __call_locality=( AptRebuild ) ; 
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
	local StrCSVSep=${AptRebuildCSV:=,} ; 
	local StrAppsName=${AptRebuildApps:=apt-src} ; 
	local StrAppsOptExtr=${AptRebuildAppsOption:=-p} ; 
	local StrCmdLine=${AptRebuildExec:=__APPS__,__OPTION__,__APPSOPT__,__PACKAGE__} ; 
	local StrCmdTag=${AptRebuildTag:=__OPTION__,__PACKAGE__,__APPS__,__APPSOPT__}
	local StrCmdTagVar=${AptRebuildTagVar:=Option,Package,StrAppsName,StrAppsOptExtr}
	local IsShowDebug=${AptRebuildShowDebug:=False} ;
	local IsCmdExec=${AptRebuildCmdExec:=True} ;
	local StrCmdOption=${AptRebuildCommand:=clean,build} ; 
	cmdline=( ${StrCmdLine//${StrCSVSep}/ } ) ; 
	
	local ArrayTag=( ${StrCmdTag//${StrCSVSep}/ } ) ; 
	local ArrayOption=( ${StrCmdOption//${StrCSVSep}/ } ) ; 
	local ArrayOptionVar=( ${StrCmdTagVar//${StrCSVSep}/ } )
	
	
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
	if [ "${Arg0}" = "--help" ] ; then 
		GetVarReference ${__call_locality[0]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	else	 
		for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
			Package=${ArrayArg[${intx}]} ; 
			for (( intAx=0 ; intAx <= ${#ArrayOption[@]}-1 ; intAx++ )) ; do
				local Option=${ArrayOption[${intAx}]} ;
				echo -ne "\tProcessing ${Option}\n" > /dev/stderr
				local CmdExec=( ${cmdline[@]} ) ; 
				
				for (( intCx=0 ; intCx <= ${#ArrayOptionVar[@]}-1 ; intCx++ )) ; do 
					local tagName=${ArrayTag[intCx]} ; 
					local varName=${ArrayOptionVar[intCx]} ; 
					eval """local NewVarValue=\${${varName}}""" ; 
					if [ "${IsShowDebug}" == "True" ] ; then 
						echo -ne "\t\ttagName: ${tagName}\n\t\tvarName: ${varName}\n\t\tValue: ${NewVarValue}\n" > /dev/stderr ; 
					fi
					eval """CmdExec=( ${CmdExec[@]//${tagName}/${NewVarValue}} )""" ; 
				done 
				echo -ne "\nCommandLine:[ ${CmdExec[@]} ]\n" > /dev/stderr ; 
				if [ ${IsCmdExec:=True} == "True" ] ; then 
					eval ${CmdExec[@]} ; 
			  fi
			done
		done
	fi 
}



function find_edit_file()
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( FEF find_edit_file ) ; 
	local StrPath=${FEFDefaultPath:=./} ;
	local StrAppsFind=${FEFAppsFind:=/usr/bin/find} ;
	local StrEditor=${FEFEditorApps:=/usr/bin/gedit} ;
	local StrFindFilterOpt=${FEFFindFilter:=-iname \"__FILE__\"} ;

		#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 	if [ "${ArrayArg[0]}" = "--help" ] ; then 
			GetVarReference find_edit_file ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
 	else	
		for file in ${ArrayArg[@]} ; do 
			local StrFilterInFind=${StrFindFilterOpt//__FILE__/${file}}
			eval "${StrAppsFind} ${StrPath} -type f ${StrFilterInFind} -exec ${StrEditor} {} \;" & 
		done ; 
	fi
}

### Usefult having clause with many compiler available and having h2xml or ctag path filtering to apply,
### having command like 
###
### -> h2xml /usr/include/math.h $( find /usr/include/ -type d -printf "-I%p " ) -c -o math_c.xml 
###	 Will reduce output of some treatment... 
###  ->>>
###  ->>>CompilerError: In file included from /usr/include/math.h:34,
###  ->>>                 from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/x86_64-linux-gnu/bits/huge_val.h:28:18: error: missing binary operator before token "("
###  ->>>/usr/include/x86_64-linux-gnu/bits/huge_val.h:30:20: error: missing binary operator before token "("
###  ->>>In file included from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/math.h:403:42: error: missing binary operator before token "("
###  ->>>In file included from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/math.h:30: error: '__BEGIN_DECLS' does not name a type
###  ->>>In file included from /usr/include/math.h:71,
###  ->>>                 from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: '__' was not declared in this scope
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: 'acos' was not declared in this scope
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: '__CONCAT' cannot be used as a function
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: expected primary-expression before ')' token
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: initializer expression list treated as compound expression
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: expected ',' or ';' before '(' token
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:57: error: redefinition of 'double __CONCAT'
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: 'double __CONCAT' previously defined here
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:57: error: 'asin' was not declared in this scope
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:57: error: expected primary-expression before ')' token

###
###
###


unset FindFilterPathExclusion
function FindFilterPathExclusion()    
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( FindFilterPathExclusion ) ; 
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 	if [ "${ArrayArg[0]}" = "--help" ] ; then 
			GetVarReference ${__call_locality[0]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
 	else	 

		### 
		### The chainning mechanism , if there is already used filter, passing thru this 
		### variable will add-it to current filter output. 
		local CurrentExlusion=${FindFilterPathKnowExclusion:=""} ; 
	
		###
		###
		###
		local SelectedPackagePath=${FindFilterPathName:="c++"} ; 

		### - Will tell to filter function if this segment should be considered as
		### first statement and in-middle statement... 
		### example, using FindFilterWithStartCond=True, for a clause for find to start adding -a ! -name "..." 
		### in first statement of if will give command like 
		### find -type d [ -a ! -name "c++/4.4" ] <--- current filter . 
		### will simply be rejected or some warning may issued from . 

		local StartFilterWithCondition=${FindFilterWithStartCond:=False};
		local StrFilterPattern="${FindFilterPattern:=NAME/VER}";
		### 	The FindFilterClause should be written like from Removing To adding
		###   ex: with find, having removing or excluding pattern start like -a ! -name or -o ! -iname ...
		###       and adding or positive filter will include -a name, -o name ... 
		###   and FindFilterClause should be written as : FindFilterClause="-a ! -name,-a name"
		local StrConditionPattern=${FindFilterClause:=! -name, -name}

		local StrTypeOfLogicForAnd=${FindFilterClauseAnd:=-a};
		local StrTypeOfLogicForOr=${FindFilterClauseAnd:=-o};
		local StrLogic=""
		### FindFilterLogicSetTo default choice : ( And / Or )
		### 
		###

		local DefaultLogic=${FindFilterLogicSetTo:=And}; 
		if [ "${DefaultLogic}" == "And" ] ; then
			StrLogic="${StrTypeOfLogicForAnd}" ;
		else
			StrLogic="${StrTypeOfLogicForOr}" ;
		fi 

		local ArrayClauseFilter ;
		for(( intx=1 ; intx <= 2 ; intx++ )) ; do 
			ArrayClauseFilter[${#ArrayClauseFilter[@]}]=$( echo "${StrConditionPattern}" | cut -d "," -f ${intx} ) ;
		done 
	

		local SelectedMajor=${FindFilterMajorVer:=4} ; 
		local SelectedMinor=${FindFilterMinorVer:=4} ; 
		local TypeClauseFilter=0 ;
		for (( intx=${FindFilterMinMajorVer:=0} ; intx <= ${FindFilterMaxMajorVer:=9} ; intx++ )) ; do 
			local StrCriteronFilter=${StrFilterPattern};
			local StrCriteronFilterPrefix="";
				StrCriteronFilter=${StrCriteronFilter/NAME/${SelectedPackagePath}} ;
				StrCriteronFilter=${StrCriteronFilter/VER/${SelectedMajor}.${intx}} ;

			if [ ${intx} -ne ${SelectedMinor:=0}  ] ; then 
				TypeClauseFilter=0 ;
				if [ "${StartFilterWithCondition}" == "True" ] ; then 
					StrCriteronFilterPrefix="${StrLogic} 1${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				else
					StrCriteronFilterPrefix="2${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				fi ;
			fi		

			if [ ${intx} -eq ${FindFilterMinMajorVer:=0} ] ; then 
				TypeClauseFilter=${TypeClauseFilter} ;
				if [ "${StartFilterWithCondition}" == "True" ] ; then 
					StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				else
					StrCriteronFilterPrefix="${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				fi ;
			else
				if [ "${StartFilterWithCondition}" == "False" ] ; then 
					StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				else
					StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				fi ;
			
			fi


			if [ ${intx} -eq ${SelectedMinor:=0} ] ; then 
				TypeClauseFilter=1 ;
				if [ "${StartFilterWithCondition}" == "True" ] ; then 
					StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} ${StrCriteronFilter}" ;
				else
					if [ ${intx} -eq ${FindFilterMinMajorVer:=0} ] ; then 
						StrCriteronFilterPrefix="${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
					else
						StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[1	]} \"${StrCriteronFilter}\"" ;				
					fi
				fi ;
			fi
			CurrentExlusion="${CurrentExlusion} ${StrCriteronFilterPrefix}" ;
		done
		echo -ne "${CurrentExlusion}" ; 
	fi 
}


unset acquire_lan_ifconfig
function acquire_lan_ifconfig()
{
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ; 
 local __call_locality=( AWI ) ; 
 local StrDefaultCard=${AWICardName:=wlan0} ;
 local StrAppsNetConf=${AWIAppsIfconf:=/sbin/ifconfig} ; 
 local StrAwkFilter=${AWIAwkScript:=/etc/init.d/Fnct.d/awk-script/ifconfig_tag_detection.awk} ; 
 local StrTagNameList=${AWIAwkTagInspect:=HWaddr,inet addr,inet6\ addr};
 
 function IfconfigGetter()
 {
  local ArrayArg=( $* ) ; 
  local __call_locality=( IfconfigGetter ) ;
  local StrOptGetter=${IfconfigGetterAddr:=local} ; 
  local StrApps=${IfconfigGetterApps:=/sbin/ifconfig} ; 
  $( eval ${StrApps} ${StrOptGetter} | tr '[:cntrl:]' ' ' | sed 's/[\ ]\+/ /g' ) ; 
 }
 function GetIpaddr()
 {
  local ArrayArg=( $* ) ; 
  local __call_locality=( GetIpaddr ) ;
  local StrAddr=${GetIpaddrAddr:=local} ; 
  local StrAppsIfconfig=${GetIpaddrAppsIfconfig:=/sbin/ifconfig} ;
  local StrAwkFilter=${GetIpaddrFilterMatch:=/etc/init.d/Fnct.d/awk-script/ifconfig_tag_detection.awk} ;   
  local StrTagList=${GetIpaddrTagList:=HWaddr,inet addr,inet6\ addr} ; 
  local StrTagCleanFilter=${StrTagList//\\ / } ;
  local StrReturn=$( IfconfigGetterApps=${StrAppsIfconfig} IfconfigGetterAddr=${StrAddr} IfconfigGetter awk -vTagName="${StrTagCleanFilter}"  -f StrAwkFilter ) ; 
  
 }
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
	if [ "${Arg0:=--start-services}" = "--help" ] ; then 
		GetVarReference acquire_lan_ifconfig ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	elif [ "${Arg0:=--start-services}" == "--start-services" ] ; then 
  GetIpaddrTagList=${StrTagNameList} \
  GetIpaddrAppsIfconfig=${StrAppsNetConf} \
  GetIpaddrAddr=${StrDefaultCard} \
  GetIpaddr ; 
 fi 
}


unset GetBuildFlagsList
function GetBuildFlagsList( )
{
		local ArrayArg=( $* ) ; 
		local __call_locality=( ZPI ) ;  
		dpkg-buildflags --list | tr '[:cntrl:]' ' ' 
} 


unset GetZenityText ; 
function GetZenityText()
{
	local ArrayArg=( $* ) ; 
	local __call_locality=( GZT GetZenityText ) ;  
	local Arg0=${ArrayArg[0]} ;
	local StrTypeUI=${GZTUiType:=--entry}
	local StrApps=${GZTUiApps:=/usr/bin/zenity} ;
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
	if [ "${Arg0:=--startservices}" == "--help" ] ; then 
		GetVarReference ${__call_locality[1]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	else
		eval ${StrApps} ${StrTypeUI} ${ArrayArg[@]} ;
	fi 
}



unset GetZenityTextEntry ; 
function GetZenityTextEntry()
{
	local ArrayArg=( $* ) ; 
	local __call_locality=( GZTE GetZenityTextEntry ) ;  
	local Arg0=${ArrayArg[0]} ;
	local IntWidth=${GZTEWidth:=640}
	local IntHeight=${GZTEHeight:=275}
	local StrTitle="""${GZTETitle:="Pip installation Try-up"}""" ; 
	local StrQuestion="""${GZTETextQuestion:="Installation Package to install (test)"}""" ; 
	local StrReturn ;
	#local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
		if [ "${Arg0:=--startservices}" == "--help" ] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
			eval $( __GetVarReferenceList ) ;
		else
			local CmdEval=( """local StrReturn=\$( GetZenityText --width=${IntWidth}  --height=${IntHeight} --title="${StrTitle}" --text="${StrQuestion}" ) """ ); 
			echo -ne "\n\nCmdEval : ${CmdEval[@]}\n\n" > /dev/stderr ; 
		fi 
		echo -ne "StrReturn return: ${StrReturn}\n" > /dev/stderr ; 
		echo -ne "${StrReturn}" ; 
}



unset zenity_pip_installer ; 
function zenity_pip_installer()    
{ 
	
		local ArrayArg=( $* ) ; 
		local __call_locality=( ZPI ) ;  
		local pkg_res=0 ; 
		function GetItemFlags()
		{
			local ArrayArg=( $* ) ; 
			local __call_locality=( GIF ) ;  
			dpkg-buildflags --get ${ArrayArg[0]} ;
		}
		
		while [ ${pkg_res:=0} -eq 0 ] ; do 
		local ADDFLAGS="" ; 
		local package=$( GetZenityTextEntry ) ; 

		for Item in $( GetBuildFlagsList ) ; do 
			local newFlags=$( GetItemFlags ${Item} ) ;
			ADDFLAGS="${ADDFLAGS} ${Item}=\"${newFlags}\"" ; 
		done  ; 
		echo -ne "ADDFLAGS:\n${ADDFLAGS}\n" ; 
		if [ ${package:=none} != "none"  ] ; then 
			eval ${ADDFLAGS} pip install ${package} ; 
		else 
			echo -ne "\n\n\t\tError reporting package: ${package:=none}\n\n" ; 
			sleep 10 ; 
			pkg_res=1 ;  
		fi ; 
		done ; 
}



unset GkSuZenityLoader ; 
function GkSuZenityLoader()
{
	local __call_locality=( GSZ GkSuZenityLoader ) ; 
	local ArrayArg=( $* ) ; 
 local Arg0=( ${ArrayArg[0]} ) ;

	local StrUser=${GSZLUser:=none}
	local StrApps=${GSZLLApps:=/usr/local/bin/idlex}
	local StrAppsOpt=${GSZLLAppsOpt:=''} ;
	local StrTitle=${GSZLTitle:="Select a user for Idlex"} ;
	local StrFileInfo=${GSZLFile:=/etc/passwd} ;
	local StrCol0=${GSZLCol0:="selection"} ;
	local StrCol1=${GSZLCol1:="user"} ;
	local StrRegSearch=${GSZLLrReg:="\/bin\/bash"}
	local StrDefaultCSV=${GSZLLCSV:=':'} ;
	local IntDefaultColExtr=${GSZLColExtr:=1} ;
	local BoolShowUserSelection=${GSZLSUS:=False} ;
 local BoolUpdateLdconfig=${GSZLUpdadeLdconfig:=True} ;
 local StrLdConfigUser=${GSZLLdconfigUser:=root} ;
 local StrLdconfigGreeting=${GSZLLdconfigGreeting:='\n\nHint\nLoading ldconfig on need if some module require to be loaded from ldconfig ( ex: from pip installation or easy_setup.py ) It can be accessible thru Prefixed-var GSZLUpdadeLdconfig=True from GkSuZenityLoader.\n\n'}
	local BoolShowFGSZ=${GSZShowFuncGSZ:=True} ; 
 
 function ZenityFilter()
	{
			egrep -i ${StrRegSearch} \
   ${StrFileInfo} | \
     cut -d ${StrDefaultCSV} \
     -f ${IntDefaultColExtr} |\
        sed  's/\(^[a-zA-Z0-9]*\)/FALSE \1/g' ; 
	}
	function GetPwdUser()
	{
		local StrUserSelection=$( zenity \
  --list \
  --title "${StrTitle}" \
  --column="${StrCol0}" \
  --column="${StrCol1}" \
  --radiolist $( StrDefaultCSV=${StrDefaultCSV} \
                 StrFileInfo=${StrFileInfo} \
                 StrRegSearch=${StrRegSearch} \
                 IntDefaultColExtr=${IntDefaultColExtr} \
                 ZenityFilter ) ) ;
		StrUserSelection=${StrUserSelection:=${StrUser}} ;
		if [ "${BoolShowUserSelection}" == "True" ] ; then 
			echo -ne "User selected: ${StrUserSelection}\n" > /dev/stderr ; 
		fi 
		echo "${StrUserSelection}" ; 
	}
 function NotificationLdConfig()
 {
		local __call_locality=( NLC NotificationLdConfig ) ; 
		local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ;
  
  local StrTextNotification=${NLCNotifyText:=You will be prompted for password to load __APPS__ with __APPS__ user allowed: __USER__} 
  local StrUser=${NLCAppsUser:=root} ; 
  local StrApps=${NLCAppsName:=ldconfig} ; 
  local StrTagUser=${NLCTagUser:=__USER__} ;
  local StrTagApps=${NLCTagApps:=__APPS__} ;
  StrTextNotification=${StrTextNotification//${StrTagUser}/${StrUser}} ;
  StrTextNotification=${StrTextNotification//${StrTagApps}/${StrApps}} ;
  
  zenity --notification --text="${StrTextNotification}" ; 
 }
 function ScreenDisplayLdconfigHint()
 {
		local __call_locality=( SDLH ScreenDisplayLdconfigHint ) ; 
		local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ;
  
  echo -ne "${StrLdconfigGreeting}" > /dev/stderr ; 
 }
 
 function LdconfigNotification()
 {
		local __call_locality=( LN LdconfigNotification ) ; 
		local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ;
  NotificationLdConfig ; gksu --user ${StrLdConfigUser} ldconfig
 }
 
	function Loader()
	{
		local __call_locality=( Loader Loader ) ; 
		local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ; 
  eval $( BVTestVarName=StrAppsLd \ 
          BVTestVarHold='StrLdconfigGreeting='${StrLdconfigGreeting}' ScreenDisplayLdconfigHint' \
          BVTestBoolVarName=\${BoolUpdateLdconfig} \
          BVTestBoolCase=True \
          BVTestBoolAssertion='LdconfigNotification' \
          BVTestScopeTest=local \
          BoolVarTestVarCreation ) ; 
  eval $( BVTestVarName=StrLdConfigLoad \
          BVTestVarHold='$( eval ${StrAppsLd} )' \
          BVTestBoolVarName=\${BoolUpdateLdconfig} \
          BVTestBoolCase=True BVTestBoolAssertion='$( eval ${StrAppsLd} )' \
          BVTestScopeTest=local \
          BoolVarTestVarCreation ) ; 
		gksu --user ${StrUser} ${StrApps} ${StrAppsOpt} 
	}
 
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 

  #local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;   
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  if [ "${StrUser:=none}" ==  "none" ] ; then 
   StrUser=$( StrDefaultCSV=${StrDefaultCSV} \
      IntDefaultColExtr=${IntDefaultColExtr} \
      StrFileInfo=${StrFileInfo} \
      StrTitle=${StrTitle} \
      StrCol0=${StrCol0} \
      StrCol1=${StrCol1} \
      StrRegSearch=${StrRegSearch} \
      BoolShowUserSelection=${BoolShowUserSelection} GetPwdUser ) ; 
  fi 
  if [ "${StrUser:=none}" == "none" ] ; then 
   echo -ne "Warning Invalid user: ${StrUser}\n" > /dev/stderr ; 
  else
   StrUser=${StrUser}                         \
   StrApps=${StrApps}                         \
   StrAppsOpt=${StrAppsOpt}                   \
   StrLdConfigUser=${StrLdConfigUser}         \
   BoolUpdateLdconfig=${BoolUpdateLdconfig}   \
   StrLdconfigGreeting='${StrLdconfigGreeting}' \ 
   Loader ;
  fi 
  
 }
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
			StrUser=${StrUser}                       \
   StrApps=${StrApps}                       \
   StrAppsOpt=${StrAppsOpt}                 \
   StrLdConfigUser=${StrLdConfigUser}       \
   BoolUpdateLdconfig=${BoolUpdateLdconfig} \
   __main_StartServices
	fi
}


unset GetUUID 
function GetUUID()
{
	local __call_locality=( GetU GetUUID ) ;
	local StrDefaultSwitches=${GetUSwitches:=-t}
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
	#local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;	
	else
		uuidgen ${StrDefaultSwitches}	; 
	fi 
} 



### Function : GetMplayerStream()
### 
### - Filter out selected stream from Firefox browser on Ubuntu/Mint and kill active stream to get only the 
### http - stream url and load itself with mplayer... Assuming the Browser openning the stream with mplayer...
### 
### Initial idea : ps -eo pid,command | egrep -i "mplayer" | egrep "http:\/\/" | awk 'BEGIN{stream="";}{printf("%s %s\n",$1,$(NF)) ; system(sprintf("kill -9 %s",$1)); stream=$(NF); }END{ system(sprintf("mplayer -ao alsa -cache 3072 %s",stream)) }'
### ... but how ingeneer see a tire over a Tree for child use... 
### 
### 

unset GetMplayerStream
function GetMplayerStream()
{
	local ArrayArg=( $* ) ; 
	local __call_locality=( GetMplayerStream ) ;
	local StrAwkPath=${GetMplayerStreamAwkPath:=/etc/init.d/Fnct.d/awk-script/} ;
	local StrAwkScriptName=${GetMplayerStreamScriptName:=MplayerStreamTransfert.awk}
	local StrAwkApps=${GetMplayerStreamAwkApps:=/usr/bin/awk} ;
	local StrGrepApps=${GetMplayerStreamGrepApps:=/bin/egrep};
	local StrGrepOpt=${GetMplayerStreamGrepOpt:=-i};
	local StrPsOpt=${GetMplayerStreamPsOpt:=-eo pid,command};

	local StrPsApps=${GetMplayerStreamPsApps:=/bin/ps};
	local StrUrlGrep=${GetMplayerStreamUrlGrep:="http:\/\/"};
	local StrPlayerName=${GetMplayerStream:=mplayer};
	local Arg0=${ArrayArg[0]} ;
	
	function GetStreamFromPs()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( GetStreamFromPs ) ;
		local StrAppsName=${GetStreamFromPsApps:=/bin/ps} ;
		local StrAppsOpt=${GetStreamFromPsOpt:=-eo pid,command} ;
		local StrFilterAppsName=${GetStreamFromPsFName:=egrep} ;
		local StrFilterAppsOpt=${GetStreamFromPsFNOpt:=-i} ;
		local StrUrlFilter=${GetStreamFromPsUrlFilter:="http:\/\/"} ;
		local StrPlayerFilter=${GetStreamFromPsUrlPlayerName:=mplayer} ;

		${StrAppsName} ${StrAppsOpt} | ${StrFilterAppsName} ${StrFilterAppsOpt} "${StrPlayerFilter}" | ${StrFilterAppsName} ${StrUrlFilter} ; 
	}
	
	function AwkScript()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( AwkScript ) ;
		local StrAwkPath=${AwkScriptAwkPath} ;
		local StrAwkScriptName=${AwkScriptScriptName} ;
		local StrAwkApps=${AwkScriptApps} ;
		${StrAwkApps} -f ${StrAwkPath}/${StrAwkScriptName}
	}

	#local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
	local cmdline=( ) ;
	local cmdline[0]="GetStreamFromPsUrlPlayerName=\"${StrPlayerName}\" GetStreamFromPsUrlFilter=\"${StrUrlGrep}\" GetStreamFromPsFName=\"${StrGrepApps}\" GetStreamFromPsFNOpt=\"${StrGrepOpt}\" GetStreamFromPsApps=\"${StrPsApps}\" GetStreamFromPsOpt=\"${StrPsOpt}\" GetStreamFromPs";
	local cmdline[1]="AwkScriptApps=\"${StrAwkApps}\" AwkScriptAwkPath=\"${StrAwkPath}\" AwkScriptScriptName=\"${StrAwkScriptName}\" AwkScript" ; 
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[0]} ;
			#echo -ne "Following switch are available:\n\n\t--startservices\tStart the application normally and output the package list\n\t--debug\tExpose result to be executed.\n\n" > /dev/stderr ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	elif [ "${Arg0:=--startservices}" == "debug"	] ; then 
		echo -ne "CmdLine[0]:${cmdline[0]} \nCmdLine[1]:${cmdline[1]}\n" > /dev/stderr ;
	else
		echo -ne "CmdLine[0]:${cmdline[0]} \nCmdLine[1]:${cmdline[1]}\n" > /dev/stderr ;		
	fi	
}
 
### Late-Homework for old duty... 
### Preceding some specific moment in a traveller when he have to know when the plane is going to leave , 
### I was messing around faulty compilation and try to find 
### way to randomize startup a bit and lib loading to see if it's anomalies in process or simply stack 
### hacking... See Hacking The art of exploitation from No Starch press...  
### Initial Setup on how collecting information and how generate fast random number was heavy and may
### collide whith the function FaultyProcess, rendering too much work from High-heavy precesing awk-sed-grep
### line at every ';' was also slowing this baby pentium-mmx from college Rosemont also... 


unset BuildOnFaultCompiler
function BuildOnFaultCompiler()
{
	local ArrayArg=( $* )
	local __call_locality=( BOFC ) ; 
	local StrAppsLib=${BOFCLib:=/sbin/ldconfig} ;
	local StrAppsLibOpt=${BOFCLibOpt:=-f,/etc/ld.so.conf} ;
	local StrAppsAppsFault=${BOFCAppsFault:=make} ;
	local StrAppsAppsFaultOpt=${BOFCAppsFaultOpt:=''} ;
	local IntRandomSize=${BOFCRandomSeedLevel:=20} ;
	local Arg0=${ArrayArg[0]:=--startservices}
	
	function InitLib()
	{
		local ArrayArg=( $* )
		local __call_locality=( InitLib ) ; 
		local StrApps=${InitLibInitApps:=/sbin/ldconfig} ;
		local StrAppsOpt={InitLibInitAppsOpt:=-f,/etc/ld.so.conf} ;
		local ArrayAppsOpt=${StrAppsOpt//,/ } ; 
		### ldconfig -f /etc/ld.so.conf ; 
		eval "${StrApps} ${ArrayAppsOpt[@]}" ; 
	}
	function FaultyProcess()
	{
		local ArrayArg=( $* )
		local __call_locality=( FaultyProcess ) ; 
		local StrApps=${FaultyProcessInitApps:=make} ;
		local StrAppsOpt=${FaultyProcessAppsOpt} ;
		local ArrayAppsOpt=${FaultyProcessAppsOpt[@]//,/ } ;
		eval "${StrApps} ${ArrayAppsOpt[@]}" > /dev/stderr  ; 
		return $? ; 
	}

	function Start()
	{
		local res=1 ; 
		local IntRandSize=${IntRandomSize} ; 
		local StrStarHeaderLine="********************************************************************************" ;
		local StrHeader="__StrStarHeaderLine__\n\n\tBuild Failed , sleeping __IntRand__\n\n__StrStarHeaderLine__\n" ;
		echo -ne "StartWhile\n" > /dev/stderr ;
		while [ ${res} -ne 0 ] ; do 
			local ArrayRandom=(  ) ; 
			local EndRand=$(( ( ${RANDOM} % ${IntRandSize} ) )) ; 
			local IndexRand=$(( ${RANDOM} % ${IntRandSize} )) ; 
			echo -ne "IntRandSize: ${IntRandSize}\nEndRand:${EndRand}\n" > /dev/stderr ; 
			sleep 5 ; 
			echo -ne "StartFor\n" > /dev/stderr ;
			for (( intx=0 ; intx <= ${EndRand} ; intx++ )) ; do 
				echo -ne "." > /dev/stderr ;
				local RandBaseMul=$(( ( ${IntRandSize} *  ( ${RANDOM} % 10 ) ) + 1 )) ; 
				local IntRandNum=$(( ${RANDOM} % ${RandBaseMul} )) ;
				ArrayRandom[${intx}]=${IntRandNum} ; 
			done ; 
			echo -ne "\n" > /dev/stderr ;
			local IntRand=${ArrayRandom[${IndexRand}]} ; 
			echo -ne "IntRand:${IntRand}\n" > /dev/stderr ; 
			echo -ne "StartInitLib:1\n" > /dev/stderr ;
			InitLibInitApps=${StrAppsLib} InitLibInitAppsOpt=${StrAppsLibOpt} InitLib ; 
			echo -ne "StartFaultyProcess\n" > /dev/stderr ;
			FaultyProcessInitApps=${StrAppsAppsFault} FaultyProcessAppsOpt=${StrAppsAppsFaultOpt} FaultyProcess
			res=$?  ;
			echo -ne "res return [${res}]\n" > /dev/stderr ; 
			echo -ne "StartIf\n" > /dev/stderr ;
			if [ ${res:=0} -ne 0 ] ; then 
				local StrDisplayHeader=${StrHeader//__StrStarHeaderLine__/${StrStarHeaderLine}} ;
				StrDisplayHeader=${StrHeader//__IntRand__/${IntRand}} ;
				echo -ne ${StrDisplayHeader} > /dev/stderr ; 
				echo -ne "StartInitSleepRandom\n" > /dev/stderr ;
				sleep ${IntRand} ; 
				echo -ne "StartInitLib:2\n" > /dev/stderr ;
				InitLib ;
			fi ; 
		done 

	}
	
	#local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;

	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference BuildOnFaultCompiler ;
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	else
		StrAppsLib=${StrAppsLib} StrAppsLibOpt=${StrAppsLibOpt} StrAppsLibOpt=${StrAppsLibOpt} StrAppsAppsFault=${StrAppsAppsFault} StrAppsAppsFaultOpt=${StrAppsAppsFaultOpt} IntRandomSize=${IntRandomSize} Start ; 
	fi 
} 



unset RoundRobinSwapRealloc
function RoundRobinSwapRealloc()
{
	local __call__locality=( RRSR ) ;
	local ArrayArg=( $* ) ;
	local Arg0=${ArrayArg[0]} ; 
	
	local Str=${RRSR:=}
	
	function GetSwapList()
	{
		local __call__locality=( GSL ) ;
		local ArrayArg=( $* ) ;
		ArrayListSwap=( $( swapon -s | cut -d ' ' -f 1  | grep -v "Filename" | tr '[:cntrl:]' ' ' ) ) ; 
		
	}
	function Start()
	{
		local __call__locality=( Start ) ;
		local ArrayArg=( $* ) ;
		
	}
	#local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
	
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference RoundRobinSwapRealloc ;
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	elif [ "${Arg0:=--startservices}" == "--swaptorealloc"	] ; then 
		GetSwapList ;
	else
		 Start ; 
	fi 
}


### Loading External Lib
. /etc/init.d/Fnct.d/_sub_PackageRepository


########### ###################################################################
########### 
########### End of normal Devlopment, upcoming devlopment or missing code from 
########### old lib Devlopment was put after, Enabling it on call of 
########### /etc/init.d/Fnct.d/fnct_debian_lib imply having VarFnctLib=True 
########### before
########### 
########### like :
########### VarFnctLib=True /etc/init.d/Fnct.d/fnct_debian_lib . 
########### 
########### Warning Not supported and may cause problems. 
########### 
########### ###################################################################


if [ ${VarFnctLib:=False} == "True" ] ; then

    Debian_DPKG_update_InstallList()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=Debian_DPKG_update_InstallList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      declare -a ArrayDPKGInstalled=( $( ${DebianProg:=dpkg} ${DebianProgQuery:=--get-selections} | awk 'BEGIN{}{printf("%s ",$1)}END{}' ) ) ; 
    }

    Debian_DPKG_update_ArchivesList()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=Debian_DPKG_update_ArchivesList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      declare -a ArrayArchiveDPKG=( $( find ${DefaultRootPath:=/var/cache/apt/archives/} -printf "%p " ) ) ; 
    }

    DebianDPKGProvideSubFunctionMember()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=DebianDPKGProvideSubFunctionMember __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __search_item()
      {
        #eval $( __InitFunc ) ;
        eval $( __call_localityLocalName=__search_item __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        if [ ${ArrayArg[1]} == ${ItemQuery:=update} ] ; then 
          return 0 ;
        fi
        return 1 ;
      }
      local Template="__CREATOR___PACKAGETYPE_____PACKAGEACTION___" ; 
      local StrCreator=${Creator:=${ArrayCreator[0]}} ;
      local StrPackageType=${PackageType:=${ArrayPackageType[0]}} ;
      local StrPackageAction=${PackageAction:=update} ;
      eval $( __in_for ArrayPackageAction __search_item ItemQuery=${StrPackageAction} ) ; 
      local ErrorStatement=$? ; 
      if [ ${ErrorStatement:=1} -eq 0 ] ; then 
        echo "__TODO__" ;  
      fi
    }

    MetaUpdateList()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=MetaUpdateList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __FuncUpdate()
      {
        #eval $( __InitFunc ) ;
        eval $( __call_localityLocalName=__FuncUpdate __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        local Template="__NODE____SECTION__List" ;
        Template=${Template/__SECTION__/${ArrayArg[0]}}
      } 
      eval $( __in_for ArrayMetaList __FuncUpdate ) ; 
    }

    function __get_col()    
    { 
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=__get_col __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      awk -vCol=${ArrayArg[0]} 'BEGIN{}{printf("%s ",$(Col));}END{}' ; 
    } ; 

    function UpdateDpkgGetSelection()
    {
      eval $( __call_localityLocalName=UpdateDpkgGetSelection __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      declare -a ArrayPackageCurrent=( $( dpkg --get-selections | __get_col 1 ) ) ; 
    }


    function get_listfile()    
    { 
      #eval $( __InitFunc get_listfile ) ;
      eval $( __call_localityLocalName=get_listfile __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __BaseEncode64()
      {
        #eval $( __InitFunc __BaseEncode64 ) ;
        eval $( __call_localityLocalName=__BaseEncode64 __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        base64 --wrap=0 ; 
      }
      function __IfTestFile()    
      { 
        #eval $( __InitFunc __IfTestFile ) ;
        eval $( __call_localityLocalName=__IfTestFile __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        if [ -f ${ArrayArg[0]} ] ; then 
          local StrStream=$( echo "${ArrayArg[0]}" | __BaseEncode64 ) ; 
          echo -ne "${StrStream} " ;
        fi 
      } ; 
      local ArrayFileList=( $( dpkg-query --listfiles ${ArrayArg[0]} ) ) ; 
      eval $( __in_for ArrayFileList __IfTestFile ) ; 
    } ; 

    function get_search()
    {
      #eval $( __InitFunc get_search ) ;
      eval $( __call_localityLocalName=get_search __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      eval $( __in_for ArrayPackageCurrent get_listfile ) ;
    }

    function get_package_by_file()
    {
      #eval $( __InitFunc get_package_by_file ) ;
      eval $( __call_localityLocalName=get_package_by_file __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function PostFilter()
      {
        #eval $( __InitFunc PostFilter ) ;
        eval $( __call_localityLocalName=PostFilter __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        awk -vGrepReturn=${GrepReturn} -f /etc/init.d/fnct.d/awk-script/DpKgQueryPackage.awk ; 
      }  
      local CmdEval=( ${Program:=apt-file} ${ProgramOption:=search} ${ProgramQuery:=lirc/lirc_client.h} ProgramQueryIs64=${ProgramQueryIs64:=false} "|" ${FilterProgram:=PostFilter} GrepReturn=${GrepReturn:=false} ${FilterProgramQuery:=""} ) ;
      echo "CmdLine:[${CmdEval[@]}]" ;
      #eval "${CmdEval[@]}" ; 
      eval "local IntResult=$( eval ${CmdEval[@]} )" ; 
      #echo "Return : ${IntResult}" ;
    }

    function AwkContentParsing()    
    { 
      #eval $( __InitFunc AwkContentParsing ) ; 
      eval $( __call_localityLocalName=AwkContentParsing __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __TinyDecode64()
      {
        #eval $( __InitFunc __TinyDecode64 ) ; 
        eval $( __call_localityLocalName=__TinyDecode64 __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        local StrBaseDecode=$( echo "${VarDecode64}" | base64 -d --wrap=0 2> /dev/null ) ; 
        local IntErrorReport=$? ;
        if [ ${IntErrorReport:=1} -eq 1 ] ; then 
          echo "${VarDecl:=local} ${VarName:=VarOut}=${VarDecode64}" ; 
        else
          echo "${VarDecl:=local} ${VarName:=VarOut}=${StrBaseDecode}" ; 
        fi 
      }
      eval $( __TinyDecode64 VarDecode64=${RecurrentTemplateSearch} VarName=StrRecurrentTemplateSearch VarDecl=${VarDecl} )  ;
      eval $( __TinyDecode64 VarDecode64=${StrQuerySearch} VarName=StrQuerySearch VarDecl=${VarDecl} )  ;
        
      
      local ProgramParserRecurrentTemplate=${StrReturnBase64DecodeTry} ;
      local CmdEval=( ${Program:=apt-file} ${ProgramOption:=search} ${StrQuerySearch} "|" ${ProgramParser:=awk} -vTemplateContent=${StrRecurrentTemplateSearch} -vVarNameOut=CmdEval -f /etc/init.d/fnct.d/awk-script/DpKgQueryPackage.awk ) ;
      echo "CmdLine:[${CmdEval[@]}]" ; 
    }

    function libsearch_AwkContentParsing()
    {
      #eval $( __InitFunc AwkContentParsing ) ; 
      eval $( __call_localityLocalName=libsearch_AwkContentParsing __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      local StrRecurrentTemplateSearch=$( echo "dpkg --get-selections | egrep -ic %s" | base64 --wrap=0 ) ;
      local StrQuerySearch=$( echo "lirc/lirc_client.h" | base64 --wrap=0 ) ; 
      AwkContentParsing RecurrentTemplateSearch=${StrRecurrentTemplateSearch} QuerySearch=${StrQuerySearch} ; 
      
    }

    __funcZenity_DpkgList() 
    { 
        eval $( __call_localityLocalName=__funcZenity_DpkgList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        
        ### This Cover-up the theory of problematic transfert of commune Variable name in external function
        ### being by definition to be treated ''AS'' the normal corpus of the definition of a script
        ### Where this example show a possibility that it does not... The WeFixIt by
        ### involve declaring this method inside this function by calling a declare-f and 
        ### renaming the function (incase of) and calling it inside the function like a 
        ### sub-function can be called and all variable within an external-function will 
        ### be accessible... 
        ### Noted by: Patrick Riendeau in 2003-2004 @vdl2 inc formelly know as Phromone inc.
        ### and 2010... 
        
        eval """$( declare -f LinkFuncRetOkA_B  | sed 's/\\n/\\\\n/g;s/LinkFuncRetOkA_B/localLinkFuncRetOkA_B/g' )"""
        
        function DisplayEvalCmd()
        {
          echo -ne "in DisplayEvalCmd:\n\t\tCmdLine:${StrFuncName}:[ ${CmdEval[@]} ]\n" > /dev/stderr  ;  
        }
        
        function ExecEvalCmd()
        {
          echo -ne "in ExecEvalCmd:\n" > /dev/stderr ;  
          eval "${CmdEval[@]}" ;
        }

        function ZenityProgressBar()
        {
          eval $( __call_localityLocalName=ZenityProgressBar __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
          local IntRandomState=$(( ${RANDOM} % 20 )) ;
          local CmdEval=( zenity --progress --percentage=${IntRandomState} --text="Fetching Package List" --auto-kill --pulsate ) ;
          #DisplayEvalCmd ;
          #ExecEvalCmd ;
          LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }
        
        function ZenityListPackage()
        {
          eval $( __call_localityLocalName=ZenityProgressBar __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
          zenity --list --checklist --column "Installed" --column "Package Name" ;
          #DisplayEvalCmd
          #ExecEvalCmd ;
          LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }
        
        function DpkgSortedByInstall()
        {
         eval $( __call_localityLocalName=DpkgSortedByInstall __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
         local CmdEval=( "dpkg" "--get-selections" "|" "sort" "-k2" "-r" ) ;
         #DisplayEvalCmd ;
         #ExecEvalCmd ;
         LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }

        function SedFilterConversionDpkgToZenityList()
        {
          eval $( __call_localityLocalName=DpkgSortedByInstall __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
          #sed -r -f /etc/init.d/fnct.d/sed-script/FilterConversionDpkgToZenityList.sed ;
          local CmdEval=( "sed" "-r" "-f" "/etc/init.d/fnct.d/sed-script/FilterConversionDpkgToZenityList.sed" ) ;
          #DisplayEvalCmd ;
          #ExecEvalCmd ;
          LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }
        local CmdEval=( LFuncAction0=ZenityProgressBar LFuncAction1=DpkgSortedByInstall LinkFuncPipedA_B ) ;
        echo -ne "From Main Func:${StrFuncName}\n\n\tCmdEval:[ ${CmdEval[@]} ]\n" > /dev/stderr ;
        LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;

    }

    function get_list()  
    { 
      #eval $( __InitFunc get_list ) ; 
      eval $( __call_localityLocalName=get_list __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      local ArrayInfo=( $( find /usr/share/ -maxdepth 1 -type d -iname "man*" | tr '[:cntrl:]' ' ' ) ) ; 
      echo "${VarDecl:=local} ${ArrayName:=ArrayList}=( ${ArrayInfo[@]})" ; 
    } 
      
    function ffind()    
    { 
      #eval $( __InitFunc ffind ) ; 
      eval $( __call_localityLocalName=ffind __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      find ${ArrayArg[0]} -type f -iname "*man*" ; 
    } 

    function __ZenityProgressBar()    
    { 
      #eval $( __InitFunc ) ;  
      eval $( __call_localityLocalName=__ZenityProgressBar __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      zenity --progress --pulsate 
    } 

    function __wrap_bar_find()    
    { 
      #eval $( __InitFunc __wrap_bar_find ) ; 
      eval $( __call_localityLocalName=__wrap_bar_find __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      eval $( get_list ArrayName=ArrayOut VarDecl=local ) ;
      eval $( __in_for ArrayOut ffind ) | __ZenityProgressBar  ;
    }


    function __BuildDpkgShowFormat ()    
    { 
     #eval $( __InitFunc __BuildDpkgShowFormat ) ; 
     eval $( __call_localityLocalName=__BuildDpkgShowFormat __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
     local DefaultTagValue="__TAG__" ;
     if [ ${StructDpkgShowFormat:=__TAG__} == "__TAG__" ] ; then 
      declare -a StructDpkgShowFormat="${DefaultTagValue}" ;
     fi 
     StructDpkgShowFormat=( $( echo "${StructDpkgShowFormat}" | sed 's/'${DefaultTagValue}'/'${ArrayDPKG_QueryHeader[${ArrayArg[0]}]}${DefaultTagValue}'/g' ) ) 
    } 

    function __BuildDpkgShowFormatXml()
    {
      eval $( __InitFunc __BuildDpkgShowFormat ) ; 
      function __functor_show_header()
      {
        #eval $( __InitFunc __BuildDpkgShowFormat ) ; 
        eval $( __call_localityLocalName=__BuildDpkgShowFormatXml __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        echo -ne "\nStyle=${Style}\n" ;     
        echo -ne "${ArrayArg[2]}" ; 
        echo -ne "\nDstyle=${Dstyle}\n" ;
      }
      eval $( __in_for ${ArrayNameDPKGQuery=ArrayDPKG_QueryHeader} __functor_show_header CCode64=$( ) ) ;
    }

    compare_package()
    {
      local ArrayArg=( $* ) ; 
      function get_name()    
      { 
        eval $( __call_localityLocalName=compare_package __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        local str="${ArrayArg[0]}" ; 
        local ArrayPackage=( ${str/_/ } ) ; 
        echo -ne "${ArrayPackage[0]} " ;  
      } 
      
      function update_package_list()
      {
        eval $( __call_localityLocalName=update_package_list __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        ${DebianProg:=dpkg} ${DebianProgQuery:=--get-selections} | awk 'BEGIN{}{printf("%s ",$1)}END{}' ; 
      }
      
      function get_specific_search()
      {
        eval $( __call_localityLocalName=get_specific_search __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        apt-file search wxPython | awk 'BEGIN{}{intlength=split($1,Array,/:/); printf("%s\n",Array[1])}END{}' | sort -u | tr '[:cntrl:]' ' '  
      }
      
      function get_specific_python()
      {
        eval $( __call_localityLocalName=get_specific_python __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        find /var/cache/apt/archives/ -iname "*.deb" -printf "%f "
      }

      function __compare_package()    
      { 
        #local ArrayArg=( $* ) ; 
        eval $( __call_localityLocalName= __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        echo "Search for Package ${ArrayArg[0]} in Installed Package( ${#ArrayDPKGInstalled[@]} ) " ;      
        function search_package_name()    
        { 
          local ArrayArg=( $* ) ; 
          if [ "${ArrayArg[0]}" == "${ArrayArg[1]}" ] ; then 
            echo -ne "\tInstalled Package is in the list [ ${ArrayArg[0]} ]\n" ; 
            return 0 ; 
          fi
            ArrayDPKGUnInstalled[${#ArrayDPKGUnInstalled[@]}]="${ArrayArg[1]}";
            return 1 ; 
        } 
        eval $( __in_for ArrayDPKGInstalled search_package_name ${ArrayArg[0]} ) ; 
      }
      
      local ArrayPythonPackage=( $( ${ArrayArg[0]} ) ) ;
      echo -ne "\nPackage List Choosed from Function: ${ArrayArg[0]}\n\t[ ${ArrayPythonPackage[@]} ]\n" ;
      local ArrayDpkgPython=( $( eval $( __in_for ArrayPythonPackage get_name ) ) ) ;  
      local ArrayDPKGInstalled=( $( update_package_list ) ) ;    
      local ArrayDPKGUnInstalled ;
      eval $( __in_for ArrayDpkgPython __compare_package ) ;
      echo "declare -a ArrayDPKGUnInstalled=( ${ArrayDPKGUnInstalled[@]} )" ; 
    }

    function KeyAptSearch()    
    { 
     eval $( __call_localityLocalName=KAS __call_locality ); 
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=PackageArrayName FParamVarName=StrPackageArrayName FParamDefaultValue=ArrayPackage __fnctCreateLocalityFuncParam     ) ;
     
     function AptSearch()    
     { 
      eval $( __call_localityLocalName=AS __call_locality ); 
      echo -ne "Key: ${ArrayArg[0]}\n" ; 
      apt-file search ${ArrayArg[0]} ; 
     } ; 
     local CmdEval=( "eval" " $( " "__in_for" ${StrPackageArrayName:=""} "AptSearch" ")" ) ; 
     eval ${CmdEval[@]} ;
    }

    function dpkg-get-selections()
    {
     eval $( __call_localityLocalName=DPKG __call_locality ); 
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=BranchShow FParamVarName=StrBranchShow FParamDefaultValue=Left __fnctCreateLocalityFuncParam     ) ;
     
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName0 FParamVarName=ArrayCmdName[0] FParamDefaultValue=dpkg __fnctCreateLocalityFuncParam     ) ;
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName1 FParamVarName=ArrayCmdName[1] FParamDefaultValue="--get-selections" __fnctCreateLocalityFuncParam     ) ;
     
     eval local StrFuncColDisplay=\${${StrBranchShow}ColDisplay} ;
     
     function CommandCall()
     {
      eval $( __call_localityLocalName=CCall __call_locality ); 
      local CmdEval=( ${ArrayCmdName[@]} ) ;
      eval ${CmdEval[@]} ;
     }
     
     function RightColDisplay()
     {
      eval $( __call_localityLocalName=ColDisplay __call_locality ); 
      awk -vColName=${StrBranchShow:=""} -f /etc/init.d/fnct.d/awk-script/dpkg-col-display.awk 
     }
     
     function LeftColDisplay()
     {
      eval $( __call_localityLocalName=ColDisplay __call_locality ); 
      awk -vColName=${StrBranchShow:=""} -f /etc/init.d/fnct.d/awk-script/dpkg-col-display.awk 
     }
     
     local CmdEval=( ${CommandCall:=""} "|" ${StrFuncColDisplay:=""} ) ;
     eval ${CmdEval[@]} ;
    }

    function dpkg-set-selections()
    {
     eval $( __call_localityLocalName=DPKG __call_locality ); 
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=BranchShow FParamVarName=StrBranchShow FParamDefaultValue=Left __fnctCreateLocalityFuncParam     ) ;
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName0 FParamVarName=ArrayCmdName[0] FParamDefaultValue=dpkg __fnctCreateLocalityFuncParam     ) ;
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName1 FParamVarName=ArrayCmdName[1] FParamDefaultValue=--set-selections __fnctCreateLocalityFuncParam     ) ;
     
     function CommandCall()
     {
      eval $( __call_localityLocalName=CCall __call_locality ); 
      local CmdEval=( ${ArrayCmdName[@]} ) ;
      eval ${CmdEval[@]} 
     } 

    }
fi 



