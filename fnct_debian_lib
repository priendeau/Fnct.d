
#. /etc/init.d/fnct.d/fnct_lib

declare -a ArrayMetaList=( Install Archives ) ; 
declare -a ArrayCreator=( Debian Ubuntu Fedora Mint ) ;
declare -a ArrayPackageType=( DPKG APT YUM RPM ) ;
declare -a ArrayPackageAction=( install update remove fix compile certify verify ) ;

 ### ValueParser :
 ### 
 ### Description: 
 ### - Aim to be a Value Parser with specific semantic to automatically create lists
 ### of variable with specific notation. It was designed to Create a Unique Variable,
 ### like StrValueParserInfo and evaluating the Variable with string-like specified with.
 ### 2 level of CSV, between type ( Profixed variable are VPCallLocalityName VPVarArgList VPScopeList VPValueList )
 ### are reserved to specify somes crucial information. 
 ### 
 ### VPCallLocalityName -> Under wichh prefix named variable are transfered from their calling name.
 ### Ex: Having Function with var __call_locality=( ValueTest ), mean all variable from incoming 
 ### function called with ValueTest(), like :
 ### var1=value1 var2=value2 ValueTest --opt , var1 and var2 must have theirs names starting by
 ### ValueTestvar1=value1 ValueTestvar2=value2 ... 
 ### 
 ### - Value parser will transform variable from ValueTestvar1 into Strvar1, Strvar2 if VPVarArgList
 ### is specified.
 ### 
 ### VPVarArgList -> Specify the list of name and their internal Prefix Type. 
 ### as said in VPCallLocalityName, variable have external and internal names. 
 ### Passing by will not directly convert by create a variable starting with specified prefix.
 ### Having :
 ### VPCallLocalityName=ValueTest VPVarArgList=Str:var1,Str:var2 
 ###  - inside function :ValueTest() will:
 ### get from extern name like ValueTestvar1=value1 ValueTestvar2=value2 , 
 ### will transfert the content into appropriate internal name: Strvar1, Strvar2 . 
 ### - This is purely a simple transfert, convertion, name mangling and linting ( like checking name of 
 ### var if they are not exceeding 32 chars are not yet show. )
 ### 
 ### VPScopeList -> Implicitly tell to ValueParser if the variable are created in local or global, telling
 ### also about lifetime of variable... Important when dealing with function and sub-function and sub-n-function. 
 ### 
 ### 
 ### 
 ###	Full-length example : 
 ### Including 
 ### 
 ### See StartCoproc, variable StrValueParserInfo hold the references and work well with triple-guillements.
 ### 
 ##
 ### eval $( eval """
 ###	VPCallLocalityName=${__call_locality[0]} 
 ###	VPVarArgList=Str:ProcName,
 ###	             Str:InWhile,
 ###	             Str:WhCond,
 ###	             Str:WhRetStat,
 ###	             Str:AppsName,
 ###	             Str:AppsPrVar,
 ###	             Str:AppsOpt
 ###	VPScopeList=ProcName:local,
 ###	             InWhile:local,
 ###	             WhCond:local,
 ###	             WhRetStat:local,
 ###	             AppsName:local,
 ###	             AppsPrVar:local,
 ###	             AppsOpt:local 
 ###	VPValueList=DefaultCoprocName:True:__VAR__ -ne 1:__VAR__=\$( __CMD__ ):GitHubCommit:GitHubCommitFilePath=/etc/init.d/Fnct.d:fnct_debian_lib
 ###	""" ValueParser )  ;
 ### 
 ### -Note Calling ValueParser with same string embedded in the value with following switches --varhelper, will transform this stream of variables
 ### - into helper like GetVarReference . Don't forget, what ValueParser showing or creating is not visible from GetVarReference. GetVarReference
 ### Function extract information from a 'declare -f ' statement and ValueParser is not creating inside the function the value, they are created 
 ### by using this function... Quite simple, almost dynamic, but not fully-dynamic... It's bash afterall... 
 ### Note : Sometimes more easy calling VPCallLocalityName=${__call_locality[0]} instead if re-writing the function names...
 ### Some will love $0 wich is the function name or the script name if this one is inside a shell-file-script. but personally,  I report a lot 
 ### of problems.  
 ### 
 ### 
 ### Comparaison : 
 ### 
 ### Following method are similar .
 ### 
 ### function ValueTest()
 ### {
	###  local ArrayArg=( $* ) ; 
	###  __call__locality=( ValueTest )	
 ###  StrValueTest=${ValueTestValue:=None} ; 
 ###  echo -ne """${StrValueTest}\n""" ; 
 ### } 
 ### 
 ### function ValueTest()
 ### {
	###  local ArrayArg=( $* ) ; 
	###  __call__locality=( ValueTest )	
 ###  local StrValueParserInfo="VPCallLocalityName=${__call_locality[0]} VPVarArgList=Str:Value VPScopeList=Value:local VPValueList=None" ; 
 ###  eval $( eval "${StrValueParserInfo} ValueParser " ) ;
 ###  echo -ne """${StrValueTest}\n""" ; 
 ### } 
 ###
 ### - It's eat more line if the number of variables are lower than 3 variables, but both function
 ### work on same way... Calling-function to see the result:
 ### 
 ###  ValueTestValue="This is a test" ValueTest
 ### 
 ### - Exception : Still unable to read new variable definition from command-line and only create 
 ### a Variable transfert blindly. 
 
 

unset ValueParser ;
function ValueParser()
{
		local ArrayArg=( $* ) ; 
		local Arg0=${ArrayArg[0]} ;
		local __call_locality=( VP ValueParser );
		local StrVarArgList=${VPVarArgList:=Str:AppsName,Str:AppsOpt} ; 
		local StrValueList=${VPValueList:=echo,__VALUE__} ; 
		local StrLocality=${VPCallLocalityName:=Default} ; 
		local StrScope=${VPScopeList:=AppsName:local,AppsOpt:local}
		local StrDefaultScope=${VPScopeDefault:=local};
		local ArrayScope=( ${StrScope//,/ } ) ; 
		local ArrayVar=( ${StrVarArgList//,/ } ) ; 
		local ArrayValue=( ${StrValueList//:/ } ) ;
		local StrValueReturn="" ;
		local StrDebug=${VPDebug:=False}
		local ArrayScopeIndex=( "local" "declare -a" ) ;

		function GetScope()
		{
				local ArrayArg=( $* ) ; 
				local __call_locality=( GetScope );
				local StrDebug=${GetScopeDebug:=False}
				local Arg0=${ArrayArg[0]} ;
				if [ "${Arg0:=local}" == "local" ] ; then 
					echo -ne "0" ; 
				elif [ "${Arg0:=local}" == "global" ] ; then 
					echo -ne "1" ; 
				fi 
		}
		function VarInScopeList()
		{
			local ArrayArg=( $* ) ; 
			local __call_locality=( VarInScopeList );
			local StrDebug=${VarInScopeListDebug:=False}
			local StrValue=${Value:=AppsName} ;
			local StrIsScoped=False
			local StrValueReturn="False" ;
			for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
				local ArrayValue=( ${ArrayArg[${intx}]//:/ } ) ;
				local StrSuffix=${ArrayValue[0]} ; 
				if [ "${StrSuffix}" == "${StrValue}" ] ; then 
					local StrScope=$( GetScope ${ArrayValue[1]} ) ; 
					StrIsScoped=True
					StrValueReturn="${StrIsScoped} ${StrScope} ${StrValue}" 
				fi 
			done 
			echo -ne "${StrValueReturn}" ; 
		}
		function MainHelper()
		{
			local ArrayVar=( $* ) ;
			local __call_locality=( MainHelper )
			local ArrayScope=( ${ArrayScope[@]//,/ } ) ; 
			local StrDebug=${MainDebug:=False} ;
			for (( intx=0 ; intx <= ${#ArrayVar[@]}-1 ; intx++ )) ; do 
				local VarSeg=( ${ArrayVar[${intx}]//:/ } ) ; 
				local StrVarSuffixType="${VarSeg[0]}" ;
				local StrVarSuffix="${VarSeg[1]}" ;
				#local StrVarName="__scope__ __prefix____suffix__=\${__locality____suffix__:=__value__}" ;
				local StrVarName="Variable __locality____suffix__,\n\tDefault Value __value__\n\tInternal variable: __prefix____suffix__\n" ;
				
				local ArrayScopeTest=( $( Value=${StrVarSuffix} VarInScopeList ${ArrayScope[@]} ) ) ; 
				
				if [ "${ArrayScopeTest[0]}" == "True" ] ; then 
					StrVarName=${StrVarName//__scope__/${ArrayScopeIndex[${ArrayScopeTest[1]}]}} ;
					StrVarName=${StrVarName//__suffix__/${StrVarSuffix}} ; 
					StrVarName=${StrVarName//__value__/${ArrayValue[${intx}]}};
					StrVarName=${StrVarName//__prefix__/${StrVarSuffixType}} ;
					StrVarName=${StrVarName//__locality__/${StrLocality}} ;
				else
					StrVarName=${StrVarName//__scope__/${StrDefaultScope}} ;
					StrVarName=${StrVarName//__suffix__/${StrVarSuffix}} ; 
					StrVarName=${StrVarName//__value__/${ArrayValue[${intx}]}} 
					StrVarName=${StrVarName//__prefix__/${StrVarSuffixType}} ;
					StrVarName=${StrVarName//__locality__/${StrLocality}} ;
				fi 
				StrValueReturn="${StrValueReturn} ${StrVarName}" ;
			done 
			echo -ne "${StrValueReturn}" ;
			
		}		
		function Main()
		{
			local ArrayVar=( $* ) ;
			local __call_locality=( Main )
			local ArrayScope=( ${ArrayScope[@]//,/ } ) ; 
			local StrDebug=${MainDebug:=False} ;
			for (( intx=0 ; intx <= ${#ArrayVar[@]}-1 ; intx++ )) ; do 
				local VarSeg=( ${ArrayVar[${intx}]//:/ } ) ; 
				local StrVarSuffixType="${VarSeg[0]}" ;
				local StrVarSuffix="${VarSeg[1]}" ;
				local StrVarName="__scope__ __prefix____suffix__=\${__locality____suffix__:=\${__locality____suffix__:=__value__}}" ;
				
				local ArrayScopeTest=( $( Value=${StrVarSuffix} VarInScopeList ${ArrayScope[@]} ) ) ; 
				
				if [ "${ArrayScopeTest[0]}" == "True" ] ; then 
					StrVarName=${StrVarName//__scope__/${ArrayScopeIndex[${ArrayScopeTest[1]}]}} ;
					StrVarName=${StrVarName//__suffix__/${StrVarSuffix}} ; 
					StrVarName=${StrVarName//__value__/${ArrayValue[${intx}]}};
					StrVarName=${StrVarName//__prefix__/${StrVarSuffixType}} ;
					StrVarName=${StrVarName//__locality__/${StrLocality}} ;
				else
					StrVarName=${StrVarName//__scope__/${StrDefaultScope}} ;
					StrVarName=${StrVarName//__suffix__/${StrVarSuffix}} ; 
					StrVarName=${StrVarName//__value__/${ArrayValue[${intx}]}} 
					StrVarName=${StrVarName//__prefix__/${StrVarSuffixType}} ;
					StrVarName=${StrVarName//__locality__/${StrLocality}} ;
				fi 
				StrValueReturn="${StrValueReturn} ${StrVarName} ; " ;
			done 
			echo -ne "${StrValueReturn}" ;
			
		}
		local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\t\n--get\t\tReturn value of Internal Variable.\n" 
		if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--startservices"	] ; then 
			ArrayScope=${ArrayScope[@]// /,} StrVarSuffix=${StrVarSuffix} StrValueReturn=${StrValueReturn} StrDefaultScope=${StrDefaultScope} StrLocality=${StrLocality}  Main ${ArrayVar[@]} ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		elif [ "${Arg0:=--startservices}" == "--varhelper"	] ; then 
			ArrayScope=${ArrayScope[@]// /,} StrVarSuffix=${StrVarSuffix} StrValueReturn=${StrValueReturn} StrDefaultScope=${StrDefaultScope} StrLocality=${StrLocality}  MainHelper ${ArrayVar[@]} ;
		fi 
	
}

unset __default_test ;
function __default_test()
{
	local ArrayArg=( $* ) ; 
	local __call_locality=( DT __default_test  ) ; 
 local Arg0=${ArrayArg[0]} ; 
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\t\n--get\t\tReturn value of Internal Variable.\n" 
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
	 GetVarReference ${__call_locality[1]} ;
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	else
		echo "__BODY__" > /dev/stderr ; 
	fi 
	
}

unset AddPValueStore
function AddPValueStore()
{
	local ArrayArg=( $* ) ; 
	local __call_locality=( APVS AddPValueStore  ) ; 
 local Arg0=${ArrayArg[0]} ; 
	local StrAction=${APVSAction:=add} ; 
	local StrFunction=${APVSFunction:=__default_test} ; 
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
	 GetVarReference ${__call_locality[1]} ;
		local StrSwitchMessages"Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	else
		echo -ne "__BODY__\n" > /dev/stderr ; 
	fi 
}


 ### StartCoproc :
 ###
 ###
 ###	Full-length example : 
 ### Including 
 ###
 ###
 ###
 ###
 ###
 ###
 ###
 ###
 ###

unset StartCoproc
function StartCoproc()
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( StartCoproc ) ; 
 local Arg0=${ArrayArg[0]} ; 
 ### Prototype model, 
 ### - Require . /etc/init.d/Fnct.d/_sub_Git to work. 
	### coproc git_fnct_debian { while [ ${res:=0} -ne 1  ] ; do res=$( GitHubCommitFilePath=/etc/init.d/Fnct.d  GitHubCommit fnct_debian_lib ) ; sleep 5 ; done ; }
	local StrValueParserInfo="""
	VPCallLocalityName=${__call_locality[0]} 
	VPVarArgList=Str:ProcName,
	             Str:InWhile,
	             Str:WhCond,
	             Str:WhRetStat,
	             Str:AppsName,
	             Str:AppsPrVar,
	             Str:AppsOpt
	VPScopeList=ProcName:local,
	             InWhile:local,
	             WhCond:local,
	             WhRetStat:local,
	             AppsName:local,
	             AppsPrVar:local,
	             AppsOpt:local,
	VPValueList=DefaultCoprocName:True:__VAR__ -ne 1:__VAR__=\$( __CMD__ ):GitHubCommit:GitHubCommitFilePath=/etc/init.d/Fnct.d:fnct_debian_lib
	""" ;
	
	eval $( eval "${StrValueParserInfo} ValueParser " ) ;
	local EvalCoprocCmd=( ${StrAppsPrVar} ${StrAppsName} ${StrAppsOpt} ) ; 
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\t\n--get\t\tReturn value of Internal Variable.\n" 
	if [ "${Arg0:=--startservices}" == "--help" ] ; then 
		GetVarReference StartCoproc ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		eval ${StrValueParserInfo} ValueParser --varhelper
		echo -ne "--asarray\tStart The application and output the content into an Array, see varriable                               PkgConfigAllArrayName to change the name. This command need an eval braced                              to get the array being initialized.\n\n"
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
		echo ""
		### Prog To create a coprocess 
		#if [ ${StrInWhile} ]
	fi
}


### Package Query function. 
### give by-package, many option at once. 
### 
### Single package:
### ex: GetPackage=flac PkgConfigQuery --cflags --libs
### 
### will output:
### 
### flac:--cflags:-I/usr/include/FLAC  
### flac:--libs:-lFLAC -lm  
### flac++:--cflags:-I/usr/include/FLAC++ -I/usr/include/FLAC  
### flac++:--libs:-lFLAC++ -lFLAC -lm  
### 
###
### Many Package : 
### ex: GetPackage=samplerate,flac PkgConfigQuery --cflags --libs 
### samplerate:--cflags: 
### samplerate:--libs:-lsamplerate  
### flac:--cflags:-I/usr/include/FLAC  
### flac:--libs:-lFLAC -lm  
### flac++:--cflags:-I/usr/include/FLAC++ -I/usr/include/FLAC  
### flac++:--libs:-lFLAC++ -lFLAC -lm  
function PkgConfigQuery()
{ 
	local ArrayArg=( $* );
	local __call_locality=( PkgQuery ) ;
	local Arg0=${ArrayArg[0]:=--start} ; 
	local ArrayArgFlag=( ${ArrayArg[@]:1} ) ; 
	local IntArgLen=${#ArrayArgFlag[@]} ;
	local StrValueParserInfo="VPCallLocalityName=${__call_locality[0]} VPVarArgList=Str:AppsName,Str:AppsOpt,Str:FlagList,Str:PackageList VPScopeList=AppsName:local,AppsOpt:local,FlagList:local,PackageList:local VPValueList=/usr/bin/pkg-config:--list-all:--libs,--static,--short-errors,--libs-only-l,--libs-only-other,--libs-only-L,--cflags,--cflags-only-I,--cflags-only-other:flac" ;
	
	### Replaced by ValueParser
	#local StrPkgConfigApps=${PkgConfigQueryAppsName:=/usr/bin/pkg-config};
	#local StrPkgConfigAppsOpt=${PkgConfigQueryAppsOption:=--list-all};
	eval $( eval "${StrValueParserInfo} ValueParser " ) ;
	
	#echo -ne "StrAppsName : ${StrAppsName}\n" > /dev/stderr ;
	#echo -ne "StrAppsOpt  : ${StrAppsOpt}\n" > /dev/stderr ;
	#echo -ne "StrFlagList  : ${StrFlagList}\n" > /dev/stderr ;
	#echo -ne "StrPackageList  : ${StrPackageList}\n" > /dev/stderr ;
	
	#local StrPackageList=${PkgConfigQueryGetPackage:=flac} ;
	#local StrFlagList=${PkgConfigQueryFlagList:=--libs,--static,--short-errors,--libs-only-l,--libs-only-other,--libs-only-L,--cflags,--cflags-only-I,--cflags-only-other} ;
	local ArrayFlagTest=( ) ;
	function FilterPackageList()
	{
		local ArrayArg=( $* );
		local __call_locality=( FilterPackageList ) ;
		local StrGrepFilter=${FilterPackageListGrepFilter:=${CurrentPackage}}
		cut -d " " -f 1 | egrep -i "${StrGrepFilter}" | tr '[:cntrl:]' ' ' 
	}

		local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 
 	if [ "${Arg0:=--start}" == "--help" ] ; then 
			GetVarReference PkgConfigQuery ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
			eval ${StrValueParserInfo} ValueParser --varhelper ;
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	else
		if [ ${IntArgLen:=0} -eq 0 ] ; then 
			ArrayFlagTest=( ${StrFlagList//,/ } ) ; 
		else
			ArrayFlagTest=( ${ArrayArgFlag[@]} ) ; 
		fi 		
		local ArrayPackageListVar=( ${StrPackageList//,/ } ) ;
		for (( intAx=0 ; intAx <= ${#ArrayPackageListVar[@]}-1 ; intAx++ )) ; do 
			local CurrentPackage="${ArrayPackageListVar[${intAx}]}" ; 
		  local _A=( $( ${StrAppsName} ${StrAppsOpt} | FilterPackageListGrepFilter=${CurrentPackage} FilterPackageList ) );
		  local IntNbPackage=${#_A[@]} ;
		  if [ ${IntNbPackage:=0} -gt 0 ]; then
		      for ((x=0 ; x <= ${#_A[@]}-1 ; x++ )) ; do
		          for (( cx=0 ; cx <= ${#ArrayFlagTest[@]}-1 ; cx++ )) ; do
		              res=$( ${StrAppsName} ${_A[${x}]} ${ArrayFlagTest[${cx}]} );
		              echo -ne "${_A[${x}]}:${ArrayFlagTest[${cx}]}:${res}\n";
		          done;
		      done;
		  else
		      echo -ne "\n\n\tPackage Not Found\n" > /dev/stderr;
		  fi
		done 
	fi 
}

### Warning : 
### This version of pkg-config-all is aliased to pkg-config inside .bashrc of the user shell and following function 
### are also dependent of alias .
### cut -> to alias cut='/usr/bin/cut -d "'" "'" '
### pkg-config -> to alias pkg-config='pkg-config-all'
### 
### 
### 

function pkg-config-all()
{
	local __call_locality=( PkgConfigAll ) ; 
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
	local StrValueParserInfo="VPCallLocalityName=${__call_locality[0]} VPVarArgList=Str:ArrayName,Int:Scoping,Str:CutAlias,Str:AppsName,Str:AppsOpt VPScopeList=ArrayName:local,Scoping:local,CutAlias:local,AppsName:local,AppsOpt:local VPValueList=ArrayPackageName:1:cut:/usr/bin/pkg-config:--list-all ValueParser" ;
	
	eval $( eval "${StrValueParserInfo} ValueParser " ) ;
	### ValueParser replace following value.
	#local StrpackageName=${PkgConfigAllArrayName:=ArrayPackageName}	;
	#local IntScoping=${PkgConfigAllScoping:=1}	;
	#local StrCutAlias=${PkgConfigAllCutAlias:=cut}	;
	#local StrPkgConfig=${PkgConfigAllApps:=/usr/bin/pkg-config} ; 
	echo -ne "Var StrAppsName: ${StrAppsName}\nVar StrAppsOpt: ${StrAppsOpt}\n" > /dev/stderr ;
	function Main()
	{
		local ArrayScopingType=( "local" "declare -a");
		if [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
			eval "${StrAppsName} --list-all | ${StrCutAlias} -f 1" ; 
		elif [ "${Arg0:=--startservices}" == "--asarray" ] ; then 
				local StrPackageList=$( ${StrAppsName} ${StrAppsOpt} | eval "${StrCutAlias} -f 1" | tr '[:cntrl:]' ' ' ) ; 
				echo -ne "${ArrayScopingType[${IntScoping}]} ${StrArrayName}=( ${StrPackageList} )\n" ;
		fi
	}
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 	if [ "${Arg0:=--startservices}" == "--help" ] ; then 
		GetVarReference pkg-config-all ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		eval ${StrValueParserInfo} --varhelper
		echo -ne "Following switch are available:\n\n\t--startservices\tStart the application normally and output the package list\n\t--asarray\tStart The application and output the content into an Array, see varriable                               PkgConfigAllArrayName to change the name. This command need an eval braced                              to get the array being initialized.\n\n"
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	else
		Arg0=${Arg0} StrAppsName=${StrAppsName} StrCutAlias=${StrCutAlias} StrAppsOpt=${StrAppsOpt} IntScoping=${IntScoping} StrArrayName=${StrArrayName} Main
	fi
}

function ObjFindFunction()
{
 local ArrayArg=( $* )	;
 local __call_locality=( ObjFindFunction ) ; 
 local Arg0=( ${ArrayArg[0]} ) ; 
 
	local StrDllFunctionFind=${ObjFindFunctionDllList:=iolog_unlink,GetUserDetailsType,GetCommandDetailsType}  ; 
	local dllFunction=( ${StrDllFunctionFind//,/ } ) ; 
	local StrObjDumpFlagsSet=${ObjFindFunctionFlagSet:=--dynamic-syms;--syms}
	local StrObjDumpApps=${ObjFindFunctionObjApps:=objdump} ;
	
	local ArrayInspecType=( ${StrObjDumpFlagsSet//;/ } ) ; 
	local StrPathStartFind=${ObjFindFunctionPath:=./} ;
	local StrDllSuffix=${ObjFindFunctionDllSearch:=*.so} ;
	local StrUniqueIDType=${ObjFindFunctionUUIDType:=--time} ;
	local StrUniqueIDTypeApps=${ObjFindFunctionUUIDType:=uuidgen} ;
	local StrPrintfFormat=${ObjFindFunctionPrintfFormat:="%h/%f"} ;
	
	function GetUniqueUUID()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( GetUniqueUUID ) ; 
		local StrUUIDFlags=${GetUniqueUUIDFlags:=--time} ; 
		local StrUUIDApps=${GetUniqueUUIDApps:=uuidgen} ; 
		
		eval """ local StrUUID=$( ${StrUUIDApps} ${StrUUIDFlags}  ) """ ;
		echo -ne "${StrUUID}" ; 
	} ; 
	function GetFindList()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( GetFindList ) ; 
		local StrStartPath=${GetFindListStartPath:=./} ; 
		local StrInameSuffix=${GetFindListNamePatter:=*.so} ; 
		local StrPrintfFormat=${GetFindListPrintfFormat:="%h/%f"} ; 
		
		find ${StrPathStartFind} -type f -iname "${StrInameSuffix}" -printf "${StrPrintfFormat}" ; 
	}
	function DllSearch()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( DllSearch ) ; 
		StrDllInspectApps=${DllSearchApps:=objdump} ; 
		StrDllInspectFlagsInArg=${DllSearchFlags:=--dynamic-syms} ; 
		StrDllInspectFlags=${StrDllInspectFlagsInArg//,/ } ;
		StrFileSearch=${DllSearchFileName:=None} ; 
		StrDllFunctionName=${DllSearchFunctionName:=none} ; 
		eval """ ${StrDllInspectApps} ${StrDllInspectFlags} ${StrFileSearch} | egrep -ic "${StrDllFunctionName}" """ ; 
		
	}
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
	
	if [ "${Arg0:=--startservices}" == "--help" ] ; then 
	 GetVarReference ${__call_locality[0]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	else
		local ArrayDll=( $( GetFindListStartPath=${StrPathStartFind} GetFindListNamePatter=${StrDllSuffix} GetFindListPrintfFormat=${StrPrintfFormat} ) ) ; 
		for StrdllFunction in ${dllFunction[@]}; do 
			for (( intx=0 ; intx <= ${#ArrayDll[@]}-1 ; intx++ )) ; do 
				item="${ArrayDll[${intx}]}" ; 
				for DllTypeInspect in ${ArrayInspecType[@]} ; do 
					local UUID_T=$( GetUniqueUUIDApps=${StrUniqueIDTypeApps} GetUniqueUUIDFlags=${StrUniqueIDType} GetUniqueUUID ) ;  
					isDllfunction=$( DllSearchApps=${StrObjDumpApps} DllSearchFlags=${DllTypeInspect} DllSearchFileName=${item} DllSearchFunctionName=${StrdllFunction} DllSearch ) ; 
					dllState=${isDllfunction:=0} ; 
					echo -ne "PKID:${UUID_T}:found:${dllState}:DllInpectMeth:${DllTypeInspect}:Function:${StrdllFunction}:dllName:${item}\n" ; 
				done ; 
			done ; 
		done
	fi
	
 
}

### Default Fast reference Helper. 
### Extract current Prefixed variables from your function and show it on stdout( screen output ). 
### The prefixed variable are indicated on decalation of __call_locality which usually had same name has 
### top function. 
### Desc : It actively look inside the function code and extract value prefixed with function name...
### was initially developped on $0, but change by creating subFunction, and some code may be reserved for private
### use or recurrent-code with recurrent variable name, may be show and alter your perception of functionality of 
### the design ...

### Example to implement the body-helper. 
### 
### function Helper()
### {
###  __call_locality=( Helper ) ; 
### 	local ArrayArg=( $* ) ; 
### 	local Arg0=${ArrayArg[0]}; 
###  local StrHelperInvolved=${HelperQuestionInvolved:=Nothing} ; ### <---1a 
### 	if [ "${Arg0:=--start}" == "--help" ] ; then 
###			GetVarReference ${__call_locality[0]} ; 
###  else	
###   ---> Normal Body event and code. 
###  
###   ... 
###  fi 
### }
### 
### Note, In case your Helper --help be tested, if it does not output only Prefixed var definition.
### retreive all your variable from your command and do like example StrHelperInvolved in 1a
### Create specific local variable and associate the content of your Prefixed variables, help get 
### better body definition and reduce complexity by reading it... 
### 


unset GetVarReference ;
function GetVarReference( )
{
	local ArrayArg=( $* ) ;

	function ParseInternalVar( )
	{
		local ArrayArg=( $* ) ;
		local __call_locality=( ParseInternalVar ) ;
		egrep -i ":=" |\
				sed -r 's/(^[\ \t]*)//g;s/=\$/ \$/g;s/;//g' |\
				cut -d ' ' -f 3- |\
				sed 's/\(:=\)/ /g;s/\${//g;s/}$//g;s/\(^[A-Za-z0-9=_]* \)/Variable \1,\n\tDefault Value:/g' | sed 's/[\}\{]//g' ;
	}
	function ParseLocalityVar()
	{
		local ArrayArg=( $* ) ;
		local __call_locality=( ParseLocalityVar ) ;
		egrep "__call_locality" | sed 's/[\)\(]/ /g;s/;//g' | cut -d ' ' -f 7 ;	
	}
	echo -ne "Help:\n\nFunction ${ArrayArg[0]}\nDefault Variable Value:\n";
	local CallLocalityInternalName=$( declare -f ${ArrayArg[0]} | ParseLocalityVar ) ;
	declare -f ${ArrayArg[0]} | egrep "${CallLocalityInternalName}" | ParseInternalVar ;
}

unset DefaultConfigure ;
function DefaultConfigure()
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( DefConfigure ) ; 
	local StrDefaultAction=${DefConfigureAction:=--start-services} ;
	local Arg0=${ArrayArg[0]:=${StrDefaultAction}}; 
	local StrLD='${DefConfigureLD:=${LD} -laudiofile}' ; 
	local StrLDFLAGS='${DefConfigureLDFLAGS:=${LDFLAGS}}' ; 
	local StrCXX=${DefConfigureCXX:=\${CXX}} ; 
	local StrCC=${DefConfigureCC:=\${CC}} ; 
	local StrCPP=${DefConfigureCPP:=\${CPP}} ; 
	local StrCFLAGS=${DefConfigureCFLAGS:=\${CFLAGS}} ;
	local StrCPPFLAGS=${DefConfigureCPPFLAGS:=\${CPPFLAGS}} ; 
	local StrCXXFLAGS=${DefConfigureCXXFLAGS:=\${CXXFLAGS}} ; 
	local StrNewConfigureOptFile=${DefConfigureOptFile:=${HOME}/.DefConfigureOption} ; 
	local StrNameConfigure=${DefConfigureName:=default} ;
	
	local CmdEval=( ./configure  ) ;
	
	function GetNameConfigureOption()
	{
			local ArrayArg=( $* ) ; 
			local __call_locality=( GetConfOpt ) ; 
			local Arg0=${ArrayArg[0]}; 
			local StrNameOption=${GetConfOptName:=default} ;
			local StrOptionFile=${GetConfOptFile:=${HOME}/.DefConfigureOption} ;
			local StrGrepSep=${GetConfOptSep:=:} ;
			local StrGrepPattern=${GetConfOptGrepPattern:=__PATTERN____SEP__} ;
			local StrGrepForm="${StrGrepPattern//__PATTERN__/${StrNameOption}}";
			StrGrepForm=${StrGrepForm//__SEP__/${StrGrepSep}} ; 
			local StrContent=$( cat ${StrOptionFile} | egrep -i ${StrGrepForm} | head -n 1 | cut -d ':' -f 2- ) ; 
			echo -ne "${StrContent}" ; 
	}
	local StrConfigureContentTest="" ;
	test -e ${StrOptionFile} && local StrConfigureContentTest=$( GetConfOptName=${StrNameConfigure} GetConfOptFile=${StrNewConfigureOptFile} GetNameConfigureOption ) ; 
	local StrConfigureContent=${StrConfigureContentTest:=--help} ; 
	#local StrConfigContent=$( test -e ${StrNewConfigureOptFile} && local CmdEval=( ./configure  ) ) ; 
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
	if [ "${ArrayArg[0]}" = "--help" ] ; then 
		GetVarReference DefaultConfigure ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${ArrayArg[0]}" == "${StrDefaultAction}" ] ; then 
		CmdEval=( ${CmdEval[@]} ${StrConfigureContent} ) ; 
		echo -ne "Configure option extracted: \n\t${CmdEval[@]}\n\n" > /dev/stderr ; 
		#eval """${CmdEval[@]}""" ; 
	elif [ "${ArrayArg[0]}" == "--add" ] ; then 
		echo -ne """Adding Configure Option Name:${StrNameOption}:\n\t\t\t${ArrayArg[@]:1:}\n""" > /dev/stderr ; 
		local StrExportSream="""${StrNameConfigure}:__configure__ ${ArrayArg[@]:1:} LD=\"${StrLD}\" LDFLAGS=\"${StrLDFLAGS}\" CXX=\"${StrCXX}\" CC=\"${StrCC}\" CPP=\"${StrCPP}\" CFLAGS=\"${StrCFLAGS}\" CPPFLAGS=\"${StrCPPFLAGS}\" CXXFLAGS=\"${StrCXXFLAGS}\" ${ArrayArg[@]:1:}""" ; 
		StrExportSream=${StrExportSream//__configure__/${StrNameOption}} ;
		echo -ne "Configure Command:\n\t${StrExportSream}\n" > /dev/stderr ; 
		#echo -ne "${StrExportSream//__configure__/${StrNameOption}}\n" >> ${StrNewConfigureOptFile} ; 
	elif [ "${ArrayArg[0]}" == "--update" ] ; then 
		echo -ne """Updating Configure Option:\n\t\t${ArrayArg[@]:1:}\n""" > /dev/stderr ; 
	elif [ "${ArrayArg[0]}" == "--remove" ] ; then 
		echo -ne """Removing Configure Option:\n\t\t${ArrayArg[@]:1:}\n""" > /dev/stderr ; 
	else
		echo -ne """Arg0 No option specified\n""" > /dev/stderr ; 
	fi

	
}

 ### IsPathName :
 ###
 ###
 ###	Full-length example : 
 ### Including 2 main definition
 ###
 ### - Return value:
 ### if the test success, it report number of element retain in grep filter. 
 ###  - it also return 0 in case of sucess and 1 if fail. 
 ### example: 
 ###
 ### - Return True on a test on Arg0 to be a path with appropriate sematic for current path. 
 ### IsPathName ./avfsd 
 ### -> return 0 
 ###
 ### IsPathNameAction=CurrentPath IsPathName ./avfsd 
 ### -> return 0 
 ###
 ### IsPathName /avfsd 
 ### -> return 1 # This is not a current path specified. 
 ###
 ### IsPathName IsPathNameAction=IsRootPath avfsd 
 ### -> return 1 # This is not a Rooted-path name.
 ###
 ### IsPathName IsPathNameAction=IsRootPath /avfsd 
 ### -> return 0 .
 ###
 ###

unset IsPathName 
function IsPathName()
{
		local __call_locality=( IsPathName );
		local ArrayArg=( $* ) ;
		local Arg0=${ArrayArg[0]}; 
		local ArgActionList=${IsPathNameActLst:=CurrentPath,IsRootPath}
		local RegActionList=${IsPathNameReglst:="^\.+\/"__SEP__"^\/"} ; 
		local StrAction=${IsPathNameAction:=CurrentPath} ; 
		local IntReturnValue=0 ; 
		local IntReturnState=0 ; 
		
		local ArrayActionList=( ${ArgActionList//,/ } ) ; 
		local ArrayRegExp=( ${RegActionList//__SEP__/ } ) ; 
		
		local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
		if [ "${ArrayArg[0]}" = "--help" ] ; then 
			IntReturnState=0 ;
			GetVarReference ${__call_locality[0]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		else
			for(( intx=0 ; intx <= ${#ArrayActionList[@]]}-1 ; intx++ )) ; do 
			 local StrReg="${ArrayRegExp[${intx}]}" ;
			 local StrMainAction=${ArrayActionList[${intx}]} ; 
			 if [ "${StrAction}" == "${StrMainAction}" ] ; then 
					IntReturnValue=$( echo "${Arg0}" | egrep -ice "${StrReg}"	 2&>1 /dev/null ) ; 
			 fi 
			done 
		 if [ ${IntReturnValue:=0} -gt 0 ] ; then 
				IntReturnState=0 ;
			else
				IntReturnState=1 ;
			fi 
			
		fi 
		return ${IntReturnState} ;  
}



 ### GetOtherDate :
 ###
 ###
 ###	Full-length example : 
 ### Including Loop to create different day pattern
 ###
 ### hint:
 ### - Having to check 1 day before and 1 day after need to combine 
 ### settign GetOtherDateReferenceFormat="__INT__ day" , and not "__INT__ day ago", give you positive forward in time
 ### setting GetOtherDateIsLoop=True 
 ### setting GetOtherDateLoop=-1,1 ( tricky but work ) , create interleave between -1 to 1, so it's -1 day in futur, 0 day in futur and 1 day in futur... 
 
 ### GetOtherDateReferenceFormat="__INT__ day ago"  GetOtherDateFormat="%Y%m%d" GetOtherDateIsLoop=True GetOtherDateLoop=1,4 GetOtherDateVerbose=True  GetOtherDate
 ### Will display :
 ### 
 ### 20121010
 ### 20121011
 ### 20121012
 ###
 ### Short example :
 ### GetOtherDate
 ###
 ### Will display :
 ###
 ### 20121011
 ###
 ### GetOtherDateReferenceFormat="__INT__ day ago"
 ###
 ###
unset GetOtherDate ;

function GetOtherDate()
{
		local __call_locality=( GetOtherDate );
		local ArrayArg=( $* ) ; 
		
		function Verbosis()
		{
			local __call_locality=( Verbosis );
			local StrMsg=${VerbosisMsg:=__TEXT__} ; 
			local StrDevOut=${VerbosisDev:=/dev/stderr} ; 
			local ArrayArg=( $* ) ; 
			if [ ${ArrayArg[0]} == "True" ] ; then 
				echo -ne "${StrMsg}" > ${StrDevOut} ;
			fi
			
		}
		
		function DateFunc()
		{
			local __call_locality=( DateFunc ) ;
			local ArrayArg=( $* ) ; 
			eval """date +"${DateFuncFormat:=%Y%m%d}" -d '${DateFuncIndicator:=0 day}'""" ; 
		}
		
		local StrDateIndicatorFormat=${GetOtherDateReferenceFormat:='__INT__ day'}
		local StrDateIndicator=${StrDateIndicatorFormat/__INT__/${GetOtherDateReference:=0}}  ;
		local StrDateFormat=${GetOtherDateFormat:=%Y%m%d} ;
		local isLoop=${GetOtherDateIsLoop:=False} ;
		local LoopRange=${GetOtherDateLoop:=0,3} ;
		local ArrayRange=( ${LoopRange/,/ } ) ;
		local OperRange="<=" ;  
		local OperRangeIn="Intx++" ;
		local OperBaseStart=${ArrayRange[0]} ;
		local IsVerbose=${GetOtherDateVerbose=False} ;
		local IntEndLoop=$(( ${ArrayRange[$((${#ArrayRange[@]}-1))]} ));
		
		local Arg0=${ArrayArg[0]}; 
		local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
		
 	if [ "${Arg0:=--start}" == "--help" ] ; then 
			GetVarReference ${__call_locality[0]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
	 else	 
	 	if [ "${isLoop:=False}" == "True" ] ; then 
				VerbosisMsg="ArrayRange, nb-element:${#ArrayRange[@]}, hold [ ${ArrayRange[@]} ]\n" Verbosis ${IsVerbose} ;
				if (( ${ArrayRange[0]} > ${IntEndLoop} )) ; then 
					OperRange=">=" ;
					OperRangeIn="Intx--" ; 
					OperBaseStart=${ArrayRange[$((${#ArrayRange[@]-1))}]} ;
				fi		
	 		VerbosisMsg="Looping from ${OperBaseStart} to ${IntEndLoop} \n" Verbosis ${IsVerbose} ;
	 		for (( Intx=${OperBaseStart} ;  Intx ${OperRange} ${IntEndLoop} ; ${OperRangeIn} )) ; do 
		 			StrDateIndicator="${StrDateIndicatorFormat/__INT__/${Intx}}" ; 
		 			DateFuncFormat=${StrDateFormat} DateFuncIndicator=${StrDateIndicator} DateFunc ;
	 		done
	 	else 
	 		DateFuncFormat=${StrDateFormat} DateFuncIndicator=${StrDateIndicator} DateFunc ;
			fi
 	fi 
}




function kill_cmd()    
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( kill_cmd ) ;  
	local IntDefaultKillSig=${kill_cmdDefaultSigInt:=-9} ;
	local StrColDisplayInSearch=${kill_cmdPsColList:=pid,command}
	local IntNbCol=$(( $( echo "${StrColDisplayInSearch}" | wc -m ) - $( echo "${StrColDisplayInSearch//,/}" | wc -m ) ))
	local IntIdPassToKiller=${kill_cmdColIdToKill:=${IntNbCol}} ; 
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
	if [ "${ArrayArg[0]}" = "--help" ] ; then 
		GetVarReference ${__call_locality[0]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	else
		for (( x=0 ; x <= ${#ArrayArg[@]}-1 ; x++ )) ; do 
			local cmd=${ArrayArg[${x}]} ; 
			local PsResult=$( ps -eo ${StrColDisplayInSearch} | egrep -i "${cmd}" | grep -v grep | cut -d ' ' -f ${IntIdPassToKiller} | tr '[:cntrl:]' ' ' )
			CmdEval=( kill ${IntDefaultKillSig} ${PsResult} ); 
			echo -ne "PsResult:\n\n${PsResult}\n\n" > /dev/stderr ;
			echo -ne "Command Eval:[ ${CmdEval} ]\n" > /dev/stderr ; 
		done 
	fi 
}



unset StartApps
function StartApps()
{ 
 local ArrayArg=( $* ) ; 
 local __call_locality=( StartApps ) ; 
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 if [ "${ArrayArg[0]}" = "--help" ] ; then 
		GetVarReference ${__call_locality[0]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
 else	 
	 local AppsRefresh=${StartAppsRefresh:=4} ; 
	 local Apps=${StartAppsCmd:=rezound --audio-method=jack} ; 
	 local ScanApps=${StartAppsScan:=rezound} ; 
		local StrAppsStopSig=/home/${USER}/stop_${ScanApps}
	 local IsStopSig
		IsStopSig=$( test -e ${StrAppsStopSig} && echo 1 );
	 while [ ${IsStopSig:=0} -eq 0 ] ; do 
		local isApps=$( ps -eo pid,command | grep -v egrep | egrep -ic "${ScanApps}" ) ; 
		if [ ${isApp:=0} -eq 0 ] ; then 
		 eval ${Apps} ; 
		fi ; 
		sleep ${AppsRefres} ; 
			IsStopSig=$( test -e ${StrAppsStopSig} && echo 1 ) ;
	 done ; 
		rm -f ${StrAppsStopSig} ;
		echo -ne "Exiting signal catch for Application ${Apps} to cancel respawing.\n" > /dev/stderr 
 fi
}

function Survey_kill_apps()    
{ 
    function KillApps()
    {
        local __call_locality=( KillApps ) ; 
        local ArrayArg=( $* ) ; 
        kill -9 $( ps -eo pid,command | egrep -i "${ArrayArg[0]}" | grep -v "egrep" | sed 's/^[\ \t]*//g' | cut -d " " -f 1 )
    }
    local __call_locality=( SurveyApps ) ; 
    local ArrayArg=( $* ) ; 
		local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
		if [ "${ArrayArg[0]}" = "--help" ] ; then 
		 GetVarReference Survey_kill_apps ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		else	 
		  local StrApps=${SurveyApps:=rezound} ; 
		  local IntDelay=${SurveyAppsRefresh:=4} ; 
		  while [ 1 ] ; do 
		      test -e /home/maxiste/kill_${StrApps} && \
		          rm -f /home/maxiste/kill_${StrApps} && \
		          KillApps ${StrApps} 
		      sleep ${IntDelay} ; 
		  done ; 
		fi
}



### Usefull for python installer using pip. 
### Happen more than once have to call pip with another gcc compiler while test failed to compile many source
### from Numpy numpy/linalg/lapack_litemodule.c and linalg/zlapack_lite.c failling or doing segmentation fault.
### Most of the time they can work compiling them direct from the shell but in bash script called from bash or
### python script like setup.py failed... 
### So I'm changing couple of variable and calling indivilually pip installer like this :
### Where cmd old followin value : cmd=( pip install __MODULE__ )
### eval $( DpkgGetInlineBuildFlags ) CC=/usr/bin/x86_64-linux-gnu-gcc-4.4 CXX=/usr/bin/x86_64-linux-gnu-g++-4.4 ${cmd[@]}
function DpkgGetInlineBuildFlags()
{
  local __call_locality=( DpkgGetInlineBuildFlags ) ;
  local ArrayArg=( $* ) ;
		local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 	if [ "${ArrayArg[0]}" = "--help" ] ; then 
			GetVarReference ${__call_locality[0]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
 	else	 
  	local CmdEval=( "cat" "${DpkgGetInlineBuildFlagsPath:=/etc/dpkg/}"${DpkgGetInlineBuildFlagsFile:=buildflags.conf} "|" """sed -e 's/^\(SET\ \)\([a-zA-Z]*FLAGS\)\([\t\ ]*\)/\2=/g'""" "|" tr """'[:cntrl:]\' ' '""" ) ;
  	eval "${CmdEval[@]}" ;
	fi 

}

function fast_dpkg_build()    
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( FDB ) ; 
	local StrOptionDpkgBuild=${FDBDpkgBuildOpt:=} ;
	local StrOptionDpkgInst=${FDBDpkgInstOpt:=} ;
	for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
		local StrPackage=${ArrayArg[${intx}]} ; 
		cd /usr/local/src/apt/ ; 
		md_cd $(pwd)/${StrPackage} ; 
		cd ${StrPackage} ; 
		local IntBuild=0 ; 
		apt-src install ${StrOptionDpkgInst} -p ${StrPackage} && apt-src ${StrOptionDpkgBuild} -p build ${StrPackage} && IntBuild=1 ; 
		echo -ne "\n\n\tBuild Status\n\t\titem : ${StrPackage}\n\t\tStatus: ${IntBuild}\n\n" ; 
		dpkg --install $( find ./ -type f -iname "*.deb" -printf "%p " ) ; 
	done ; 
}

function DebianAptSrcCompiler()
{
	local __call_locality=( DebianAptSrcCompiler ) ; 
	local ArrayArg=$( $* ) ; 
  local ArrayPackageName=( ${DebianAptSrcCompilerPackage//;/ } ) ;
	local CompilerVersion=${DebianAptSrcCompilerVersion:=4.4} ; 
	local StrAptProc=${DebianAptSrcCompilerPackageAptProc:=clean;install;build}
	local AddPatch=${DebianAptSrcCompilerPatch:=True} ;
	local ArrayAptSrcProc=( ${StrAptProc//;/ }  ) ; 
	local StrPatchOpt="" ; 
	local res_exec=0 ; 
	local StrPath=${DebianAptSrcCompilerPath:=/usr/local/src/apt} ;
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 	if [ "${ArrayArg[0]}" = "--help" ] ; then 
			GetVarReference ${__call_locality[0]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
 	else	 	
		if [ ${AddPatch:=True} == "True" ]; then 
			StrPatchOpt="-p" ;
		else
			StrPatchOpt="" ;
		fi 
		for Package in ${ArrayPackageName[@]} ; do 
			local old_dir=$( pwd )
			test ! -d ${StrPath}/${Package} && mkdir -p ${StrPath}/${Package} ;
			cd ${StrPath}/${Package} ; 
			apt-src update ;
			local UpdateState=$? ;
			if [ ${UpdateState:=0} -eq 0 ] ; then 
				echo -ne "\t\t----- Building -----\n\t\t\t${Package}\n\n" > /dev/stderr ; 
				for item in ${ArrayAptSrcProc[@]} ; do 
					echo -ne "\n\n\n\t\t----- APT-SRC STEP: -----\n\t\t\t${item}\n\n\n" > /dev/stderr ; 
					CC=${DebianAptSrcCompilerCBaseName:=/usr/bin/x86_64-linux-gnu-gcc-}${CompilerVersion} \
					CXX=${DebianAptSrcCompilerCXXBaseName:=/usr/bin/x86_64-linux-gnu-g++-}${CompilerVersion} \
					apt-src ${item} ${Package} ${StrPatchOpt} ; 
					res_exec=$? ; 
					echo -ne "\n\n\t\t-----------------\n\t\t Error Status: ${res_exec}\n\t\t-----------------\n\n" > /dev/stderr  ;  
				done ;
			else
				echo -ne "\n\n\t\t-------------------------------------------------------\n\t\t Error compilation/installation of ${Package}\n\t\t-------------------------------------------------------\n" > /dev/stderr 
			fi 
			cd ${old_dir}  ;
		done 
	fi
}

 ### AptRebuild :
 ### - Use script apt-src to commonly clean and build a debian source packages
 ###  being installed as source and it's ready to compile. This function uses 
 ###  the prefixed variable AptRebuildCommand to select any new order wanted to
 ###  pass to the function. 
 ###    - Commonly AptRebuildCommand is owning 'clean,build' but affecting it with 
 ###  other task like install and build can be substitued to this Common Task. 
 ###
 ###	Full-length example : 
 ### AptRebuildCommand=install,build AptRebuild libots-dev
 ###
 ### hint:
 ###  - switch '--help' is available for this function. 
 ### 
 ### 
 ### 
 
 ### Fixing a Predefined Association of Tag and Variable Name using the GetVarReference structure. 
 ### AptRebuild, may own it's own purposes by assigning to AptRebuildTagVar other variable and 
 ### other Tag inside AptRebuildTag prefixed var. meaning it can support 
 ###
 ###  following call : 
 ###    NewVar=Value AptRebuildTagVar=NewVar,Option,Package,StrAppsName,StrAppsOptExtr AptRebuildTag=__OTHERTAG__,__OPTION__,__PACKAGE__,__APPS__,__APPSOPT__ AptRebuild <package-module>, and will automatically parse the Variable NewVar into ${NewVar} (in this case it exist and will not overwrite the affected value.) into the Tag __OTHERTAG__. 
 ### 
 ###  This also need to change the AptRebuildExec Tag order to let it evaluate correctly. 
 ### 
 ### Use of Pre-Fixed Variable AptRebuildExec and AptRebuildTag. 
 ### 
 ### Description:
 ### - While this function is quite restricted, it's a mechanism that feed definition and will
 ### ultimately execute the sequence. Having a strong role inside AptRebuildCommand. the code 
 ### is structured like 1-finite loop of instruction and have to parse the commandline 
 ### defined inside AptRebuildExec and having others application being substitued you can
 ### create a virtual other command working inside this type of loop. 
 ### 
 ###  AptRebuildCommand hold 2 item : clean,build 
 ###  - where this variable fix the first command to own instruction for 'clean' and 'build' . 
 ###  - The Argument List after the  AptRebuild are the complete loop whitin First Fixed Element,
 ###  Variable -> Tag and execution . The case is tweaky, assuming eth0 and wlan0 are ultimately
 ###  the source being analysed with other condition , This one will pre-used eth0 and wlan0, 
 ###  to use the Forced Variable Package to hold eth0 or wlan0. This mean Package and 
 ### 
 ###  AptRebuildApps hold usually apt-src but in other case it may hold network-topology application
 ### being used. One popular, ifconfig. 
 ###  - In many uses ifconfig may also depend os some fixed instruction. like seeing the interface
 ### eth0 and wlan0 to verify both information. 
 ### 
 ### give as parameter : AptRebuildCommand=eth0,wlan0  AptRebuildApps=ifconfig 
 ### 
 ### AptRebuildExec and AptRebuildTag are also the order you want to use pre-defined 
 ### VAR -> __TAG__ substitution and the way the command exit depend of working example.
 ### 
 ### And there is 2 finite hard-fixed value to not remove because it hold in a double-loop value
 ### from iteration 
 ### for A ( Argument[ 0 - 15+ ] )
 ### 			 for B ( AptRebuildCommand ) 
 ### 					--- Parsing Level and Substitution Level --- 
 ### 
 ### - Also some basic prefixed value also own it's priority .
 ### AptRebuildAppsOption -> Internally used as StrAppsOptExtr will use the tag you defined but 
 ### need to be reflected inside the Tag-Loop Association. It will use 
 ### AptRebuildTag=__OPTION__,__PACKAGE__,__OTHEROPTION__ and use tag __OTHEROPTION__ is definied inside 
 ### AptRebuildTagVar, like :
 ### AptRebuildTagVar=Option,Package,StrAppsOptExtr AptRebuildTag=__OPTION__,__PACKAGE__,__OTHEROPTION__
 ### and commandline inside AptRebuildExec should reflect an __OTHEROPTION__ tag. 
 ### 
 ### AptRebuildApps -> Internally used as StrApps will own have to define it's own Tag too. 
 ### 
 ### 
 ### example : ifconfig eth0 -apr 
 ###  - To Set NOARP to your local ethernet card. 
 ###  
 ###  - And AptRebuildTag will look like this : 
 ###   AptRebuildCmdExec=False \
 ###   AptRebuildApps=ifconfig \
 ###   AptRebuildCommand=eth0,wlan0 \
 ###   AptRebuildAppsOption=-arp \
 ###   AptRebuildTag=__OPTION__,__PACKAGE__,__APPS__,__OTHEROPTION__ \
 ###   AptRebuildTagVar=Option,Package,StrAppsName,StrAppsOptExtr \
 ###   AptRebuildExec=__APPS__,__OPTION__,__OTHEROPTION__,__PACKAGE__  AptRebuild -v 
 ### 
 ### Will give a sequence to set -arp and verbosis to internet working interface:
 ### 
 ### AptRebuildCmdExec=False AptRebuildApps=ifconfig AptRebuildCommand=eth0,wlan0 AptRebuildAppsOption=-arp AptRebuildTag=__OPTION__,__PACKAGE__,__APPS__,__OTHEROPTION__ AptRebuildTagVar=Option,Package,StrAppsName,StrAppsOptExtr AptRebuildExec=__APPS__,__OPTION__,__OTHEROPTION__,__PACKAGE__  AptRebuild -v
 ### - Output
 ### 
 ###  	Processing eth0
 ### 
 ### CommandLine:[ ifconfig eth0 -arp -v ]
 ### 	Processing wlan0
 ### 
 ### CommandLine:[ ifconfig wlan0 -arp -v ]
 ### 
 ###  just by setting AptRebuildCmdExec=False to True will allow executing the sequence. 
 ### 
 ### 
 ### ... Just a good candidate for automation and generating corpus definition in variable transfert and
 ### Variable substitution. 
 

 ### AptSrcChange :
 ### 
 ### - Function AptSrcSourceChange, change the default /etc/apt/source.list and restitute it
 ### after coming back from the application apt-src. 
 ### -Note : apt-src is dependant from packages apt-src, and need to be installed with apt, dpkg
 ### and/or synaptic. 
 ### - It voluntary change the source.list until it was more convenient to alter the content
 ### of this file by replacing only debian information for package retrevial into debian-source
 ### package. It also change the type of architecture and it's convenient to leave and/or 
 ### adapt other application dependant from /etc/apt/source.list . 
 ### 
 ###  exemple : 
 ###   - synaptic depend from /etc/apt/source.list  
 ### using AptSrcChangeApps=synaptic AptSrcChange 
 ###  - and will load automatically synaptic after doing a change inside /etc/apt/source.list .  
 ###  - it will not do an automatic update. Like apt-src need to run periodically apt-src update
 ### to update it's cache, synaptic has this example show there is no update available as external 
 ### switch and the condition are not yet defined to supply a function for automatic-update. 
 ### ... while python module from apt and dpkg can re-update and write the cache it was not supply 
 ### here. 
 ### 
 ### 
 
 
 
unset AptSrcChange
function AptSrcChange()
{
 local __call_locality=( AptSrc ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ; 
 local IntUUID=$( uuidgen -t ) ; 
 local StrUUID="/tmp/${IntUUID}" ; 
 local StrApps=${AptSrcChangeApps:=/usr/bin/apt-src} ; 
 local StrAptSourceList=${AptSrcChangeFile:=/etc/apt/sources.list} ; 
 local StrAptSourceSave=${AptSrcChangeSave:=/etc/apt/sources.list.save} ; 
 local StrTagSearch=${AptSrcChangeTagSearch:=deb} ;
 local StrTagAdd=${AptSrcChangeTagChange:=deb-src} ;
 local StrDefaultArch=${AptSrcChangeArch:=amd64} ;
 local StrDefaultURI=${AptSrcChangeURIType:=http}
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 if [ "${Arg0}" = "--help" ] ; then 
  GetVarReference ${__call_locality[0]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
 else	
  cp ${StrAptSourceList} ${StrAptSourceSave} ; 
  cat ${StrAptSourceList} | sed 's/^${StrTagSearch} ${StrDefaultURI}/${StrTagAdd} [ arch=${StrDefaultArch} ] ${StrDefaultURI}/g' > ${StrUUID} ; 
  cp ${StrUUID} ${StrAptSourceList} ; 
  echo -ne "\n\tUUID: ${StrUUID}\n" > /dev/stderr ; 
  if [ "${StrApps}" == "/usr/bin/apt-src" ]  ;then 
   # doing extra update 
   eval "${StrApps} update" ; 
  fi 
  eval "${StrApps} ${ArrayArg[@]}" ; 
  cp ${StrAptSourceSave} ${StrAptSourceList}
 fi
}


unset AptRebuild ; 
function AptRebuild()    
{ 
	local __call_locality=( AptRebuild ) ; 
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
	local StrCSVSep=${AptRebuildCSV:=,} ; 
	local StrAppsName=${AptRebuildApps:=apt-src} ; 
	local StrAppsOptExtr=${AptRebuildAppsOption:=-p} ; 
	local StrCmdLine=${AptRebuildExec:=__APPS__,__OPTION__,__APPSOPT__,__PACKAGE__} ; 
	local StrCmdTag=${AptRebuildTag:=__OPTION__,__PACKAGE__,__APPS__,__APPSOPT__}
	local StrCmdTagVar=${AptRebuildTagVar:=Option,Package,StrAppsName,StrAppsOptExtr}
	local IsShowDebug=${AptRebuildShowDebug:=False} ;
	local IsCmdExec=${AptRebuildCmdExec:=True} ;
	local StrCmdOption=${AptRebuildCommand:=clean,build} ; 
	cmdline=( ${StrCmdLine//${StrCSVSep}/ } ) ; 
	
	local ArrayTag=( ${StrCmdTag//${StrCSVSep}/ } ) ; 
	local ArrayOption=( ${StrCmdOption//${StrCSVSep}/ } ) ; 
	local ArrayOptionVar=( ${StrCmdTagVar//${StrCSVSep}/ } )
	
	
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
	if [ "${Arg0}" = "--help" ] ; then 
		GetVarReference ${__call_locality[0]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	else	 
		for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
			Package=${ArrayArg[${intx}]} ; 
			for (( intAx=0 ; intAx <= ${#ArrayOption[@]}-1 ; intAx++ )) ; do
				local Option=${ArrayOption[${intAx}]} ;
				echo -ne "\tProcessing ${Option}\n" > /dev/stderr
				local CmdExec=( ${cmdline[@]} ) ; 
				
				for (( intCx=0 ; intCx <= ${#ArrayOptionVar[@]}-1 ; intCx++ )) ; do 
					local tagName=${ArrayTag[intCx]} ; 
					local varName=${ArrayOptionVar[intCx]} ; 
					eval """local NewVarValue=\${${varName}}""" ; 
					if [ "${IsShowDebug}" == "True" ] ; then 
						echo -ne "\t\ttagName: ${tagName}\n\t\tvarName: ${varName}\n\t\tValue: ${NewVarValue}\n" > /dev/stderr ; 
					fi
					eval """CmdExec=( ${CmdExec[@]//${tagName}/${NewVarValue}} )""" ; 
				done 
				echo -ne "\nCommandLine:[ ${CmdExec[@]} ]\n" > /dev/stderr ; 
				if [ ${IsCmdExec:=True} == "True" ] ; then 
					eval ${CmdExec[@]} ; 
			  fi
			done
		done
	fi 
}



function find_edit_file()
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( FEF ) ; 
	local StrPath=${FEFDefaultPath:=./} ;
	local StrAppsFind=${FEFAppsFind:=/usr/bin/find} ;
	local StrEditor=${FEFEditorApps:=/usr/bin/gedit} ;
	local StrFindFilterOpt=${FEFFindFilter:=-iname \"__FILE__\"} ;

		local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 	if [ "${ArrayArg[0]}" = "--help" ] ; then 
			GetVarReference find_edit_file ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
 	else	
		for file in ${ArrayArg[@]} ; do 
			local StrFilterInFind=${StrFindFilterOpt//__FILE__/${file}}
			eval "${StrAppsFind} ${StrPath} -type f ${StrFilterInFind} -exec ${StrEditor} {} \;" & 
		done ; 
	fi
}

### Usefult having clause with many compiler available and having h2xml or ctag path filtering to apply,
### having command like 
###
### -> h2xml /usr/include/math.h $( find /usr/include/ -type d -printf "-I%p " ) -c -o math_c.xml 
###	 Will reduce output of some treatment... 
###  ->>>
###  ->>>CompilerError: In file included from /usr/include/math.h:34,
###  ->>>                 from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/x86_64-linux-gnu/bits/huge_val.h:28:18: error: missing binary operator before token "("
###  ->>>/usr/include/x86_64-linux-gnu/bits/huge_val.h:30:20: error: missing binary operator before token "("
###  ->>>In file included from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/math.h:403:42: error: missing binary operator before token "("
###  ->>>In file included from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/math.h:30: error: '__BEGIN_DECLS' does not name a type
###  ->>>In file included from /usr/include/math.h:71,
###  ->>>                 from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: '__' was not declared in this scope
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: 'acos' was not declared in this scope
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: '__CONCAT' cannot be used as a function
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: expected primary-expression before ')' token
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: initializer expression list treated as compound expression
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: expected ',' or ';' before '(' token
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:57: error: redefinition of 'double __CONCAT'
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: 'double __CONCAT' previously defined here
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:57: error: 'asin' was not declared in this scope
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:57: error: expected primary-expression before ')' token

###
###
###

function FindFilterPathExclusion()    
{ 
	local ArrayArg=( $* ) ; 
	local __call_locality=( FindFilterPathExclusion ) ; 
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 	if [ "${ArrayArg[0]}" = "--help" ] ; then 
			GetVarReference ${__call_locality[0]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
 	else	 

		### 
		### The chainning mechanism , if there is already used filter, passing thru this 
		### variable will add-it to current filter output. 
		local CurrentExlusion=${FindFilterPathKnowExclusion:=""} ; 
	
		###
		###
		###
		local SelectedPackagePath=${FindFilterPathName:="c++"} ; 

		### - Will tell to filter function if this segment should be considered as
		### first statement and in-middle statement... 
		### example, using FindFilterWithStartCond=True, for a clause for find to start adding -a ! -name "..." 
		### in first statement of if will give command like 
		### find -type d [ -a ! -name "c++/4.4" ] <--- current filter . 
		### will simply be rejected or some warning may issued from . 

		local StartFilterWithCondition=${FindFilterWithStartCond:=False};
		local StrFilterPattern="${FindFilterPattern:=NAME/VER}";
		### 	The FindFilterClause should be written like from Removing To adding
		###   ex: with find, having removing or excluding pattern start like -a ! -name or -o ! -iname ...
		###       and adding or positive filter will include -a name, -o name ... 
		###   and FindFilterClause should be written as : FindFilterClause="-a ! -name,-a name"
		local StrConditionPattern=${FindFilterClause:=! -name, -name}

		local StrTypeOfLogicForAnd=${FindFilterClauseAnd:=-a};
		local StrTypeOfLogicForOr=${FindFilterClauseAnd:=-o};
		local StrLogic=""
		### FindFilterLogicSetTo default choice : ( And / Or )
		### 
		###

		local DefaultLogic=${FindFilterLogicSetTo:=And}; 
		if [ "${DefaultLogic}" == "And" ] ; then
			StrLogic="${StrTypeOfLogicForAnd}" ;
		else
			StrLogic="${StrTypeOfLogicForOr}" ;
		fi 

		local ArrayClauseFilter ;
		for(( intx=1 ; intx <= 2 ; intx++ )) ; do 
			ArrayClauseFilter[${#ArrayClauseFilter[@]}]=$( echo "${StrConditionPattern}" | cut -d "," -f ${intx} ) ;
		done 
	

		local SelectedMajor=${FindFilterMajorVer:=4} ; 
		local SelectedMinor=${FindFilterMinorVer:=4} ; 
		local TypeClauseFilter=0 ;
		for (( intx=${FindFilterMinMajorVer:=0} ; intx <= ${FindFilterMaxMajorVer:=9} ; intx++ )) ; do 
			local StrCriteronFilter=${StrFilterPattern};
			local StrCriteronFilterPrefix="";
				StrCriteronFilter=${StrCriteronFilter/NAME/${SelectedPackagePath}} ;
				StrCriteronFilter=${StrCriteronFilter/VER/${SelectedMajor}.${intx}} ;

			if [ ${intx} -ne ${SelectedMinor:=0}  ] ; then 
				TypeClauseFilter=0 ;
				if [ "${StartFilterWithCondition}" == "True" ] ; then 
					StrCriteronFilterPrefix="${StrLogic} 1${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				else
					StrCriteronFilterPrefix="2${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				fi ;
			fi		

			if [ ${intx} -eq ${FindFilterMinMajorVer:=0} ] ; then 
				TypeClauseFilter=${TypeClauseFilter} ;
				if [ "${StartFilterWithCondition}" == "True" ] ; then 
					StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				else
					StrCriteronFilterPrefix="${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				fi ;
			else
				if [ "${StartFilterWithCondition}" == "False" ] ; then 
					StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				else
					StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
				fi ;
			
			fi


			if [ ${intx} -eq ${SelectedMinor:=0} ] ; then 
				TypeClauseFilter=1 ;
				if [ "${StartFilterWithCondition}" == "True" ] ; then 
					StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} ${StrCriteronFilter}" ;
				else
					if [ ${intx} -eq ${FindFilterMinMajorVer:=0} ] ; then 
						StrCriteronFilterPrefix="${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
					else
						StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[1	]} \"${StrCriteronFilter}\"" ;				
					fi
				fi ;
			fi
			CurrentExlusion="${CurrentExlusion} ${StrCriteronFilterPrefix}" ;
		done
		echo -ne "${CurrentExlusion}" ; 
	fi 
}

unset acquire_lan_ifconfig
function acquire_lan_ifconfig()
{
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ; 
 local __call_locality=( AWI ) ; 
 local StrDefaultCard=${AWICardName:=wlan0} ;
 local StrAppsNetConf=${AWIAppsIfconf:=/sbin/ifconfig} ; 
 local StrAwkFilter=${AWIAwkScript:=/etc/init.d/Fnct.d/awk-script/ifconfig_tag_detection.awk} ; 
 local StrTagNameList=${AWIAwkTagInspect:=HWaddr,inet addr,inet6\ addr};
 
 function IfconfigGetter()
 {
  local ArrayArg=( $* ) ; 
  local __call_locality=( IfconfigGetter ) ;
  local StrOptGetter=${IfconfigGetterAddr:=local} ; 
  local StrApps=${IfconfigGetterApps:=/sbin/ifconfig} ; 
  $( eval ${StrApps} ${StrOptGetter} | tr '[:cntrl:]' ' ' | sed 's/[\ ]\+/ /g' ) ; 
 }
 function GetIpaddr()
 {
  local ArrayArg=( $* ) ; 
  local __call_locality=( GetIpaddr ) ;
  local StrAddr=${GetIpaddrAddr:=local} ; 
  local StrAppsIfconfig=${GetIpaddrAppsIfconfig:=/sbin/ifconfig} ;
  local StrAwkFilter=${GetIpaddrFilterMatch:=/etc/init.d/Fnct.d/awk-script/ifconfig_tag_detection.awk} ;   
  local StrTagList=${GetIpaddrTagList:=HWaddr,inet addr,inet6\ addr} ; 
  local StrTagCleanFilter=${StrTagList//\\ / } ;
  local StrReturn=$( IfconfigGetterApps=${StrAppsIfconfig} IfconfigGetterAddr=${StrAddr} IfconfigGetter awk -vTagName="${StrTagCleanFilter}"  -f StrAwkFilter ) ; 
  
 }
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
	if [ "${Arg0:=--start-services}" = "--help" ] ; then 
		GetVarReference acquire_lan_ifconfig ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	elif [ "${Arg0:=--start-services}" == "--start-services" ] ; then 
  GetIpaddrTagList=${StrTagNameList} GetIpaddrAppsIfconfig=${StrAppsNetConf} GetIpaddrAddr=${StrDefaultCard} GetIpaddr ; 
 fi 
}

unset GetBuildFlagsList
function GetBuildFlagsList( )
{
		local ArrayArg=( $* ) ; 
		local __call_locality=( ZPI ) ;  
		dpkg-buildflags --list | tr '[:cntrl:]' ' ' 
} 

unset GetZenityText ; 
function GetZenityText()
{
	local ArrayArg=( $* ) ; 
	local __call_locality=( GZT GetZenityText ) ;  
	local Arg0=${ArrayArg[0]} ;
	local StrTypeUI=${GZTUiType:=--entry}
	local StrApps=${GZTUiApps:=/usr/bin/zenity} ;
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
	if [ "${Arg0:=--startservices}" == "--help" ] ; then 
		GetVarReference ${__call_locality[1]} ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ; 			
	else
		eval ${StrApps} ${StrTypeUI} ${ArrayArg[@]} ;
	fi 
}

unset GetZenityTextEntry ; 
function GetZenityTextEntry()
{
	local ArrayArg=( $* ) ; 
	local __call_locality=( GZTE GetZenityTextEntry ) ;  
	local Arg0=${ArrayArg[0]} ;
	local IntWidth=${GZTEWidth:=640}
	local IntHeight=${GZTEHeight:=275}
	local StrTitle="""${GZTETitle:="Pip installation Try-up"}""" ; 
	local StrQuestion="""${GZTETextQuestion:="Installation Package to install (test)"}""" ; 
	local StrReturn ;
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
		if [ "${Arg0:=--startservices}" == "--help" ] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			
		else
			local CmdEval=( """local StrReturn=\$( GetZenityText --width=${IntWidth}  --height=${IntHeight} --title="${StrTitle}" --text="${StrQuestion}" ) """ ); 
			echo -ne "\n\nCmdEval : ${CmdEval[@]}\n\n" > /dev/stderr ; 
		fi 
		echo -ne "StrReturn return: ${StrReturn}\n" > /dev/stderr ; 
		echo -ne "${StrReturn}" ; 
}


unset zenity_pip_installer ; 
function zenity_pip_installer()    
{ 
	
		local ArrayArg=( $* ) ; 
		local __call_locality=( ZPI ) ;  
		local pkg_res=0 ; 
		function GetItemFlags()
		{
			local ArrayArg=( $* ) ; 
			local __call_locality=( GIF ) ;  
			dpkg-buildflags --get ${ArrayArg[0]} ;
		}
		
		while [ ${pkg_res:=0} -eq 0 ] ; do 
		local ADDFLAGS="" ; 
		local package=$( GetZenityTextEntry ) ; 

		for Item in $( GetBuildFlagsList ) ; do 
			local newFlags=$( GetItemFlags ${Item} ) ;
			ADDFLAGS="${ADDFLAGS} ${Item}=\"${newFlags}\"" ; 
		done  ; 
		echo -ne "ADDFLAGS:\n${ADDFLAGS}\n" ; 
		if [ ${package:=none} != "none"  ] ; then 
			eval ${ADDFLAGS} pip install ${package} ; 
		else 
			echo -ne "\n\n\t\tError reporting package: ${package:=none}\n\n" ; 
			sleep 10 ; 
			pkg_res=1 ;  
		fi ; 
		done ; 
}


unset GkSuZenityLoader ; 
function GkSuZenityLoader()
{
	local ArrayArg=( $* ) ; 
	local __call_locality=( GkSuZenityLoader ) ; 
	local StrUser=${GkSuZenityLoaderUser:=none}
	local StrApps=${GkSuZenityLoaderApps:=/usr/local/bin/idlex}
	local StrAppsOpt=${GkSuZenityLoaderAppsOpt:=''} ;
	local StrTitle=${GkSuZenityLoaderTitle:="Select a user for Idlex"} ;
	local StrFileInfo=${GkSuZenityLoaderFile:=/etc/passwd} ;
	local StrCol0=${GkSuZenityLoaderCol0:="selection"} ;
	local StrCol1=${GkSuZenityLoaderCol1:="user"} ;
	local StrRegSearch=${GkSuZenityLoaderReg:="\/bin\/bash"}
	local StrDefaultCSV=${GkSuZenityLoaderCSV:=':'} ;
	local IntDefaultColExtr=${GkSuZenityLoaderColExtr:=1} ;
	local BoolShowUserSelection=${GkSuZenityLoaderSUS:=False}
	
	local Arg0=( ${ArrayArg[0]} ) ;
	
	function ZenityFilter()
	{
			egrep -i ${StrRegSearch} ${StrFileInfo} | cut -d ${StrDefaultCSV} -f ${IntDefaultColExtr} | sed  's/\(^[a-zA-Z0-9]*\)/FALSE \1/g' ; 
	}
	function GetPwdUser()
	{
		local StrUserSelection=$( zenity --list --title "${StrTitle}" --column="${StrCol0}" --column="${StrCol1}" --radiolist $( StrDefaultCSV=${StrDefaultCSV} StrFileInfo=${StrFileInfo} StrRegSearch=${StrRegSearch} IntDefaultColExtr=${IntDefaultColExtr} ZenityFilter ) ) ;
		StrUserSelection=${StrUserSelection:=${StrUser}} ;
		if [ "${BoolShowUserSelection}" == "True" ] ; then 
			echo -ne "User selected: ${StrUserSelection}\n" > /dev/stderr ; 
		fi 
		echo "${StrUserSelection}" ; 
	}
	function Loader()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( Loader ) ; 
		gksu --user ${StrUser} ${StrApps} ${StrAppsOpt} 
	}
		local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
	 if [ "${ArrayArg[0]}" = "--help" ] ; then 
			GetVarReference ${__call_locality[0]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ; 			 	else	
			if [ "${StrUser:=none}" ==  "none" ] ; then 
				StrUser=$( StrDefaultCSV=${StrDefaultCSV} IntDefaultColExtr=${IntDefaultColExtr} StrFileInfo=${StrFileInfo} StrTitle=${StrTitle} StrCol0=${StrCol0} StrCol1=${StrCol1} StrRegSearch=${StrRegSearch} BoolShowUserSelection=${BoolShowUserSelection} GetPwdUser ) ; 
			fi 
			if [ "${StrUser:=none}" == "none" ] ; then 
				echo -ne "Warning Invalid user: ${StrUser}\n" > /dev/stderr ; 
			else
				StrUser=${StrUser} StrApps=${StrApps} StrAppsOpt=${StrAppsOpt} Loader ;
			fi 
			
	fi
	
}



### Yet Another Debian package Mangler and backup-management. 
### 
### It basically move actual Debian package from archive /var/cache/apt/archives
### some-where else like /media/COMST500GB/Linux-Debian/archives/Mint-14_x86-64...
### or some NFS mounted point or any mounted partition dedicated to save or backup... 
### - It create an index of the day, inside the Destination.
###  - The index file is in a new directory of the destination, calling it Destination/index
###  - The index file-name is named on the today date or on the day executed by the manager. 
###  - The index used to drop Package into destination are accounted and the index hold 
###  - the beginnign of the transfert. 
###  - Index day used can be changed thru PkgRepoMgmtReposIndexDay, but the time of the transaction
###    remain unchanged... look weird, but may have some goal .... 
###   - Variable PkgRepoMgmtReposIndex change the Index destination. 
### 
### The Action. 
### It's A loop inside the archives, a move to the destination and a link is done between them 
### - to remain somewhat active, or become inacessible if the mount is down... not bad for nfs
### mounting detection or lazy mount with economic transfert mode while having no reason
### to leave it mounted until you need to get some update or removing stuff. 
### If the management from APT, dpkg, gdebi remove the package, it give silent error to 
### remove something not being a file but link, but are not following the source... 
### Being serious with this action, PkgRepoMgmtReposBkpAct can change the Action. 
### 
### basically work like this :
### [ cmd1 __VIRG__ cmd2 ... ] 
### 
### cmd1 should include at least 
### __SRC__ tag , it transform it into proper destication  called __DEST__ 
### __FILE__ is critical and mandatory, it loop the command and turn __FILE__ into every item to be backuped 
### 
### - __VIRG__ tag is an hack, It's required when more then one command is called, it change in into ';' . 
### ex : PkgRepoMgmtReposBkpAct="scp  __SRC__/__FILE__ root@domainname:/__DEST__ __VIRG__ rm -f __SRC__/__FILE__" PackageRepositoryMgmt
### - transfert by scp a file from Debian packages from /var/cache/apt/archives and remove it. 
### 
### 
### ... So basically, this guys had a spade in hand and Spell it: 'I.B.M.' ;) from 1901, I should live long 
### enought to work there or know what they are doing... 
### 


unset PackageRepositoryMgmt ; 

function PackageRepositoryMgmt()
{
	
	local __call_locality=( PkgRepoMgmt PackageRepositoryMgmt ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
	function GetUUID()
	{
		local __call_locality=( GetUUID ) ;
		local StrDefaultSwitches=${GetUUIDSwitches:=-t}
		local ArrayArg=( $* ) ;  
		uuidgen ${StrDefaultSwitches}	; 
	} 
	local StrUUID=$( GetUUID ) ; 
	local StrPathArchives=${PkgRepoMgmtPathArchives:=/var/cache/apt/archives} ; 
	local StrFindStringFormat=${PkgRepoMgmtStrFmt:="%f "} ;
	local StrPackageType=${PkgRepoMgmtFileFormat:=deb} ;
	local StrPathRepository=${PkgRepoMgmtRepository:=/media/COMST500GB/Linux-Debian/archives/Mint-14_x86-64} ;
	local StrPathReposIndex=${PkgRepoMgmtReposIndex:=/media/COMST500GB/Linux-Debian/archives/Mint-14_x86-64/index} ;
	local StrIndexLatest=${PkgRepoMgmtLatestIndexName:=latest};
	local StrAddPackageListing=${PkgRepoMgmtAddPkgLst:=False} ; 
	local StrPkgLstExt=${PkgRepoMgmtPkgExt:=base64.bz2}
	local StrAppsLinkerName=${PkgRepoMgmtLinkerName:=/bin/ln} ; 
	local StrAppsLinkerOptionRecv=${PkgRepoMgmtLinkerOption:=-s} ; 
	local StrAppsLinkerOption=( ${StrAppsLinkerOptionRecv//,/ }  );
	local StrDumpingFormat=${PkgRepoMgmtReposIndexFmt:=__ID__:__FILE__};
	local StrDefaultActionIndex=${PkgRepoMgmtReposIndexAction:="mkdir -p __PATH__"} ;
	local StrTestDriveDebug=${PkgRepoMgmtReposDriveDebug:=False} ;
	local StrIndexTest=${PkgRepoMgmtReposIndexTest:=! -d} ;
	local ScriptAwkFilter=${PkgRepoMgmtReposAwkLst:=/etc/init.d/Fnct.d/awk-script/dpkg-package-id-listing.awk} ;
	### Explained in GetOtherDate, GetOtherDateReference can be negative and report yesterday date too. and not null will
  ### give n-day after today... 	
	local IntDefaultDayIndexName=${PkgRepoMgmtReposIndexDay:=0} ;
	local StrBackupAction=${PkgRepoMgmtReposBkpAct:=mv __SRC__/__FILE__ __DEST__ __VIRG__ ln -s __DEST__/__FILE__ __SRC__/__FILE__} ;
	local StrTransactionStart=$( GetOtherDateFormat="%Y%m%d\ %H:%M:%S" GetOtherDate ) ; 
	local StrTodatDateTransfert=$( GetOtherDateReference=${IntDefaultDayIndexName} GetOtherDate ) ; 
	local StrIndexFile=${StrPathReposIndex}/${StrTodatDateTransfert};
	
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally and output the package list.\n\t--get\t\tReturn value of Internal Variable.\n\t--checkdrive\tPerform a Drive/Path check to see if access point is valid.\n\t--add-snapshoot\tAdd DPKG Listing inside Current Index File.\n\t\t\tOnly Store an ID in the index-file and the content into UUID-name from index path.\n\n" ;
	
	function GetIdDpkgListing()
	{
		local __call_locality=( GetIdDpkgListing ) ;
		local ArrayArg=( $* ) ;		
		local StrID=$( GetUUID ) ; 
		echo -ne "ADD SNAPSHOT\nDATE:${StrTransactionStart}:ID:${StrID}\n" >> ${StrIndexFile} ; 
		echo -ne "${StrID}"  > /dev/stderr ; 
	}
	
	function GetDpkgInstalled()
	{
		local __call_locality=( GetDpkgInstalled ) ;
		local StrAwkScript=${GetDpkgInstalledAwkScript:=/etc/init.d/Fnct.d/awk-script/dpkg-package-id-listing.awk}
		local ArrayArg=( $* ) ; 
		dpkg --get-selections | awk -f ${StrAwkScript}
	}
	
	function StreamCprEnvlTxt()
	{
		local __call_locality=( StreamCprEnvlTxt ) ;
		local StrFile=${StreamCprEnvlTxtFile:=none.${StrPkgLstExt}}
		local ArrayArg=( $* ) ; 
		bzip2 -9z | base64 --wrap=0 > ${StrFile} ; 
	}
	
	function GetDpkgListing()
	{
		local __call_locality=( GetPackageListing ) ;
		local ArrayArg=( $* ) ; 
		local StrId=$( StrIndexFile=${StrIndexFile} StrTransactionStart=${StrTransactionStart} GetIdDpkgListing ) 
		GetDpkgInstalledAwkScript=${ScriptAwkFilter} GetDpkgInstalled | StrPkgLstExt=${StrPkgLstExt} StreamCprEnvlTxtFile=${StrPathReposIndex}/${StrId}.${StrPkgLstExt} StreamCprEnvlTxt  ; 
		local StrSHASnap=$( sha1sum --binary ${StrPathReposIndex}/${StrId}.${StrPkgLstExt} | cut -d ' ' -f 1 ) 
		echo -ne "ShaSUM of snapshot, ID:${StrId} SHA:${StrSHASnap}\n" > /dev/stderr ; 
		echo -ne "SNAPSHOT:SHA1SUM:${StrSHASnap}\nSNAPSHOT END\n" >> ${StrIndexFile} ; 
	}
	
	function TestPathIndex()
	{
		local __call_locality=( TestPathIndex ) ;
		local ArrayArg=( $* ) ; 
		local StrPathTest=${TestPathIndexName:=/media/COMST500GB/Linux-Debian/archives/Mint-14_x86-64/index} ; 
		local StrTestType="${TestPathIndexTest:=! -d}" ;
		local StrTestResultAction="${TestPathIndexResultAction:=mkdir -p __PATH__}" ;
		test ${StrTestType} ${StrPathReposIndex} && ${StrTestResultAction//__PATH__/${StrPathReposIndex}} ;
	}	
	
	function GetPackageList()
	{
		local __call_locality=( GetPackageList ) ;
		local ArrayArg=( $* ) ; 
		local StrPathArchives=${GetPackageListPathArchives:=/var/cache/apt/archives} ; 
		local StrPackageType=${GetPackageListFormat:=deb} ;
		local StrDisplayOutput="${GetPackageListStringFormat:='%f '}" ;
		local ArrayFileList=( $( find ${StrPathArchives} -maxdepth 1 -type f -iname "*.${StrPackageType}" -printf "${StrDisplayOutput}" ) ) ; 
		local IntLenFileList=${#ArrayFileList[@]} ;
		if [ ${IntLenFileList:=0} -gt 0 ] ; then 
			echo "${ArrayFileList[@]}" ; 
			return 0 ; 
		else
			echo "None" ;
			return 1 ; 
		fi
	}
	
	function TestDriveMount()
	{
		local __call_locality=( TestDriveMount ) ; 
		local ArrayArg=( $* ) ; 
		local IsMountDrive="True";
		local StrScopeType="${TestDriveMountScope:=local -a}";
		local StrDriveList="${TestDriveMountList}";
		local MountDriveCheck=( ${StrDriveList//,/ } ) ;
		local IsDisplayDebug=${TestDriveMountDebug:=False} ;
		local Arg0="${ArrayArg[0]}" ;
		local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
		if [ "${Arg0:=--startservices}" == "--help"	] ; then 
				GetVarReference ${__call_locality[0]} ; 
				echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
		elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
			eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
			echo -ne """${ArgGet}\n""" ;
		else
			for (( intx=0 ; intx <= ${#MountDriveCheck[@]}-1 ; intx++ )) ; do
				if [ "${IsDisplayDebug:=False}" == "True" ] ; then 
					echo -ne "Checking Path: ${MountDriveCheck[${intx}]}\n" > /dev/stderr ; 
				fi
				test ! -d "${MountDriveCheck[${intx}]}" && IsMountDrive="False" ;
			done 
			if [ "${IsMountDrive:=True}" == "False" ] ; then 
				echo -ne "\nCheck Variable PkgRepoMgmtRepository,PkgRepoMgmtPathArchives, some Path are inaccessible or not mounted\n" > /dev/stderr ; 
			fi 
			echo -ne "${StrScopeType} IsMountDrive=${IsMountDrive}" ; 
		fi 
	}

	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--checkdrive"	] ; then 
		$( TestDriveMountDebug=${StrTestDriveDebug} TestDriveMountList=${StrPathRepository},${StrPathArchives} TestDriveMount ) ; 
		echo -ne "Status of IsMountDrive: ${IsMountDrive}\n" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--add-snapshoot" ] ; then 
		$( TestDriveMountDebug=${StrTestDriveDebug} TestDriveMountList=${StrPathRepository},${StrPathArchives} TestDriveMount ) ; 
		StrPathReposIndex=${StrPathReposIndex}     \
		StrIndexFile=${StrIndexFile}               \
		StrTransactionStart=${StrTransactionStart} \
		StrPkgLstExt=${StrPkgLstExt}               \
		GetDpkgInstalledAwkScript=${ScriptAwkFilter} GetDpkgListing ; 
	else 
			$( TestDriveMountDebug=${StrTestDriveDebug} TestDriveMountList=${StrPathRepository},${StrPathArchives} TestDriveMount ) ; 
			if [ "${IsMountDrive:=True}" == "True" ] ; then 
				TestPathIndexName=${StrPathReposIndex}   \
				TestPathIndexTest=${StrIndexTest}        \
				TestPathIndexResultAction=${StrDefaultActionIndex} TestPathIndex ;
				
				local ArrayFileList=( $( GetPackageListPathArchives=${StrPathArchives} GetPackageListFormat=${StrPackageType} GetPackageListStringFormat="${StrFindStringFormat}" GetPackageList ) )
				local ShaSum=$( echo ${ArrayFileList[@]} | sha1sum | cut -d ' ' -f 1 )
				if [ ${StrAddPackageListing:=False} == "True" ] ; then 
					 StrPathReposIndex=${StrPathReposIndex}     \
					 StrIndexFile=${StrIndexFile}               \
					 StrTransactionStart=${StrTransactionStart} \
					 StrPkgLstExt=${StrPkgLstExt}               \
					 GetDpkgInstalledAwkScript=${ScriptAwkFilter} GetDpkgListing ; 
				fi
				local IntIsFile=0 ;
				test -e ${StrIndexFile} && IntIsFile=1 ; 
				if [ ${IntIsFile:=0} -eq 1 ] ; then 
					echo -ne "NEW TRANSACTION:${StrTransactionStart}\n" >> ${StrIndexFile} ;  
				else
				 echo -ne "NEW FILE\n" > ${StrIndexFile} ; 
				 echo -ne "NEW TRANSACTION:${StrTransactionStart}\n" > ${StrIndexFile} ;  
				fi 
				echo -ne "COMMIT TRANSACTION:ID:${StrUUID}:NB_FILE:${#ArrayFileList[@]}:SHA1SUM:${ShaSum}:${StrTransactionStart}\n" >> ${StrIndexFile} ; 
				
				local Result=$? ; 
				if [ ${Result:=1} -eq 0 ] ; then 
					for (( intx=0 ; intx <= ${#ArrayFileList[@]}-1 ; intx++ )) ; do 
						local strfile="${ArrayFileList[${intx}]}" ;
						echo -ne "File: ${strfile}\n" > /dev/stderr ; 
						local StrLinkAction=${StrBackupAction};
						StrLinkAction=${StrLinkAction//__FILE__/${strfile}} ; 
						StrLinkAction=${StrLinkAction//__SRC__/${StrPathArchives}} ; 
						StrLinkAction=${StrLinkAction//__DEST__/${StrPathRepository}} ;
						StrLinkAction=${StrLinkAction//__VIRG__/;} ; 
						local StrDump=${StrDumpingFormat}; 
						StrDump=${StrDump//__ID__/${StrUUID}};
						StrDump=${StrDump//__FILE__/${strfile}};
						echo -ne "${StrDump}\n" >> ${StrIndexFile} ; 
						echo -ne "Action:[ ${StrLinkAction} ]\n" > /dev/stderr ; 
						eval "${StrLinkAction}" ; 
					
					done 
					### Adding Latest index being stored.
					eval """${StrAppsLinkerName} ${StrAppsLinkerOption[@]} ${StrIndexFile} ${StrPathReposIndex}/${StrIndexLatest} """; 
				else
					echo -ne "ArrayFileList return Empty List\n" > /dev/stderr . 
  			fi
			else
				echo -ne "Exit on Path acces Problems\nStatus of IsMountDrive: ${IsMountDrive}\n" > /dev/stderr ;
				return 1 ;
			fi
	fi 
}

### Here the restoring for PackageRepositoryMgmt
### Likely to use PRRIsLink=1 PRRIsResolve=0 PackageRepositoryRest
### PRRIsResolve variable is reserver to search the package following specific time
### inside an index, which is merely not working to restore whole packaging...
### lacking ID on every Package name index, which is not hard to modify.
function PackageRepositoryRest()
{
	local __call_locality=( PRR )	 ; 
	local ArrayArg=( $* ) ;
	local IsLink=${PRRIsLink:=0} ; 
	local IsResolve=${PRRIsResolve:=1} ; 
	local IsDebug=${PRRIsDebug:=0} ; 
	local IsDebugResult=${PRRIsDebugResult:=0} ;
	local IsRemoveResolve=${PRRRemoveOldResolved:=1} ;
	local thisdate=${PRRGetDate:=20121108} ;
	local drv=${PRRBackupPath:=/media/COMST500GB/Linux-Debian/archives/Mint-14_x86-64} ; 
	local index=${PRRBackupIndex:=__BackupPath__/index} ;
	local resolve=${PRRResolveFile:=__IndexFile__/resolve-__DATE__} ;
	local IntSleepWarning=${PRRSleepWarning:=10} ; 	
	
	local src=${PRRRepositoryPath:=/var/cache/apt/archives} ; 
	local _TA=( ) ;
	local Arg0=${ArrayArg[0]}	; 
	
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
	if [ "${Arg0:=--startservices}" == "--help" ] ; then 
		GetVarReference PackageRepositoryRest ; 
		echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
		index=${index//__BackupPath__/${drv}} ;
		resolve=${resolve//__DATE__/${thisdate}} ;
		resolve=${resolve//__IndexFile__/${index}} ;
		local _index=${index}/${thisdate} ; 
	
		
  if [ ${IsResolve:=0} -eq 1 ] ; then  
			echo -ne "Will resolve package into resolve file store inside index path.\n\tUsefull to get all package-name, package-file and commit level based on PRRGetDate value.\n\tFile resolver:${resolve}\n" > /dev/stderr ; 
		else
			echo -ne	"Will not perform a resolution package into resolve file store inside index path.\n" > /dev/stderr ; 
		fi ### End of test IsResolve-eq-1 
		
  if [ ${IsLink:=0} -eq 1 ] ; then 
			echo -ne "Will link package into Repository destination, based on Variable PRRRepositoryPath,\n\twill link inside path:${src}\n" > /dev/stderr ; 
		else
			echo -ne "Will not performing linking package into Repository destination\n" > /dev/stderr ;		
		fi ### End of test IsLink-eq-1 
		sleep ${IntSleepWarning} ; 

		### erasing old resolved information:
		test ${IsRemoveResolve:=1} == 1 &&	test -e ${resolve} && rm -f ${resolve} ; 

		### List of Deb File
		local _A=( $( find ${drv} -maxdepth 1 -type f -printf "%f " ) ) ;
	
		### Current Line Number and time for all commit from ${thisdate}
		### Format by Index: Line[1-...],Date[YYYYMMDD],Time[HH:MM:SS], 
		local _TI=(  $( cat ${_index} | egrep -n "COMMIT" | sed 's/\ /:/g;s/\\n//g' | cut -d ':' -f 1,4,5,6,7 | sed 's/^\([0-9]*\):\([0-9]*\):/\1,\2,/g' | tr '[:cntrl:]' ' ' ) ) ; 
		local _RA=( ) ; 

		if [ ${IsResolve:=0} -eq 1 ] ; then  
			for (( x=0 ; x<= ${#_A[@]}-1 ; x++ )) ; do 
				local file=${_A[${x}]} ; 
				### Do the resolving .
					local tfile=$( cat ${_index} | egrep -n "${file}" ) ;
					local ifile=( ${tfile//:/ } ) ; 
					ifile=${ifile[0]:=-1} ; 
					### Get The ID from which commit file was part of (... may be none if file was not installed on ${thisday} )
					local IntoldIndex=1 ;		
					local IsIndexed=0 ; 		
					test ${IsDebugResult:=0} == 1 && echo -ne "Resolving File: ${file},\n\tat line ${ifile},from commit " > /dev/stderr ; 
					local PackageName=( ${file//_/ } ) ; 
					for (( y=0 ; y<= ${#_TI[@]}-1 ; y++ )) ; do 
								local _TIA=( ${_TI[${y}]/,/ } ) ; 
								local IntLine=${_TIA[0]} ; 
								if [ ${ifile:=0} -gt 0 ] ; then 
									if [ ${ifile:=0} -gt ${IntoldIndex} ] ; then 
										if [ ${ifile:=0} -lt ${IntLine} ] ; then 
											test ${IsDebugResult:=0} == 1 && echo -ne "${IntLine}\n" > /dev/stderr ; 
											test ${IsDebug:=0} == 1 && echo -ne "File located at index: ${ifile:=0}, from commit: ${IntLine}\n" > /dev/stderr  
											_RA[${#_RA[@]}]="${IntLine},${PackageName[0]},${ifile:=0},${file}" ; 
											IsIndexed=1; 
										else
											IsIndexed=0; 
										fi ### End of test ifile-lt-IntLine
									fi ### End of test ifile-gt-IntoldIndex
								fi ### End of test ifile-gt-0
						IntoldIndex=${IntLine} ; 
					### _TI -> Action Based on Index from commit in file-index from ${thisdate}
					done 
					if [ ${IsIndexed:=0} -eq 0 ] ; then 
						test ${IsDebugResult:=0} == 1 && echo -ne "None\n" > /dev/stderr ;  
						_RA[${#_RA[@]}]="0,${PackageName[0]},${ifile:=0},${file}"
					fi ### End of test IsIndexed-eq-0 
				### _A -> File location and action based on file 
				done 
				echo -ne "Resolved information from index writed in file ${resolve}\n" ;		
				for (( x=0 ; x<= ${#_RA[@]}-1 ; x++ )) ; do 
					echo -ne "${_RA[${x}]//,/ }\n" >> ${resolve} ; 
				### _RA -> Stored informations while looping in _TI and _A to get all resolved file.
				done 
		else
			echo -ne "\n\n\tResolving Procedure was cancelled"
		fi ### End of test IsResolve-eq-1 
		### Do The link.
		if [ ${IsLink:=0} -eq 1 ] ; then 
			for (( x=0 ; x<= ${#_A[@]}-1 ; x++ )) ; do 
				local file=${_A[${x}]} ; 
				test ! -L ${src}/${file} && ln -s ${drv}/${file} ${src}/${file} ; 
			### _A -> File location and action based on file 
			done 
		fi ### End of test IsLink-eq-1 
		
	fi ### End of test Arg0==--startservices
}


### Function : GetMplayerStream()
### 
### - Filter out selected stream from Firefox browser on Ubuntu/Mint and kill active stream to get only the 
### http - stream url and load itself with mplayer... Assuming the Browser openning the stream with mplayer...
### 
### Initial idea : ps -eo pid,command | egrep -i "mplayer" | egrep "http:\/\/" | awk 'BEGIN{stream="";}{printf("%s %s\n",$1,$(NF)) ; system(sprintf("kill -9 %s",$1)); stream=$(NF); }END{ system(sprintf("mplayer -ao alsa -cache 3072 %s",stream)) }'
### ... but how ingeneer see a tire over a Tree for child use... 
### 
### 
function GetMplayerStream()
{
	local ArrayArg=( $* ) ; 
	local __call_locality=( GetMplayerStream ) ;
	local StrAwkPath=${GetMplayerStreamAwkPath:=/etc/init.d/Fnct.d/awk-script/} ;
	local StrAwkScriptName=${GetMplayerStreamScriptName:=MplayerStreamTransfert.awk}
	local StrAwkApps=${GetMplayerStreamAwkApps:=/usr/bin/awk} ;
	local StrGrepApps=${GetMplayerStreamGrepApps:=/bin/egrep};
	local StrGrepOpt=${GetMplayerStreamGrepOpt:=-i};
	local StrPsOpt=${GetMplayerStreamPsOpt:=-eo pid,command};

	local StrPsApps=${GetMplayerStreamPsApps:=/bin/ps};
	local StrUrlGrep=${GetMplayerStreamUrlGrep:="http:\/\/"};
	local StrPlayerName=${GetMplayerStream:=mplayer};
	local Arg0=${ArrayArg[0]} ;
	
	function GetStreamFromPs()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( GetStreamFromPs ) ;
		local StrAppsName=${GetStreamFromPsApps:=/bin/ps} ;
		local StrAppsOpt=${GetStreamFromPsOpt:=-eo pid,command} ;
		local StrFilterAppsName=${GetStreamFromPsFName:=egrep} ;
		local StrFilterAppsOpt=${GetStreamFromPsFNOpt:=-i} ;
		local StrUrlFilter=${GetStreamFromPsUrlFilter:="http:\/\/"} ;
		local StrPlayerFilter=${GetStreamFromPsUrlPlayerName:=mplayer} ;

		${StrAppsName} ${StrAppsOpt} | ${StrFilterAppsName} ${StrFilterAppsOpt} "${StrPlayerFilter}" | ${StrFilterAppsName} ${StrUrlFilter} ; 
	}
	
	function AwkScript()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( AwkScript ) ;
		local StrAwkPath=${AwkScriptAwkPath} ;
		local StrAwkScriptName=${AwkScriptScriptName} ;
		local StrAwkApps=${AwkScriptApps} ;
		${StrAwkApps} -f ${StrAwkPath}/${StrAwkScriptName}
	}

	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
	local cmdline=( ) ;
	local cmdline[0]="GetStreamFromPsUrlPlayerName=\"${StrPlayerName}\" GetStreamFromPsUrlFilter=\"${StrUrlGrep}\" GetStreamFromPsFName=\"${StrGrepApps}\" GetStreamFromPsFNOpt=\"${StrGrepOpt}\" GetStreamFromPsApps=\"${StrPsApps}\" GetStreamFromPsOpt=\"${StrPsOpt}\" GetStreamFromPs";
	local cmdline[1]="AwkScriptApps=\"${StrAwkApps}\" AwkScriptAwkPath=\"${StrAwkPath}\" AwkScriptScriptName=\"${StrAwkScriptName}\" AwkScript" ; 
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[0]} ;
			#echo -ne "Following switch are available:\n\n\t--startservices\tStart the application normally and output the package list\n\t--debug\tExpose result to be executed.\n\n" > /dev/stderr ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "debug"	] ; then 
		echo -ne "CmdLine[0]:${cmdline[0]} \nCmdLine[1]:${cmdline[1]}\n" > /dev/stderr ;
	else
		echo -ne "CmdLine[0]:${cmdline[0]} \nCmdLine[1]:${cmdline[1]}\n" > /dev/stderr ;		
	fi	
}
 
### Late-Homework for old duty... 
### Preceding some specific moment in a traveller when he have to know when the plane is going to leave , 
### I was messing around faulty compilation and try to find 
### way to randomize startup a bit and lib loading to see if it's anomalies in process or simply stack 
### hacking... See Hacking The art of exploitation from No Starch press...  
### Initial Setup on how collecting information and how generate fast random number was heavy and may
### collide whith the function FaultyProcess, rendering too much work from High-heavy precesing awk-sed-grep
### line at every ';' was also slowing this baby pentium-mmx from college Rosemont also... 
unset BuildOnFaultCompiler
function BuildOnFaultCompiler()
{
	local ArrayArg=( $* )
	local __call_locality=( BOFC ) ; 
	local StrAppsLib=${BOFCLib:=/sbin/ldconfig} ;
	local StrAppsLibOpt=${BOFCLibOpt:=-f,/etc/ld.so.conf} ;
	local StrAppsAppsFault=${BOFCAppsFault:=make} ;
	local StrAppsAppsFaultOpt=${BOFCAppsFaultOpt:=''} ;
	local IntRandomSize=${BOFCRandomSeedLevel:=20} ;
	local Arg0=${ArrayArg[0]:=--startservices}
	
	function InitLib()
	{
		local ArrayArg=( $* )
		local __call_locality=( InitLib ) ; 
		local StrApps=${InitLibInitApps:=/sbin/ldconfig} ;
		local StrAppsOpt={InitLibInitAppsOpt:=-f,/etc/ld.so.conf} ;
		local ArrayAppsOpt=${StrAppsOpt//,/ } ; 
		### ldconfig -f /etc/ld.so.conf ; 
		eval "${StrApps} ${ArrayAppsOpt[@]}" ; 
	}
	function FaultyProcess()
	{
		local ArrayArg=( $* )
		local __call_locality=( FaultyProcess ) ; 
		local StrApps=${FaultyProcessInitApps:=make} ;
		local StrAppsOpt=${FaultyProcessAppsOpt} ;
		local ArrayAppsOpt=${FaultyProcessAppsOpt[@]//,/ } ;
		eval "${StrApps} ${ArrayAppsOpt[@]}" > /dev/stderr  ; 
		return $? ; 
	}

	function Start()
	{
		local res=1 ; 
		local IntRandSize=${IntRandomSize} ; 
		local StrStarHeaderLine="********************************************************************************" ;
		local StrHeader="__StrStarHeaderLine__\n\n\tBuild Failed , sleeping __IntRand__\n\n__StrStarHeaderLine__\n" ;
		echo -ne "StartWhile\n" > /dev/stderr ;
		while [ ${res} -ne 0 ] ; do 
			local ArrayRandom=(  ) ; 
			local EndRand=$(( ( ${RANDOM} % ${IntRandSize} ) )) ; 
			local IndexRand=$(( ${RANDOM} % ${IntRandSize} )) ; 
			echo -ne "IntRandSize: ${IntRandSize}\nEndRand:${EndRand}\n" > /dev/stderr ; 
			sleep 5 ; 
			echo -ne "StartFor\n" > /dev/stderr ;
			for (( intx=0 ; intx <= ${EndRand} ; intx++ )) ; do 
				echo -ne "." > /dev/stderr ;
				local RandBaseMul=$(( ( ${IntRandSize} *  ( ${RANDOM} % 10 ) ) + 1 )) ; 
				local IntRandNum=$(( ${RANDOM} % ${RandBaseMul} )) ;
				ArrayRandom[${intx}]=${IntRandNum} ; 
			done ; 
			echo -ne "\n" > /dev/stderr ;
			local IntRand=${ArrayRandom[${IndexRand}]} ; 
			echo -ne "IntRand:${IntRand}\n" > /dev/stderr ; 
			echo -ne "StartInitLib:1\n" > /dev/stderr ;
			InitLibInitApps=${StrAppsLib} InitLibInitAppsOpt=${StrAppsLibOpt} InitLib ; 
			echo -ne "StartFaultyProcess\n" > /dev/stderr ;
			FaultyProcessInitApps=${StrAppsAppsFault} FaultyProcessAppsOpt=${StrAppsAppsFaultOpt} FaultyProcess
			res=$?  ;
			echo -ne "res return [${res}]\n" > /dev/stderr ; 
			echo -ne "StartIf\n" > /dev/stderr ;
			if [ ${res:=0} -ne 0 ] ; then 
				local StrDisplayHeader=${StrHeader//__StrStarHeaderLine__/${StrStarHeaderLine}} ;
				StrDisplayHeader=${StrHeader//__IntRand__/${IntRand}} ;
				echo -ne ${StrDisplayHeader} > /dev/stderr ; 
				echo -ne "StartInitSleepRandom\n" > /dev/stderr ;
				sleep ${IntRand} ; 
				echo -ne "StartInitLib:2\n" > /dev/stderr ;
				InitLib ;
			fi ; 
		done 

	}
	
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 

	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference BuildOnFaultCompiler ;
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	else
		StrAppsLib=${StrAppsLib} StrAppsLibOpt=${StrAppsLibOpt} StrAppsLibOpt=${StrAppsLibOpt} StrAppsAppsFault=${StrAppsAppsFault} StrAppsAppsFaultOpt=${StrAppsAppsFaultOpt} IntRandomSize=${IntRandomSize} Start ; 
	fi 
} 



function RoundRobinSwapRealloc()
{
	local __call__locality=( RRSR ) ;
	local ArrayArg=( $* ) ;
	local Arg0=${ArrayArg[0]} ; 
	
	local Str=${RRSR:=}
	
	function GetSwapList()
	{
		local __call__locality=( GSL ) ;
		local ArrayArg=( $* ) ;
		ArrayListSwap=( $( swapon -s | cut -d ' ' -f 1  | grep -v "Filename" | tr '[:cntrl:]' ' ' ) ) ; 
		
	}
	function Start()
	{
		local __call__locality=( Start ) ;
		local ArrayArg=( $* ) ;
		
	}
	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
	
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference RoundRobinSwapRealloc ;
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--swaptorealloc"	] ; then 
		GetSwapList ;
	else
		 Start ; 
	fi 
}

if [ ${VarFnctLib:=False} == "True" ] ; then

    Debian_DPKG_update_InstallList()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=Debian_DPKG_update_InstallList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      declare -a ArrayDPKGInstalled=( $( ${DebianProg:=dpkg} ${DebianProgQuery:=--get-selections} | awk 'BEGIN{}{printf("%s ",$1)}END{}' ) ) ; 
    }

    Debian_DPKG_update_ArchivesList()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=Debian_DPKG_update_ArchivesList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      declare -a ArrayArchiveDPKG=( $( find ${DefaultRootPath:=/var/cache/apt/archives/} -printf "%p " ) ) ; 
    }

    DebianDPKGProvideSubFunctionMember()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=DebianDPKGProvideSubFunctionMember __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __search_item()
      {
        #eval $( __InitFunc ) ;
        eval $( __call_localityLocalName=__search_item __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        if [ ${ArrayArg[1]} == ${ItemQuery:=update} ] ; then 
          return 0 ;
        fi
        return 1 ;
      }
      local Template="__CREATOR___PACKAGETYPE_____PACKAGEACTION___" ; 
      local StrCreator=${Creator:=${ArrayCreator[0]}} ;
      local StrPackageType=${PackageType:=${ArrayPackageType[0]}} ;
      local StrPackageAction=${PackageAction:=update} ;
      eval $( __in_for ArrayPackageAction __search_item ItemQuery=${StrPackageAction} ) ; 
      local ErrorStatement=$? ; 
      if [ ${ErrorStatement:=1} -eq 0 ] ; then 
        echo "__TODO__" ;  
      fi
    }

    MetaUpdateList()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=MetaUpdateList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __FuncUpdate()
      {
        #eval $( __InitFunc ) ;
        eval $( __call_localityLocalName=__FuncUpdate __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        local Template="__NODE____SECTION__List" ;
        Template=${Template/__SECTION__/${ArrayArg[0]}}
      } 
      eval $( __in_for ArrayMetaList __FuncUpdate ) ; 
    }

    function __get_col()    
    { 
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=__get_col __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      awk -vCol=${ArrayArg[0]} 'BEGIN{}{printf("%s ",$(Col));}END{}' ; 
    } ; 

    function UpdateDpkgGetSelection()
    {
      eval $( __call_localityLocalName=UpdateDpkgGetSelection __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      declare -a ArrayPackageCurrent=( $( dpkg --get-selections | __get_col 1 ) ) ; 
    }


    function get_listfile()    
    { 
      #eval $( __InitFunc get_listfile ) ;
      eval $( __call_localityLocalName=get_listfile __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __BaseEncode64()
      {
        #eval $( __InitFunc __BaseEncode64 ) ;
        eval $( __call_localityLocalName=__BaseEncode64 __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        base64 --wrap=0 ; 
      }
      function __IfTestFile()    
      { 
        #eval $( __InitFunc __IfTestFile ) ;
        eval $( __call_localityLocalName=__IfTestFile __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        if [ -f ${ArrayArg[0]} ] ; then 
          local StrStream=$( echo "${ArrayArg[0]}" | __BaseEncode64 ) ; 
          echo -ne "${StrStream} " ;
        fi 
      } ; 
      local ArrayFileList=( $( dpkg-query --listfiles ${ArrayArg[0]} ) ) ; 
      eval $( __in_for ArrayFileList __IfTestFile ) ; 
    } ; 

    function get_search()
    {
      #eval $( __InitFunc get_search ) ;
      eval $( __call_localityLocalName=get_search __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      eval $( __in_for ArrayPackageCurrent get_listfile ) ;
    }

    function get_package_by_file()
    {
      #eval $( __InitFunc get_package_by_file ) ;
      eval $( __call_localityLocalName=get_package_by_file __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function PostFilter()
      {
        #eval $( __InitFunc PostFilter ) ;
        eval $( __call_localityLocalName=PostFilter __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        awk -vGrepReturn=${GrepReturn} -f /etc/init.d/fnct.d/awk-script/DpKgQueryPackage.awk ; 
      }  
      local CmdEval=( ${Program:=apt-file} ${ProgramOption:=search} ${ProgramQuery:=lirc/lirc_client.h} ProgramQueryIs64=${ProgramQueryIs64:=false} "|" ${FilterProgram:=PostFilter} GrepReturn=${GrepReturn:=false} ${FilterProgramQuery:=""} ) ;
      echo "CmdLine:[${CmdEval[@]}]" ;
      #eval "${CmdEval[@]}" ; 
      eval "local IntResult=$( eval ${CmdEval[@]} )" ; 
      #echo "Return : ${IntResult}" ;
    }

    function AwkContentParsing()    
    { 
      #eval $( __InitFunc AwkContentParsing ) ; 
      eval $( __call_localityLocalName=AwkContentParsing __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __TinyDecode64()
      {
        #eval $( __InitFunc __TinyDecode64 ) ; 
        eval $( __call_localityLocalName=__TinyDecode64 __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        local StrBaseDecode=$( echo "${VarDecode64}" | base64 -d --wrap=0 2> /dev/null ) ; 
        local IntErrorReport=$? ;
        if [ ${IntErrorReport:=1} -eq 1 ] ; then 
          echo "${VarDecl:=local} ${VarName:=VarOut}=${VarDecode64}" ; 
        else
          echo "${VarDecl:=local} ${VarName:=VarOut}=${StrBaseDecode}" ; 
        fi 
      }
      eval $( __TinyDecode64 VarDecode64=${RecurrentTemplateSearch} VarName=StrRecurrentTemplateSearch VarDecl=${VarDecl} )  ;
      eval $( __TinyDecode64 VarDecode64=${StrQuerySearch} VarName=StrQuerySearch VarDecl=${VarDecl} )  ;
        
      
      local ProgramParserRecurrentTemplate=${StrReturnBase64DecodeTry} ;
      local CmdEval=( ${Program:=apt-file} ${ProgramOption:=search} ${StrQuerySearch} "|" ${ProgramParser:=awk} -vTemplateContent=${StrRecurrentTemplateSearch} -vVarNameOut=CmdEval -f /etc/init.d/fnct.d/awk-script/DpKgQueryPackage.awk ) ;
      echo "CmdLine:[${CmdEval[@]}]" ; 
    }

    function libsearch_AwkContentParsing()
    {
      #eval $( __InitFunc AwkContentParsing ) ; 
      eval $( __call_localityLocalName=libsearch_AwkContentParsing __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      local StrRecurrentTemplateSearch=$( echo "dpkg --get-selections | egrep -ic %s" | base64 --wrap=0 ) ;
      local StrQuerySearch=$( echo "lirc/lirc_client.h" | base64 --wrap=0 ) ; 
      AwkContentParsing RecurrentTemplateSearch=${StrRecurrentTemplateSearch} QuerySearch=${StrQuerySearch} ; 
      
    }

    __funcZenity_DpkgList() 
    { 
        eval $( __call_localityLocalName=__funcZenity_DpkgList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        
        ### This Cover-up the theory of problematic transfert of commune Variable name in external function
        ### being by definition to be treated ''AS'' the normal corpus of the definition of a script
        ### Where this example show a possibility that it does not... The WeFixIt by
        ### involve declaring this method inside this function by calling a declare-f and 
        ### renaming the function (incase of) and calling it inside the function like a 
        ### sub-function can be called and all variable within an external-function will 
        ### be accessible... 
        ### Noted by: Patrick Riendeau in 2003-2004 @vdl2 inc formelly know as Phéromone inc.
        ### and 2010... 
        
        eval """$( declare -f LinkFuncRetOkA_B  | sed 's/\\n/\\\\n/g;s/LinkFuncRetOkA_B/localLinkFuncRetOkA_B/g' )"""
        
        function DisplayEvalCmd()
        {
          echo -ne "in DisplayEvalCmd:\n\t\tCmdLine:${StrFuncName}:[ ${CmdEval[@]} ]\n" > /dev/stderr  ;  
        }
        
        function ExecEvalCmd()
        {
          echo -ne "in ExecEvalCmd:\n" > /dev/stderr ;  
          eval "${CmdEval[@]}" ;
        }

        function ZenityProgressBar()
        {
          eval $( __call_localityLocalName=ZenityProgressBar __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
          local IntRandomState=$(( ${RANDOM} % 20 )) ;
          local CmdEval=( zenity --progress --percentage=${IntRandomState} --text="Fetching Package List" --auto-kill --pulsate ) ;
          #DisplayEvalCmd ;
          #ExecEvalCmd ;
          LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }
        
        function ZenityListPackage()
        {
          eval $( __call_localityLocalName=ZenityProgressBar __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
          zenity --list --checklist --column "Installed" --column "Package Name" ;
          #DisplayEvalCmd
          #ExecEvalCmd ;
          LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }
        
        function DpkgSortedByInstall()
        {
         eval $( __call_localityLocalName=DpkgSortedByInstall __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
         local CmdEval=( "dpkg" "--get-selections" "|" "sort" "-k2" "-r" ) ;
         #DisplayEvalCmd ;
         #ExecEvalCmd ;
         LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }

        function SedFilterConversionDpkgToZenityList()
        {
          eval $( __call_localityLocalName=DpkgSortedByInstall __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
          #sed -r -f /etc/init.d/fnct.d/sed-script/FilterConversionDpkgToZenityList.sed ;
          local CmdEval=( "sed" "-r" "-f" "/etc/init.d/fnct.d/sed-script/FilterConversionDpkgToZenityList.sed" ) ;
          #DisplayEvalCmd ;
          #ExecEvalCmd ;
          LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }
        local CmdEval=( LFuncAction0=ZenityProgressBar LFuncAction1=DpkgSortedByInstall LinkFuncPipedA_B ) ;
        echo -ne "From Main Func:${StrFuncName}\n\n\tCmdEval:[ ${CmdEval[@]} ]\n" > /dev/stderr ;
        LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;

    }

    function get_list()  
    { 
      #eval $( __InitFunc get_list ) ; 
      eval $( __call_localityLocalName=get_list __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      local ArrayInfo=( $( find /usr/share/ -maxdepth 1 -type d -iname "man*" | tr '[:cntrl:]' ' ' ) ) ; 
      echo "${VarDecl:=local} ${ArrayName:=ArrayList}=( ${ArrayInfo[@]})" ; 
    } 
      
    function ffind()    
    { 
      #eval $( __InitFunc ffind ) ; 
      eval $( __call_localityLocalName=ffind __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      find ${ArrayArg[0]} -type f -iname "*man*" ; 
    } 

    function __ZenityProgressBar()    
    { 
      #eval $( __InitFunc ) ;  
      eval $( __call_localityLocalName=__ZenityProgressBar __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      zenity --progress --pulsate 
    } 

    function __wrap_bar_find()    
    { 
      #eval $( __InitFunc __wrap_bar_find ) ; 
      eval $( __call_localityLocalName=__wrap_bar_find __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      eval $( get_list ArrayName=ArrayOut VarDecl=local ) ;
      eval $( __in_for ArrayOut ffind ) | __ZenityProgressBar  ;
    }


    function __BuildDpkgShowFormat ()    
    { 
     #eval $( __InitFunc __BuildDpkgShowFormat ) ; 
     eval $( __call_localityLocalName=__BuildDpkgShowFormat __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
     local DefaultTagValue="__TAG__" ;
     if [ ${StructDpkgShowFormat:=__TAG__} == "__TAG__" ] ; then 
      declare -a StructDpkgShowFormat="${DefaultTagValue}" ;
     fi 
     StructDpkgShowFormat=( $( echo "${StructDpkgShowFormat}" | sed 's/'${DefaultTagValue}'/'${ArrayDPKG_QueryHeader[${ArrayArg[0]}]}${DefaultTagValue}'/g' ) ) 
    } 

    function __BuildDpkgShowFormatXml()
    {
      eval $( __InitFunc __BuildDpkgShowFormat ) ; 
      function __functor_show_header()
      {
        #eval $( __InitFunc __BuildDpkgShowFormat ) ; 
        eval $( __call_localityLocalName=__BuildDpkgShowFormatXml __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        echo -ne "\nStyle=${Style}\n" ;     
        echo -ne "${ArrayArg[2]}" ; 
        echo -ne "\nDstyle=${Dstyle}\n" ;
      }
      eval $( __in_for ${ArrayNameDPKGQuery=ArrayDPKG_QueryHeader} __functor_show_header CCode64=$( ) ) ;
    }

    compare_package()
    {
      local ArrayArg=( $* ) ; 
      function get_name()    
      { 
        eval $( __call_localityLocalName=compare_package __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        local str="${ArrayArg[0]}" ; 
        local ArrayPackage=( ${str/_/ } ) ; 
        echo -ne "${ArrayPackage[0]} " ;  
      } 
      
      function update_package_list()
      {
        eval $( __call_localityLocalName=update_package_list __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        ${DebianProg:=dpkg} ${DebianProgQuery:=--get-selections} | awk 'BEGIN{}{printf("%s ",$1)}END{}' ; 
      }
      
      function get_specific_search()
      {
        eval $( __call_localityLocalName=get_specific_search __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        apt-file search wxPython | awk 'BEGIN{}{intlength=split($1,Array,/:/); printf("%s\n",Array[1])}END{}' | sort -u | tr '[:cntrl:]' ' '  
      }
      
      function get_specific_python()
      {
        eval $( __call_localityLocalName=get_specific_python __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        find /var/cache/apt/archives/ -iname "*.deb" -printf "%f "
      }

      function __compare_package()    
      { 
        #local ArrayArg=( $* ) ; 
        eval $( __call_localityLocalName= __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        echo "Search for Package ${ArrayArg[0]} in Installed Package( ${#ArrayDPKGInstalled[@]} ) " ;      
        function search_package_name()    
        { 
          local ArrayArg=( $* ) ; 
          if [ "${ArrayArg[0]}" == "${ArrayArg[1]}" ] ; then 
            echo -ne "\tInstalled Package is in the list [ ${ArrayArg[0]} ]\n" ; 
            return 0 ; 
          fi
            ArrayDPKGUnInstalled[${#ArrayDPKGUnInstalled[@]}]="${ArrayArg[1]}";
            return 1 ; 
        } 
        eval $( __in_for ArrayDPKGInstalled search_package_name ${ArrayArg[0]} ) ; 
      }
      
      local ArrayPythonPackage=( $( ${ArrayArg[0]} ) ) ;
      echo -ne "\nPackage List Choosed from Function: ${ArrayArg[0]}\n\t[ ${ArrayPythonPackage[@]} ]\n" ;
      local ArrayDpkgPython=( $( eval $( __in_for ArrayPythonPackage get_name ) ) ) ;  
      local ArrayDPKGInstalled=( $( update_package_list ) ) ;    
      local ArrayDPKGUnInstalled ;
      eval $( __in_for ArrayDpkgPython __compare_package ) ;
      echo "declare -a ArrayDPKGUnInstalled=( ${ArrayDPKGUnInstalled[@]} )" ; 
    }

    function KeyAptSearch()    
    { 
     eval $( __call_localityLocalName=KAS __call_locality ); 
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=PackageArrayName FParamVarName=StrPackageArrayName FParamDefaultValue=ArrayPackage __fnctCreateLocalityFuncParam     ) ;
     
     function AptSearch()    
     { 
      eval $( __call_localityLocalName=AS __call_locality ); 
      echo -ne "Key: ${ArrayArg[0]}\n" ; 
      apt-file search ${ArrayArg[0]} ; 
     } ; 
     local CmdEval=( "eval" " $( " "__in_for" ${StrPackageArrayName:=""} "AptSearch" ")" ) ; 
     eval ${CmdEval[@]} ;
    }

    function dpkg-get-selections()
    {
     eval $( __call_localityLocalName=DPKG __call_locality ); 
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=BranchShow FParamVarName=StrBranchShow FParamDefaultValue=Left __fnctCreateLocalityFuncParam     ) ;
     
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName0 FParamVarName=ArrayCmdName[0] FParamDefaultValue=dpkg __fnctCreateLocalityFuncParam     ) ;
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName1 FParamVarName=ArrayCmdName[1] FParamDefaultValue="--get-selections" __fnctCreateLocalityFuncParam     ) ;
     
     eval local StrFuncColDisplay=\${${StrBranchShow}ColDisplay} ;
     
     function CommandCall()
     {
      eval $( __call_localityLocalName=CCall __call_locality ); 
      local CmdEval=( ${ArrayCmdName[@]} ) ;
      eval ${CmdEval[@]} ;
     }
     
     function RightColDisplay()
     {
      eval $( __call_localityLocalName=ColDisplay __call_locality ); 
      awk -vColName=${StrBranchShow:=""} -f /etc/init.d/fnct.d/awk-script/dpkg-col-display.awk 
     }
     
     function LeftColDisplay()
     {
      eval $( __call_localityLocalName=ColDisplay __call_locality ); 
      awk -vColName=${StrBranchShow:=""} -f /etc/init.d/fnct.d/awk-script/dpkg-col-display.awk 
     }
     
     local CmdEval=( ${CommandCall:=""} "|" ${StrFuncColDisplay:=""} ) ;
     eval ${CmdEval[@]} ;
    }

    function dpkg-set-selections()
    {
     eval $( __call_localityLocalName=DPKG __call_locality ); 
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=BranchShow FParamVarName=StrBranchShow FParamDefaultValue=Left __fnctCreateLocalityFuncParam     ) ;
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName0 FParamVarName=ArrayCmdName[0] FParamDefaultValue=dpkg __fnctCreateLocalityFuncParam     ) ;
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName1 FParamVarName=ArrayCmdName[1] FParamDefaultValue=--set-selections __fnctCreateLocalityFuncParam     ) ;
     
     function CommandCall()
     {
      eval $( __call_localityLocalName=CCall __call_locality ); 
      local CmdEval=( ${ArrayCmdName[@]} ) ;
      eval ${CmdEval[@]} 
     } 

    }
fi 



