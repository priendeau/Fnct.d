#!/bin/bash

 ### Package : fnct_debian_lib
 
 ###	Specification : 
 ###	- This following Draft-Specification, offer a decent explanation of doing a function with
 ###	appropriate control proned-protocolar development for scalarity-design . 
 ###	
 ### Example of definition of __call_locality:
 ###	function FuncNameThatIsUnderstandable()
	###	{
	###		local __call_locality=( FNTIU FuncNameThatIsUnderstandable ); 
 ###	                           |    |
 ###	                           |    +---> LongName to be used with GetVarReference, see (3)
 ###	                           |
 ###	                           +---> Short Name to be used to name Prefixed Variable, see (2)
 ###	
 ###	
 ###	Basic and Mandatory visibility and variable control 
 ###	
 ###	Since there is possible management with case switch, and index-pushing ArrayArg manage 
 ###	- called value after Function name was called :
 ###	 ex: Var1=value Var2=valueA;ValueB FuncNameThatIsUnderstandable --switches
 ###	----> Uses of --switches is almost important and should be controled from Arg0, see (1)
 ###	
 ###	Note on Function Behavior : There is almost only one switches used from command line telling 
 ###	which part is called , the actual embodinement after note (3) is an example of a called part.
 ###	- This example uses if-elif-else-fi statement, but a loop with pre-defined switches control
 ###	should end after is call. However uses of Prefixed-Var are infinite and might control
 ###	Behavior of a part into sub-derived part, but should stay in scope and definition of switches made. 
 ###	---> Later an round-up will convert all function from fnct_debian_lib into a Python parser that 
 ###	generate the same file here but with possibility to control everything and should generate a
 ###	stable meta-data file where this function should reflect it's present definition here. 
 ###	Note1: After seeing unworkable switches or switches entering in conflicts it's better to 
 ###	define value with possibilities to be useless or not used but preventing future version
 ###	to not work by calling contradictive switches. 
 ###	
 ###	
 ###	
 ###	
 ###	local ArrayArg=( $* ); ---> Really important line, all variable from outside are mangling inside
 ###	this Variable-ArrayArg, we do not uses $* alone since there is a possible alteration.
 ###	In Fact the declaration of ArrayArg should involve a read-only switch in final-draft. 
 ###	
 ###	Final Draft proposition of ArrayArg:
 ###	local -r ArrayArg=( $* ); *** Only if bash version accept it, which start to be effective from 
 ###	bash version 2.99 from FreeBsd transport to linux around 1997. 
 ###	
 ###	
 ###	*(1)
 ###	local Arg0=${ArrayArg[0]} ; ---> Allow uses of switches like --help, --list, --startservices, --get
 ###	---> Default switches and easy to do stuff , --help, --list, --startservices, --get
 ###	
 ###	
 ###	
 ###	*(2)
 ###	local StrSomeMeanFulName=${FNTIUDefinitionName}
 ###	
 ###	
 ###	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n" 
 ###	+---> Should be usefull to see default switches availables. 
 ###	
 ###	- First use in main body of a function 
 ### *(3)
 ###	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
	###  GetVarReference ${__call_locality[1]} ;  
	###	 echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	### elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
	###	 eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
	###	 echo -ne """${ArgGet}\n""" ; 			
	### elif [ "${Arg0:=--startservices}" == "--list" ] ; then } ---> Sequence to extract Prefixed-var and uses 
	###	 eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;                     } of function call to accelerate external variable 
 ###	                                                       } transfert, ex : FuncNameThatIsUnderstandable --get $(  FuncNameThatIsUnderstandable --list | cut -d ' ' -f 1  ) *(4)
 ###	                                                       } will get the First Prefixed-variable value
 ###	 
 ###	 
	### elif    [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
 ###	 +--------------> Main Body <--------------+
 ###	else
 ###	 
 ###	...
 ###	fi 
 ###	
 ###	



 ### ValueParser :
 ### 
 ### Description: 
 ### - Aim to be a Value Parser with specific semantic to automatically create lists
 ### of variable with specific notation. It was designed to Create a Unique Variable,
 ### like StrValueParserInfo and evaluating the Variable with string-like specified with.
 ### 2 level of CSV, between type ( Profixed variable are VPCallLocalityName VPVarArgList VPScopeList VPValueList )
 ### are reserved to specify somes crucial information. 
 ### 
 ### VPCallLocalityName -> Under wichh prefix named variable are transfered from their calling name.
 ### Ex: Having Function with var __call_locality=( ValueTest ), mean all variable from incoming 
 ### function called with ValueTest(), like :
 ### var1=value1 var2=value2 ValueTest --opt , var1 and var2 must have theirs names starting by
 ### ValueTestvar1=value1 ValueTestvar2=value2 ... 
 ### 
 ### - Value parser will transform variable from ValueTestvar1 into Strvar1, Strvar2 if VPVarArgList
 ### is specified.
 ### 
 ### VPVarArgList -> Specify the list of name and their internal Prefix Type. 
 ### as said in VPCallLocalityName, variable have external and internal names. 
 ### Passing by will not directly convert by create a variable starting with specified prefix.
 ### Having :
 ### VPCallLocalityName=ValueTest VPVarArgList=Str:var1,Str:var2 
 ###  - inside function :ValueTest() will:
 ### get from extern name like ValueTestvar1=value1 ValueTestvar2=value2 , 
 ### will transfert the content into appropriate internal name: Strvar1, Strvar2 . 
 ### - This is purely a simple transfert, convertion, name mangling and linting ( like checking name of 
 ### var if they are not exceeding 32 chars are not yet show. )
 ### 
 ### VPScopeList -> Implicitly tell to ValueParser if the variable are created in local or global, telling
 ### also about lifetime of variable... Important when dealing with function and sub-function and sub-n-function. 
 ### 
 ### 
 ### 
 ###	Full-length example : 
 ### Including 
 ### 
 ### See StartCoproc, variable StrValueParserInfo hold the references and work well with triple-guillements.
 ### 
 ##
 ### eval $( eval """
 ###	VPCallLocalityName=${__call_locality[0]} 
 ###	VPVarArgList=Str:ProcName,
 ###	             Str:InWhile,
 ###	             Str:WhCond,
 ###	             Str:WhRetStat,
 ###	             Str:AppsName,
 ###	             Str:AppsPrVar,
 ###	             Str:AppsOpt
 ###	VPScopeList=ProcName:local,
 ###	             InWhile:local,
 ###	             WhCond:local,
 ###	             WhRetStat:local,
 ###	             AppsName:local,
 ###	             AppsPrVar:local,
 ###	             AppsOpt:local 
 ###	VPValueList=DefaultCoprocName:True:__VAR__ -ne 1:__VAR__=\$( __CMD__ ):GitHubCommit:GitHubCommitFilePath=/etc/init.d/Fnct.d:fnct_debian_lib
 ###	""" ValueParser )  ;
 ### 
 ### -Note Calling ValueParser with same string embedded in the value with following switches --varhelper, will transform this stream of variables
 ### - into helper like GetVarReference . Don't forget, what ValueParser showing or creating is not visible from GetVarReference. GetVarReference
 ### Function extract information from a 'declare -f ' statement and ValueParser is not creating inside the function the value, they are created 
 ### by using this function... Quite simple, almost dynamic, but not fully-dynamic... It's bash afterall... 
 ### Note : Sometimes more easy calling VPCallLocalityName=${__call_locality[0]} instead if re-writing the function names...
 ### Some will love $0 wich is the function name or the script name if this one is inside a shell-file-script. but personally,  I report a lot 
 ### of problems.  
 ### 
 ### 
 ### Comparaison : 
 ### 
 ### Following method are similar .
 ### 
 ### function ValueTest()
 ### {
	###  local ArrayArg=( $* ) ; 
	###  __call__locality=( ValueTest )	
 ###  StrValueTest=${ValueTestValue:=None} ; 
 ###  echo -ne """${StrValueTest}\n""" ; 
 ### } 
 ### 
 ### function ValueTest()
 ### {
	###  local ArrayArg=( $* ) ; 
	###  __call__locality=( ValueTest )	
 ###  local StrValueParserInfo="VPCallLocalityName=${__call_locality[0]} VPVarArgList=Str:Value VPScopeList=Value:local VPValueList=None" ; 
 ###  eval $( eval "${StrValueParserInfo} ValueParser " ) ;
 ###  echo -ne """${StrValueTest}\n""" ; 
 ### } 
 ###
 ### - It's eat more line if the number of variables are lower than 3 variables, but both function
 ### work on same way... Calling-function to see the result:
 ### 
 ###  ValueTestValue="This is a test" ValueTest
 ### 
 ### - Exception : Still unable to read new variable definition from command-line and only create 
 ### a Variable transfert blindly. 

 
#unset ValueParser ;
eval $( GFCFuncName=ValueParser GlobalFunctionCleaning ) ;
function ValueParser()
{
  if [ "${versionCA:=0.0.0}" == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( VP ValueParser ) ;
   local Arg0="${ArrayArg[0]}";  
   local StrStartMain=${VPFuncStart:=__main_StartServices} ; 
   local StrParentApps=${__call_locality[1]} ; 
  elif [ "${versionCA:=0.0.0}" == "0.0.1" ] ; then 
   eval $( eval CAFunctName=ValueParser CAIsAddParent=False __Call_Argument ) ; 
  elif [ "${versionCA:=0.0.0}" == "0.0.2" ] ; then 
   eval $( eval CAFunctName=ValueParser CAIsAddParent=False CallArgument ) ; 
  fi
  
  local StrVarArgList=${VPVarArgList:=Str:AppsName,Str:AppsOpt} ; 
  local StrValueList=${VPValueList:=echo,__VALUE__} ; 
  local StrLocality=${VPCallLocalityName:=Default} ; 
  local StrScope=${VPScopeList:=AppsName:local,AppsOpt:local} ; 
  local StrDefaultScope=${VPScopeDefault:=local} ;
  local StrValueReturn="" ;
  local StrDebug=${VPDebug:=False}
  local ArrayScopeIndex=( "local" "declare -a" ) ;

  function GetScope()
  {
    local __call_locality=( GS GetScope );
    local ArrayArg=( $* ) ; 
    local Arg0=${ArrayArg[0]} ;
    local StrDebug=${GetScopeDebug:=False}
    eval $( BVTIdType=0           \
            BVTVarName=StrReturn  \
            BVTVarHold="0"        \
            BVTBoolVarName=\${Arg0:=local} \
            BVTBoolCase="global"  \
            BVTBoolAssertion="1"  \
            BoolVarTest ) ;
    echo -ne "${StrReturn}" ; 

  }
  function VarInScopeList()
  {
   local __call_locality=( VISL VarInScopeList );
   local ArrayArg=( $* ) ; 
   local Arg0=${ArrayArg[0]} ;
   local StrDebug=${VISLDebug:=False} ;
   local StrValue=${VISLValue:=AppsName} ;
   local StrIsScoped=False ;
   local StrValueReturn="False" ;
   
   for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
    local ArrayValue=( ${ArrayArg[${intx}]//:/ } ) ;
    local StrSuffix=${ArrayValue[0]} ; 
    if [ "${StrSuffix}" == "${StrValue}" ] ; then 
     local StrScope=$( GetScope ${ArrayValue[1]} ) ; 
     StrIsScoped=True
     StrValueReturn="${StrIsScoped} ${StrScope} ${StrValue}" 
    fi 
   done 
   echo -ne "${StrValueReturn}" ; 
  }
 
 function VarReplace()
 {
  local __call_locality=( VR VarReplace ) ;
  local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]};
  local ArrayScoceA=(  __suffix__:${StrVarSuffix} __value__:${AValue} __prefix__:${StrVarSuffixType} __locality__:${StrLocality} ) ; 
  local StrScoreResultParse ; 
  if [ "${AscopeType}" == "True" ] ; then 
   StrScoreResultParse= ${ArrayScopeIndex[${ArrayScopeTest[1]}]}
  else
   StrScoreResultParse = ${StrDefaultScope}
  fi 
  for (( intx=0 ; intx <= ${#ArrayScoceA[@]}-1 ; intx++ )) ; do 
   local ArrayIScope=( ${ArrayScoceA[${intx}]//:/ } ) 
   StrVarName=${StrVarName//${ArrayIScope[0]}/${ArrayIScope[1]}} ; 
  done 
  StrVarName=${StrVarName//__scope__/${StrScoreResultParse}} ;
  
 }
 
 function VarHelper()
 {
  local __call_locality=( VH VarHelper ) ;
  local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]};
  local ArrayScope=( ${ArrayScope[@]//,/ } ) ; 
  local StrDebug=${MainDebug:=False} ;
  for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
    local VarSeg=( ${ArrayArg[${intx}]//:/ } ) ; 
    local StrVarSuffixType="${VarSeg[0]}" ;
    local StrVarSuffix="${VarSeg[1]}" ;
    local StrVarName="Variable __locality____suffix__,\n\tDefault Value __value__\n\tInternal variable: __prefix____suffix__\n" ;
    
    local ArrayScopeTest=( $( Value=${StrVarSuffix} \
                              VarInScopeList        \
                              ${ArrayScope[@]}    ) ) ; 
    ### __scope__ Tag is eclued, because it's the only one does not respect the
    ### the looping sequence, explicitly needs a of Scope test to dismiss between
    ### local scoping and global scoping. 
    
    StrVarSuffix=${StrVarSuffix}          \
    AValue=${ArrayValue[${intx}]}         \
    StrVarSuffixType=${StrVarSuffixType}  \
    StrLocality=${StrLocality}            \
    AscopeType=${ArrayScopeTest[0]}       \
    VarReplace                            ;
    StrValueReturn="${StrValueReturn} ${StrVarName}" ;
   done 
   echo -ne "${StrValueReturn}" ;
   
  }		
  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}";  
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ; 
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ; 
   fi    
   local StrDebug=${MainDebug:=False} ;
   
   local ArrayScope=( ${StrScope//,/ } ) ; 
   local ArrayVar=( ${StrVarArgList//,/ } ) ; 
   local ArrayValue=( ${StrValueList//:/ } ) ;


   for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
    local VarSeg=( ${ArrayArg[${intx}]//:/ } ) ; 
    local StrVarSuffixType="${VarSeg[0]}" ;
    local StrVarSuffix="${VarSeg[1]}" ;
    local StrVarName="__scope__ __prefix____suffix__=\${__locality____suffix__:=\${__locality____suffix__:=__value__}}" ;
    
    local ArrayScopeTest=( $( Value=${StrVarSuffix} \
                              VarInScopeList        \
                              ${ArrayScope[@]}    ) ) ; 
    
    StrVarSuffix=${StrVarSuffix}          \
    AValue=${ArrayValue[${intx}]}         \
    StrVarSuffixType=${StrVarSuffixType}  \
    StrLocality=${StrLocality}            \
    AscopeType=${ArrayScopeTest[0]}       \
    VarReplace                            ;
    StrValueReturn="${StrValueReturn} ${StrVarName} ; " ;
   done 
   echo -ne "${StrValueReturn}" ;
   
  }
  ### ${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n\t--set\t\tStore value in an instance.\n\t\t\t( Overwrite value if exist\n\t\t\tstore value in a instance ).\n\t\t\tAlso wrong-stored value might affect\n\t\t\tthe application.\n\t--query\t\tQuery in instance for a variable.\n${StrCompWordMsgSwitches}\n" ;
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ; 			
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
  elif [ "${Arg0:=--startservices}" == "--varhelper"	] ; then 
   ArrayScope=${ArrayScope[@]// /,}      \
   StrVarSuffix=${StrVarSuffix}          \
   StrValueReturn=${StrValueReturn}      \
   StrDefaultScope=${StrDefaultScope}    \
   StrLocality=${StrLocality}            \
   VarHelper   ${ArrayVar[@]} ;
  elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
   eval $( __GetVarReferenceCompWord ) ;
  elif [ "${Arg0:=--startservices}" == "--startservices"	] ; then 
   ArrayScope=${ArrayScope[@]// /,} \
   StrVarSuffix=${StrVarSuffix} \
   StrValueReturn=${StrValueReturn} \
   StrDefaultScope=${StrDefaultScope} \
   StrLocality=${StrLocality}  Main ${ArrayVar[@]} ; 
  fi 
 
}

eval $( GFCFuncName=CompiledBashCode GlobalFunctionCleaning ) ;

function CompiledBashCode () 
{ 
  local __call_locality=( CBC CompiledBashCode ) ;
  local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]};
  local StrPathRefCompil=${CBCCacheCompile:=/var/cache/Fnct.D/CompiledBashCode};
  local StrPathLinking=${CBCPathLink:=/usr/local/bin} ; 
  local StrShcCompiler=${CBCShellCompiler:=/usr/local/bin/shc} ;
  local StrBashTemplate=${CBCFuncShellTemplate:=/etc/init.d/Fnct.D/examples/template_funct.bash} ;
  if [ ! -d /var/cache/Fnct.D/${__call_locality[1]} ] ; then 
   mkdir /var/cache/Fnct.D/${__call_locality[1]} ; 
  fi   
  StrFuncCode=$( declare -f ${Arg0} );
  StrTemplateFile=$( cat ${StrBashTemplate} );
  StrTemplateFile=${StrTemplateFile//__FUNCT__/${StrFuncCode}};
  StrTemplateFile=${StrTemplateFile//__NAME__/${Arg0}};
  echo "${StrTemplateFile}" > /${Arg0}.bash;
  ${StrShcCompiler} -f ${Arg0}.bash;
  ln -sf ${StrPathRefCompil}/${Arg0}.bash.x ${StrPathLinking}/${Arg0};
  $( eval $( eval GFCFuncName=${Arg0} GlobalFunctionCleaning ) )
}


eval $( GFCFuncName=DefaultTest GlobalFunctionCleaning ) ;
### 
### Function DefaultTest :
### 
### Should found inside this function Sub-Function of common command-Syntax 
### found inside library of Fnct.D where observation from this point make 
### possible to substitute by replacing this sub-funtion in a call from 
### 
### As example: PipedAppsRunInVtv is a replicated line from __main_StartServices
### of GitChckBranchEngine inside _sub_Git, where an application like 
### git branch -l, does displaying in fact a start on selected item , Filter from
### this application transform it into a Zenity List Windows ready for selection.
### 
### Imagining there is an easy way to paste the information in a buffer with a 
### star '*', on selected information, to be a find command, a grep command or
### any debugging tools like objdump parsed in this PipedAppsRunInVtv should 
### make-it ready to configure a zenity instance for user selection. 
### 
### As example: AppsRunInVtv is replicated from many observation of common
### ValueToVariable call and latest example found inside __main_StartServices
### of GitChckBranchEngine inside _sub_Git, where code of Zenity where moved
### of __main_StartServices and does require a direct cut of the command and 
### transfert of sub-set of Var-List transfert exempt it to slow and receive
### useless variable. 
### 
### 
### 
### 


function DefaultTest()
{
  function Verbosis()
  {
   #eval $( CAFunctName=Verbosis CAIsAddParent=False __Call_Argument ) ; 
   local -a ArrayArg=( $* ) ; 
   local -a __call_locality=( Verb Verbosis )
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
        echo "${StrMsg}" ;  
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo "${StrMsg}" >> ${StrDevOut} ;
      else
       echo "${StrMsg}" > ${StrDevOut} ;
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
  
  if [ "${versionCA:=0.0.0}" == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( DT DefaultTest ) ;
   local Arg0="${ArrayArg[0]}";  
   local StrStartMain=${DTFuncStart:=__main_StartServices} ; 
   local StrParentApps=${__call_locality[1]} ; 
  elif [ "${versionCA:=0.0.0}" == "0.0.1" ] ; then 
   eval $( eval CAFunctName=DefaultTest CAIsAddParent=False __Call_Argument ) ; 
  elif [ "${versionCA:=0.0.0}" == "0.0.2" ] ; then 
   eval $( eval \
     CAIsAddDebug=True \
     CAProvideDebug=DisplayDebug,DisplayEntry,DisplayCmd,DisplayParser \
     CAFunctName=DefaultTest \
     CAIsAddParent=False \
     CallArgument ) ; 
  fi
  
  #local BoolDisplayDebug=${DTDisplayDebug:=False} ; 
  #local BoolDisplayEntry=${DTDisplayEntry:=False} ; 
  #local BoolDisplayCmd=${DTDisplayCmd:=False} ; 
  #local BoolDisplayParser=${DTDisplayParserNotice:=False} ; 
  local BoolBodyIsEval=${DTBodyEvalCmd:=False} ; 
  local StrBodyTag=${DTBodyTagTpl:='__BODY__'} ; 
  local StrExecEvalStart=${DTStartExec:='\$('} ;
  local StrExecEvalEnd=${DTEndExec:=')'} ;

  ### Common for all.
  local StrTPRightRegexp=${DTTPRReg:=':__[A-Za-z0-9\_]*__'} ;
  local StrInternalVTVReg=${DTVTVRegistry:=VTVIsArrayStyleInsert=True VTVIsQuotedValue=True VTVIsValueReAssign=True VTVIsValueToConvert=False} ;
  
    
  ### Common or required by PipedAppsRunInVtv
  local StrPipedAppsTpl=${DTPipedAppsTpl:='__APPS__ __OPT__ | __VTV__ __FILTER__ __FILTER__OPT__'} ;
  local StrVTVTpl=${DTVTVTpl:='eval __TES__ eval __REGISTRY__ VTVValueEntry=__LIST_TRANSFERT__ ValueToVariable __TEE__ '}
  local StrPipedTagDef=${DTPipedTagDef:='StrVTVTpl:__VTV__,StrPipedApps:__APPS__,StrPipedAppsOpt:__OPT__,StrPipedFilter:__FILTER__,StrPipedFilterOpt:__FILTER__OPT__,StrInternalVTVReg:__REGISTRY__,StrVarList:__LIST_TRANSFERT__,StrExecEvalStart:__TES__,StrExecEvalEnd:__TEE__'};

  ### Common or required by  AppsRunInVtv  
  local StrArAppsTpl=${DTPipedAppsTpl:='__VTV__ __APPS__'} ;
  local StrArVTVTpl=${DTVTVTpl:='__TES__ __REGISTRY__ VTVValueEntry=__LIST_TRANSFERT__ ValueToVariable __TEE__'}
  local StrArTagDef=${DTAppsTagDef:='StrArVTVTpl:__VTV__,StrArAppsTpl:__APPS__,StrInternalVTVReg:__REGISTRY__,StrVarList:__LIST_TRANSFERT__,StrExecEvalStart:__TES__,StrExecEvalEnd:__TEE__'};

 
  local StrVarList=${DTVarListTransfert:=BoolDisplayParser,BoolDisplayDebug,BoolDisplayEntry,BoolDisplayCmd,StrBodyTag,StrPipedAppsTpl,StrInternalVTVReg,StrVarList,StrExecEvalStart,StrExecEvalEnd,StrVTVTpl,StrPipedTagDef,StrTPRightRegexp} ; 
  
  local -a ArrayMsg ;
  ArrayMsg[0]="Entry in function" ;
  
  ### comment over PipedAppsRunInVtv:
  ### This is the after piped instruction VTV(ValueToVariable) is acting, since 
  ### somes application like git did not require to use Prefixed-variable, our
  ### Filter does and an entry point in configuring a Filter does require a lot
  ### of variable to make it open as tools utility. 
  ### 
  ### 
  ### 
 function PipedAppsRunInVtv()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( PARIV PipedAppsRunInVtv ${StrParentApps} ) ;
   local Arg0="${ArrayArg[0]}";  
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=PipedAppsRunInVtv CAIsAddParent=True __Call_Argument ) ; 
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=PipedAppsRunInVtv CAIsAddParent=True CallArgument ) ; 
  fi  
  
  local StrPipedTpl="${StrPipedAppsTpl}"
  local StrPipedApps=${PARIVApps:=None} ; 
  local StrPipedAppsOpt=${PARIVAppsOpt:=None} ; 
  local StrPipedFilter=${PARIVFilter:=None} ;
  local StrPipedFilterOpt=${PARIVFilterOpt:=None}; 
  local StrEvalVar=${PARIVEvalVar:=StrPipedCmd} ; 
  eval $( \
       TPListTag=${StrPipedTagDef}                   \
       TPVarNameParsed=StrPipedTpl               \
       TPRightStrPtrn=${StrTPRightRegexp}             \
       TPArrayName="Array${__call_locality[0]}Tag"    \
       TPDisplayDebug=${BoolDisplayDebug}        \
       TPDisplayParserNotice=${BoolDisplayTPNotice}   \
       TagParser  ) ;
  
  ### After parsing offering to see the cmdline if 
  ### it does satisfy debugging purposes. 
  ### 
  VerbMsg="${StrPipedTpl}"               \
  VerbState=${BoolDisplayCmd}            \
  VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ; 

       
  ### By Definition This code sample should reflect the same 
  ### Defined Tag template in 
  ### - StrPipedAppsTpl and __VTV__ TAG inside the variable should 
  ### correspond to this following Tag Template in 
  ### - StrVTVTpl
  ###
  ###local StrBranchToZenityField=$( \
  ###    ${StrGitBranchQuery//__APPS__/${StrGitApps}} | eval  \
  ###      $( eval ${StrInternalVTVReg}          \
  ###              VTVValueEntry=${StrVarListFS} \
  ###              ValueToVariable ) FSFilterApps=${StrFilterApps}         \
  ###                                FSDisplayDebug=${BoolDisplayRegExpOp} \
  ###                                FilterSed ) ;
  ###
  ###
  eval "${StrEvalVar}=$( ${StrPipedTpl} )" 
  
 }
 
  ### comment over AppsRunInVtv:
  ### They are very common, simple function call requiring to pass some or 
  ### all their Internal variable. They are code-chunk reduced because they are
  ### too long or sometimes, some-part are totally different when a case/ switch
  ### if does apply a condition where something else require code to work.
  ### This is why they are evaluated to simply execute, but some case require 
  ### to get back information after execution. 
  ### 
 function AppsRunInVtv()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( ARIV AppsRunInVtv ${StrParentApps} ) ;
   local Arg0="${ArrayArg[0]}";  
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=AppsRunInVtv CAIsAddParent=True __Call_Argument ) ; 
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=AppsRunInVtv CAIsAddParent=True CallArgument ) ; 
  fi  
  
  local StrAppsTpl="${StrArAppsTpl}" ;
  local StrEvalVar=${ARIVEvalVar:=StrAppsCmd} ; 
  local StrApps=${ARIVApps:=None} ; 
  local BoolIsEval=${ARIVIsEval:=False} ; 
  
  eval $( \
       TPListTag=${StrArTagDef}                       \
       TPVarNameParsed=StrAppsTpl                     \
       TPRightStrPtrn=${StrTPRightRegexp}             \
       TPArrayName="Array${__call_locality[0]}Tag"    \
       TPDisplayDebug=${BoolDisplayDebug}             \
       TPDisplayParserNotice=${BoolDisplayTPNotice}   \
       TagParser  ) ;

  ### After parsing offering to see the cmdline if 
  ### it does satisfy debugging purposes. 
  ### 
  VerbMsg="${StrAppsTpl}"                \
  VerbState=${BoolDisplayCmd}            \
  VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ; 

  
  ### By Definition This code sample should reflect the same 
  ### Defined Tag template in 
  ### - StrArAppsTpl and __VTV__ TAG inside the variable should 
  ### correspond to this following Tag Template in 
  ### - StrArVTVTpl
  ### 
  ###  $(  ${StrInternalVTVReg}           \
  ###       VTVValueEntry=${StrVarListZWH} \
  ###       ValueToVariable ) ZenityWindowHandler ;
  ### This example work with no eval. This application
  ### will not use eval by default but offer the 
  ### ARIVIsEval=True to let the eval take place . 
  ### 

  ###
  ### Later version will offer a BoolVarTest If-solution . 
  ### 
  if [ "${BoolIsEval:=False}" == "True" ] ; then 
   eval "${StrPipedTpl}" ; 
  else
   ${StrPipedTpl} ;  
  fi 

 }
       
       
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  local StrNameHelper="\tA General-Purpose Test Application\n\n";
  local StrSynopsis="\n\tSet to be a Default test in pass-through function not altering other function \n";
  local StrSummary="\n\tSummary present, but unfinished\n" ; 
  local StrDescription="\n\tMight come with a description in future.\n";
 
 function __main_StartServices()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
   local Arg0="${ArrayArg[0]}";  
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ; 
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ; 
  fi  
  
  ###
  ### By Definition, this __BODY__ found inside DTBodyTagTpl, or internally 
  ### known as StrBodyTag, may have to receive command to let it virtually 
  ### be a command-wrapped . 
  ### 
  
  VerbMsg="${StrBodyTag}"                \
  VerbState=${BoolDisplayCmd}            \
  VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ; 
  ###
  ### Later version will offer a BoolVarTest If-solution . 
  ### 
  if [ "${BoolBodyIsEval:=False}" == "True" ] ; then 
   eval "${StrBodyTag}" ; 
  else
   ${StrBodyTag} ;  
  fi 
 } 
 
 function __main_StopServices()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Main __main_StopServices ${StrParentApps} ) ;
   local Arg0="${ArrayArg[0]}";  
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True __Call_Argument ) ; 
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True CallArgument ) ; 
  fi 

 } 
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GVRIsName=True     \
   GVRIsSynopsis=True \
   GVRIsSummary=True  \
   GVRIsDesc=True     \
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
  eval $( __GetVarReferenceCompWord ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( eval VTVIsArrayStyleInsert=True   \
                VTVValueEntry=${StrVarList} \
                VTVIsValueReAssign=True     \
                VTVIsValueToConvert=False   \
                ValueToVariable ) ${StrStartMain} ;
 
 fi
 
}
 #"\n\tMost simplest way to call-it\n\n\tUsing Firefox as example:\n\n\tGSZLApps=/usr/bin/firefox GkSuZenityLoader\n\n\tHaving Some library update to do before, adding GSZLUpdadeLdconfig=True\n\tto command will enhance this task.\n\n\tGSZLUpdadeLdconfig=True GSZLApps=/usr/bin/firefox GkSuZenityLoader" ;
 



eval $( GFCFuncName=AddPValueStore GlobalFunctionCleaning ) ;
function AddPValueStore()
{
 local ArrayArg=( $* ) ; 
 local __call_locality=( APVS AddPValueStore  ) ; 
 local Arg0=${ArrayArg[0]} ; 
 local StrAction=${APVSAction:=add} ; 
 local StrFunction=${APVSFunction:=__default_test} ; 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
  GetVarReference ${__call_locality[1]} ;
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n" ;
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ; 			
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  echo -ne "__BODY__\n" > /dev/stderr ; 
 fi 
}



### AnsiCodeTest 
#unset AnsiCodeTest
eval $( GFCFuncName=AnsiCodeTest GlobalFunctionCleaning ) ;
. ${FNCTDLIBPATH}/6e063cbc-0ce2-11e3-8879-001b3875b29c 


### ZenityRadioOptionConfig, ZenityListOptionConfig, ZenityPrefixedVarBuilder 
#unset ZenityRadioOptionConfig
#unset ZenityListOptionConfig
#unset ZenityPrefixedVarBuilder
eval $( GFCFuncName=ZenityRadioOptionConfig GlobalFunctionCleaning ) ;
eval $( GFCFuncName=ZenityListOptionConfig GlobalFunctionCleaning ) ;
eval $( GFCFuncName=ZenityPrefixedVarBuilder GlobalFunctionCleaning ) ;
. ${FNCTDLIBPATH}/50ccda66-2ebb-11e3-98a2-001b3875b29c

### ZenityPythonInstaller 
#unset ZenityPythonInstaller ; 
eval $( GFCFuncName= GlobalFunctionCleaning ) ;
. ${FNCTDLIBPATH}/950966fa-0e67-11e3-98a2-001b3875b29c

### FileNameConversion
unset FileNameConversion ; 
eval $( GFCFuncName= GlobalFunctionCleaning ) ;
. ${FNCTDLIBPATH}/877d7e9a-1001-11e3-98a2-001b3875b29c

### MdCd GetDateReportCreation
#unset MdCd GetDateReportCreation ; 
#. ${FNCTDLIBPATH}/0f86b448-72f4-11e6-8b1d-001e4c8856d6
### This is required code for MdCd, extruded from file md_cd it's code is 
### now part of fnct_debian_lib_code.  
### Added 2017-01-25 : Since addition of MdCd to Makefile project from 
### MakeFileInstaller branch of the project, MdCd is istalled first to it's
### mandatory uses during path creation and file based model to be deployed 
### on every creation of path, Creation of .ArrayMdCd as well. 
### 

#unset PackageRepositoryFilter  PackageRepositoryMgmt    PackageRepositoryRest
### PackageRepositoryFilter  PackageRepositoryMgmt    PackageRepositoryRest 
# . ${FNCTDLIBPATH}/_sub_PackageRepository
### Added 2017-01-25 : Important restructuration of PackageRepositoryFilter  
### PackageRepositoryMgmt    PackageRepositoryRest require to load independtly.  
### Will require to add it to ArrayLib during LibLoader action. 
### 






### 
### Note, Existence of A-Range Boolean Purposes and B-Applied Boolean
### Variable. 
### 
### Def : A-Range Boolean Variable.
###  - Allow the Position between True and False Adding A WIDE-RANGE of 
### Information, Settled from Possibilities to Have at least 1 Data to 
### Fit inside a compound, the A-Range Boolean will be defined as:
### - Test 1:
### The AIsMoreFruitTo=False will leave a compound sentence as is:
### Sentence : The fruit are Grapes were all loved by children 
### 
### The AIsMoreFruitTo=True will Add-A-Range, this case being finite and
### unique the sentence will Have an addition:
### 
### Sentence : The fruit are Grapes ( and Banana ) were all loved by children 
### 
### See Answer to pattern inside BoolVarTest to see similarities. 
### 
### 
### Def : B-Applied Boolean Variable.
### - Expected case to add some extra functionalities to common argument. 
### - See PackageRepositoryMgmt for example of PkgRepoMgmtAddPkgLst Boolean
### variable allowing to add a listing in case Package are backuped and 
### need a reference of status of package . 
### 
### 
### To Fellow M.Murgullescu, Interrupted course to supplied informations 
### to teacher about limitation of homo-erectus (also called Midget) . 
### INF101 College Rosemont and Pre-homo-sapiens-sapiens limitation in 
### learning problems. 
### -Interaction done silently by turn-based event and noticing only 
### on volume / ratio in comment on Any-Type defined from Pascal-Programmation.
### 
### - Teacher just supplied the answer in a case for an examen of 15% of the
### sum and give any other information thru course traversal. 

eval $( GFCFuncName=BoolVarTestVarCreation GlobalFunctionCleaning ) ;
# unset BoolVarTestVarCreation ; 
function BoolVarTestVarCreation()
{

### The main goal : 
### Will represent a correct view of this example into pattern . 
### 
###   local StrMultipleFileSelectionAttr="--multiple"
###   if [ "${StrZenityFSMultipleFile}" == "False" ] ; then 
###    StrMultipleFileSelectionAttr="" ; 
###   fi 
### 
### Into CommandLine Echo like pattern and  being evaluated to create following statement:
### - Having a variable A Holding a content. 
### - Having a Prefixed-Var named B holding either False Or True like ${Prefixed_Var_named_B:=False}
### - On Having Reverse position inside ${Prefixed_Var_named_B:=False}, content of variable A, should
### Be erased of asking to get alternative.
### 
### Answer to pattern, 
### 
### BVTestVarName=StrMultipleFileSelectionAttr BVTestVarHold="--multiple" BVTestBoolVarName=StrZenityFSMultipleFile BoolVarTestVarCreation 
### 
### Nominal purposes: 
### This is intended to supply a Boolean test and Value Association, done in one line, 
### it allow to generate a range of variable being Transited from Prefixed-Var and value
### passed in a query, which is sometimes had no value and give extra code that might trigger error. 
### 
### For a Generated example between command-line BoolVarTestVarCreation and Pre-fixed value, see 
### 
### BoolVarTestVarCreation for substitution of StrFileTmp from function ZenityShellEval()
### Note reference : f1161962-0ad8-11e3-b166-001b3875b29c  
### 
### 
###  Warning : 
###  Note reference : 7236e956-f6cf-11e5-98a2-001e4c8856d6
###  - Recurrent call in BoolVarTestVarCreation
###  and avoid uses of  ValueToVariable . 
###  While BoolVarTestVarCreation is a low-level call indirectly call
###  by ValueToVariable it's hard to define first will end having 
###  good sub-body to acheive a strict identity and be able to 
###  parse all variable before BoolVarTestVarCreation 'will' have to 
###  end a possible __main_start_services if this one is implemented 
###  with normal body-topology  .  So it's not recommended to use 
###  ValueToVariable inside BoolVarTestVarCreation has long there is 
###  a better mechanisms correcting this problems in bash of recurrent  
###  function call recurently a lower level function will simply loop
###  and not finishing the work . 
### 
### 
### 

### Factory Section 
 unset StrVarBoolTest StrDefaultBoolTest StrNotAsserted StrScopeType StrIfTestType StrIfStringOp IsPreambule StrDefaultEndTest IsTypePreamb StrVTRPrbTpl StrVTRPrbVar StrVTRPrbVTReg StrVTRPrbVTFnct IsTypeAssert StrVTRAsrtTpl StrVTRAsrtVar StrVTRAsrtVTReg StrVTRAsrtVTFnct StrKeyTestType IntDefautlType IsDisplayIfStatement StrIfPattern ArrayIfPattern ArrayAssertion StrTestTemplate IsPreambulePolNtRespt ;
 local __call_locality=( BVTest BoolVarTestVarCreation ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ;
### End of Factory Section.
 local ArrayTypeTest=( False True ) ;
 local ArrayPreambule=( ) ; 

 local StrVarNamed=${BVTestVarName:=StrAttrHold} ; 
 local StrVarNamedHold=${BVTestVarHold:=CONTENT} ; 
 ### Following variable Stand for Is-Preambule-Polish-Notation-Respect is respected ( 
 ### like allow cleaning content and validate output for easy-Integer respect instead 
 ### of having case like IntValue="0" so far is valuable, but fail in case and if test -> 
 ### if [ "0" -eq 0 ] ; then ; fi , will notice some problems. )
 local IsPreambulePolNtRespt=${BVTestIsPrmblPlNt:=True} ; 
 local StrVarBoolTest=${BVTestBoolVarName:=IsVarShould} ; 
 local StrDefaultBoolTest=${BVTestBoolCase:=False} ;
 local StrNotAsserted=${BVTestBoolAssertion:=\"\"} ;
 local StrScopeType=${BVTestScopeTest:=local} ;
 local StrIfTestType=${BVTestIfType:=String} ; 
 local StrIfStringOp=${BVTestIfOp:='=='} ;
 local IsPreambule=${BVTestIsPreambule:=True} ; 
 local StrDefaultEndTest=${BVTestConclude:=";"} ;
 ### Section ValueToVariable in Preambule 
 local IsTypePreamb=${BVTestIsValueToVar:=False} ;
 local StrVTRPrbTpl=${BVTestVTVTPL:=eval __TES__  __REGISTRY_PRE__ VTVValueEntry=__VAR_ENTRY_PRE__ ValueToVariable __TEE__ __FNCT_PRE__} ;
 local StrVTRPrbVar=${BVTestVTVVar:=IsVerbose,IsDebug} ;
 local StrVTRPrbVTReg=${BVTestVTReg:=VTVIsQuotedValue=True VTVIsArrayStyleInsert=True VTVIsValueReAssign=True VTVIsValueToConvert=False} ;
 local StrVTRPrbVTFnct=${BVTestVTFnct:=__FNCT__} ;
 ### Section ValueToVariable in Assertion .
 local IsTypeAssert=${BVTestIsValueToVarAssert:=False};
 local StrVTRAsrtTpl=${BVTestVTVTPLA:=eval __TES__  __REGISTRY_ASRT__ VTVValueEntry=__VAR_ENTRY_ASRT__ ValueToVariable __TEE__ __FNCT_ASRT__} ;
 local StrVTRAsrtVar=${BVTestVTVVarA:=IsVerbose,IsDebug};
 local StrVTRAsrtVTReg=${BVTestVTRegA:=VTVIsQuotedValue=True VTVIsArrayStyleInsert=True VTVIsValueReAssign=True VTVIsValueToConvert=False}
 local StrVTRAsrtVTFnct=${BVTestVTFnctA:=__FNCT__}
 local StrKeyTestType=${BVTestType:='if:fi,if:elif,elif:elif,elif:else,if:else,else:fi'} ;
 local IntDefautlType=${BVTestIdType:=0} ; 
 local IsDisplayIfStatement=${BVTestDisplayIf:=False} ; 
 
 local StrTestTemplate="""__PREAMBULE__
 __IF_PATTERN__  
  __ASSERTION__ 
  __END_TEST__ __END_MARK__""" ;

 function Verbosis()
 {
  local __call_locality=( Verbosis Verb );
  local StrMsg=${VerbMsg:=__TEXT__} ; 
  local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local VerboseState=${VerbState:=False} ;
  local ArrayArg=( $* ) ; 
  if [ "${VerboseState:=False}" == "True" ] ; then 
   echo -ne "VERBOSE:[ ${StrMsg} ]\n" > ${StrDevOut} ;
  fi
 }
 
 
 local ArrayTestType=( ${StrKeyTestType//,/ } ) ; 
 local ArrayTestSection=( ${ArrayTestType[${IntDefautlType}]//:/ } ) ; 
 
 ### Note : ArrayTestSection should test if value end with 'fi' and will require an extra semi-colon
 ### before adding element 'fi' --> 'else ... (;) fi ' 
 if [ ${ArrayTestSection[1]} == "fi" ] ; then 
  ArrayTestSection[1]="; ${ArrayTestSection[1]}" ; 
 fi 
 local ArrayTestType=( String File Test Int Shell ) ;
 local StrIfPattern ; 
 local ArrayIfPattern=(  ) ;
 ArrayIfPattern[0]="__START_TEST__ [ \"${StrVarBoolTest}\" __OP__ \"${StrDefaultBoolTest}\" ] " ;
 ArrayIfPattern[1]="__START_TEST__ [ \"__OP__ \"${StrDefaultBoolTest}\" ] " ;
 ArrayIfPattern[2]="__START_TEST__ \$( test \"__OP__ \"${StrDefaultBoolTest}\" ) " ;
 ArrayIfPattern[3]="__START_TEST__ [ ${StrVarBoolTest} __OP__ ${StrDefaultBoolTest} ] " ;
 ArrayIfPattern[4]="eval ${StrVarNamed} ; res=\$? ; __START_TEST__  [ \${res:=1} __OP__ ${StrDefaultBoolTest} ] " ;
 

 ###
 ### ArrayIfPattern, Loop and test to select proper 
 ### StrIfTestType and it's Operator StrIfStringOp.
 ###
 for (( intx=0 ; intx <= ${#ArrayTestType[@]}-1 ; intx++ )) ; do 
  if [ "${StrIfTestType}" == "${ArrayTestType[${intx}]}" ] ; then 
   StrIfPattern=${ArrayIfPattern[${intx}]//__OP__/${StrIfStringOp}} ; 
  fi 
 done 
 ArrayPreambule[0]="__SCOPE__ __VAR_NAME__=__VALUE__" ;
 local ArrayAssertion=( ) ; 
 local ArrayAssertion[0]="__ASRT_VAR__NAME__=__ASRT_VAR_VALUE__" ;
 ### Old Preambule : ${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\"" 
 ### Old Assertion : \${StrVarNamed}=\${StrNotAsserted} ; 
  
  if [ "${IsTypeAssert:=False}" == "True" ] ; then 
   StrTestTemplate=${StrTestTemplate//__ASSERTION__/${StrVTRAsrtTpl}} ;
   StrTestTemplate=${StrTestTemplate//__REGISTRY_ASRT__/${StrVTRAsrtVTReg}} ;
   StrTestTemplate=${StrTestTemplate//__VAR_ENTRY_ASRT__/${StrVTRAsrtVar}} ;
   StrTestTemplate=${StrTestTemplate//__TES__/\$(} ;
   StrTestTemplate=${StrTestTemplate//__TEE__/)} ;
     ### 2016-08-29, require a ';' at the end of a command or an error will occur after the preambule or near the end after assertion
   StrTestTemplate=${StrTestTemplate//__FNCT_ASRT__/${StrVTRAsrtVTFnct} } ;
  else
   StrTestTemplate=${StrTestTemplate//__ASSERTION__/${ArrayAssertion[0]}} ;
   StrTestTemplate=${StrTestTemplate//__ASRT_VAR__NAME__/${StrVarNamed}} ;
   StrTestTemplate=${StrTestTemplate//__ASRT_VAR_VALUE__/${StrNotAsserted}} ;
  fi 
  
  if [ "${IsPreambule:=True}" == "True" ] ; then 
    if [ "${IsTypePreamb:=False}" == "True" ] ; then 
     StrTestTemplate=${StrTestTemplate//__PREAMBULE__/${StrVTRPrbTpl}} ; 
     StrTestTemplate=${StrTestTemplate//__VAR_ENTRY_PRE__/${StrVTRPrbVar}} ; 
     StrTestTemplate=${StrTestTemplate//__REGISTRY_PRE__/${StrVTRPrbVTReg}} ; 
     StrTestTemplate=${StrTestTemplate//__TES__/\$(} ; 
     StrTestTemplate=${StrTestTemplate//__TEE__/)} ; 
     ### 2016-08-29, require a ';' at the end of a command or an error will occur after the preambule or near the end after assertion
     StrTestTemplate=${StrTestTemplate//__FNCT_PRE__/${StrVTRPrbVTFnct} ; } ; 
    else
     ### Missing, Initially we have defined here some Polish notation and we 
     ### don't have any test related to Integer, String and so forth... 
     if [ ${IsPreambulePolNtRespt:=True} == "True" ] ; then 
      ### To Qualify all test we do Made a First variable StrTypeVar ; Will hold the conclusion into
      ### following answer form ( Bool / Int / String ) ; 
      ### between String Test or Not 
      ### Test is made in this order : -> Do we discover something else than number inside the StrVarNamedHold
      ### First the copy made from StrVarNamedHold remove every number and test the value.
      ### Secondly ( might not be immediately ), Detecting 0L , or simply called Long not rationnal
      ### inside script but might be interresting . 
      ### Succedding to removing all number, counting the remaining char. 
      local StrVarHoldTest=${StrVarNamedHold} ; 
      local StrTypeVar=None ; 
      
      ### Because Boolean are Special case, are likely to be String with only 
      ### 2 type of answer, True/False, It's like old story of Coolege Programmation
      ### Introduction 101 at Rosemont Cegep in 1997-1999 using Pascal and pseudo-code.
      ### It does the same for Boolean, having to type it plain text True/False and 
      ### the lexer/parser inide should understand what is Boolean to what is not... 
      ### In This context, we have craft a singular one with filtering .
      
      ### Special Case, detection of Boolean are made with sed reduction of specific
      ### Sub-Group. Especially found nothing inside Regular Expression of O'Reilly 
      ### Pocket reference, but still only a Pocket Reference. 
      
      ### Bash Big Line, It's especially important to declare it correctly and allow 
      ### type definition rather to not filtering the input at start and have many
      ### messages having problems to handle variable. Especially in Bash is actor
      ### or builtin/function/shell script to generate error on type not correctly 
      ### handled. If the variable is designe as Integer and hold String-like 
      ### information, if you do notthing with that variable or called-it 
      ### future-design, it won't tell you problems until the day you start to use it.
      
      ### Before reducing everything to nil, do a Boolean Detection:
      StrVarHoldTest=$( echo ${StrVarHoldTest} | sed 's/[{'True','False'}]//g'  ) ; 
      local IntPolishBool=${#StrVarHoldTest};
      local IntPolisgString ;
      local IntPolishInteger ;
      if [ ${IntPolishBool:=0} -eq 0 ] ; then 
       ### It's a Boolean form notation 
       StrTypeVar="Bool" ;  
      fi 
      
      if [ ${StrTypeVar:=None} == "None" ] ; then 
       StrVarHoldTest=$( echo ${StrVarHoldTest} | sed 's/[0-9]//g' ) ;
       IntPolishInteger=${#StrVarHoldTest} ; 
      fi 
      
      if [ ${StrTypeVar:=None} == "None" ] ; then 
       StrVarHoldTest=$( echo ${StrVarHoldTest} |\
         sed 's/[A-Za-z\ ]//g'  |\
         tr '[:graph:]' ' '     |\
         tr '[:cntrl:]' ' '     |\
         tr '[:punct:]' ' '     |\
         tr '[:space:]' ' '     |\
         sed 's/ //g' ) ;
       IntPolisgString=${#StrVarHoldTest} ;
      fi 
      
      if [ ${StrTypeVar:=None} == "None" ] ; then 
       if [ ${IntPolishInteger:=0} -gt 0 ] ; then 
         ### it's not number 
         if [ ${IntPolisgString:=0} -eq 0 ] ; then 
          ### It own couple of extra char inside and should be see as String . 
          StrTypeVar="String" ; 
         fi 
       fi
      fi 
      if [ ${StrTypeVar:=None} == "None" ] ; then 
       if [ ${IntPolishInteger:=0} -eq 0 ] ; then 
        ### It's formely all number 
        StrTypeVar="Int" ; 
       fi
      fi
      
      if [ ${StrTypeVar:=None} == "Int" ] ; then 
       StrTestTemplate=${StrTestTemplate//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=${StrVarNamedHold} ;} ; 
      elif [ ${StrTypeVar:=None} == "String" ] ; then 
       StrTestTemplate=${StrTestTemplate//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\" ;} ; 
      elif [ ${StrTypeVar:=None} == "Bool" ] ; then 
       StrTestTemplate=${StrTestTemplate//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\" ;} ; 
      else
       ### Kept as String .
       StrTestTemplate=${StrTestTemplate//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\" ;} ;  
      fi  
     else 
      StrTestTemplate=${StrTestTemplate//__PREAMBULE__/${StrScopeType} ${StrVarNamed}=\"${StrVarNamedHold}\" ;} ; 
     fi 
     
     
    fi 
  else
    ### This section exist only because BVTestIsPreambule=False allow to completely remove the 
    ### preambule. Having work around like using IntDefautlType=[1,2,3,4] can remove the 
    ### preambule and we are out of problem... Not so clean and some efforts are trying to 
    ### resolve 
    StrTestTemplate=${StrTestTemplate//__PREAMBULE__/} ; 
  fi
  if [ ${IntDefautlType} -eq 0 ] ; then  
   StrTestTemplate=${StrTestTemplate//__IF_PATTERN__/${StrIfPattern} ; then} ; 
  elif [ ${IntDefautlType} -eq 1 ] ; then  
   StrTestTemplate=${StrTestTemplate//__IF_PATTERN__/${StrIfPattern} ; then} ; 
  elif [ ${IntDefautlType} -eq 2 ] ; then  
   StrTestTemplate=${StrTestTemplate//__IF_PATTERN__/${StrIfPattern} ; then} ; 
  elif [ ${IntDefautlType} -eq 3 ] ; then  
   StrTestTemplate=${StrTestTemplate//__IF_PATTERN__/${StrIfPattern} ; then} ; 
  elif [ ${IntDefautlType} -eq 4 ] ; then  
   StrTestTemplate=${StrTestTemplate//__IF_PATTERN__/${StrIfPattern} ; then} ; 
  elif [ ${IntDefautlType} -eq 5 ] ; then  
   StrTestTemplate=${StrTestTemplate//__IF_PATTERN__/} ; 
  fi
  
  StrTestTemplate=${StrTestTemplate//__START_TEST__/${ArrayTestSection[0]}} ; 
  StrTestTemplate=${StrTestTemplate//__END_TEST__/${ArrayTestSection[1]}} ; 
  ### Uses of Array BVTestType 
  ### index of operation : 
  ### 0 -> if:fi,
  ### 1 -> if:elif,
  ### 2 -> elif:elif,
  ### 3 -> elif:else,
  ### 4 -> if:else,
  ### 5 -> else:fi
  ### Exception in case IntDefautlType=4 for Imbrication of if, we need to 
  ### suppress the StrDefaultEndTest or provide a return caracter to allow 
  ### to fill second declaration of BoolVarTestVarCreation with state 
  ### IntDefautlType=4 , Supply a first level if/else 
  if [ ${IntDefautlType} -eq 1 ] ; then 
   StrTestTemplate=${StrTestTemplate//__END_MARK__/} ; 
  elif [ ${IntDefautlType} -eq 2 ] ; then 
   StrTestTemplate=${StrTestTemplate//__END_MARK__/} ; 
  elif [ ${IntDefautlType} -eq 3 ] ; then 
   StrTestTemplate=${StrTestTemplate//__END_MARK__/} ; 
  elif [ ${IntDefautlType} -eq 4 ] ; then 
   StrTestTemplate=${StrTestTemplate//__END_MARK__/} ; 
  else
   StrTestTemplate=${StrTestTemplate//__END_MARK__/${StrDefaultEndTest}} ;  
  fi 
  
  
  
  ### 
  ### Section We transform StrTestTemplate into 
  ### IF 
  ### ...
  ### FI 
  ### IF  
  ### ...
  ### ELIF 
  ### ELIF 
  ### ...
  ### ELSE, 
  ### ... --> See BVTestType for all choice made by default. It's a 2 choice 
  ### method and don't forget, it cover only One test at the time, 
  ### Either to not execute it after parsing you can call BoolVarTestVarCreation
  ### many time and glueing result_BVT1 + result_BVT2 + result_BVT3
  ### to form a complete 
  ### 
  ### if   +
  ### ...  +--> Made by BVTestType=1 BoolVarTestVarCreation Stored in Var1
  ### elif +
  ### ...
  ### elif +
  ### ...  +--> Made by BVTestType=2 BoolVarTestVarCreation Stored in Var2
  ### elif +
  ### ...
  ### else +
  ### ...  +--> Made by BVTestType=5 BoolVarTestVarCreation Stored in Var3
  ### fi   +
  ### And A new variable NewVarTEst=${Var1}${Var2}${Var3} will hold the entire 
  ### test ...
  ### Notice there is odd sequence where the last line of your test SHOULD
  ### END with FI, like BVTestType=4 BoolVarTestVarCreation
  ### with if-else marker. This Boolean test does include a TAG named __END_MARK__
  ### with help you changing it for a 'fi' or either a semi-colon ';' 
  ### See BVTestConclude where is default is semi-colon ';', but may old
  ### value like BVTestConclude='fi ;' , BVTestConclude='fi' 
 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
  eval $( __GetVarReferenceCompWord ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
 
  local StrMsg="\nFunction ${__call_locality[1]}, Display Result:\n ${StrTestTemplate}\n" ; 
  VerbState=${IsDisplayIfStatement} VerbDev=/dev/stderr VerbMsg=${StrMsg} Verbosis
  echo -ne "${StrTestTemplate}" ; 
 fi
 
}




##################################                 ########################
################################## In Prototyping  ########################
################################## Start           ########################

unset PropertyLibName
function PropertyLibName()
{
 local __call_locality=( PLN PropertyLibName ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]};
 local StrAction=${PLNAction:=Add} ; 
 local StrLibName=${PLNLib:=NONE} ; 
 local StrOutArrayRef=${PLNArrayRef:=ArrayLibName} ;
 local ArrayActionType=( Add Delete Test Show ) ; 
 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 
 function __main_StartServices()
 {
  local __call_locality=( Main __main_StartServices ) ;
  local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]};
     
 }
 
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
  eval $( __GetVarReferenceCompWord ) ;
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  StrAction=${StrAction}           \ 
  StrLibName=${StrLibName}         \
  StrOutArrayRef=${StrOutArrayRef} \
  __main_StartServices       ${Arg0} ; 
 fi
 
}
##################################                 ########################
################################## In Prototyping  ########################
################################## End             ########################


##################################                 ########################
################################## In Prototyping  ########################
################################## Start           ########################

 ###
 ### function BodyFunc()
 ### - Like BoolVarTest, is defined to create on-demand if-pattern based on True Statement-Initial affectation and 
 ### residual False statement as Assertive condition being another mechanism or either a branch this function BodyFunc
 ### will manage the switch condition from Arg0, know to be the Operator for finite and unique action. Actual Action are 
 ### Getter, List, Helper and StartServices. __Future__ view predict uses of Setter where it's actually tweaked with external
 ### Subset of command within Bash whole-list of command. Developped has Micro-Architecture expansion require several
 ### analysis and may depend of another compromised information related to Data. Data used from Setter Will stay out of the
 ### code and actual Pre-fixed Variable are unique Start-up information where ultimately all information will migrate to None after
 ### uniformisation and expansion of Exception into proper design. 
 ###
 ###
 ### BodyFunc Goal :
 ### To create an [ if / elif / n-elif / fi ] command from finite action required inside need of fnct_debian_lib to be wise information
 ### discovery . Wise-Discovery is not part of the function-type itself, but any coumpound will have Serious Notation and 
 ### minimal helper.  Actually it will cover Finite action of Listing Prefixed-Var or Transport-Layer signature and Getter will 
 ### extract entry from this Transport Layer, know to be actual Prefixed-Var. 
 ###
 ### BodyFunc and Expanded Entry inside Finite action, StartServices uses : 
 ### - Since Getter, Helper and List are simple finite action, a function body from this lib are the core of evolving multi-party-actor
 ### involving many sub-derivate. Example: 
 ### Inside PackageRepositoryMgmt, uses of GetOtherDate is crutial to leave a valid-footprint inside and index based on File-system
 ### information deposition. 
 ###
 ### - The StartServices being a function with Tiny Prefixed-Var internally be a Inter-transport-Layer, it should result into calling a 
 ### possible function inside the Function Body or Any good compound from this Lib with awarness of calling correctly any Pre-fixed
 ### var. 
 ### Exception in Internal design from Function to Sub-Function Transport-Layer this mechanism is not regulated, but will not work if 
 ### variable are not transfered. 
 ###
 ### Facility in External transport connection of BodyFunc. 
 ### - The prefixed-variable BFStackVariableList will accept a language operator known to be '+' sign to allow any conversion 
 ### from good appelation of working function inside fnct_debian_lib by calling it and extracting variable. uses of GetOtherDate will
 ### be use inside the example. 
 ###
 ### BFStackVariableList=$( GetOtherDate --list | sed 's/\([a-zA-Z]*\)/\1+,/g;s/\ //g;s/+,+,/+/g'  ) BF*=... BodyFunc 
 ###
 ### Will shorten the transfert mechanism from Outgoing Transport-Connection into automated StackList adding sequence, and 
 ### will also offer Glueing technique for several descendant  uses of BoolVarTest / Function_from_fnct_debian_lib, and 
 ### BodyFunc, with consideration had possibilty to be a fixed if-elif-fi topology . 
 ###



function BodyFunc()
{
 local __call_locality=( BF BodyFunc ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]};

 local StrHelpCmd="GetVarReference ${__call_locality[1]} ;  echo -ne \"${StrSwitchMessages}\" > /dev/stderr ; " ;
 local StrGetCmd=" eval \"\"\"local ArgGet=\${\${ArrayArg[1]}}\"\"\" ;  echo -ne \"\"\"\${ArgGet}\n\"\"\" ; "
 local StrListCmd="eval \$( __GetVarReferenceList ) ;" ;
 local StrStartServicesCmd="__main_StartServices" ;
 local StrDefineHelp=${BFHelpSwRules:=Help:--help:__HELP__:StrHelpCmd} ;
 local StrDefineGet=${BFGetSwRules:=Get:--get:__GET__:StrGetCmd} ;
 local StrDefineList=${BFListSwRules:=List:--list:__LIST__:StrListCmd} ;
 local StrDefineStartServices=${BFStartServicesSwRules:=StartServices:--startservices:__ApplicationMain__:StrStartServicesCmd} ;
 local StrVarConvertOp=${BFVarTransfertOp:=+} ; 
 local StrUUIDBoolRegistration=${BFBoolUUIDRegistered:=False} ; 
 local StrUUIDRegister=${BFUUID:=""} ; 
 local StrUUIDFormat=${BFUUIDFmt:=XXXXXXXX_XXXX_XXXX_XXXX_XXXXXXXXXXXX} ; 
 ### planning to register an UUID, will imply a transformation of the dashes to pass the lexer. 
 local StrUUIDRegistered="" ;

 if [ "${StrUUIDBoolRegistration}" == "True" ] ; then 
  if [ "${StrUUIDRegister}" == "" ] ; then 
   ### Situation of Blank registration and not yet registered Mechanism. 
    echo -ne "Asked for registration and missing UUID\n " ; 
    StrUUIDRegistered="${StrUUIDFormat}" ; 
  else
   ### This situation will imply implementation of post stored UUID into
   ### local data ( database / file, in memory, from collected info )
   ### and merely had only the UUID lexer to change dashes for underscore.  
   ### A test situation that will always return an error is to use
   ### BodyFunc with BFUUID=$( uuidgen -t ) or $( uuidgen -r ) which
   ### will not exist in 11 or 22 years before having an old candidate
   ### stored being revamp from data collection . 
   StrUUIDRegistered=${StrUUIDRegister//-/_} ; 
   ### ... 
  fi
 elif [ "${StrUUIDBoolRegistration}" == "False" ] ; then 
  if [ "${StrUUIDRegister}" != "" ] ; then 
   StrUUIDRegistered=${StrUUIDRegister//-/_} ; 
  fi
 fi
 ### removing dash and changing it for underscore. 
 

   
 ###
 ### The Prefixed-var BFVarTransfertOp:
 ### - To reduce rewriting, using the Operator '+' inside the Prefixed-Var BFStartServicesSwRules using rule like
 ### BFStackVariableList=Var1+ will transform Var1=Value by Var1=${Var1} inside Template __Stack_Variable__
 ### - Assuming BodyFunc is mangling the bottom of a function inside fnct_debian_lib into protocolar function creation
 ### with self verification ability like transfert mechanism and assignation possibility.
 ###
 local StrStackVar=${BFStackVariableList:=StrFileTmp=+,StrTitle="A title",IntSleep=+,Size=IntFontSize,IsEditField=+,IntWidth=+,IntHeight=+,IntDefaultModeExec=+} ;
 local ArrayServicesSwitches=( ${StrDefineHelp} ${StrDefineGet} ${StrDefineList}  ${StrDefineStartServices} )
 
 local StrPatternIf="""if [ \"${Arg0:=--startservices}\" == \"--help\"	] ; then 
 __HELP__${StrUUIDRegistered} 
elif [ \"${Arg0:=--startservices}\" == \"--get\" ] ; then 
 __GET__${StrUUIDRegistered} 
elif [ \"${Arg0:=--startservices}\" == \"--list\" ] ; then 
 __LIST__${StrUUIDRegistered} 
elif [ \"${Arg0:=--startservices}\" == \"--startservices\" ] ; then 
  __Stack_Variable__${StrUUIDRegistered} 
  __ApplicationMain__${StrUUIDRegistered} ; """ ;

echo -ne "###BodyFunc Pattern\n\n###Based on UUID Registered: (${StrUUIDRegistered})\n\n###--------------------------------------------------\n${StrPatternIf}\n###--------------------------------------------------\n"
}

##################################                 ########################
################################## In Prototyping  ########################
################################## End             ########################




### 
### function WrapPathIntegration()
###
### As Path Accessor in some internal development and first integrated to 
### md_cd command to transform it's call :
### -> from ( md_cd __PATH__ ) in to 
### -> prefixed_var=__PATH__ md_cd 
###
### -- Allowing addition of --startservices to set a possible cumulation of informations
### -- Allowing addition of --get , --list . 
### -- Implicitly develop a filter for relativistic path added to the command and 
### or adding default mechanism to filter and inform of explicit action like 
### disallowing uses of relativistic path or inversly disallow uses of absolut
### path...  [ /ekivk/-ly /kt/ the /nt/ /ntnt/ /kn/ ]

###
### WrapPathIntegration
### Will also allow a third-party function being [kc]rafted depending of ListToArray
### this one will also possible to not use it by specifying your own function 
### thru WPIListTransformFunc and it's method to call it internally. Using the
### function WPILstFuncCall .
### Helper own it's own example of calling the internal function: 
###
### see: (pre-note, not the official pre-fixed var are definied here )
###
###
###  Function WrapPathIntegration
###  Default Variable Value:
###  Variable WPIPathList ,
###  	Default Value:''
###  Variable WPIListTransformFunc ,
###  	Default Value:ListToArray
###  Variable WPIListCSV ,
###  	Default Value:','
###  Variable WPILstFuncCall ,
###   
###      +---------------------------------------------------------------+
###  	   | Default Value:LTAComma='__CSV__' LTAEntry=__LIST__ __FNCT__   |
###      +---------------------------------------------------------------+
###
###
###  Variable WPIVerbose ,
###  	Default Value:False
###
### By Default, LTAComma and LTAEntry are provided by default and should not 
### interfer with your own function. Despite having few report based before the
### Fnct.D appear, it's idea to own at least the required TAG such __CSV__ and 
### __LIST__ is mandatory if you do collect information thru the command-line.
### Some other thinking may developt a in file data-collection or from Database
### query to extract your data, but initially provided a in-hand and in-command
### line provider is essential. Some may forget the uses of concept of 
### Comma separeted value like passing a full-length Base64 Line like precedent
### development of __fnctCreateLocalityFuncParam with uses of FParamBase64 
### to identifie the variable as Base64 codec and having extra accessor 
### decoding and encoding... All rejected for getter and setter problems near
### 2011/2012 after discovering a development problems in uses of variable
### parsing and be unable to acheive a better algorith. 
### 
### Note: ed0719fe-e959-11e5-98a2-001e4c8856d6
### Evolution of Variable with pre-designed called like ValueToVariable
### and presence of unified Getter .
### While some effort toward __fnctCreateLocalityFuncParam owning ability
### to interpret uses of __call_locality , predecessor from old_fnct.D does
### owning specificity of variable . Today having unified call of variable 
### thru uses of Array called __call_locality( Member-call Function-Name ), 
### the function __GetVarReferenceList and apparatus :
### 
### eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
### echo -ne """${ArgGet}\n""" ;
### 
### found in '--get' , filter from Arg0 does report information about 
### value inside the function and allow them having different action. 
### - Totally Unified the declaration of Inside-member like Verbosis 
### exemple in WPI, show:
### 
### IsVerbose=${WPIVerbose:=False} ;
### 
### - Presence of variable formating and will be inserted inside 
### __GetVarReferenceList action because it start with Is or Bool,
### or Array or Str or even Int. 
###
### While Uses of Base64 is not definied Here, a presence of 
### Variable like WPIBase64=True/False will let other function 
### query them with this form :
### __FUNCTION__ --get WPIBase64 
### and if this report thru, we guess we can start thinking using 
### this way to enable codec... This improve speed and reduce code .
### Known to be heavy old __fnctCreateLocalityFuncParam, and 
### __call_locality as Function not Array does pump +/- 200 line 
### of code per call... Having discovered a problem, in calling 
### sequence, or problems between Real Unix/Solarix uses of function
### accepting dot ( . )  inside function name it's not scheduled in 
### bash anymore and did not comment anything over this choice... 
### It's purely  acknowledgible  ... 
### 
### Because Sets of main new function __GetVarReferenceList, GetVarReference, 
### ValueToVariable , It start to unravel a steady way to respect some decent 
### coding adding <Plus> in way to affirm passthru of pre-fixed variable does 
### work and does not leak. 
### GetVarReference being glued inside ZenityEditFile Idiom integrity test leave
### a bad breath in home-made third-party eavesdroping ... Free development
### is also subject to be altered and being hack directly to github server 
### and prone development should depend of at least a codec to infirm in safe
### test being done because some arbitrary code are summed, and ZenityEditFile
### had property to affirm if a today code work or not after testing the 
### integrity. Which is bad in auto-development tool observed being able to 
### alter sub-set of code but not really helping in development. Based on 
### CRAN statistics tools, comming alone this auto-development widget is only
### to let beleive there is work toward a project, while real project path look
### like heratic. Time is something we spend on and it's not counted when it's
### afformentionned finited goal. 
### 
### Resume in, some part are fixed for good, some other like ValueToVariable
### are not finished but give good result and will continue to help the loosed 
### development left as example on what to not follow, help definition of standing
### component inside a function rather to implement lost variable and nestled 
### function . 
### 
### 
### 





### Dedicated for md_cd
### While ValueToVariable is under verification, an alternative is deployed to 
### allow function MdCd  from this Fnct.D project to work with Path Listed 
### from normal unix like command calling and be decoyed and parsed into a 
### prefixed-variable. Some effort toward ValueToVariable was defined but not 
### yet ported or tested. Somes effort in the past are mildly report some exception
### between different version of bash and all test are not concluent at this step.
### 
### But for sure, MdCd should join back fnct_debian_lib by integrating it's lock 
### mechanism that prevent many acces at the time. A Wonderfull effort to allow 
### contigous interaction like Unicity lock or permanent survey. Theses type of 
### mechanism avoid accessing to a file index storing precious data and rewrite
### them to prevent visible trace of temporary path being made, being used and 
### wipe before a Main or higher process open the file and did not report presence 
### of that action. A big problem in HAL, access in time is Heavy and action in 
### local are slowed while important process are using it to detect presence of 
### alteration. Just install usb-image-creator of gtk-usb-imagewriter are slow
### updating re-formated disk . 
### 


function WrapPathIntegration()
{
 local __call_locality=( WPI WrapPathIntegration ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} 
 local StrEntryListPath=${WPIPathList:=''} ;
 local StrListFnct=${WPIListTransformFunc:=ListToArray}
 local StrCommaValue=${WPIListCSV:=','} ;
 local IsPathIncludeSemantic=${WPIPathSemantic:=True} ; 
 local StrListArgCall=${WPILstFuncCall:=LTAComma=\'__CSV__\' LTAMatchRelative=__REG__ LTASemanticTag=__TAG__ LTAEntry=__LIST__ __FNCT__}  ;
 local IsVerbose=${WPIVerbose:=False} ; 
 local StrFilterRelativePath=${WPIRelativeMatch:='^[\.]+[\/]?[A-Za-z0-9_]+|^\w+[\/]?'}
 local StrSemanticPathTag=${WPISemanticTag:=R,A}

 function Verbosis()
 {
  local __call_locality=( Verbosis Verb );
  local StrMsg=${VerbMsg:=__TEXT__} ; 
  local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local VerboseState=${VerbState:=False} ;
  local ArrayArg=( $* ) ; 
  if [ "${VerbState:=False}" == "True" ] ; then 
   echo -ne "VERBOSE:[ ${StrMsg} ]\n" > ${StrDevOut} ;
  fi
 }
  
 function ListToArray()
 {
  local __call_locality=( LTA ListToArray ) ;
  local Arg0=${ArrayArg[0]} ;
  local ArrayArg=( $* ) ;
  local StrCommaConverted=${LTAComma//\'/} ;
  local StrDebugMsg="\tIn Func:${__call_locality[1]}\n\t\tContent of LTAEntry:[${LTAEntry}]\n\t\tContent of LTAComma:[${LTAComma}]\n\t\tContent of StrCommaConverted:[${StrCommaConverted}]\n\t\tContent of IsPathIncludeSemantic:[${IsPathIncludeSemantic}]" ; 
  VerbState=${IsVerbose} VerbMsg=${StrDebugMsg} Verbosis ; 
  local StrEntryFilter="\"${LTAEntry//${StrCommaConverted}/\" \"}\"" ;
  local StrFilterRelative=${LTAMatchRelative:='^[\.]+[\/]?[A-Za-z0-9_]+|^\w+[\/]?'} ; 
  local StrTagSemList=${LTASemanticTag:=R,A}
  
  ### According to arbitrary value 
  ###             R -> Relative Path and 
  ###             A -> Absolut Path 
  ### These values are stocked into an array where value 0 and 1 are pointing 
  ### on linear correspondance. 
  ### Array[0] -> point on value R
  ### Array[1] -> point on value A .
  ### Why it's important to developt a regular expression matchin Value 0 on 
  ### Array[0] of transformed LTASemanticTag or WPISemanticTag because 
  ### for a positive match like finding
  ### ./path or ../path or path/other_path will report 1 count by the egrep .
  ### After hiting once it is associate to 0 and if there is no hit, associate
  ### to an Absolut path . 
  ### About LTASemanticTag, it taking value from WPISemanticTag, if information
  ### are specified from WrapPathIntegration ( like WPISemanticTag=R,A WrapPathIntegration)
  ### it is automatically reported inside Section 2 of __main_StartServices .
  ### It basically developt StrCmd, parsing __TAG__ and adding the definition or
  ### Ordered information about Semantic . Being added to section 3 of __main_StartServices
  ### Thru ValueToVariable
  
  local ArrayPathSemantic=( ${StrTagSemList/,/ } ) ; 
  
  
  local StrPath ; 
  local ArrayLocalList=( ${StrEntryFilter} ) ;
  local IntResultRelative=1 ;
  local StrCmdSem ;
  for (( i=0 ; i <= (( ${#ArrayLocalList[@]} -1 )) ; i++ )) ; do 
   local StrPath=${ArrayLocalList[${i}]} ; 
   local IntFilterTest=1  ; 
   local IntResultRelative=-1 ;
   
   if [ ${IsPathIncludeSemantic:=True} == "True" ] ; then 
    StrCmdSem="echo ${StrPath} | egrep -c -E \"${StrFilterRelative}\"" ; 
    IntFilterTest=$( eval ${StrCmdSem} ) ;
    if [ ${IntFilterTest:=-1} -eq 1 ] ; then
     IntResultRelative=0 ;
    else
     IntResultRelative=1 ;
    fi
    #test ${IntFilterTest:=1} -eq 1 && IntResultRelative=1 ;
    #test ${IntFilterTest:=1} -eq 0 && IntResultRelative=0 ;
    StrDebugMsg="\tIn Func:${__call_locality[1]}\n\t\tContent of StrPath:[${StrPath}]\n\t\tRegExp StrFilterRelative Filter:[${StrFilterRelative}]\n\t\tContent of IntFilterTest:[${IntFilterTest}]\n\t\tContent of IntResultRelative:[${IntResultRelative}]" ;  
    VerbState=${IsVerbose} VerbMsg=${StrDebugMsg} Verbosis ; 
    StrDebugMsg="\tIn Func:${__call_locality[1]}\n\t\tPath Semantic Tag:[${ArrayPathSemantic[${IntResultRelative}]}]" ; 
    VerbState=${IsVerbose} VerbMsg=${StrDebugMsg} Verbosis ; 
    
    ArrayLocalList[${i}]="${ArrayPathSemantic[${IntResultRelative}]}:${StrPath}" ; 
   else 
    ArrayLocalList[${i}]="${StrPath}" ; 
   fi 
  done 
  StrDebugMsg="\tIn Func:${__call_locality[1]}\n\t\tContent of StrEntryFilter:[${StrEntryFilter}]" ; 
  VerbState=${IsVerbose} VerbMsg=${StrDebugMsg} Verbosis ; 
  echo -ne "${ArrayLocalList[@]}" ; 
 }
 
 function __main_StartServices()
 {
  ###
  ### Section 1
  ###
  local __call_locality=( Main __main_StartServices ) ;
  local Arg0=${ArrayArg[0]} ;
  local ArrayArg=( $* ) ;
  local StrCmd=${StrListArgCall//__CSV__/\'${StrCommaValue}\'} ;

  ###
  ### Section 2
  ###
  StrEntryListPath=${StrEntryListPath//}
  StrCmd=${StrCmd//__LIST__/${StrEntryListPath}} ;
  StrCmd=${StrCmd//__FNCT__/${StrListFnct}} ;
  StrCmd=${StrCmd//__TAG__/${StrSemanticPathTag}} ;
  StrCmd=${StrCmd//__REG__/${StrFilterRelativePath}} ;
  
  local StrDebugMsg="In Func:${__call_locality[1]}\n\tContent of StrCmd:[${StrCmd}]" ; 
  VerbState=${IsVerbose} VerbMsg=${StrDebugMsg} Verbosis ; 
  
  ###
  ### Section 3
  ###
  local ArrayPath=( $( \
       eval $( VTVIsArrayStyleInsert=True \
       VTVIsValueReAssign=True \
       VTVIsValueToConvert=False \
       VTVValueEntry=IsVerbose,IsPathIncludeSemantic ValueToVariable ) ${StrCmd} ) ) ;  
                       
  StrDebugMsg="In Func:${__call_locality[1]}\n\tContent of ArrayPath :[${ArrayPath[@]}]"
  
  VerbState=${IsVerbose} VerbMsg=${StrDebugMsg} Verbosis ; 
 }

  ###
  ### Section 4
  ###
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;	
 else
  eval $( VTVIsArrayStyleInsert=True \
          VTVIsValueReAssign=True \
          VTVIsValueToConvert=False \
          VTVValueEntry=StrEntryListPath,StrListFnct,StrCommaValue,StrListArgCall,IsVerbose,IsPathIncludeSemantic,StrSemanticPathTag,StrFilterRelativePath ValueToVariable ) __main_StartServices 
 fi 
 
 
 
}


### Note: MakeLink
### - While I'm making rezound work without linking libsoundtouch.0 to 
### libsoundtouch.1 and linking libaudiofile.so.1 with libaudiofile.so.0 for 
### installing the rezound_0.12.3beta-2.3_amd64.deb from dpkg --install
### it report error but does installing the debian package... Between this 
### work-around and compiling the rezound_0.12.3 from launchpad distribution it 
### come with many error or untelled warning to add inside the Makefile.am... 
### Having it compiling from my github 
### ( https://github.com/priendeau/Technical-PorteFolio/tree/master/C/rezound/rezound-0.12.3beta ) 
### it may occurs sometimes correction I did not add and are blind to actual 
### repository... re-linking one-by-one erronous file and working file I do need to 
### do a tiny MakeLink function where the SRC location is stored inside 
### MLLocationRoot and may call make after linking with prefixed variable 
### MLMainActionAfterLink ... 

unset MakeLink
function MakeLink() 
{ 
 local ArrayArg=( $* );
 local __call_locality=( ML MakeLink );
 local Arg0=${ArrayArg[0]} ;
 local StrRootOrigin=${MLLocationRoot:=/home/maxiste/github/Technical-PorteFolio/C/rezound/rezound-0.12.3beta/src} ;
 local StrAction=${MLMainActionAfterLink:=make} ;
 local StrFileSearch=${MLFileSearch:=None.cpp} ;
 local StrAliasFind=${MLAliasFind:=find -type f -iname } ;
 local IsMake=${MLDoPostAction:=True} ;
 local IsRenameDest=${MLBoolReplaceDest:=True} ; 
 local StrLinkApps=${MLLinkApps:=/bin/ln} ; 
 local StrLinkOpt=${MLLinkopt:=-s} ; 
 local StrLinkFormat=${MLLinkFormat:=__LINK__ __OPT__ __SRC__ __DEST__} ;
 local StrDebugLink=${MLLinkDisplayDebug:=False} ;
 local StrMoveSuffix=${MLMoveSuffixName:=-old} ; 
 
 function __Link()
 {
  local __call_locality=( _L __Link ) ;
  local ArrayArg=( $* ) ; 
  local StrVarSrc=${StrRootOrigin}/${StrFile} ;
  local StrEval=${StrLinkFormat} ; 
  
  local StrFileReplace=$( echo "${StrFile}" | sed 's/\(\.[a-z]*\)/${StrMoveSuffix}\1/g' ) ; 

          
  StrEval=${StrEval//__LINK__/${StrLinkApps}} ;
  StrEval=${StrEval//__OPT__/${StrLinkOpt}} ; 
  StrEval=${StrEval//__SRC__/${StrVarSrc}} ; 
  StrEval=${StrEval//__DEST__/${StrFile}}
  if [ ${StrDebugLink} == "False" ] ; then 
   eval $( BVTVarName=StrToMove \
           BVTVarHold='' \
           BVTBoolVarName=\${IsRenameDest} \
           BVTBoolCase=True \
           BVTBoolAssertion='$( mv ${StrFile} ${StrFileReplace} )' \
           BVTScopeTest=local BVTIdType=0 \
           BoolVarTest ) ;   
   eval "${StrEval}" ;
  else
   echo -ne "Eval:[ ${StrEval} ]\n" > /dev/stderr ; 
  fi
  
 }
 
 function __PostAction()
 {
  local __call_locality=( __PA __PostAction ) ;
  local ArrayArg=( $* ) ; 
  
  eval $( BVTVarName=StrRecurrent \
          BVTVarHold='' \
          BVTBoolVarName=\${IsMake} \
          BVTBoolCase=True \
          BVTBoolAssertion='$( ${StrAction} )' \
          BVTScopeTest=local BVTIdType=0       \
          BoolVarTest ) ; 
  
 }
 
 function __main_StartServices()
 {
  local __call_locality=( Main __main_StartServices ) ;
  local ArrayArg=( $* ) ; 
  eval alias find='${StrAliasFind}';
  local StrFile=$( find ${StrFileSearch} );
  local Arg0=${ArrayArg[0]};
  if [ "${StrFile:=None}" != "None" ] ; then 
   StrFile=${StrFile//\.\//} ; 
   local ArrayLayerVar=( StrRootOrigin,StrFile,StrLinkApps,StrLinkFormat,StrLinkOpt,StrDebugLink,IsRenameDest,StrMoveSuffix IsMake,StrAction ) ;
   local ArrayFunction=( __Link __PostAction )
   for (( intx=0 ; intx <= ${#ArrayLayerVar[@]}-1; intx++ )) ; do 
    eval $( VTVIsArrayStyleInsert=True \
    VTVValueEntry=${ArrayLayerVar[${intx}]} \
    VTVIsValueReAssign=True \
    VTVIsValueToConvert=False \
    VTVIsArrayStyleInsert=True \
    ValueToVariable ) ${ArrayFunction[${intx}]} ; 
   done
  else
   echo -ne "Can not continue linking, no existing file:\n\tResult:${StrFile:=None}\n\tQuery:${StrFileSearch}\n" > /dev/stderr ; 
  fi 

  unalias find ;
 }
 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n" ;
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrRootOrigin,IsMake,StrAction,StrFileSearch,StrAliasFind,StrLinkFormat,StrLinkApps,StrLinkOpt,StrDebugLink,IsRenameDest,StrMoveSuffix \
  VTVIsValueReAssign=True \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StartServices
 fi

 
}

### ************************************************************************
### **** Exception                                                      ****
### ************************************************************************
### This is just a Fast-loader, reconverting ArrayArg[n] taked from inline 
### command, this also what will create ZenityRadioOptionConfig, 
### ZenityListOptionConfig, ZenityPrefixedVarBuilder suite, a series of 
### fast-loader, to manage more easily pre-fixed variables... 

function FMakeLink() 
{ 
 local __call_locality=(FML FMakeLink);
 local ArrayArg=( $* );
 local Arg0=${ArrayArg[0]} ;
 MLDoPostAction=False MLLinkDisplayDebug=True MLFileSearch=${Arg0} MakeLink;
 MLDoPostAction=True MLLinkDisplayDebug=False MLFileSearch=${Arg0} MakeLink
}


unset AutoChown ;
function AutoChown()    
{ 
 local __call_locality=( AC AutoChown ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]};
 local StrUser=${ACUser:=maxiste.maxiste} ; 
 local IntSleep=${ACSleep:=30} ; 
 local IsPathRecurr=${ACRecurrent:=True} ; 
 local StrApps=${ACChownApps:=chown} ; 
 local IsLoop=${ACLooping:=True}
 local StrPathList=${ACPathList:=Path1:Path2} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 
 function __main_StartServices()
 {
  local __call_locality=( Main __main_StartServices ) ;
  local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]};
  local ArrayPath=( ${StrPathList//:/ } ) ; 
  
  eval $( BVTIdType=0 BVTVarName=StrRecurrent BVTVarHold='-R' BVTBoolVarName=\${IsPathRecurr} BVTBoolCase=False BVTBoolAssertion='' BVTScopeTest=local BoolVarTest ) ; 
  eval $( BVTIdType=0 BVTVarName=IntXWh BVTVarHold='1' BVTBoolVarName='\${IsLoop}' BVTBoolCase=False BVTBoolAssertion='0' BVTScopeTest=local BoolVarTest ) ; 
  
  while [ ${IntXWh} -eq 1 ] ; do 
    for (( x=0 ; x <= ${#ArrayPath[@]}-1 ; x++ )) ; do 
     local StrPathName=${ArrayPath[${x}]} ; 
     chown ${StrUser} ${StrPathName} ${StrRecurrent} ; 
    done ; 
    if [ "${IsLoop}" == "False" ] ; then 
     IntXWh=0 ; 
    fi 
   sleep ${IntSleep} ; 
  
  done
 }
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  StrUser=${StrUser}               \
  IntSleep=${IntSleep}             \
  StrOutArrayRef=${StrOutArrayRef} \
  IsPathRecurr=${IsPathRecurr}     \
  StrApps=${StrApps}               \
  StrPathList=${StrPathList}       \
  IsLoop=${IsLoop}                 \
  __main_StartServices             ; 
  
 fi
 
 
}
 ### ZenityShellEval :
 ###
 ###
 ###	Full-length example : 
 ### Including 1 example :
 ###
 ### $> ZenityShellEval (Enter)
 ### 
 ### - It Open Windows from Zenity with parameter for Text-info in editable
 ### mode.
 ### 
 ### It Open by default a uuid-like temporary file. There is no actual was
 ### to modify the name, but assuming the implementation of ZenityShellEval
 ### imply a limited acces to shell, you might recuper information from shell
 ### or futur adding to transfert a name or simple renaming the uuid-like
 ### file-name... This is to prevent auto-execution of a script from 
 ### canned-design by playing with without having all clearly create your 
 ### shell script and/or having fully pseudo-code explained and having 
 ### confirmation of your design work... 
 ### 
 ### - Like ZenityShellEval, will reach first stage-maturity fast enought,
 ### it's possible the followed function will move into fnct_lib or fnct_lib_tool,
 ### being a method to control chuck of information like descendant script lib
 ### where fnct_debian_lib should descent from:
 ### 
 ### Level1 : ( fnct_lib or fnct_lib_tool )
 ###     |
 ###     +-----------> fnct_debian_lib ( Second Level )
 ###                          |
 ###                          +----------> { _sub_PackageRepository
 ###                                         _sub_Git
 ###                                         _sub_ssh_handler        } ( Third level and specialized chunk )
 ### 
 ### Where fnct_lib shall have all mandatory function being Really Essential.
 ### Where fnct_lib_tool shall have all common tools to create code and Interract
 ### with UX ( User Experience. )
 ### 
 ### Note: UX, like HP-UX, for Home-Profesionnal User-eXperience, and not UX for Unix/*nix 
 ### 
 ### Example of code for ZenityShellEval
 ### 
 ### Assuming you are looking to link fastly unpacked .deb from File-manager into
 ### Unusual path and wanting to link against correct uses nvidia-driver to 
 ### possibly manage a fake instance of CUDA from not-wished Capable-Card like 
 ### Geforce 7000M, where it can exist at leat 4 to 8 node of CUDA GPU which is
 ### not enought because minimal number of node are 16 and higher and willing 
 ### to create so-cheap demo card around 1999-2002 in displaced time-and-space
 ### 
 ### - So having to find all nvidia .so lib, it should be linked inside 
 ### /usr/lib/nvidia-304.84 which is your memory having merely remember the 
 ### automated design from version 295.xx . 
 ### Following that you bring into /usr/lib/lib*.so.1, /usr/lib/lib*.so.[3-5]
 ### all other linked lib found inside /usr/lib/nvidia-304.84,
 ### 
 ### In Other term it's
 ### Also seed to uses X from Xorg with the nouveau driver and wich to use 
 ### the entire GPU memory location and VDPAU reserved operation for GPUing.
 ### Like a package allowing to store image into GPU memory card... Having
 ### feeling many slice of superposed image is just a matrix canonical-form
 ### of code assembly to re-interpret into real execution... 
 ### 
 ### the sample to put inside the Zenity Text-Info in editable mode :
 ### 
 ### ----------------------------- SAMPLE ----------------------------- 
 ### 
 ### function test_expr()
 ### {
 ###   local __call_locality=( Filter __filter ) ;
 ###   local Arg0=${ArrayArg[0]} ;
 ###   local ArrayArg=( $* ) ; 
 ###   local StrPath=/usr/local/src/apt/nvidia-304 ;
 ###   function __filter()
 ###   {
 ###     local __call_locality=( Filter __filter ) ;
 ###     local Arg0=${ArrayArg[0]} ;
 ###     local ArrayArg=( $* ) ; 
 ###     local StrFilterGrep=${FilterGrep:='lib32'} ;
 ###     local StrTaillingSearch={FilterTrSearch:=[:cntrl:]};
 ###     local StrTaillingRepl=${FilterTrReplace:=' '} ;
 ###     grep -v "${StrFilterGrep}" | tr '${StrTaillingSearch}' '${StrTaillingRepl}' ; 
 ###   }
 ###   local AF=( $( find ${StrPath} -type f -iname "*.so*" | __filter ) ) ; 
 ###   for (( x=0 ; x<= ${#AF[@]}-1; x++ )) ; do 
 ###    item=${AF[${x}]} ; 
 ###    local _file=( ${item//\// }  ) ; 
 ###    local file="${_file[$((${#_file[@]}-1))]}" ;
 ###    echo ln -s ${item} $(pwd)/${file} ; 
 ###   done
 ### }
 ### test_expr ; 
 ### ----------------------------- SAMPLE ----------------------------- 
 ### 
 ### You hit Enter or OK from the Window 'Shell Evaluation command', and 
 ### Should not give you an error, if so the same code reapear and you 
 ### have to find yourself the error if ZenityShellEval was not executed
 ### from allowed Terminal or Windows-shell . 
 ### If you do executed it from, you can read error and seemlesly seek for 
 ### error... 
 ### 
 ### - Later example might have support for error like puting into warning 
 ### Windows, error. And possibly conversion between uuid-like file into 
 ### finite name... 
 ### 
 ### PS: Hint:
 ###  - Using AutoChown will also let use execute the script with your own
 ### user and group, and might allow you to put it elsewhere like into 
 ### localized-execution section..... 
 ### 
 ### 
 
 
eval $( GFCFuncName=ZenityShellEval GlobalFunctionCleaning ) ;
#unset ZenityShellEval ;
function ZenityShellEval()    
{
 function Verbosis()
 {
  local -a ArrayArg=( $* ) ;
  local -a __call_locality=( Verb Verbosis ) ; 
  local Arg0=${ArrayArg[0]} ; 
  local StrMsg=${VerbMsg:=__TEXT__} ; 
  local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
  local IsDisplayFormatted=${VerbFormated:=True} ;
  local IsAppendMode=${VerbAppendDev:=False} ; 
  local IsExtendedOutput=${VerbExtendedOut:=False} ; 
  local ArrayArg=( $* ) ; 
  if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
    if [ "${IsAppendMode:=False}" == "True" ] ; then 
      echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
    else  
      echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
    fi
   else
    if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
     if [ "${IsExtendedOutput:False}" == "True" ] ; then 
       echo -ne "${StrMsg}" ;  
     else
       echo "${StrMsg}" ;  
     fi
    else
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
      if [ "${IsExtendedOutput:False}" == "True" ] ; then 
        echo -ne "${StrMsg}" >> ${StrDevOut} ;
      else
        echo "${StrMsg}" >> ${StrDevOut} ;
      fi
     else
      if [ "${IsExtendedOutput:False}" == "True" ] ; then 
       echo -ne "${StrMsg}" > ${StrDevOut} ;
      else
       echo "${StrMsg}" > ${StrDevOut} ;
      fi 
     fi
    fi 
   fi 
  fi
 } 
 ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
 if [ "${versionCA:=0.0.0}" == "0.0.0" ] ; then  
  local -a ArrayArg=( $* ) ; 
  local -a __call_locality=( ZSE ZenityShellEval ) ;
  local Arg0=${ArrayArg[0]};
  local StrStartMain=${ZSEFuncStart:=__main_StartServices} ;
 elif [ "${versionCA:=0.0.0}" == "0.0.1" ] ; then  
  eval $( eval CAFunctName=ZenityShellEval CAIsAddParent=False __Call_Argument ) ; 
 elif [ "${versionCA:=0.0.0}" == "0.0.2" ] ; then  
  eval $( eval CAFunctName=ZenityShellEval CAIsAddParent=False CallArgument )  ; 
 fi
 

 local IntSleep=${ZSESleepInterval:=5}  ;
 local IntFontSize=${ZSEFontSize:=12}   ;
 local StrFontFamily=${ZSEFontFamily:=Monospace} ;  
 local IsEditField=${ZSEEditable:=True} ; 
 local IsAddFootPrint=${ZSEAddFootPrint:=True} ; 
 local StrTitle=${ZSEZenityTitle:='Shell Evaluation command'} ;
 local StrDateFormat=${ZSEDateFormat:=%Y%m%d-%H:%M:%S,%s}
 local IntDefaultModeExec=${ZSEChmodFileExec:=775} ;
 local StrFilePath=${ZSEPathStorage:=./} ; 
 local StrFileName=${ZSEFileName:=None} ;
 local IntWidth=${ZSEWindowWidth:=640} ;
 local IntHeight=${ZSEWindowHeight:=400} ;
 local IsLoopOnSucc=${ZSELoopOnSucc:=True} ; 
 local IsCheckSumOnly=${ZSECheckSumTest:=False} ; 
 local BoolDisplayDebug=${ZSEDisplayDebug:=False} ; 
 local StrCheckBoxAgree=${ZSECHReadyTxt:=I am ready to save this file and add a checksum certification.} ; 
 local StrVarList="StrStartMain,TmpUUIDEdit,IntSleep,IntFontSize,IsEditField,IsAddFootPrint,StrTitle,StrFileName,StrDateFormat,IntDefaultModeExec,StrFilePath,IntWidth,IntHeight,IsLoopOnSucc,IsCheckSumOnly,BoolDisplayDebug,StrVarList" ; 
 local -a ArrayMsg=( ) ; 
 
 ArrayMsg[0]="#!/bin/bash\n###\n### FootPrint Added, see Prefixed-Var ZSEAddFootPrint from ZenityShellEval\n###\n\n###File:__FILE__\n###UUID-TIME-MARKER:__UUID_MAKER__\n###Date: __DATE_CONFIRM__\n###Sha1Sum: __SHA1SUM__\n###Size:__SIZE__\n###NbLine: __NB_LINE__\n###NbWord: __NB_WORD__\n\n" ; 
 ArrayMsg[1]="###\n### THIS IS NOT A FOOTPRINT, ONLY CONFIRMATION of This code was parsed and do not return error after parsing.\n###No FootPrint Added, see Prefixed-Var ZSEAddFootPrint from ZenityShellEval\n###\n###\n###\n###\n###\n###\n###\n###\n###\n"
 ArrayMsg[2]="Note: New FileName : __FILE__ " ; 
 ArrayMsg[3]="### FileName: __FILE__" ; 
 ArrayMsg[4]="Re-opening File : __FILE__ " ; 
 ArrayMsg[5]="User Shell evaluation reported error" ; 
 ArrayMsg[6]="User cancel the test." ; 
 ArrayMsg[7]="Quitting Function :__FUNCT__" ; 
 ArrayMsg[8]="Removing temporary UUID Holder : File: __TMP__/__UUID__" ; 
 ArrayMsg[9]="\n\tFile: __FILE__\n\tFootprint: __CHECKSUM__" ; 
 ArrayMsg[10]="file-shasum:__PATH__/__FILE__:__DIGEST__" ; 
  
 ### 
 ### FootPrint Section
 ###
 ###
 function _NoFootPrint()
 {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( _NFP NoFootPrint ${StrParentApps} ) ;
   local Arg0="${ArrayArg[0]}" ;
   VerbMsg="Entry in function" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
   local StrMsg=$( ZenityShellEval --get ArrayMsg[1] ) ; 
   VerbMsg="${StrMsg}" VerbExtendedOut=True VerbEvalForm=True VerbFormated=False VerbState=True VerbDev=${StrFileTmp} Verbosis ; 
 }
 
 function _FootPrint()
 {
   local -a __call_locality=( FP _FootPrint ${StrParentApps} ) ;
   local -a ArrayArg=( $* ) ;
   local Arg0="${ArrayArg[0]}" ;
   VerbMsg="Entry in function" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
   local StrUUID=$( uuidgen -t ) ; 
     
   local StrSha1Sum=$( /usr/bin/sha1sum ${StrFileContent} | cut -d ' ' -f 1 ) ; 
   #rm -f ${HOME}/${StrUUID} ; 
   local StrSize=$( /usr/bin/wc -c ${StrFileContent} | cut -d ' ' -f 1 ) ; 
   local StrNbWord=$( /usr/bin/wc -w ${StrFileContent} | cut -d ' ' -f 1 ) ; 
   local IntNbLine=$( /usr/bin/wc  -l ${StrFileContent} | cut -d ' ' -f 1 ) ; 
   local StrDateFoot=$( GODFormat="${StrDateFormat}" GetOtherDate ) ;
   local StrMsg=$( ZenityShellEval --get ArrayMsg[0] ) ; 
   StrMsg=${StrMsg//__NB_WORD__/${StrNbWord}}; 
   StrMsg=${StrMsg//__SIZE__/${StrSize}};
   StrMsg=${StrMsg//__SHA1SUM__/${StrSha1Sum}};
   StrMsg=${StrMsg//__DATE_CONFIRM__/${StrDateFoot}};
   StrMsg=${StrMsg//__UUID_MAKER__/${StrUUID}};
   StrMsg=${StrMsg//__FILE__/${StrFileTmp}};
   StrMsg=${StrMsg//__NB_LINE__/${IntNbLine}};
   
   VerbMsg="File To write:${StrFileTmp} FootPrint:${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr Verbosis ; 
   VerbMsg="${StrMsg}" VerbExtendedOut=True VerbEvalForm=False VerbFormated=False VerbState=True VerbDev=${StrFileTmp} Verbosis ; 
   
 }
 
 function _DetectFootPrint()
 {
  local -a __call_locality=( DFP _DetectFootPrint ${StrParentApps} ) ;
  local -a ArrayArg=( $* ) ;
  local Arg0="${ArrayArg[0]}" ;
  VerbMsg="Entry in function" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
  local IntFootPrintDetection=$( echo -ne "${CmdEval}" | head -n 11 | egrep -ic "FootPrint" ) ;
  eval $( eval \
    BVTVarName=StrFootPrintMark \
    BVTVarHold='$( StrDateFormat=${StrDateFormat} CmdEval=${CmdEval} _FootPrint )' \
    BVTBoolVarName=\${IsAddFootPrint} \
    BVTBoolCase=False \
    BVTBoolAssertion='$( _NoFootPrint )' \
    BVTScopeTest=local BVTIdType=0       \
    BoolVarTest ) ;
 } 
 ###
 ### End FootPrint
 ###

 function MainEditor()
 {
  local -a ArrayArg=( $* ) ;
  local -a __call_locality=( ME MainEditor ${StrParentApps} ) ;
  local Arg0=${ArrayArg[0]} ;
  local StrMsg=""
  VerbMsg="Entry in function" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
    
  if [ ! -f ${StrFileTmp} ] ; then 
   touch ${StrFileTmp} ; 
  fi
  #test ! -e ${StrFileTmp} && echo "" > ${StrFileTmp} ; 
  
  local IntRes=1 ; 
  local IntShellRes=0 ; 
  local IntShellQuit=0 ; 
  eval $( BVTIdType=0                \
          BVTVarName=StrEditableAttr \
          BVTVarHold=\'--editable\'  \
          BVTBoolVarName=\${IsEditField:=True} \
          BVTBoolCase=False          \
          BVTBoolAssertion=''        \
          BVTScopeTest=local         \
          BoolVarTest                ) ; 
  #local -a ArrayMsg=( ) ; 
  
  if [ ! -f ${StrFileTmp} ] ; then 
   StrMsg=$( ZenityShellEval --get ArrayMsg[2] ) ; 
   StrMsg=${StrMsg//__FILE__/${StrFileTmp}} ; 
   VerbMsg=${StrMsg} VerbHeader="MESSAGE" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
   StrMsg=$( ZenityShellEval --get ArrayMsg[3] ) ; 
   StrMsg=${StrMsg//__FILE__/${StrFileTmp}} ; 
   VerbMsg=${StrMsg} VerbHeader="MESSAGE" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
  elif [ -f ${StrFileTmp} ] ; then 
   StrMsg=$( ZenityShellEval --get ArrayMsg[4] ) ; 
   StrMsg=${StrMsg//__FILE__/${StrFileTmp}} ; 
   VerbMsg=${StrMsg} VerbHeader="MESSAGE" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
  fi   
  #test ! -e ${StrFileTmp} && echo -ne "\n\nNote: New FileName : ${StrFileTmp} \n\n" > /dev/stderr ; 
  #test ! -e ${StrFileTmp} && echo -ne "\n\n### FileName: ${StrFileTmp}\n\n" > ${StrFileTmp} ; 
  #test -e ${StrFileTmp} && echo -ne "\n\nRe-opening File : ${StrFileTmp} \n\n" > /dev/stderr ; 
  
  ### Header calculation of line :
  local IntHeaderLength=$( ZenityShellEval --get ArrayMsg[0] | wc -l ) ; 
  
  ### Current detection of footprint:
  local IntHeaderDetec=$( egrep -ic "### FootPrint Added" ${StrFileTmp}  ) ; 
  ### Copy File into Local HOME/path and removing the header and avoid to overwrite the initial 
  ### Protected file 
  local IntNbLineInFile=0 ; 
  local IntNbLineNoHeader=0 ; 
  IntNbLineInFile=$( wc -l ${StrFileTmp} | cut -d ' ' -f1  ) ;  
  ### Depend presence of header there is N-amount of line less the header or
  ### only N-line if header is not present: 
  if [ ${IntHeaderDetec:=0} -gt 0 ] ; then 
    IntNbLineNoHeader=$(( ${IntNbLineInFile} - (( ${IntHeaderLength} - 2 )) )) ; 
  else 
   IntNbLineNoHeader=${IntNbLineInFile} ; 
  fi 
  StrMsg="Temporary file stats: IntNbLineInFile:__INTA__ IntNbLineNoHeader:__INTB__" ;
  StrMsg=${StrMsg//__INTA__/${IntNbLineInFile}}  ; 
  StrMsg=${StrMsg//__INTB__/${IntNbLineNoHeader}}  ; 
  VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
  
  
  
  #test -e ${StrFileTmp} &&  
  if [ -f ${StrFileTmp} ] ; then 
   tail -n ${IntNbLineNoHeader} ${StrFileTmp} > ${HOME}/${TmpUUIDEdit}  ; 
  fi
  
  StrMsg=$( ZenityShellEval --get ArrayMsg[2] ) ;
  StrMsg=${StrMsg//__FILE__/${HOME}/${TmpUUIDEdit}}  ; 
  VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
     
  while [ ${IntRes} -eq 1 -a ${IntShellQuit} -eq 0 ] ; do 
   local CmdEval=$( zenity \
              --text-info ${StrEditableAttr} \
              --font="${StrFontFamily} ${IntFontSize}" \
              --filename=${HOME}/${TmpUUIDEdit} \
              --title="${StrTitle}" \
              --width=${IntWidth} \
              --height=${IntHeight} \
              --checkbox="${StrCheckBoxAgree}" ) ; 
   IntRes=$? ; 
   if [ ${IntRes} -ne 1 ] ; then 
     local StrTypePrint="_NoFootPrint"
     if [ "${IsAddFootPrint:=False}" == "True" ] ; then 
      StrTypePrint="_FootPrint" ;
     fi 
     VerbMsg="Type of FootPrint: ${StrTypePrint}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
     
     local StrUUID=$( uuidgen -t ) ; 
     local StrFileContent=${HOME}/${StrUUID}
     
     VerbMsg="${CmdEval}"  \
     VerbExtendedOut=False \
     VerbEvalForm=False    \
     VerbFormated=False    \
     VerbState=True        \
     VerbDev=${StrFileContent} Verbosis ;      
     
     VerbMsg="File StrFileContent Location: ${StrFileContent}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
     
     ### For Function _NoFootPrint and _FootPrint
     ### It SHOULD write down to the file 
     ### the header first so we can use a Verbosis with 
     ### VerbAppendDev=True to Append with rest of the 
     ### Command edited previously . 
     ### 
     eval $( eval VTVIsArrayStyleInsert=True  \
        VTVValueEntry=${StrVarList},StrFileContent \
        VTVIsValueReAssign=True     \
        VTVIsValueToConvert=False   \
        VTVIsQuotedValue=True       \
        ValueToVariable ) ${StrTypePrint} ; 

    local StrStreamContent=$( cat ${StrFileContent} ) ; 
    VerbMsg="${StrStreamContent}" VerbAppendDev=True VerbExtendedOut=False VerbEvalForm=False VerbFormated=False VerbState=True VerbDev=${StrFileTmp}  Verbosis ;
    
    /bin/chmod ${IntDefaultModeExec} ${StrFileTmp} ; 
    . ${StrFileTmp} ; 
    IntShellRes=$?
    StrMsg=$( ZenityShellEval --get ArrayMsg[5] ) ; 
    if [ ${IntShellRes:=1} -eq 1 ] ; then 
     VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-MESSAGE" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
     IntRes=1 ; 
     IntShellRes=1 ; 
    fi 
   else 
     StrMsg=$( ZenityShellEval --get ArrayMsg[6] ) ; 
     VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-MESSAGE" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
    IntShellQuit=1 ; 
   fi ; 
   sleep ${IntSleep} ; 
   if [ ${IntRes:=1} -eq 0 -a ${IntShellRes:=1} -eq 0 ] ; then 
     eval $( eval       \
     BVTIdType=0        \
     BVTVarName=IntRes  \
     BVTVarHold='0'     \
     BVTBoolVarName=\${IsLoopOnSucc:=False} \
     BVTBoolCase=False  \
     BVTBoolAssertion='1'       \
     BVTScopeTest=local \
     BoolVarTest ) ; 
   fi 
  done
  
  StrMsg=$( ZenityShellEval --get ArrayMsg[7] ) ; 
  StrMsg=${StrMsg//__FUNCT__/${__call_locality[1]}} ; 
  VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-MESSAGE" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
  
  StrMsg=$( ZenityShellEval --get ArrayMsg[8] ) ; 
  StrMsg=${StrMsg//__TMP__/${HOME}} ;
  StrMsg=${StrMsg//__UUID__/${TmpUUIDEdit}} ;
  VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-MESSAGE" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
  
  rm -f ${HOME}/${TmpUUIDEdit} ${StrFileContent} ; 
 }
 
 function MainCheckSum()
 {
  local __call_locality=( MCS MainCheckSum ) ;
  local ArrayArg=( $* ) ;
  local Arg0=${ArrayArg[0]} ;
  VerbMsg="Entry in function" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
  
  local IntNbSizeFileSum=$( cat ${StrFilePath}/${StrFileName} | grep "^###Size:" | sed 's/\(###Size:\)//g' ) ; 
  local IntSizeTotal=$( wc -c ${StrFilePath}/${StrFileName} | cut -d ' ' -f 1 ) ; 
  IntNbLineFileSum=$(( IntNbLineFileSum -1 )) ; 
  ### replaced Mechanically extract with dd  in size of file reported by header from skipping the difference of the file size and thus report the the valid sha1sum to apply
  ### Nb-line does not work for not starting to a specific line and sha1sum does add extra space
  ### inside the diget. 
  ### cat ${StrFilePath}/${StrFileName} | grep -v "^###" | /usr/bin/sha1sum | cut -d ' ' -f 1 
  ### Getting the checksum by computed NbLine-1 of file to sum . 
  local CheckSumFile=$( dd if=${StrFilePath}/${StrFileName} bs=1 skip=$(( ${IntSizeTotal} - ${IntNbSizeFileSum} )) count=${IntNbSizeFileSum} 2> /dev/null | /usr/bin/sha1sum | /usr/bin/cut -d ' ' -f 1 ) ; 
  ### Getting the Checksum from the header-file.
  local CheckSumIdentity=$( cat ${StrFilePath}/${StrFileName} | grep "^###Sha1Sum:" | cut -d ' ' -f 2  | sed 's/[\ \t]//g' ) ;
  local ArrayResult=( MATCH FAILED ) ; 
  local IntResult=0 ; 
  
  StrMsg=$( ZenityShellEval --get ArrayMsg[9] ) ; 
  StrMsg=${StrMsg//__FILE__/${CheckSumFile}} ; 
  StrMsg=${StrMsg//__CHECKSUM__/${CheckSumIdentity}} ; 
  VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DIGEST" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
  
  
  if [ "${CheckSumFile}" != "${CheckSumIdentity}" ] ; then 
   IntResult=1 ; 
  fi 
  
  StrMsg=$( ZenityShellEval --get ArrayMsg[10] ) ; 
  StrMsg=${StrMsg//__PATH__/${StrFilePath}} ; 
  StrMsg=${StrMsg//__FILE__/${StrFileName}} ; 
  StrMsg=${StrMsg//__DIGEST__/${ArrayResult[${IntResult}]}} ; 
  VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DIGEST" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 

 }

 function __main_StartServices()
 {
  local __call_locality=( Main __main_StartServices ) ;
  local Arg0=${ArrayArg[0]} ;
  local ArrayArg=( $* ) ; 
  VerbMsg="Entry in function" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
  
  ### Note: f1161962-0ad8-11e3-b166-001b3875b29c 
  ### 
  ### Title : Variable Forwarding Example in BoolVarTest & mutation 
  ### of BoolVarTest from True/False test into None
  ### 
  ### BoolVarTest for substitution of StrFileTmp has unidirectionnaly
  ### a uuid-like file name into Pre-fixed Var ZSEFileName:=None for 
  ### affectation inside StrFileName=None, where if this one != None, will 
  ### get the parameter Name Being passed inside StrFileTmp. 
  ### 
  ### - Had consequence:
  ###  - if the file does not exist, an echo > StrFileTmp will be done . 
  ###  - if the file exist, content will be open by Zenity in text-info --editable
  ###  - Selected filename supplied, content will be overwritted and there is 
  ###  no protection mechanism and no verification against file-permission
  ###    - To this, a workaround will store all code generated from this application
  ###    - into sub-directory being made by the command and store-it inside user
  ###      respective home location which is safe and Pre-fixable into 
  ###      your specification, and not-warrented to be correct but designable. 
  ###  
  ### 
  ### - If the variable ZSEFileName is untouched, the content of StrFileTmp will
  ### hold value 'None' and belong to parsed BoolVarTest it should 
  ### get it's uuid-like filename, see generated command from parameter below
  ### 
  ### Command : BVTVarName=StrFileTmp BVTVarHold='${StrFileName}' BVTBoolVarName=\${StrFileName} BVTBoolCase=None BVTBoolAssertion='$( uuidgen -t )' BVTScopeTest=local BoolVarTest
  ### 
  ### generated code:
  ### local StrFileTmp="${StrFileName}" ; 
  ### if [ "${StrFileName}" == "None" ] ; then 
  ###  StrFileTmp=$( uuidgen -t ) ; 
  ### fi
  ### 
  ### Which is making sense. 
  ### 
  ### Also Note f1161962-0ad8-11e3-b166-001b3875b29c introduce explanation on mutation of BoolVarTest from True/False test into None and moving uuid-file-id variable inside BVTBoolAssertion
  ### 
  ### 
  eval $( eval BVTIdType=0        \
          BVTVarName=StrFileTmp   \
          BVTVarHold='${StrFilePath}/${StrFileName}' \
          BVTBoolVarName=\${StrFileName:=None}       \
          BVTBoolCase=None        \
          BVTBoolAssertion='${StrFilePath}/${TmpUUIDEdit}' \
          BVTScopeTest=local      \
          BoolVarTest ) ;  
  StrMsg="Value StrFileName:__FILE__" ; 
  StrMsg=${StrMsg//__FILE__/${StrFileName}} ; 
  VerbMsg=${StrMsg} VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
  
  ### Definition of StrActionClause
  ### 2 action are performed inside the variable StrActionClause, both using 
  ### at 2 moments BoolVarTest it construct a TypeIf 4 and 5 . 
  ### Require BVTIdType=4 to build the first member it:
  ### - It's not coming with a preambule or SHALL add Prefixed-Variable build here with BVTVarName=IsCheckSumOnly BVTVarHold=\${ZSECheckSumTest:=False}, to respect introduction of function and Possibly have paremeter to start the SHA1SUM action between content of a chunk and proposed file . In this case it's separated for reason ( not filtered by GetVarReference and being absent of helper-documentation. )
  ###  -Don't need BVTVarName BVTVarHold for first part . 
  ###  
  ###  - BVTIdType=4 is in reference with BVTType, type 
  ###  4 : will produce a [ if __STATEMENT__ else ] Statement or between 'if' and 'else', it will:
  ###   - Contain an Assertion, since we haven't filled criterion of Preambule. 
  ###   - THIS mean only have to fill either BVTBoolAssertion for variable assignation, BVTVarName if we do obtain a value from clause out of a Preambule like variable already managed and require something else. Imagine a seach where item is not found and declare before the loop to 0 and in this case element In assertion is IsCheckSumOnly become true after loop control information , so filling BVTVarName is usefulll and BVTBoolAssertion to say We-found it. THIS CASE suggestion another uses of Assertion , using BVTIsValueToVarAssert suggest a transfert of variable in case we are calling a function. Required BVTIsValueToVarAssert=True BVTVTVVarA for the list of variable, BVTVTFnctA for function name it's the minimalitic Prefixed variable to fill . 
  ###    - Producing if __STATEMENT__ ; then __ASSERTION__ else ; where Assertion is the ValueToVariable information. 
  ###  5 : will produce a [  __STATEMENT__ fi ] Statement or after else which is already declared inside  previous BoolVarTest BVTIdType=4. Preambule is useless since we are inside the Assertion. So only section of  BVTVTVVarA BVTVTFnctA require to be filled for another ValueToVariable where __main_Editor is the function onto not choosing to validate a file. 
  ###  
  ### so Building a if - else  - fi ; require 2 call of BoolVarTest .   

  local StrActionClause=$( BVTIdType=4 BVTConclude=';' BVTIsPreambule=False BVTBoolVarName="\${IsCheckSumOnly:=False}" BVTBoolCase=True BVTIsValueToVarAssert=True BVTVTVVarA="StrFilePath,StrFileName" BVTVTFnctA=MainCheckSum  BoolVarTest ; BVTIdType=5 BVTConclude=';' BVTIsPreambule=False BVTIsValueToVar=False BVTIsValueToVarAssert=True BVTVTVVarA="${StrVarList}" BVTVTFnctA="MainEditor" BoolVarTest ) ; 
  
  ### Should replace next statement :
  # if [ "${IsCheckSumOnly}" == "True" ] ; then 
  #  eval $( VTVValueEntry=StrFilePath,StrFileName VTVIsValueReAssign=True VTVIsValueToConvert=False VTVIsArrayStyleInsert=True ValueToVariable ) MainCheckSum ; 
  # else 
  #  eval $( VTVValueEntry=${StrVarList} VTVIsValueReAssign=True VTVIsValueToConvert=False VTVIsArrayStyleInsert=True ValueToVariable ) MainEditor  ; 
  # fi
  StrMsg="Value IsCheckSumOnly:__VAR__ StrActionClause:__IF__" ; 
  StrMsg=${StrMsg//__IF__/${StrActionClause}} ; 
  StrMsg=${StrMsg//__VAR__/${IsCheckSumOnly}} ; 
  VerbMsg=${StrMsg} VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 

  eval $( eval ${StrActionClause} ) ;   

 }
 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;

 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
  eval $( __GetVarReferenceCompWord ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  local TmpUUIDEdit=$( GetUIDRegister=True GetUAppsRegisterName=${__call_locality[1]} GetUUID )
  StrMsg="Application:${__call_locality[1]} , version:( versionCA:__VER_CA__, versionBVT:__VER_BVT__)" ; 
  StrMsg=${StrMsg//__VER_CA__/${versionCA}} ;
  StrMsg=${StrMsg//__VER_BVT__/${versionBVT}} ;
  VerbMsg=${StrMsg} VerbHeader="VERSION" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
  VerbMsg="Entry in function ${StrStartMain}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis ; 
  eval $( eval VTVIsArrayStyleInsert=True  \
          VTVValueEntry=${StrVarList} \
          VTVIsValueReAssign=True     \
          VTVIsValueToConvert=False   \
          VTVIsQuotedValue=True       \
          ValueToVariable ) ${StrStartMain} ; 
 fi


}



 ### StartCoproc :
 ###
 ###
 ###	Full-length example : 
 ### Including 
 ###
 ###
 ###
 ###
 ###
 ###
 ###
 ###
 ###



unset StartCoproc
function StartCoproc()
{ 
 local ArrayArg=( $* ) ; 
 local __call_locality=( StartCoproc ) ; 
 local Arg0=${ArrayArg[0]} ; 
 ### Prototype model, 
 ### - Require . /etc/init.d/Fnct.d/_sub_Git to work. 
 ### coproc git_fnct_debian { while [ ${res:=0} -ne 1  ] ; do res=$( GitHubCommitFilePath=/etc/init.d/Fnct.d  GitHubCommit fnct_debian_lib ) ; sleep 5 ; done ; }
 local StrValueParserInfo="""
 VPCallLocalityName=${__call_locality[0]} 
 VPVarArgList=Str:ProcName,
              Str:InWhile,
              Str:WhCond,
              Str:WhRetStat,
              Str:AppsName,
              Str:AppsPrVar,
              Str:AppsOpt
 VPScopeList=ProcName:local,
              InWhile:local,
              WhCond:local,
              WhRetStat:local,
              AppsName:local,
              AppsPrVar:local,
              AppsOpt:local,
 VPValueList=DefaultCoprocName:True:__VAR__ -ne 1:__VAR__=\$( __CMD__ ):GitHubCommit:GitHubCommitFilePath=${FNCTDLIBPATH}:fnct_debian_lib
 """ ;
 
 eval $( eval "${StrValueParserInfo} ValueParser " ) ;
 local EvalCoprocCmd=( ${StrAppsPrVar} ${StrAppsName} ${StrAppsOpt} ) ; 
 #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${Arg0:=--startservices}" == "--help" ] ; then 
  GetVarReference StartCoproc ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  eval ${StrValueParserInfo} ValueParser --varhelper
  echo -ne "--asarray\tStart The application and output the content into an Array, see varriable                               PkgConfigAllArrayName to change the name. This command need an eval braced                              to get the array being initialized.\n\n"
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ; 			
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  echo ""
  ### Prog To create a coprocess 
  #if [ ${StrInWhile} ]
 fi
}


### Package Query function. 
### give by-package, many option at once. 
### 
### Single package:
### ex: GetPackage=flac PkgConfigQuery --cflags --libs
### 
### will output:
### 
### flac:--cflags:-I/usr/include/FLAC  
### flac:--libs:-lFLAC -lm  
### flac++:--cflags:-I/usr/include/FLAC++ -I/usr/include/FLAC  
### flac++:--libs:-lFLAC++ -lFLAC -lm  
### 
###
### Many Package : 
### ex: GetPackage=samplerate,flac PkgConfigQuery --cflags --libs 
### samplerate:--cflags: 
### samplerate:--libs:-lsamplerate  
### flac:--cflags:-I/usr/include/FLAC  
### flac:--libs:-lFLAC -lm  
### flac++:--cflags:-I/usr/include/FLAC++ -I/usr/include/FLAC  
### flac++:--libs:-lFLAC++ -lFLAC -lm  


function PkgConfigQuery()
{ 
 local ArrayArg=( $* );
 local __call_locality=( PkgQuery ) ;
 local Arg0=${ArrayArg[0]:=--start} ; 
 local ArrayArgFlag=( ${ArrayArg[@]:1} ) ; 
 local IntArgLen=${#ArrayArgFlag[@]} ;
 local StrValueParserInfo="VPCallLocalityName=${__call_locality[0]} VPVarArgList=Str:AppsName,Str:AppsOpt,Str:FlagList,Str:PackageList VPScopeList=AppsName:local,AppsOpt:local,FlagList:local,PackageList:local VPValueList=/usr/bin/pkg-config:--list-all:--libs,--static,--short-errors,--libs-only-l,--libs-only-other,--libs-only-L,--cflags,--cflags-only-I,--cflags-only-other:flac" ;
 
 ### Replaced by ValueParser
 #local StrPkgConfigApps=${PkgConfigQueryAppsName:=/usr/bin/pkg-config};
 #local StrPkgConfigAppsOpt=${PkgConfigQueryAppsOption:=--list-all};
 eval $( eval "${StrValueParserInfo} ValueParser " ) ;
 
 #echo -ne "StrAppsName : ${StrAppsName}\n" > /dev/stderr ;
 #echo -ne "StrAppsOpt  : ${StrAppsOpt}\n" > /dev/stderr ;
 #echo -ne "StrFlagList  : ${StrFlagList}\n" > /dev/stderr ;
 #echo -ne "StrPackageList  : ${StrPackageList}\n" > /dev/stderr ;
 
 #local StrPackageList=${PkgConfigQueryGetPackage:=flac} ;
 #local StrFlagList=${PkgConfigQueryFlagList:=--libs,--static,--short-errors,--libs-only-l,--libs-only-other,--libs-only-L,--cflags,--cflags-only-I,--cflags-only-other} ;
 local ArrayFlagTest=( ) ;
 function FilterPackageList()
 {
  local ArrayArg=( $* );
  local __call_locality=( FilterPackageList ) ;
  local StrGrepFilter=${FilterPackageListGrepFilter:=${CurrentPackage}}
  cut -d " " -f 1 | egrep -i "${StrGrepFilter}" | tr '[:cntrl:]' ' ' 
 }

  #local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 
  if [ "${Arg0:=--start}" == "--help" ] ; then 
   GetVarReference PkgConfigQuery ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
   eval ${StrValueParserInfo} ValueParser --varhelper ;
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ; 			
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 else
  if [ ${IntArgLen:=0} -eq 0 ] ; then 
   ArrayFlagTest=( ${StrFlagList//,/ } ) ; 
  else
   ArrayFlagTest=( ${ArrayArgFlag[@]} ) ; 
  fi 		
  local ArrayPackageListVar=( ${StrPackageList//,/ } ) ;
  for (( intAx=0 ; intAx <= ${#ArrayPackageListVar[@]}-1 ; intAx++ )) ; do 
   local CurrentPackage="${ArrayPackageListVar[${intAx}]}" ; 
    local _A=( $( ${StrAppsName} ${StrAppsOpt} | FilterPackageListGrepFilter=${CurrentPackage} FilterPackageList ) );
    local IntNbPackage=${#_A[@]} ;
    if [ ${IntNbPackage:=0} -gt 0 ]; then
        for ((x=0 ; x <= ${#_A[@]}-1 ; x++ )) ; do
            for (( cx=0 ; cx <= ${#ArrayFlagTest[@]}-1 ; cx++ )) ; do
                res=$( ${StrAppsName} ${_A[${x}]} ${ArrayFlagTest[${cx}]} );
                echo -ne "${_A[${x}]}:${ArrayFlagTest[${cx}]}:${res}\n";
            done;
        done;
    else
        echo -ne "\n\n\tPackage Not Found\n" > /dev/stderr;
    fi
  done 
 fi 
}

### Warning : 
### This version of pkg-config-all is aliased to pkg-config inside .bashrc of the user shell and following function 
### are also dependent of alias .
### cut -> to alias cut='/usr/bin/cut -d "'" "'" '
### pkg-config -> to alias pkg-config='pkg-config-all'
### 
### 
### 


function pkg-config-all()
{
 local __call_locality=( PkgConfigAll ) ; 
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ;
 local StrValueParserInfo="VPCallLocalityName=${__call_locality[0]} VPVarArgList=Str:ArrayName,Int:Scoping,Str:CutAlias,Str:AppsName,Str:AppsOpt VPScopeList=ArrayName:local,Scoping:local,CutAlias:local,AppsName:local,AppsOpt:local VPValueList=ArrayPackageName:1:cut:/usr/bin/pkg-config:--list-all ValueParser" ;
 
 eval $( eval "${StrValueParserInfo} ValueParser " ) ;
 ### ValueParser replace following value.
 #local StrpackageName=${PkgConfigAllArrayName:=ArrayPackageName}	;
 #local IntScoping=${PkgConfigAllScoping:=1}	;
 #local StrCutAlias=${PkgConfigAllCutAlias:=cut}	;
 #local StrPkgConfig=${PkgConfigAllApps:=/usr/bin/pkg-config} ; 
 echo -ne "Var StrAppsName: ${StrAppsName}\nVar StrAppsOpt: ${StrAppsOpt}\n" > /dev/stderr ;
 function Main()
 {
  local ArrayScopingType=( "local" "declare -a");
  if [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
   eval "${StrAppsName} --list-all | ${StrCutAlias} -f 1" ; 
  elif [ "${Arg0:=--startservices}" == "--asarray" ] ; then 
    local StrPackageList=$( ${StrAppsName} ${StrAppsOpt} | eval "${StrCutAlias} -f 1" | tr '[:cntrl:]' ' ' ) ; 
    echo -ne "${ArrayScopingType[${IntScoping}]} ${StrArrayName}=( ${StrPackageList} )\n" ;
  fi
 }
 #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  if [ "${Arg0:=--startservices}" == "--help" ] ; then 
  GetVarReference pkg-config-all ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  eval ${StrValueParserInfo} --varhelper
  echo -ne "Following switch are available:\n\n\t--startservices\tStart the application normally and output the package list\n\t--asarray\tStart The application and output the content into an Array, see varriable                               PkgConfigAllArrayName to change the name. This command need an eval braced                              to get the array being initialized.\n\n"
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ; 			
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 else
  Arg0=${Arg0} StrAppsName=${StrAppsName} StrCutAlias=${StrCutAlias} StrAppsOpt=${StrAppsOpt} IntScoping=${IntScoping} StrArrayName=${StrArrayName} Main
 fi
}


function ObjFindFunction()
{
 local ArrayArg=( $* )	;
 local __call_locality=( ObjFindFunction ) ; 
 local Arg0=( ${ArrayArg[0]} ) ; 
 
 local StrDllFunctionFind=${ObjFindFunctionDllList:=iolog_unlink,GetUserDetailsType,GetCommandDetailsType}  ; 
 local dllFunction=( ${StrDllFunctionFind//,/ } ) ; 
 local StrObjDumpFlagsSet=${ObjFindFunctionFlagSet:=--dynamic-syms;--syms}
 local StrObjDumpApps=${ObjFindFunctionObjApps:=objdump} ;
 
 local ArrayInspecType=( ${StrObjDumpFlagsSet//;/ } ) ; 
 local StrPathStartFind=${ObjFindFunctionPath:=./} ;
 local StrDllSuffix=${ObjFindFunctionDllSearch:=*.so} ;
 local StrUniqueIDType=${ObjFindFunctionUUIDType:=--time} ;
 local StrUniqueIDTypeApps=${ObjFindFunctionUUIDType:=uuidgen} ;
 local StrPrintfFormat=${ObjFindFunctionPrintfFormat:="%h/%f"} ;
 
 function GetUniqueUUID()
 {
  local ArrayArg=( $* ) ; 
  local __call_locality=( GetUniqueUUID ) ; 
  local StrUUIDFlags=${GetUniqueUUIDFlags:=--time} ; 
  local StrUUIDApps=${GetUniqueUUIDApps:=uuidgen} ; 
  
  eval """ local StrUUID=$( ${StrUUIDApps} ${StrUUIDFlags}  ) """ ;
  echo -ne "${StrUUID}" ; 
 } ; 
 function GetFindList()
 {
  local ArrayArg=( $* ) ; 
  local __call_locality=( GetFindList ) ; 
  local StrStartPath=${GetFindListStartPath:=./} ; 
  local StrInameSuffix=${GetFindListNamePatter:=*.so} ; 
  local StrPrintfFormat=${GetFindListPrintfFormat:="%h/%f"} ; 
  
  find ${StrPathStartFind} -type f -iname "${StrInameSuffix}" -printf "${StrPrintfFormat}" ; 
 }
 function DllSearch()
 {
  local ArrayArg=( $* ) ; 
  local __call_locality=( DllSearch ) ; 
  StrDllInspectApps=${DllSearchApps:=objdump} ; 
  StrDllInspectFlagsInArg=${DllSearchFlags:=--dynamic-syms} ; 
  StrDllInspectFlags=${StrDllInspectFlagsInArg//,/ } ;
  StrFileSearch=${DllSearchFileName:=None} ; 
  StrDllFunctionName=${DllSearchFunctionName:=none} ; 
  eval """ ${StrDllInspectApps} ${StrDllInspectFlags} ${StrFileSearch} | egrep -ic "${StrDllFunctionName}" """ ; 
  
 }
 #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 
 if [ "${Arg0:=--startservices}" == "--help" ] ; then 
  GetVarReference ${__call_locality[0]} ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ; 			
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 else
  local ArrayDll=( $( GetFindListStartPath=${StrPathStartFind} GetFindListNamePatter=${StrDllSuffix} GetFindListPrintfFormat=${StrPrintfFormat} ) ) ; 
  for StrdllFunction in ${dllFunction[@]}; do 
   for (( intx=0 ; intx <= ${#ArrayDll[@]}-1 ; intx++ )) ; do 
    item="${ArrayDll[${intx}]}" ; 
    for DllTypeInspect in ${ArrayInspecType[@]} ; do 
     local UUID_T=$( GetUniqueUUIDApps=${StrUniqueIDTypeApps} GetUniqueUUIDFlags=${StrUniqueIDType} GetUniqueUUID ) ;  
     isDllfunction=$( DllSearchApps=${StrObjDumpApps} DllSearchFlags=${DllTypeInspect} DllSearchFileName=${item} DllSearchFunctionName=${StrdllFunction} DllSearch ) ; 
     dllState=${isDllfunction:=0} ; 
     echo -ne "PKID:${UUID_T}:found:${dllState}:DllInpectMeth:${DllTypeInspect}:Function:${StrdllFunction}:dllName:${item}\n" ; 
    done ; 
   done ; 
  done
 fi
 
 
}

### Default Fast reference Helper. 
### Extract current Prefixed variables from your function and show it on stdout( screen output ). 
### The prefixed variable are indicated on decalation of __call_locality which usually had same name has 
### top function. 
### Desc : It actively look inside the function code and extract value prefixed with function name...
### was initially developped on $0, but change by creating subFunction, and some code may be reserved for private
### use or recurrent-code with recurrent variable name, may be show and alter your perception of functionality of 
### the design ...

### Example to implement the body-helper. 
### 
### function Helper()
### {
###  __call_locality=( Helper ) ; 
### 	local ArrayArg=( $* ) ; 
### 	local Arg0=${ArrayArg[0]}; 
###  local StrHelperInvolved=${HelperQuestionInvolved:=Nothing} ; ### <---1a 
### 	if [ "${Arg0:=--start}" == "--help" ] ; then 
###			GetVarReference ${__call_locality[0]} ; 
###  else	
###   ---> Normal Body event and code. 
###  
###   ... 
###  fi 
### }
### 
### Note, In case your Helper --help be tested, if it does not output only Prefixed var definition.
### retreive all your variable from your command and do like example StrHelperInvolved in 1a
### Create specific local variable and associate the content of your Prefixed variables, help get 
### better body definition and reduce complexity by reading it... 
### 

### ZenityPrefixedVarSelection :
###
### Full-length example : ZPVSFunctionName=ValueToVariable  ZenityPrefixedVarSelection
###	
### ZenityPrefixedVarSelection and ZenityBuildForm are 2 set of helper declared from 
### list section, it will be easy to setup Command-line function from --list switch
### and uses of Prefixed-Variable : 
###
### example :
### ZenityBuildForm=True ValueToVariable --list
###
### - will pop you the first interface ZenityPrefixedVarSelection which
### show you selectable variable to configure or to change. We recommand 
### you to choose them even if they are true, and make them changeable on
### need . This mean Associating them to variable or leave it as same 
### value. I do decide to present a First interface for economic reason, the 
### interface of some function is so abundant in condition than it take most 
### of the screen showing you and some without screen equiped with pannig 
### factor ( virtual screen ) won't be able to push the OK or event the cancel
### Button. Once the selected variable is done the other interface is text field
### format and for all variable even True/False once require 
###
###
###

unset ZenityPrefixedVarSelection ; 
function ZenityPrefixedVarSelection()
{
 local __call_locality=( ZPVS ZenityPrefixedVarSelection ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ;
 
 local BoolDisplayDebug=${ZPVSDisplayDebug:=True} ; 
 local StrFuncName=${ZPVSFunctionName:=None} ;
 local IntHeight=${ZPVSHeight:=600} ; 
 local IntWidth=${ZPVSWidth:=400} ; 
 local StrTextWindows=${ZPVSZenityTxtWin:=Choose your Prefixed-Variable to Edit} ;
 local StrDefaultSep=${ZPVSSeparatorList:=' '} ;
 local StrTxtCheckCase=${ZPVSTxtChkName:=Prefixed-Var}
 local StrTxtListValue=${ZPVSTxtListValue:=Value} ;
 local StrDefaultSelection=${ZPVSDefaultSet:=FALSE} ; 
 local StrZenityApps=${ZPVSZenityApps:=/usr/bin/zenity} 
 local StrZenityOptWin=${ZPVSZenityOptWin:="--list --checklist --multiple"}
 local StrTagList=${ZPVSTagParserOpt:=StrZenityOptWin:__OPT__,StrZenityApps:__APPS__,IntHeight:__HEIGHT__,IntWidth:__WIDTH__,StrTextWindows:__TEXT__,StrTxtCheckCase:__COL1__,StrTxtListValue:__COL2__,StrDefaultSep:__SEP__,StrZenityListBuild:__LIST__} ; 
 local StrZenityListParser=${ZPVSZenityListOpt:="""__APPS__ __OPT__ --height=__HEIGHT__ --width=__WIDTH__ --text=\"__TEXT__\" --column=Selection --column=\"__COL1__\" --column=\"__COL2__\" --print-column=2 --separator='__SEP__ ' __LIST__ """} ; 
 local StrTransfertFunc="" ; 
 local StrFunctionMain=${ZPVSFunctionCall:=__main_StartServices} ; 
 local StrParentApps="${__call_locality[1]}" ; 
 
 local StrVarList="BoolDisplayDebug,StrDefaultSelection,StrFuncName,IntWidth,IntHeight,StrTextWindows,StrDefaultSep,StrTxtCheckCase,StrTxtListValue,StrZenityListParser,StrZenityApps,StrZenityOptWin,StrTagList,StrParentApps,StrFunctionMain" ; 

 function Verbosis()
 {
  local __call_locality=( Verbosis Verb );
  local StrMsg=${VerbMsg:=__TEXT__} ; 
  local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
  local IsDisplayFormatted=${VerbFormated:=True} ;
  local ArrayArg=( $* ) ; 
  if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
    echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
    if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
     echo "${StrMsg}" ;  
    else
     echo "${StrMsg}" > ${StrDevOut} ;
    fi 
   fi 
  fi
 } 
 ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis

 ### Function BuildListInformation:
 ### Because this part is usefull to build a list for Selection, aka :
 ###  Transforming the query ( Function --list ) into 
 ###  TRUE/FALSE + PreFixedVariable + """__PreFixedVariable__"""
 ###  - And also parse the content of __PreFixedVariable__ into 
 ### default value it's hard to not having engine read the content
 ### and be able to parse-it safely. 
 ### 
 function BuildListInformation()
 {
  local __call_locality=( BLI BuildListInformation ${StrParentApps} ) ;
  local ArrayArg=( $* ) ;
  local Arg0=${ArrayArg[0]};  
  local StrCallName=$( GetStdPrefixName ${StrFuncName} ) ;  
  
  StrMsg="Prefixed String for Function: ${StrFuncName} :${StrCallName}" ; 
  VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbState=${BoolDisplayDebug} VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis
  local ArrayPrefixedVar=( $( ${StrFuncName} --list ) ) ; 
  StrMsg="Building entry List: ${VarName}" ; 
  VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbState=${BoolDisplayDebug} VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis
  local StrZenityListBuild=$( eval "${StrFuncName} --list" | sed 's/\('${StrCallName}'[A-Za-z0-9]*\)/'${StrDefaultSelection}' \1/g ; s/\('${StrCallName}'[A-Za-z0-9]*\)/\1 __\1__/g' ) ; 
  StrMsg="Initial Zenity TagParser List: ${StrZenityListBuild}\n" ; 
  VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbState=${BoolDisplayDebug} VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis
  local StrDefautVal="" ; 
  
  for VarName in ${ArrayPrefixedVar[@]} ; do 
   StrDefautVal=$( ${StrFuncName} --get ${VarName} ) ; 
   StrZenityListBuild="""${StrZenityListBuild//__${VarName}__/\"\"\" ${StrDefautVal}\"\"\"}""" ;  
  done 
  
  StrZenityListBuild="""${StrZenityListCmd} ${StrZenityListBuild}""" ; 
  StrMsg="Zenity List Value for CmdLine: ${StrZenityListBuild}\n" ;  
  VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbState=${BoolDisplayDebug} VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis
  
  ### This Verbosis required to be set tot VerbState=True + VerbFormated=False to allow 
  ### The list to be outputed.
  VerbMsg="${StrZenityListBuild}" VerbDev=/dev/stdout VerbState=True VerbFormated=False VerbHeader="" Verbosis
 }
 
 function __main_StartServices()
 {
  local __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
  local ArrayArg=( $* ) ;
  local Arg0=${ArrayArg[0]};  
 
  local StrZenityListBuild=$( eval $( VTVValueEntry=${StrVarList} VTVIsArrayStyleInsert=True VTVIsValueReAssign=True VTVIsValueToConvert=False ValueToVariable  ) BuildListInformation ) ; 
  StrMsg="Zenity List Value CmdLine: ${StrZenityListBuild}\n" ; 
  VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbState=True VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis
  
  local StrCmdLine="${StrZenityListParser}" ;
   
  StrMsg="Zenity List CmdLine: ${StrCmdLine}\n" ; 
  VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbState=True VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis
  ### Section using TagParser to Replace __TAG__ by Variable Name. 
  eval $( TPIsMatchRtoL=True TPDisplayDebug=True TPArrayName=ArrayZPVSTag TPVarNameParsed="StrCmdLine" TPListTag="${StrTagList}" TagParser ) ; 
  # eval "${StrTagCmdLine}" ;  
  
  StrMsg="Parsed Zenity List CmdLine: ${StrCmdLine}\n" ; 
  VerbMsg="${StrMsg}" VerbDev=/dev/stderr VerbState=True VerbFormated=True VerbHeader="${__call_locality[1]}-CMDLINE" Verbosis
  
  eval """${StrCmdLine}""" ; 
 }
 
 function __main_StopServices()
 {
  local __call_locality=( Main __main_StopServices ${StrParentApps} ) ;
  local ArrayArg=( $* ) ;
  local Arg0=${ArrayArg[0]};  
 }
 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n" ;
 local StrNameHelper="ZenityPrefixedVarSelection\t\tThe Fnct.D Zenity Services to Select from Windows Frame required Prefixed-Variable to build a query";
 local StrSynopsis="Implementation of a Member for Registration process, ZenityPrefixedVarSelection, is the 1st door to knock by choosing item to register, to use correctly in building one or severals line of code for Fnct.D";
 local StrSummary="This function simply open a Zenity Windows depending which function you have choosed it display registered Prefixed-Variable, you select required field and wait for the second windows which pop-up a form to feed the information on selected Prefixed-Variable. All alone it output only the selected variable and return by String Space separated value the Registered Prefixed variable. Reserved by possibility to change the String-Space separated value by ZPVSSeparatorList it does the same. " ; 
 local StrDescription="Initially called by ZenityBuildForm, you can re-use the application for complementary query. Some effort to integrate this windows to --list operator switches it ill require uses of Prefixed-Variable. Suggested method imply adding ZenityList=True to a function you require to select value. While services like compword is active in all function with bottom-clause to filter switched --compword to tab accross Prefixed-Expansion variable showing you on prompt ZenityPrefixedVarSelection does the same in Windows form." ;   
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
  GVRIsName=True GVRIsSynopsis=True GVRIsSummary=True GVRIsDesc=True GetVarReference ${__call_locality[1]} ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;	
 elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
  eval $( VTVValueEntry=${StrVarList} \ 
          VTVIsArrayStyleInsert=True   \
          VTVIsValueReAssign=True      \
          VTVIsValueToConvert=False    \
          ValueToVariable  ) __main_StopServices ; 
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVValueEntry=${StrVarList}  \ 
          VTVIsArrayStyleInsert=True    \
          VTVIsValueReAssign=True       \
          VTVIsValueToConvert=False     \
          ValueToVariable  ) ${StrFunctionMain} ; 
 fi  
 
} ; 

unset ZenityBuildForm ;
function ZenityBuildForm()    
{ 
 local __call_locality=( ZBF ZenityBuildForm ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ;
 local StrFuncName=${ZBFFunctionName:=None} ; 
 local StrSep=${ZBFSep:=' '} ;
 local StrTextApps=${ZBFTitle:='Form Builder, Prefixed-Variable Property'} ;
 local IntHeight=${ZBFHeight:=500}
 local StrTagZenityForm=${ZBFParserForm:=StrParentApps:__LOCAL__,StrTextApps:__TEXT__,IntHeight:__HEIGHT__,StrSep:__SEP__} ; 
 local StrTagZenityMkdir=${ZBFParserMkdir:=StrAppsSudo:__SUDO__,StrAppsSudoOpt:__OPT__,StrAppsMkdir:__APPS__,StrRepositoryQuery:__PATH__}
 local StrTagZenityChmod=${ZBFParserChmod:=StrAppsSudo:__SUDO__,StrAppsSudoOpt:__OPT__,StrAppsChmod:__APPS__,StrRepositoryQuery:__PATH__,StrDefaultPerm:__PERM__}
 local StrTagZenityChown=${ZBFParserChown:=StrAppsSudo:__SUDO__,StrAppsSudoOpt:__OPT__,StrAppsChown:__APPS__,StrRepositoryQuery:__PATH__,StrDefaultUser:__OWNER__}
 local BoolRepoCreaEnabled=${ZBFRepoCreatEnabled:=True} ; 
 local BoolDisplayParserDebug=${ZBFParserDebug:=False} ;
 local BoolDisplayDebug=${ZBFDebug:=False} ; 
 local BoolProvideUUIDQuery=${ZBFUUIDQuery:=False} ;
 local StrRepositoryQuery=${ZBFQueryRepository:=/var/cache/Fnct.D/BuildForm} ;  
 local BoolCreateRepository=${ZBFRepositoryCreation:=False} ; 
 local StrDefaultUser=${ZBFRepoUser:=\${USER}.\${USER}} ;
 local StrDefaultPerm=${ZBFRepoPerm:=775} ;  
 local StrAppsSudo=${ZBFAppsSudo:=/usr/bin/sudo} ;
 local StrAppsSudoOpt=${ZBFAppsSudoOpt:=-s -H} ;
 local StrAppsMkdir=${ZBFAppsMkdir:=/bin/mkdir} ;
 local StrAppsChown=${ZBFChown:=/bin/chown} ;
 local StrAppsChmod=${ZBFChmod:=/bin/chmod} ;
 local StrStartMain=${ZBFFuncStart:=__main_StartServices}
 
 local -A ArrayTplAction ; 
 local -A ArrayVarVal ; 
 local -A ArrayPV ;
 #local -A ArrayQueryGenertor ; 
 
 ArrayTplAction['Mkdir']="__SUDO__ __OPT__ __APPS__ __PATH__" ;  
 ArrayTplAction['Chown']="__SUDO__ __OPT__ __APPS__ __OWNER__ __PATH__"   ;
 ArrayTplAction['Chmod']="__SUDO__ __OPT__ __APPS__ __PERM__ __PATH__"   ;
 local ArrayActionOrder=( "Mkdir" "Chmod" "Chown" ) ;
      
 local StrMsg="" ; 
 local StrParentApps="${__call_locality[1]}" ; 
 local StrUUIDSession=$( GetUAppsRegisterName=${StrParentApps} GetUIDRegister=True GetUTimeBased=True GetUSeq=1 GetUUID ) ;   
 local StrStorageID="${StrRepositoryQuery}/${StrUUIDSession}" ; 
 local StrText ;
 local StrForm="""zenity --height=__HEIGHT__ --text=\"__LOCAL__ __TEXT__\"  --separator='__SEP__' --forms __ENTRY__""" ; 
 local StrValueReturn="__VAR__ __APPS__" ;
 local StrVarList="BoolRepoCreaEnabled,StrStartMain,StrTagZenityMkdir,StrTagZenityChmod,StrTagZenityChown,StrAppsSudo,StrAppsSudoOpt,StrAppsMkdir,StrAppsChown,StrAppsChmod,StrDefaultPerm,StrDefaultUser,StrFuncName,StrSep,StrTextApps,IntHeight,StrTagZenityForm,BoolDisplayParserDebug,BoolDisplayDebug,BoolProvideUUIDQuery,StrRepositoryQuery,BoolCreateRepository,StrParentApps,StrUUIDSession,StrStorageID,StrForm,StrValueReturn,StrVarList" ; 
 
 function Verbosis()
 {
  local __call_locality=( Verbosis Verb );
  local StrMsg=${VerbMsg:=__TEXT__} ; 
  local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
  local IsDisplayFormatted=${VerbFormated:=True} ;
  local ArrayArg=( $* ) ; 
  if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
    echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
    if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
     echo "${StrMsg}" ;  
    else
     echo "${StrMsg}" > ${StrDevOut} ;
    fi 
   fi 
  fi
 } 
 ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis
 
 function SimpleQueryGenerator()
 {
  local __call_locality=( SQG SimpleQueryGenerator ${StrParentApps} ) ; 
  local Arg0=${ArrayArg[0]} ; 
  local ArrayArg=( $* ) ; 
  zenity --entry --title="ZenityBuildForm Function Template Model" --text="Builder Prefixed Variable and Function Return Statement" --entry-text="${StrValueReturn}" ;  
 } 
 
 function UUIDQueryGenerator()
 {
  local __call_locality=( UQG UUIDQueryGenerator ${StrParentApps} ) ; 
  local Arg0=${ArrayArg[0]} ; 
  local ArrayArg=( $* ) ; 
  local StrContentCert="${StrValueReturn}\n#UUID:${StrUUIDSession}\n";
  local StrShaSum=$( echo -ne "${StrContentCert}" | sha1sum  | cut -d ' ' -f 1 ) ; 
  echo -ne "#${StrShaSum}\n" > ${StrStorageID} ;
  echo -ne "${StrContentCert}" >>  ${StrStorageID} ; 
  zenity --text-info --title="ZenityBuildForm Function Template Model UUID=${StrUUIDSession}" --filename=${StrStorageID} --font=12 ; 
  
 }
 function FunctionGenerator()
 {
  local __call_locality=( FG FunctionGenerator ${StrParentApps} ) ; 
  local Arg0=${ArrayArg[0]} ; 
  local ArrayArg=( $* ) ;  ### Because StrSep is uniform it's clumsy to exchange 
  ### space for a space .
  local -a ArrayValue ;
  if [ "${StrSep}" != ' ' ] ; then 
   ArrayValue=( ${StrFieldValue//${StrSep}/ } ) ;
  else
   ArrayValue=( ${StrFieldValue} ) ;
  fi 
  local IntCountArg=0 ; 
  
  for VarPrefix in ${!ArrayVarVal[@]} ; do 
   ArrayVarVal[${VarPrefix}]="${ArrayValue[${IntCountArg}]}" ; 
   ### Must increase the Counter after each iteration to 
   ### extract Space Formated Output of Zenity Form captured
   ### in a String transformed into Array.
   StrValueReturn=${StrValueReturn//${VarPrefix}/${VarPrefix}=${ArrayVarVal[${VarPrefix}]}} ; 
   IntCountArg=$(( ${IntCountArg} + 1 )) ;
  
  done 

 }
 function RepositoryCreation()
 {
  local __call_locality=( RC RepositoryCreation ${StrParentApps} ) ; 
  local Arg0=${ArrayArg[0]} ; 
  local ArrayArg=( $* ) ;
  local StrAction ; 
  StrMsg="Prefixed Variable: __VAR__=__VALUE__\nThis is an assistan creating the Repository (location: __PATH__)\n.This is reserved to store your Query for future uses. Prepare to enter into\nCredential action to create the Repository. In case your haven't chooses Variable\n\tZBFRepoUser ZBFRepoPerm\nto set your user(s)/Group accessing the repository or Permission to read and write,\nyou can stop the application and start over. If you haven't choose a Function Name\nfor this step it will pop-you a warning and stop the application." ;
  StrMsg=${StrMsg//__VALUE__/${BoolCreateRepository}} ; 
  StrMsg=${StrMsg//__VAR__/BoolCreateRepository} ; 
  StrMsg=${StrMsg//__PATH__/${StrRepositoryQuery}} ; 
  VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis ; 
  
  StrMsg="Creation of PATH __PATH__, Right Attribution : __MODE__, Owner: __USER__" ;
  StrMsg=${StrMsg//__PATH__/${StrRepositoryQuery}} ;
  StrMsg=${StrMsg//__MODE__/${StrDefaultPerm}} ;
  StrMsg=${StrMsg//__USER__/${StrDefaultUser}} ;
  VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis ; 
  if [ ! -d ${StrRepositoryQuery} ] ; then 
   for IterActionName in $( ${StrParentApps} --get ArrayActionOrder[@] ) ; do 
    StrAction=$( ${StrParentApps} --get ArrayTplAction[${IterActionName}] ) ; 
    StrArrayName="StrTagZenity" ;
    ### There is 3 active Template-index inside ArrayActionOrder.
    ### Each one is inside an Associatiev Array where we do extract the Template
    ### command line Noted: ArrayTplAction[${IterActionName}]
    ### But There is no common Array of Tag association with variable. 
    ### There is no possibility because I have use __APPS__ 3 time in all of template
    ### having exactely 3 definition in 3 other Array of Tag association.
    ### Theirs name : StrTagZenityMkdir StrTagZenityChmod StrTagZenityChown
    ### If we retreive the Common-name of these variable, the prefix is : StrTagZenity
    ### So Stemming StrTagZenity with concatenation of ${IterActionName} it do 
    ### forming the Dictionnary name a.k.a. String of Tag association with var.  
    ### We do require to procure a new version of StrAction at the beginning of
    ### the loop . All this should replace the execution of 3 commands. 
    ### And because ZenityBuildForm require a ZBFFuncStart=__main_StartServices 
    ### Mean we can lunch this command without passing by the Test of Function 
    ### Name like ZBFFuncStart=RepositoryCreation ZenityBuildForm 
    ### and come idea to use this function like suplemment of creation of path
    ### if This Application become a hand in management of a Bigger infrastructure.
    ### like creating other path, launching other Zenity Frame... 
    
    eval "StrTagListVar=\${${StrArrayName}${IterActionName}} ;" ; 
    eval $( TPVarNameParsed="StrAction" TPListTag=${StrTagListVar} TPIsMatchRtoL=True TPDisplayParserNotice=\${BoolDisplayParserDebug} TPDisplayDebug=${BoolDisplayDebug} TPArrayName="Array${__call_locality[0]}Tag" TagParser 2> /dev/null ) ;
    StrMsg="__CMD__ " ; 
    VerbMsg="${StrMsg//__CMD__/${StrAction}}" VerbHeader="${__call_locality[1]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis ; 
    if [ "${BoolRepoCreaEnabled:=False}" == "True" ] ; then 
      eval """$( ${StrAction} )""" ;
    fi 
   done 

  fi 

 } 
 function FunctionQuery( )
 {
  local __call_locality=( FQ FunctionQuery ${StrParentApps} ) ; 
  local Arg0=${ArrayArg[0]} ; 
  local ArrayArg=( $* ) ;
  local StrQueryGenerator ; 
  #for VarName in $( ${StrFuncName} --list ) ; do 
  local ArrayPreFixV=( $( ZPVSFunctionName=${StrFuncName} ZenityPrefixedVarSelection ) ) ; 
  ### We also Feed the StrValueReturn to exchange __VAR__ for all Prefixed Variable. 
  StrValueReturn=${StrValueReturn//__VAR__/${ArrayPreFixV[@]}} ; 
  ### We also Feed the StrValueReturn to exchange __APPS__ for the function Name. 
  StrValueReturn=${StrValueReturn//__APPS__/${StrFuncName}} ; 
  for VarName in ${ArrayPreFixV[@]} ; do  
   ### For Reading the General Value from Default one . 
   ArrayVarVal[${VarName}]=$( ${StrFuncName} --get ${VarName} ) ; 
   ### The new Associative Array to associate the new Value . 
   ArrayPV[${VarName}]=""
  done ; 
  StrText=$( GetVarReference ${StrFuncName} ) ; 
  StrText="${StrText}"
  
  ### Point of Parsing, At this moment We should own all required variable being 
  ### ready to Parse the command-line StrForm . 
  eval $( TPIsMatchRtoL=True TPDisplayParserNotice=${BoolDisplayParserDebug} TPDisplayDebug=${BoolDisplayDebug} TPArrayName="Array${__call_locality[0]}Tag" TPVarNameParsed="StrForm" TPListTag="${StrTagZenityForm}" TagParser 2> /dev/null ) ;
  
  StrMsg="Zenity CMD:__FORM__" ; 
  #eval """${StrForm}""" ;         
  ### This Section Add an __ENTRY__ after each parsing and require to remove it 
  ### to avoid of excess of informations on zenity command-line . 
  for ItemName in ${!ArrayVarVal[@]} ; do 
    StrValue=${ArrayVarVal[${ItemName}]} ; 
    StrForm=${StrForm//__ENTRY__/--add-entry=\"${ItemName} value: ${StrValue}\" __ENTRY__} ; 
  done ; 
  
  StrForm=${StrForm/__ENRTY__/} ; 
  
  StrMsg="Zenity CMD:__FORM__" ; 
  VerbMsg=${StrMsg//__FORM__/${StrForm}} VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} StrDevOut=/dev/stderr Verbosis ; 
  
  eval """StrFieldValue=\$( ${StrForm} )""" ;  
  
  StrMsg="Result Value:__VALUE__" ; 
  VerbMsg=${StrMsg//__VALUE__/${StrFieldValue}} VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} StrDevOut=/dev/stderr Verbosis ; 
  
  eval $( VTVIsArrayStyleInsert=True \
       VTVValueEntry=${StrVarList},StrFieldValue,StrValueReturn   \
       VTVIsValueReAssign=True       \
       VTVIsValueToConvert=False     \
       VTVIsArrayStyleInsert=True    \
       ValueToVariable ) FunctionGenerator ; 
  
  StrQueryGenerator="SimpleQueryGenerator" ; 
  if [ "${BoolProvideUUIDQuery:=False}" == "True" ] ; then 
   StrQueryGenerator="UUIDQueryGenerator" ; 
  fi
  
  eval $( VTVIsArrayStyleInsert=True \
       VTVValueEntry=${StrVarList}   \
       VTVIsValueReAssign=True       \
       VTVIsValueToConvert=False     \
       VTVIsArrayStyleInsert=True    \
       ValueToVariable ) ${StrQueryGenerator} ;  
 }
 
 function __main_StartServices()
 {
  local __call_locality=( Main __main_StartServices ${StrParentApps} ) ; 
  local Arg0=${ArrayArg[0]} ; 
  local ArrayArg=( $* ) ;
  StrMsg="Function To Select Variable:__FUNC__" ; 
  VerbMsg="${StrMsg//__FUNC__/${StrFuncName}}" VerbHeader="${__call_locality[1]}-DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} StrDevOut=/dev/stderr  Verbosis ; 
  
  
  if [ ${BoolCreateRepository:=False} == "True" ] ; then
   eval $( VTVIsArrayStyleInsert=True \
       VTVValueEntry=${StrVarList}   \
       VTVIsValueReAssign=True       \
       VTVIsValueToConvert=False     \
       VTVIsArrayStyleInsert=True    \
       ValueToVariable ) RepositoryCreation ;
  fi 
  
  if [ ${StrFuncName:=None} != "None" ] ; then 
   eval $( VTVIsArrayStyleInsert=True \
        VTVValueEntry=${StrVarList},StrFieldValue,StrValueReturn   \
        VTVIsValueReAssign=True       \
        VTVIsValueToConvert=False     \
        VTVIsArrayStyleInsert=True    \
        ValueToVariable ) FunctionQuery ;
  else
   StrMsg="No function selected : __FUNCT__" ; 
   VerbMsg="${StrMsg//__FUNCT__/${StrFuncName}}" VerbHeader="${__call_locality[1]}-WARNING" VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis ; 
  fi
 }
 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 local StrNameHelper="ZenityBuildForm\tThe Fnct.D Mechanism This is the Helper Selecting Variable and Throught the Gui Interface.";
 local StrSummary="This is a simple helper to generate Function for your command-line and/or Function to craft. They can be stored inside a Repository and own specific signature were tool like GetterByLineData might extract informations. Repository is /var/cache/Fnct.D/BuildForm ; and required appropriate permission and owner. ZenityBuildForm will propably own a repository creator in fews versions." ; 
 local StrSynopsis="Works in 3 Steps, First it pop you the windows for the choosed function name. ; Selecting the variable required to fit in your code . Secondly it pop you after pressing OK button, another form with Variable Name and a field to let you write your information. It can be fixed value ,this can also include variable name like ${VAR} and __TAG__ as well. Don't forget it require TagParser to Interpret the Tag .After the end it pop-you a Third windows with the answer. The asnwer come in 2 mode, simple text-form with the function-line or second mode require ues of Prefixed-Variable ZBFUUIDQuery=True and store the information in UUID mode, and write the Query to a file inside /var/cache/Fnct.D/BuildForm and hold a signature in the top of the file certify your query is integral after creation. The receip is the last line and second line your query.";
 local StrDescription="Please use the Prefixed-Variable ZBFFunctionName= to subscribe a function to Start the Sequence 1\n\nZenity Notice Prefixed Var:\n\n ZBFTitle\tSTRING Set the title of the main windows\n ZBFHeight\tINT Set the Height of an application, WIDTH depend of the Length of your variable, some effort will be deployed to trunk the varaible content example.\n ZBFSep\tCHAR Zenity Windows ouput the information from pipe '|' sometimes. Require attention it will reflect information on Shell command created.\n\nParser Notice Prefixed Var:\n\n ZBFParserForm\tSTRING Private information but it's handled by TagParser, hint, removing sudoer layer imply removing information about tag __SUDO__ __OPT__\n ZBFParserMkdir\tSTRING Private information but it's handled by TagParser, Having better Mkdir like MdCd, this can be fit here.\n ZBFParserChmod\tSTRING Private information but it's handled by TagParser, Having Security in mind, Having a Secret report to read about change of owner, can be fited here.\n ZBFParserChown\tSTRING Private information but it's handled by TagParser, Having Intelligent observer changing information on demand, can change this here.\n\n\nRepository Notice Prefixed Var:\n\n ZBFQueryRepository\tSTRING The repository for storing your query, initially /var/cache/Fnct.D/BuildForm can be changed but require to be set an alias with your next call.\n ZBFRepoUser\t\tSTRING This is the user and group required to create your repository and be able to gain acces. ex: user.root; 500.devlpt\n ZBFRepoPerm\t\tSTRING This is the permission applied to the Repository, ex 775 where user and group can create, read, execute, and other can only read and execute\n\n\nBoolean Notice Prefixed Var :\n\n ZBFRepositoryCreation\tSet True/False Add a Pass to check the presence of /var/cache/Fnct.D/BuildForm, may forget to use ZBFFunctionName if it's a task to create the Repository\n ZBFRepoCreatEnabled\tSet True/False Emulate the action, will only display the command invoked, similar to a dry-run \n ZBFParserDebug\t\tSet True/False Display Debug-information for every parser invoked during run  \n ZBFDebug\t\tSet True/False Display extra Debug like verbose during run\n ZBFUUIDQuery\t\tSet True/False Allow uses of zenity text-info and store your query inside /var/cache/Fnct.D/BuildForm under UUID file-name and show you the Function invoked in a Zenity Windows and UUID is also inside the file so you can copy/paste the information. Any Query made with this Trigger make a certified quesry and informations are coming with a signature in comment. This can be verified with GetterByLineData a function to extract certified information." ;
 
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GVRIsName=True GVRIsSynopsis=True GVRIsSummary=True GVRIsDesc=True GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
       VTVValueEntry=${StrVarList}   \
       VTVIsValueReAssign=True       \
       VTVIsValueToConvert=False     \
       VTVIsArrayStyleInsert=True    \
       ValueToVariable ) ${StrStartMain}
 elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
  eval $( __GetVarReferenceCompWord ) ;
 fi 
 
 }  ; 

function UUIDBuildForm()
{ 
 
 ### This is a wrapped around ZenityBuildForm to accept by default 
 ### To create query directly inside the repository and uses 
 ### Arg0 to handle the function name. 
 local __call_locality=( UUIDBF UUIDBuildForm ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ;
 ZBFUUIDQuery=True ZBFFunctionName=${Arg0} ZenityBuildForm ; 

}


unset DefaultConfigure ;
function DefaultConfigure()
{ 
 local ArrayArg=( $* ) ; 
 local __call_locality=( DefConfigure ) ; 
 local StrDefaultAction=${DefConfigureAction:=--start-services} ;
 local Arg0=${ArrayArg[0]:=${StrDefaultAction}}; 
 local StrLD='${DefConfigureLD:=${LD} -laudiofile}' ; 
 local StrLDFLAGS='${DefConfigureLDFLAGS:=${LDFLAGS}}' ; 
 local StrCXX=${DefConfigureCXX:=\${CXX}} ; 
 local StrCC=${DefConfigureCC:=\${CC}} ; 
 local StrCPP=${DefConfigureCPP:=\${CPP}} ; 
 local StrCFLAGS=${DefConfigureCFLAGS:=\${CFLAGS}} ;
 local StrCPPFLAGS=${DefConfigureCPPFLAGS:=\${CPPFLAGS}} ; 
 local StrCXXFLAGS=${DefConfigureCXXFLAGS:=\${CXXFLAGS}} ; 
 local StrNewConfigureOptFile=${DefConfigureOptFile:=${HOME}/.DefConfigureOption} ; 
 local StrNameConfigure=${DefConfigureName:=default} ;
 
 local CmdEval=( ./configure  ) ;
 
 function GetNameConfigureOption()
 {
   local ArrayArg=( $* ) ; 
   local __call_locality=( GetConfOpt ) ; 
   local Arg0=${ArrayArg[0]}; 
   local StrNameOption=${GetConfOptName:=default} ;
   local StrOptionFile=${GetConfOptFile:=${HOME}/.DefConfigureOption} ;
   local StrGrepSep=${GetConfOptSep:=:} ;
   local StrGrepPattern=${GetConfOptGrepPattern:=__PATTERN____SEP__} ;
   local StrGrepForm="${StrGrepPattern//__PATTERN__/${StrNameOption}}";
   StrGrepForm=${StrGrepForm//__SEP__/${StrGrepSep}} ; 
   local StrContent=$( cat ${StrOptionFile} | egrep -i ${StrGrepForm} | head -n 1 | cut -d ':' -f 2- ) ; 
   echo -ne "${StrContent}" ; 
 }
 local StrConfigureContentTest="" ;
 test -e ${StrOptionFile} && local StrConfigureContentTest=$( GetConfOptName=${StrNameConfigure} GetConfOptFile=${StrNewConfigureOptFile} GetNameConfigureOption ) ; 
 local StrConfigureContent=${StrConfigureContentTest:=--help} ; 
 #local StrConfigContent=$( test -e ${StrNewConfigureOptFile} && local CmdEval=( ./configure  ) ) ; 
 #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${ArrayArg[0]}" = "--help" ] ; then 
  GetVarReference DefaultConfigure ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ; 			
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 elif [ "${ArrayArg[0]}" == "${StrDefaultAction}" ] ; then 
  CmdEval=( ${CmdEval[@]} ${StrConfigureContent} ) ; 
  echo -ne "Configure option extracted: \n\t${CmdEval[@]}\n\n" > /dev/stderr ; 
  #eval """${CmdEval[@]}""" ; 
 elif [ "${ArrayArg[0]}" == "--add" ] ; then 
  echo -ne """Adding Configure Option Name:${StrNameOption}:\n\t\t\t${ArrayArg[@]:1:}\n""" > /dev/stderr ; 
  local StrExportSream="""${StrNameConfigure}:__configure__ ${ArrayArg[@]:1:} LD=\"${StrLD}\" LDFLAGS=\"${StrLDFLAGS}\" CXX=\"${StrCXX}\" CC=\"${StrCC}\" CPP=\"${StrCPP}\" CFLAGS=\"${StrCFLAGS}\" CPPFLAGS=\"${StrCPPFLAGS}\" CXXFLAGS=\"${StrCXXFLAGS}\" ${ArrayArg[@]:1:}""" ; 
  StrExportSream=${StrExportSream//__configure__/${StrNameOption}} ;
  echo -ne "Configure Command:\n\t${StrExportSream}\n" > /dev/stderr ; 
  #echo -ne "${StrExportSream//__configure__/${StrNameOption}}\n" >> ${StrNewConfigureOptFile} ; 
 elif [ "${ArrayArg[0]}" == "--update" ] ; then 
  echo -ne """Updating Configure Option:\n\t\t${ArrayArg[@]:1:}\n""" > /dev/stderr ; 
 elif [ "${ArrayArg[0]}" == "--remove" ] ; then 
  echo -ne """Removing Configure Option:\n\t\t${ArrayArg[@]:1:}\n""" > /dev/stderr ; 
 else
  echo -ne """Arg0 No option specified\n""" > /dev/stderr ; 
 fi

 
}

 ### IsPathName :
 ###
 ###
 ###	Full-length example : 
 ### Including 2 main definition
 ###
 ### - Return value:
 ### if the test success, it report number of element retain in grep filter. 
 ###  - it also return 0 in case of sucess and 1 if fail. 
 ### example: 
 ###
 ### - Return True on a test on Arg0 to be a path with appropriate sematic for current path. 
 ### IsPathName ./avfsd 
 ### -> return 0 
 ###
 ### IsPathNameAction=CurrentPath IsPathName ./avfsd 
 ### -> return 0 
 ###
 ### IsPathName /avfsd 
 ### -> return 1 # This is not a current path specified. 
 ###
 ### IsPathName IsPathNameAction=IsRootPath avfsd 
 ### -> return 1 # This is not a Rooted-path name.
 ###
 ### IsPathName IsPathNameAction=IsRootPath /avfsd 
 ### -> return 0 .
 ###
 ###


unset IsPathName 
function IsPathName()
{
  local __call_locality=( IsPathName );
  local ArrayArg=( $* ) ;
  local Arg0=${ArrayArg[0]}; 
  local ArgActionList=${IsPathNameActLst:=CurrentPath,IsRootPath}
  local RegActionList=${IsPathNameReglst:="^\.+\/"__SEP__"^\/"} ; 
  local StrAction=${IsPathNameAction:=CurrentPath} ; 
  local IntReturnValue=0 ; 
  local IntReturnState=0 ; 
  
  local ArrayActionList=( ${ArgActionList//,/ } ) ; 
  local ArrayRegExp=( ${RegActionList//__SEP__/ } ) ; 
  
  #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  if [ "${ArrayArg[0]}" = "--help" ] ; then 
   IntReturnState=0 ;
   GetVarReference ${__call_locality[0]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ; 			
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
  else
   for(( intx=0 ; intx <= ${#ArrayActionList[@]]}-1 ; intx++ )) ; do 
    local StrReg="${ArrayRegExp[${intx}]}" ;
    local StrMainAction=${ArrayActionList[${intx}]} ; 
    if [ "${StrAction}" == "${StrMainAction}" ] ; then 
     IntReturnValue=$( echo "${Arg0}" | egrep -ice "${StrReg}"	 2&>1 /dev/null ) ; 
    fi 
   done 
   if [ ${IntReturnValue:=0} -gt 0 ] ; then 
    IntReturnState=0 ;
   else
    IntReturnState=1 ;
   fi 
   
  fi 
  return ${IntReturnState} ;  
}



unset kill_cmd ; 
function kill_cmd()    
{ 
 local ArrayArg=( $* ) ; 
 local __call_locality=( kill_cmd ) ;  
 local IntDefaultKillSig=${kill_cmdDefaultSigInt:=-9} ;
 local StrColDisplayInSearch=${kill_cmdPsColList:=pid,command}
 local IntNbCol=$(( $( echo "${StrColDisplayInSearch}" | wc -m ) - $( echo "${StrColDisplayInSearch//,/}" | wc -m ) ))
 local IntIdPassToKiller=${kill_cmdColIdToKill:=${IntNbCol}} ; 
 #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${ArrayArg[0]}" = "--help" ] ; then 
  GetVarReference ${__call_locality[0]} ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ; 			
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 else
  for (( x=0 ; x <= ${#ArrayArg[@]}-1 ; x++ )) ; do 
   local cmd=${ArrayArg[${x}]} ; 
   local PsResult=$( ps -eo ${StrColDisplayInSearch} | egrep -i "${cmd}" | grep -v grep | cut -d ' ' -f ${IntIdPassToKiller} | tr '[:cntrl:]' ' ' )
   CmdEval=( kill ${IntDefaultKillSig} ${PsResult} ); 
   echo -ne "PsResult:\n\n${PsResult}\n\n" > /dev/stderr ;
   echo -ne "Command Eval:[ ${CmdEval} ]\n" > /dev/stderr ; 
  done 
 fi 
}




unset StartApps
function StartApps()
{ 
 local ArrayArg=( $* ) ; 
 local __call_locality=( StartApps ) ; 
 #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${ArrayArg[0]}" = "--help" ] ; then 
  GetVarReference ${__call_locality[0]} ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ; 			
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 else	 
  local AppsRefresh=${StartAppsRefresh:=4} ; 
  local Apps=${StartAppsCmd:=rezound --audio-method=jack} ; 
  local ScanApps=${StartAppsScan:=rezound} ; 
  local StrAppsStopSig=/home/${USER}/stop_${ScanApps}
  local IsStopSig
  IsStopSig=$( test -e ${StrAppsStopSig} && echo 1 );
  while [ ${IsStopSig:=0} -eq 0 ] ; do 
  local isApps=$( ps -eo pid,command | grep -v egrep | egrep -ic "${ScanApps}" ) ; 
  if [ ${isApp:=0} -eq 0 ] ; then 
   eval ${Apps} ; 
  fi ; 
  sleep ${AppsRefres} ; 
   IsStopSig=$( test -e ${StrAppsStopSig} && echo 1 ) ;
  done ; 
  rm -f ${StrAppsStopSig} ;
  echo -ne "Exiting signal catch for Application ${Apps} to cancel respawing.\n" > /dev/stderr 
 fi
}



function Survey_kill_apps()    
{ 
    function KillApps()
    {
        local __call_locality=( KillApps ) ; 
        local ArrayArg=( $* ) ; 
        kill -9 $( ps -eo pid,command | egrep -i "${ArrayArg[0]}" | grep -v "egrep" | sed 's/^[\ \t]*//g' | cut -d " " -f 1 )
    }
    local __call_locality=( SurveyApps ) ; 
    local ArrayArg=( $* ) ; 
  #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  if [ "${ArrayArg[0]}" = "--help" ] ; then 
   GetVarReference Survey_kill_apps ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ; 			
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
  else	 
    local StrApps=${SurveyApps:=rezound} ; 
    local IntDelay=${SurveyAppsRefresh:=4} ; 
    while [ 1 ] ; do 
        test -e /home/maxiste/kill_${StrApps} && \
            rm -f /home/maxiste/kill_${StrApps} && \
            KillApps ${StrApps} 
        sleep ${IntDelay} ; 
    done ; 
  fi
}



### Usefull for python installer using pip. 
### Happen more than once have to call pip with another gcc compiler while test failed to compile many source
### from Numpy numpy/linalg/lapack_litemodule.c and linalg/zlapack_lite.c failling or doing segmentation fault.
### Most of the time they can work compiling them direct from the shell but in bash script called from bash or
### python script like setup.py failed... 
### So I'm changing couple of variable and calling indivilually pip installer like this :
### Where cmd old followin value : cmd=( pip install __MODULE__ )
### eval $( DpkgGetInlineBuildFlags ) CC=/usr/bin/x86_64-linux-gnu-gcc-4.4 CXX=/usr/bin/x86_64-linux-gnu-g++-4.4 ${cmd[@]}

unset DpkgGetInlineBuildFlags ; 
function DpkgGetInlineBuildFlags()
{
  local __call_locality=( DpkgGetInlineBuildFlags ) ;
  local ArrayArg=( $* ) ;
  #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  if [ "${ArrayArg[0]}" = "--help" ] ; then 
   GetVarReference ${__call_locality[0]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ; 			
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
  else	 
   local CmdEval=( "cat" "${DpkgGetInlineBuildFlagsPath:=/etc/dpkg/}"${DpkgGetInlineBuildFlagsFile:=buildflags.conf} "|" """sed -e 's/^\(SET\ \)\([a-zA-Z]*FLAGS\)\([\t\ ]*\)/\2=/g'""" "|" tr """'[:cntrl:]\' ' '""" ) ;
   eval "${CmdEval[@]}" ;
 fi 

}


unset fast_dpkg_build ; 
function fast_dpkg_build()    
{ 
 local ArrayArg=( $* ) ; 
 local __call_locality=( FDB ) ; 
 local StrOptionDpkgBuild=${FDBDpkgBuildOpt:=} ;
 local StrOptionDpkgInst=${FDBDpkgInstOpt:=} ;
 for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
  local StrPackage=${ArrayArg[${intx}]} ; 
  cd /usr/local/src/apt/ ; 
  md_cd $(pwd)/${StrPackage} ; 
  cd ${StrPackage} ; 
  local IntBuild=0 ; 
  apt-src install ${StrOptionDpkgInst} -p ${StrPackage} && apt-src ${StrOptionDpkgBuild} -p build ${StrPackage} && IntBuild=1 ; 
  echo -ne "\n\n\tBuild Status\n\t\titem : ${StrPackage}\n\t\tStatus: ${IntBuild}\n\n" ; 
  dpkg --install $( find ./ -type f -iname "*.deb" -printf "%p " ) ; 
 done ; 
}



unset DebianAptSrcCompiler ; 
function DebianAptSrcCompiler()
{
 local __call_locality=( DebianAptSrcCompiler ) ; 
 local ArrayArg=$( $* ) ; 
 local ArrayPackageName=( ${DebianAptSrcCompilerPackage//;/ } ) ;
 local CompilerVersion=${DebianAptSrcCompilerVersion:=4.4} ; 
 local StrAptProc=${DebianAptSrcCompilerPackageAptProc:=clean;install;build}
 local AddPatch=${DebianAptSrcCompilerPatch:=True} ;
 local ArrayAptSrcProc=( ${StrAptProc//;/ }  ) ; 
 local StrPatchOpt="" ; 
 local res_exec=0 ; 
 local StrPath=${DebianAptSrcCompilerPath:=/usr/local/src/apt} ;
 #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${ArrayArg[0]}" = "--help" ] ; then 
  GetVarReference ${__call_locality[0]} ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ; 			
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 else	 	
  if [ ${AddPatch:=True} == "True" ]; then 
   StrPatchOpt="-p" ;
  else
   StrPatchOpt="" ;
  fi 
 for Package in ${ArrayPackageName[@]} ; do 
  local old_dir=$( pwd )
  test ! -d ${StrPath}/${Package} && mkdir -p ${StrPath}/${Package} ;
  cd ${StrPath}/${Package} ; 
  apt-src update ;
  local UpdateState=$? ;
  if [ ${UpdateState:=0} -eq 0 ] ; then 
   echo -ne "\t\t----- Building -----\n\t\t\t${Package}\n\n" > /dev/stderr ; 
   for item in ${ArrayAptSrcProc[@]} ; do 
    echo -ne "\n\n\n\t\t----- APT-SRC STEP: -----\n\t\t\t${item}\n\n\n" > /dev/stderr ; 
    CC=${DebianAptSrcCompilerCBaseName:=/usr/bin/x86_64-linux-gnu-gcc-}${CompilerVersion} \
    CXX=${DebianAptSrcCompilerCXXBaseName:=/usr/bin/x86_64-linux-gnu-g++-}${CompilerVersion} \
    apt-src ${item} ${Package} ${StrPatchOpt} ; 
    res_exec=$? ; 
    echo -ne "\n\n\t\t-----------------\n\t\t Error Status: ${res_exec}\n\t\t-----------------\n\n" > /dev/stderr  ;  
   done ;
   else
    echo -ne "\n\n\t\t-------------------------------------------------------\n\t\t Error compilation/installation of ${Package}\n\t\t-------------------------------------------------------\n" > /dev/stderr 
   fi 
   cd ${old_dir}  ;
  done 
  fi
}

 ### AptRebuild :
 ### - Use script apt-src to commonly clean and build a debian source packages
 ###  being installed as source and it's ready to compile. This function uses 
 ###  the prefixed variable AptRebuildCommand to select any new order wanted to
 ###  pass to the function. 
 ###    - Commonly AptRebuildCommand is owning 'clean,build' but affecting it with 
 ###  other task like install and build can be substitued to this Common Task. 
 ###
 ###	Full-length example : 
 ### AptRebuildCommand=install,build AptRebuild libots-dev
 ###
 ### hint:
 ###  - switch '--help' is available for this function. 
 ### 
 ### 
 ### 
 
 ### Fixing a Predefined Association of Tag and Variable Name using the GetVarReference structure. 
 ### AptRebuild, may own it's own purposes by assigning to AptRebuildTagVar other variable and 
 ### other Tag inside AptRebuildTag prefixed var. meaning it can support 
 ###
 ###  following call : 
 ###    NewVar=Value AptRebuildTagVar=NewVar,Option,Package,StrAppsName,StrAppsOptExtr AptRebuildTag=__OTHERTAG__,__OPTION__,__PACKAGE__,__APPS__,__APPSOPT__ AptRebuild <package-module>, and will automatically parse the Variable NewVar into ${NewVar} (in this case it exist and will not overwrite the affected value.) into the Tag __OTHERTAG__. 
 ### 
 ###  This also need to change the AptRebuildExec Tag order to let it evaluate correctly. 
 ### 
 ### Use of Pre-Fixed Variable AptRebuildExec and AptRebuildTag. 
 ### 
 ### Description:
 ### - While this function is quite restricted, it's a mechanism that feed definition and will
 ### ultimately execute the sequence. Having a strong role inside AptRebuildCommand. the code 
 ### is structured like 1-finite loop of instruction and have to parse the commandline 
 ### defined inside AptRebuildExec and having others application being substitued you can
 ### create a virtual other command working inside this type of loop. 
 ### 
 ###  AptRebuildCommand hold 2 item : clean,build 
 ###  - where this variable fix the first command to own instruction for 'clean' and 'build' . 
 ###  - The Argument List after the  AptRebuild are the complete loop whitin First Fixed Element,
 ###  Variable -> Tag and execution . The case is tweaky, assuming eth0 and wlan0 are ultimately
 ###  the source being analysed with other condition , This one will pre-used eth0 and wlan0, 
 ###  to use the Forced Variable Package to hold eth0 or wlan0. This mean Package and 
 ### 
 ###  AptRebuildApps hold usually apt-src but in other case it may hold network-topology application
 ### being used. One popular, ifconfig. 
 ###  - In many uses ifconfig may also depend os some fixed instruction. like seeing the interface
 ### eth0 and wlan0 to verify both information. 
 ### 
 ### give as parameter : AptRebuildCommand=eth0,wlan0  AptRebuildApps=ifconfig 
 ### 
 ### AptRebuildExec and AptRebuildTag are also the order you want to use pre-defined 
 ### VAR -> __TAG__ substitution and the way the command exit depend of working example.
 ### 
 ### And there is 2 finite hard-fixed value to not remove because it hold in a double-loop value
 ### from iteration 
 ### for A ( Argument[ 0 - 15+ ] )
 ### 			 for B ( AptRebuildCommand ) 
 ### 					--- Parsing Level and Substitution Level --- 
 ### 
 ### - Also some basic prefixed value also own it's priority .
 ### AptRebuildAppsOption -> Internally used as StrAppsOptExtr will use the tag you defined but 
 ### need to be reflected inside the Tag-Loop Association. It will use 
 ### AptRebuildTag=__OPTION__,__PACKAGE__,__OTHEROPTION__ and use tag __OTHEROPTION__ is definied inside 
 ### AptRebuildTagVar, like :
 ### AptRebuildTagVar=Option,Package,StrAppsOptExtr AptRebuildTag=__OPTION__,__PACKAGE__,__OTHEROPTION__
 ### and commandline inside AptRebuildExec should reflect an __OTHEROPTION__ tag. 
 ### 
 ### AptRebuildApps -> Internally used as StrApps will own have to define it's own Tag too. 
 ### 
 ### 
 ### example : ifconfig eth0 -apr 
 ###  - To Set NOARP to your local ethernet card. 
 ###  
 ###  - And AptRebuildTag will look like this : 
 ###   AptRebuildCmdExec=False \
 ###   AptRebuildApps=ifconfig \
 ###   AptRebuildCommand=eth0,wlan0 \
 ###   AptRebuildAppsOption=-arp \
 ###   AptRebuildTag=__OPTION__,__PACKAGE__,__APPS__,__OTHEROPTION__ \
 ###   AptRebuildTagVar=Option,Package,StrAppsName,StrAppsOptExtr \
 ###   AptRebuildExec=__APPS__,__OPTION__,__OTHEROPTION__,__PACKAGE__  AptRebuild -v 
 ### 
 ### Will give a sequence to set -arp and verbosis to internet working interface:
 ### 
 ### AptRebuildCmdExec=False AptRebuildApps=ifconfig AptRebuildCommand=eth0,wlan0 AptRebuildAppsOption=-arp AptRebuildTag=__OPTION__,__PACKAGE__,__APPS__,__OTHEROPTION__ AptRebuildTagVar=Option,Package,StrAppsName,StrAppsOptExtr AptRebuildExec=__APPS__,__OPTION__,__OTHEROPTION__,__PACKAGE__  AptRebuild -v
 ### - Output
 ### 
 ###  	Processing eth0
 ### 
 ### CommandLine:[ ifconfig eth0 -arp -v ]
 ### 	Processing wlan0
 ### 
 ### CommandLine:[ ifconfig wlan0 -arp -v ]
 ### 
 ###  just by setting AptRebuildCmdExec=False to True will allow executing the sequence. 
 ### 
 ### 
 ### ... Just a good candidate for automation and generating corpus definition in variable transfert and
 ### Variable substitution. 
 

 ### AptSrcChange :
 ### 
 ### - Function AptSrcSourceChange, change the default /etc/apt/source.list and restitute it
 ### after coming back from the application apt-src. 
 ### -Note : apt-src is dependant from packages apt-src, and need to be installed with apt, dpkg
 ### and/or synaptic. 
 ### - It voluntary change the source.list until it was more convenient to alter the content
 ### of this file by replacing only debian information for package retrevial into debian-source
 ### package. It also change the type of architecture and it's convenient to leave and/or 
 ### adapt other application dependant from /etc/apt/source.list . 
 ### 
 ###  exemple : 
 ###   - synaptic depend from /etc/apt/source.list  
 ### using AptSrcChangeApps=synaptic AptSrcChange 
 ###  - and will load automatically synaptic after doing a change inside /etc/apt/source.list .  
 ###  - it will not do an automatic update. Like apt-src need to run periodically apt-src update
 ### to update it's cache, synaptic has this example show there is no update available as external 
 ### switch and the condition are not yet defined to supply a function for automatic-update. 
 ### ... while python module from apt and dpkg can re-update and write the cache it was not supply 
 ### here. 
 ### 
 ### 


 
unset AptSrcChange
function AptSrcChange()
{
 local __call_locality=( AptSrc ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ; 
 local IntUUID=$( uuidgen -t ) ; 
 local StrUUID="/tmp/${IntUUID}" ; 
 local StrApps=${AptSrcChangeApps:=/usr/bin/apt-src} ; 
 local StrAptSourceList=${AptSrcChangeFile:=/etc/apt/sources.list} ; 
 local StrAptSourceSave=${AptSrcChangeSave:=/etc/apt/sources.list.save} ; 
 local StrTagSearch=${AptSrcChangeTagSearch:=deb} ;
 local StrTagAdd=${AptSrcChangeTagChange:=deb-src} ;
 local StrDefaultArch=${AptSrcChangeArch:=amd64} ;
 local StrDefaultURI=${AptSrcChangeURIType:=http}
 #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${Arg0}" = "--help" ] ; then 
  GetVarReference ${__call_locality[0]} ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ; 			
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
  else	
  cp ${StrAptSourceList} ${StrAptSourceSave} ; 
  cat ${StrAptSourceList} | sed 's/^${StrTagSearch} ${StrDefaultURI}/${StrTagAdd} [ arch=${StrDefaultArch} ] ${StrDefaultURI}/g' > ${StrUUID} ; 
  cp ${StrUUID} ${StrAptSourceList} ; 
  echo -ne "\n\tUUID: ${StrUUID}\n" > /dev/stderr ; 
  if [ "${StrApps}" == "/usr/bin/apt-src" ]  ;then 
   # doing extra update 
   eval "${StrApps} update" ; 
  fi 
  eval "${StrApps} ${ArrayArg[@]}" ; 
  cp ${StrAptSourceSave} ${StrAptSourceList}
 fi
}

unset AptRebuild ; 
function AptRebuild()    
{ 
 local __call_locality=( AptRebuild ) ; 
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ;
 local StrCSVSep=${AptRebuildCSV:=,} ; 
 local StrAppsName=${AptRebuildApps:=apt-src} ; 
 local StrAppsOptExtr=${AptRebuildAppsOption:=-p} ; 
 local StrCmdLine=${AptRebuildExec:=__APPS__,__OPTION__,__APPSOPT__,__PACKAGE__} ; 
 local StrCmdTag=${AptRebuildTag:=__OPTION__,__PACKAGE__,__APPS__,__APPSOPT__}
 local StrCmdTagVar=${AptRebuildTagVar:=Option,Package,StrAppsName,StrAppsOptExtr}
 local IsShowDebug=${AptRebuildShowDebug:=False} ;
 local IsCmdExec=${AptRebuildCmdExec:=True} ;
 local StrCmdOption=${AptRebuildCommand:=clean,build} ; 
 cmdline=( ${StrCmdLine//${StrCSVSep}/ } ) ; 
 
 local ArrayTag=( ${StrCmdTag//${StrCSVSep}/ } ) ; 
 local ArrayOption=( ${StrCmdOption//${StrCSVSep}/ } ) ; 
 local ArrayOptionVar=( ${StrCmdTagVar//${StrCSVSep}/ } )
 
 
 #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${Arg0}" = "--help" ] ; then 
  GetVarReference ${__call_locality[0]} ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ; 			
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 else	 
  for (( intx=0 ; intx <= ${#ArrayArg[@]}-1 ; intx++ )) ; do 
   Package=${ArrayArg[${intx}]} ; 
   for (( intAx=0 ; intAx <= ${#ArrayOption[@]}-1 ; intAx++ )) ; do
    local Option=${ArrayOption[${intAx}]} ;
    echo -ne "\tProcessing ${Option}\n" > /dev/stderr
    local CmdExec=( ${cmdline[@]} ) ; 
    
    for (( intCx=0 ; intCx <= ${#ArrayOptionVar[@]}-1 ; intCx++ )) ; do 
     local tagName=${ArrayTag[intCx]} ; 
     local varName=${ArrayOptionVar[intCx]} ; 
     eval """local NewVarValue=\${${varName}}""" ; 
     if [ "${IsShowDebug}" == "True" ] ; then 
      echo -ne "\t\ttagName: ${tagName}\n\t\tvarName: ${varName}\n\t\tValue: ${NewVarValue}\n" > /dev/stderr ; 
     fi
     eval """CmdExec=( ${CmdExec[@]//${tagName}/${NewVarValue}} )""" ; 
    done 
    echo -ne "\nCommandLine:[ ${CmdExec[@]} ]\n" > /dev/stderr ; 
    if [ ${IsCmdExec:=True} == "True" ] ; then 
     eval ${CmdExec[@]} ; 
     fi
   done
  done
 fi 
}



function find_edit_file()
{ 
 local ArrayArg=( $* ) ; 
 local __call_locality=( FEF find_edit_file ) ; 
 local StrPath=${FEFDefaultPath:=./} ;
 local StrAppsFind=${FEFAppsFind:=/usr/bin/find} ;
 local StrEditor=${FEFEditorApps:=/usr/bin/gedit} ;
 local StrFindFilterOpt=${FEFFindFilter:=-iname \"__FILE__\"} ;

  #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  if [ "${ArrayArg[0]}" = "--help" ] ; then 
   GetVarReference find_edit_file ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ; 			
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
  else	
  for file in ${ArrayArg[@]} ; do 
   local StrFilterInFind=${StrFindFilterOpt//__FILE__/${file}}
   eval "${StrAppsFind} ${StrPath} -type f ${StrFilterInFind} -exec ${StrEditor} {} \;" & 
  done ; 
 fi
}

### Usefult having clause with many compiler available and having h2xml or ctag path filtering to apply,
### having command like 
###
### -> h2xml /usr/include/math.h $( find /usr/include/ -type d -printf "-I%p " ) -c -o math_c.xml 
###	 Will reduce output of some treatment... 
###  ->>>
###  ->>>CompilerError: In file included from /usr/include/math.h:34,
###  ->>>                 from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/x86_64-linux-gnu/bits/huge_val.h:28:18: error: missing binary operator before token "("
###  ->>>/usr/include/x86_64-linux-gnu/bits/huge_val.h:30:20: error: missing binary operator before token "("
###  ->>>In file included from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/math.h:403:42: error: missing binary operator before token "("
###  ->>>In file included from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/math.h:30: error: '__BEGIN_DECLS' does not name a type
###  ->>>In file included from /usr/include/math.h:71,
###  ->>>                 from /tmp/tmpX768Me.cpp:1:
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: '__' was not declared in this scope
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: 'acos' was not declared in this scope
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: '__CONCAT' cannot be used as a function
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: expected primary-expression before ')' token
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: initializer expression list treated as compound expression
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: expected ',' or ';' before '(' token
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:57: error: redefinition of 'double __CONCAT'
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:55: error: 'double __CONCAT' previously defined here
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:57: error: 'asin' was not declared in this scope
###  ->>>/usr/include/x86_64-linux-gnu/bits/mathcalls.h:57: error: expected primary-expression before ')' token

###
###
###


unset FindFilterPathExclusion
function FindFilterPathExclusion()    
{ 
 local ArrayArg=( $* ) ; 
 local __call_locality=( FindFilterPathExclusion ) ; 
 #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  if [ "${ArrayArg[0]}" = "--help" ] ; then 
   GetVarReference ${__call_locality[0]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ; 			
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
  else	 

  ### 
  ### The chainning mechanism , if there is already used filter, passing thru this 
  ### variable will add-it to current filter output. 
  local CurrentExlusion=${FindFilterPathKnowExclusion:=""} ; 
 
  ###
  ###
  ###
  local SelectedPackagePath=${FindFilterPathName:="c++"} ; 

  ### - Will tell to filter function if this segment should be considered as
  ### first statement and in-middle statement... 
  ### example, using FindFilterWithStartCond=True, for a clause for find to start adding -a ! -name "..." 
  ### in first statement of if will give command like 
  ### find -type d [ -a ! -name "c++/4.4" ] <--- current filter . 
  ### will simply be rejected or some warning may issued from . 

  local StartFilterWithCondition=${FindFilterWithStartCond:=False};
  local StrFilterPattern="${FindFilterPattern:=NAME/VER}";
  ### 	The FindFilterClause should be written like from Removing To adding
  ###   ex: with find, having removing or excluding pattern start like -a ! -name or -o ! -iname ...
  ###       and adding or positive filter will include -a name, -o name ... 
  ###   and FindFilterClause should be written as : FindFilterClause="-a ! -name,-a name"
  local StrConditionPattern=${FindFilterClause:=! -name, -name}

  local StrTypeOfLogicForAnd=${FindFilterClauseAnd:=-a};
  local StrTypeOfLogicForOr=${FindFilterClauseAnd:=-o};
  local StrLogic=""
  ### FindFilterLogicSetTo default choice : ( And / Or )
  ### 
  ###

  local DefaultLogic=${FindFilterLogicSetTo:=And}; 
  if [ "${DefaultLogic}" == "And" ] ; then
   StrLogic="${StrTypeOfLogicForAnd}" ;
  else
   StrLogic="${StrTypeOfLogicForOr}" ;
  fi 

  local ArrayClauseFilter ;
  for(( intx=1 ; intx <= 2 ; intx++ )) ; do 
   ArrayClauseFilter[${#ArrayClauseFilter[@]}]=$( echo "${StrConditionPattern}" | cut -d "," -f ${intx} ) ;
  done 
 

  local SelectedMajor=${FindFilterMajorVer:=4} ; 
  local SelectedMinor=${FindFilterMinorVer:=4} ; 
  local TypeClauseFilter=0 ;
  for (( intx=${FindFilterMinMajorVer:=0} ; intx <= ${FindFilterMaxMajorVer:=9} ; intx++ )) ; do 
   local StrCriteronFilter=${StrFilterPattern};
   local StrCriteronFilterPrefix="";
    StrCriteronFilter=${StrCriteronFilter/NAME/${SelectedPackagePath}} ;
    StrCriteronFilter=${StrCriteronFilter/VER/${SelectedMajor}.${intx}} ;

   if [ ${intx} -ne ${SelectedMinor:=0}  ] ; then 
    TypeClauseFilter=0 ;
    if [ "${StartFilterWithCondition}" == "True" ] ; then 
     StrCriteronFilterPrefix="${StrLogic} 1${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
    else
     StrCriteronFilterPrefix="2${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
    fi ;
   fi		

   if [ ${intx} -eq ${FindFilterMinMajorVer:=0} ] ; then 
    TypeClauseFilter=${TypeClauseFilter} ;
    if [ "${StartFilterWithCondition}" == "True" ] ; then 
     StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
    else
     StrCriteronFilterPrefix="${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
    fi ;
   else
    if [ "${StartFilterWithCondition}" == "False" ] ; then 
     StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
    else
     StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
    fi ;
   
   fi


   if [ ${intx} -eq ${SelectedMinor:=0} ] ; then 
    TypeClauseFilter=1 ;
    if [ "${StartFilterWithCondition}" == "True" ] ; then 
     StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[${TypeClauseFilter}]} ${StrCriteronFilter}" ;
    else
     if [ ${intx} -eq ${FindFilterMinMajorVer:=0} ] ; then 
      StrCriteronFilterPrefix="${ArrayClauseFilter[${TypeClauseFilter}]} \"${StrCriteronFilter}\"" ;
     else
      StrCriteronFilterPrefix="${StrLogic} ${ArrayClauseFilter[1	]} \"${StrCriteronFilter}\"" ;				
     fi
    fi ;
   fi
   CurrentExlusion="${CurrentExlusion} ${StrCriteronFilterPrefix}" ;
  done
  echo -ne "${CurrentExlusion}" ; 
 fi 
}


unset acquire_lan_ifconfig
function acquire_lan_ifconfig()
{
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ; 
 local __call_locality=( AWI ) ; 
 local StrDefaultCard=${AWICardName:=wlan0} ;
 local StrAppsNetConf=${AWIAppsIfconf:=/sbin/ifconfig} ; 
 local StrAwkFilter=${AWIAwkScript:=${FNCTDLIBPATH}/awk-script/ifconfig_tag_detection.awk} ; 
 local StrTagNameList=${AWIAwkTagInspect:=HWaddr,inet addr,inet6\ addr};
 
 function IfconfigGetter()
 {
  local ArrayArg=( $* ) ; 
  local __call_locality=( IfconfigGetter ) ;
  local StrOptGetter=${IfconfigGetterAddr:=local} ; 
  local StrApps=${IfconfigGetterApps:=/sbin/ifconfig} ; 
  $( eval ${StrApps} ${StrOptGetter} | tr '[:cntrl:]' ' ' | sed 's/[\ ]\+/ /g' ) ; 
 }
 function GetIpaddr()
 {
  local ArrayArg=( $* ) ; 
  local __call_locality=( GetIpaddr ) ;
  local StrAddr=${GetIpaddrAddr:=local} ; 
  local StrAppsIfconfig=${GetIpaddrAppsIfconfig:=/sbin/ifconfig} ;
  local StrAwkFilter=${GetIpaddrFilterMatch:=/etc/init.d/Fnct.D/awk-script/ifconfig_tag_detection.awk} ;   
  local StrTagList=${GetIpaddrTagList:=HWaddr,inet addr,inet6\ addr} ; 
  local StrTagCleanFilter=${StrTagList//\\ / } ;
  local StrReturn=$( IfconfigGetterApps=${StrAppsIfconfig} IfconfigGetterAddr=${StrAddr} IfconfigGetter awk -vTagName="${StrTagCleanFilter}"  -f StrAwkFilter ) ; 
  
 }
 #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${Arg0:=--start-services}" = "--help" ] ; then 
  GetVarReference acquire_lan_ifconfig ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ; 			
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 elif [ "${Arg0:=--start-services}" == "--start-services" ] ; then 
  GetIpaddrTagList=${StrTagNameList} \
  GetIpaddrAppsIfconfig=${StrAppsNetConf} \
  GetIpaddrAddr=${StrDefaultCard} \
  GetIpaddr ; 
 fi 
}


unset GetBuildFlagsList
function GetBuildFlagsList( )
{
  local ArrayArg=( $* ) ; 
  local __call_locality=( ZPI ) ;  
  dpkg-buildflags --list | tr '[:cntrl:]' ' ' 
} 


unset GetZenityText ; 
function GetZenityText()
{
 local ArrayArg=( $* ) ; 
 local __call_locality=( GZT GetZenityText ) ;  
 local Arg0=${ArrayArg[0]} ;
 local StrTypeUI=${GZTUiType:=--entry}
 local StrApps=${GZTUiApps:=/usr/bin/zenity} ;
 #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 if [ "${Arg0:=--startservices}" == "--help" ] ; then 
  GetVarReference ${__call_locality[1]} ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ; 			
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 else
  eval ${StrApps} ${StrTypeUI} ${ArrayArg[@]} ;
 fi 
}



unset GetZenityTextEntry ; 
function GetZenityTextEntry()
{
 local ArrayArg=( $* ) ; 
 local __call_locality=( GZTE GetZenityTextEntry ) ;  
 local Arg0=${ArrayArg[0]} ;
 local IntWidth=${GZTEWidth:=640}
 local IntHeight=${GZTEHeight:=275}
 local StrTitle="""${GZTETitle:="Pip installation Try-up"}""" ; 
 local StrQuestion="""${GZTETextQuestion:="Installation Package to install (test)"}""" ; 
 local StrReturn ;
 #local StrSwitchMessages="Following switch(es) are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--set\t\tStore new value for prefixed-var \n\t\t\t( only if ValueParser is used and it store value in a user profile ).\n\t\t\tAlso wrong-stored value might affect the application.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\t--query\t\tQuery for a Prefixed variable name.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  if [ "${Arg0:=--startservices}" == "--help" ] ; then 
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ; 			
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
  else
   local CmdEval=( """local StrReturn=\$( GetZenityText --width=${IntWidth}  --height=${IntHeight} --title="${StrTitle}" --text="${StrQuestion}" ) """ ); 
   echo -ne "\n\nCmdEval : ${CmdEval[@]}\n\n" > /dev/stderr ; 
  fi 
  echo -ne "StrReturn return: ${StrReturn}\n" > /dev/stderr ; 
  echo -ne "${StrReturn}" ; 
}



unset zenity_pip_installer ; 
function zenity_pip_installer()    
{ 
	
		local ArrayArg=( $* ) ; 
		local __call_locality=( ZPI ) ;  
		local pkg_res=0 ; 
		function GetItemFlags()
		{
			local ArrayArg=( $* ) ; 
			local __call_locality=( GIF ) ;  
			dpkg-buildflags --get ${ArrayArg[0]} ;
		}
		
		while [ ${pkg_res:=0} -eq 0 ] ; do 
		local ADDFLAGS="" ; 
		local package=$( GetZenityTextEntry ) ; 

		for Item in $( GetBuildFlagsList ) ; do 
			local newFlags=$( GetItemFlags ${Item} ) ;
			ADDFLAGS="${ADDFLAGS} ${Item}=\"${newFlags}\"" ; 
		done  ; 
		echo -ne "ADDFLAGS:\n${ADDFLAGS}\n" ; 
		if [ ${package:=none} != "none"  ] ; then 
			eval ${ADDFLAGS} pip install ${package} ; 
		else 
			echo -ne "\n\n\t\tError reporting package: ${package:=none}\n\n" ; 
			sleep 10 ; 
			pkg_res=1 ;  
		fi ; 
		done ; 
}

eval $( GFCFuncName=ZenityContentListing GlobalFunctionCleaning ) ; 
#unset ZenityContentListing ; 

function ZenityContentListing( )
{
	local -a ArrayArg=( $* ) ; 
	local -a __call_locality=( ZCL ZenityContentListing ) ; 
 local Arg0="${ArrayArg[0]}" ;

 local StrParentApps=${__call_locality[1]} ;
 local StrStartMain=${ZCLFuncStart:=__main_StartServices} ; 
 local StrTitle=${ZCLTitle:="Select a user for __APPS__"} ;
	local StrCol0=${ZCLCol0:="selection"} ;
	local StrCol1=${ZCLCol1:="user"} ; 
 local IntWidth=${ZCLWidth:=400} ;
 local IntHeight=${ZCLHeight:=500} ;
 local StrDefaultCSV=${ZCLCSV:=':'} ;
 local IntDefaultColExtr=${ZCLColExtr:=1} ;
 local StrFileInfo=${ZCLFilePasswd:=/etc/passwd} ;
 local StrAppsName=${ZCLAppsName:=Application};
 local StrTagEntry=${ZCLTagListParser:=StrAppsName:__APPS__,StrZenityFilterCmd:__ZenityFilter__,IntWidth:__WIDTH__,IntHeight:__HEIGHT__,StrTypeListOpt:__LIST_TYPE__} ;
	local StrRegSearch=${ZCLRegSearch:="\/bin\/bash"} ;
	
 local BoolDisplayDebug=${ZCLDebug:=False} ; 
 local BoolShowUserSelection=${ZCLSUS:=False} ;
 local BoolCheckList=${ZCLIsCheckList:=False} ; 
 local BoolCheckListMulti=${ZCLIsCheckListMulti:=False} ;
 local StrVarList="StrStartMain,BoolDisplayDebug,StrAppsName,StrTagEntry,StrParentApps,IntWidth,IntHeight,StrTitle,StrCol0,StrCol1,StrDefaultCSV,IntDefaultColExtr,StrFileInfo,StrRegSearch,BoolShowUserSelection,BoolCheckList,BoolCheckListMulti,StrVarList" ;
 local -A ArrayZenityTypeList ;
 
 ArrayZenityTypeList["multi"]="--checklist --multiple" ; 
 ArrayZenityTypeList["checklist"]="--checklist" ;
 ArrayZenityTypeList["standard"]="--radiolist" ;
 
 function Verbosis()
 {
  local -a ArrayArg=( $* ) ; 
  local -a __call_locality=( Verbosis Verb );
  local Arg0="${ArrayArg[0]}"
  local StrMsg=${VerbMsg:=__TEXT__} ; 
  local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
  local IsDisplayFormatted=${VerbFormated:=True} ;
  if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
    echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
    if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
     echo "${StrMsg}" ;  
    else
     echo "${StrMsg}" > ${StrDevOut} ;
    fi 
   fi 
  fi
 } 
 ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis

 
 ### Uses current variable 
 ### StrRegSearch,StrFileInfo,StrDefaultCSV,IntDefaultColExtr
 ### 
 function ZenityFilter()
	{
  local -a __call_locality=( ZF ZenityFilter )
  local -a ArrayArg=( $* ) ; 
  local Arg0="${ArrayArg[0]}" ;			
  egrep -i ${StrRegSearch} ${StrFileInfo} | /usr/bin/cut -d ${StrDefaultCSV} -f ${IntDefaultColExtr} | sed  's/\(^[a-zA-Z0-9]*\)/FALSE \1/g' ; 
	}
	
 ### Uses current variable 
 ### StrTitle,StrCol0,StrCol1,StrDefaultCSV,StrFileInfo,StrRegSearch,IntDefaultColExtr,StrUser,BoolShowUserSelection,,,
 ### 
 function ZenityFileReader()
	{
  local -a ArrayArg=( $* ) ; 
  local -a __call_locality=( ZFR ZenityFileReader ${StrParentApps} ) ; 
  local Arg0="${ArrayArg[0]}";		
  local StrTypeList="standard" ; 
  local StrSelectionCmd ; 
  local StrTypeListOpt ; 
  local StrZenityFilterCmd ; 
  local StrUserSelection;
  local StrMsg ; 
  local StrTypeListOpt ; 
  local StrTagParser; 
  ### "StrZenityFilterCmd:__ZenityFilter__,IntWidth:__WIDTH__,IntHeight:__HEIGHT__,StrTypeListOpt:__LIST_TYPE__" ;
  
  if [ ${BoolCheckList:=False} == "True" ] ; then
   StrTypeList="checklist" ;
  fi 
  
  if [ ${BoolCheckListMulti:=False} == "True" ] ; then
   StrTypeList="multi" ;
  fi 
  StrTypeListOpt=$( ${StrParentApps} --get ArrayZenityTypeList[${StrTypeList}] ) ;   
  
  
  StrZenityFilterCmd="""eval \$( eval VTVIsArrayStyleInsert=True VTVValueEntry=${StrVarList} VTVIsValueReAssign=True VTVIsValueToConvert=False VTVIsArrayStyleInsert=True ValueToVariable ) ZenityFilter ; """ ; 
  
  StrMsg="ZenityFilter Should return This command-line: __CMD__" ;
  VerbMsg=${StrMsg//__CMD__/${StrZenityFilterCmd}} VerbState=${BoolDisplayDebug} VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True StrDevOut=/dev/stderr Verbosis

  StrSelectionCmd="""StrUserSelection=\$( zenity --width=__WIDTH__ --height=__HEIGHT__ --list --title \"${StrTitle}\" --column=\"${StrCol0}\" --column=\"${StrCol1}\" __LIST_TYPE__ \$( __ZenityFilter__  ) 2> /dev/null )""" ;
  
  eval StrTagParser=$( eval                   \
    TPVarNameParsed="StrSelectionCmd"         \
    TPDisplayParserNotice=${BoolDisplayDebug} \
    TPDisplayDebug=${BoolDisplayDebug}        \
    TPIsMatchRtoL=True                        \
    TPArrayName=ArrayGPUTag                   \
    TPListTag="${StrTagEntry}"                \
    TagParser ) ; 

  local IRet=$? ;  
  StrMsg="Return Status of IRet: __IRET__,\nStrTagParser:__PARSER__\nStrSelectionCmd: __STR__" ;
		StrMsg=${StrMsg//__PARSER__/${StrTagParser}} ;
		StrMsg=${StrMsg//__IRET__/${IRet:=-1}} ;
		StrMsg=${StrMsg//__STR__/${StrSelectionCmd}} ;
  VerbMsg=${StrMsg} VerbState=${BoolDisplayDebug} VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbDev=/dev/stderr Verbosis
  ### Adding one more eval to this line and the error 'Arg0=: command not found' disapearing !
  eval $( eval "${StrTagParser}" )  ;
  StrMsg="After TagParser Action: value of StrSelectionCmd:[ __STR__ ]" ;
  VerbMsg=${StrMsg//__STR__/${StrSelectionCmd}} VerbState=${BoolDisplayDebug} VerbHeader="DEBUG-${__call_locality[1]}" VerbFormated=True VerbDev=/dev/stderr Verbosis
  
  ### section here replaced by ValueToVariable 
  ###StrZenityFilter="""StrDefaultCSV=${StrDefaultCSV} \
  ###               StrFileInfo=${StrFileInfo} \
  ###               StrRegSearch=${StrRegSearch} \
  ###               IntDefaultColExtr=${IntDefaultColExtr} \
  ###               ZenityFilter""" ;     
         
  
		### Notice, since the StrUserSelection is embedded inside the StrSelectionCmd
  ### We need to evaluate without execution back-trace -> $( __COMMAND__ ) ; 
  ### simply eval __COMMAND__ 
  eval "${StrSelectionCmd}" ;
  
  StrMsg="User selected: __USER__" ;
   
  ### Replace the Output for User-selected, aka Prefixed-Variable BoolShowUserSelection from ZCLSUS
		VerbMsg=${StrMsg//__USER__/${StrUserSelection}} VerbHeader=DEBUG VerbFormated=True VerbState=${BoolShowUserSelection} VerbDev=/dev/stdout  Verbosis ;
		
  ### Replace the echo and the selected informations
  #echo "${StrUserSelection}" ; 
  VerbMsg=${StrUserSelection} VerbEvalForm=True  VerbFormated=False VerbState=True Verbosis ; 
 }

 function __main_StartServices()
 {
		local ArrayArg=( $* ) ; 
		local __call_locality=( Main __main_StartServices ) ; 
		local Arg0=${ArrayArg[0]} ; 
  
  eval $( eval \
  VTVIsArrayStyleInsert=True  \
  VTVValueEntry=${StrVarList} \
  VTVIsValueReAssign=True     \
  VTVIsValueToConvert=False   \
  VTVIsArrayStyleInsert=True  \
  ValueToVariable ) ZenityFileReader
  
 }
 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 local StrNameHelper="ZenityContentListing\n\tThe Fnct.D Mechanism To list-down information from file and report it\n\tinside a Standardized Zenity-List container.";
 local StrSynopsis="\n\tHelper involved inside GksuZenityLoader to load application like\n\tFirefox, Idlex and many more application configured internaly, ";
 local StrSummary="\n\tFirst it's an helper reserved to choose a user to load the application\n\tunder a specific name. Used in PackageRepositoryMgmt to select or\n\tvisualize the UNIQUE-ID snapshoot of maintained archives linked to a\n\tbackup place to reduce size of /var this application is quite useful if\n\tyou know how to specify and pass a regular-expression to\n\tinternal function to ZenityFilter." ; 
 local StrDescription="\nVariable helper:\n\nZCLIsCheckList   Set True/False, To use a checkboxlist rather than \n\t\tmove the radio-buton to your item inside the list.\nZCLIsCheckListMulti\n\t\tSet True/False, To activate Multiple selection and \n\t\tCheckboxlist altogether.\n\n\tOnly one of the two is affecting the Zenity List interface at the time. \nChanging the selection to check-list and choosing none of them is restoring the\ninterface to a radio-button action.\n\nInterface Field and File-reader options:\n\nZCLFilePasswd\tFILENAME, File choosed to  read out, Belong to GksuZenityLoader\n\t\treference to use the sudo belong to user to load the application\n\t\tit read  user list from /etc/passwd,  from  PackageRepositoryMgmt \n\t\tit  read the latest file ( named  latest after doing  package \n\t\ttransfert ) .\nZCLRegSearch\tSTRING The Regular Expression to  search by  column  lines.  In\n\t\t/etc/passwd  it's all user  having /bin/bash like shell, but a\n\t\tline  start with  anything can  be  \[A-Za-z0-9\]*  Some  case\n\t\trequire  good quoting or  error will happen ...\nZCLColExtr\tINT 0 .. NF  Awk-based  Field location.  Tel  to \n\t\tZenityContentListing which  column to display  or to read from \n\t\tyour CSV  match\nZCLCSV\t\tCHAR, Variable used as CHAR identifier in Comma Separated Value\n\t\tand usually  choosed ':' or ','. We  strongly suggest to wrap\n\t\tyour CSV choice with single quote / guillemets is mandatory for\n\t\tsemi-colon : ';'\n\nInterface options:\n\nZCLTitle\tString To Define a Title ( suggested to use simple or triple\n\t\t quotes ). ZCLTitle  have  property to hold a  Tag named __APPS__\n\t\tand will hold the  application name,  adding this  tag to the \n\t\tproperty of ZCLTitle will  parse-it.\nZCLCol0\t\tFirst Column a.k.a  selection column  it take the  name of the\n\t\taction when  the second one  is a file-list  as example :\n\t\t(ZCLCol0=\"file deletion\")\nZCLCol1\t\tSecond Column name  always represent  the listing desired,  in\n\t\tcase of  filtering file /etc/passwd  it take the user result in\n\t\tCSV=1, at CSV=7 it take the shell per-user.\n\nZCLWidth\tWidth Size or X-axis of the List-Box. \nZCLHeight\tHeight or Y-axis of the List-Box.\n\nGkSuZenityLoader options:\n\nZCLSUS\t\tSet True/False to change the output to Desired GkSuZenityLoader\n\t\trequirement  to format  the output to  form a  sentences  from\n\t\tselection and should  be  inserted inside  a  Text-dialog.\n" ; 
 ### \nVariable helper:\n\nZCLIsCheckList\t\tSet True/False, To use a checkboxlist rather than move the radio-buton to your item inside the list. \nZCLIsCheckListMulti\tSet True/False, To activate Multiple selection and Checkboxlist altogether.\n\n\t\tOnly one of the two is affecting the Zenity List interface at the time. Changing the selection to check-list and choosing none of them is retoring the interface to a radio-button action.\n\n\tInterface Field and File-reader options:\n\nZCLFilePasswd\tFILENAME, File choosed to read out, Belong to GksuZenityLoader reference to use the sudo belong to user to load the application it read user list from /etc/passwd, from PackageRepositoryMgmt it read the latest file (named latest after doing package transfert)\nZCLRegSearch\tSTRING The Regular Expression to search by column lines. In /etc/passwd it's all user having /bin/bash like shell, but a line start with anything can be \[A-Za-z0-9\]* Some case require good quoting or error will happen...\nZCLColExtr\tINT 0 .. NF Tel to ZenityContentListing which column to display or to read from your CSV match\nZCLCSV\t\tCHAR, Variable used as CHAR identifier in Comma Separated Value and usually choosed ':' or ','. We strongly suggest to wrap your CSV choice with single quote/guillemets mandatory for semi-colon : ';' \n\n\tInterface options:\n\nZCLTitle\tTo Define a Title (suggested to use simple or triple quotes ) ; ZCLTitle have property to hold a Tag named __APPS__ and will hold the application name, adding this tag to the property of ZCLTitle will parse-it.\nZCLCol0\t\tFirst Column a.k.a selection column it take the name of the action when the second one is a file-list as example (ZCLCol0=\"file deletion\")\nZCLCol1\t\tSecond Column name always represent the listing desired, in case of filtering file /etc/passwd it take the user result in CSV=1, at CSV=7 it take the shell per-user.\nZCLWidth\tWidth Size or X-axis of the List-Box. \nZCLHeight\tHeight or Y-axis of the List-Box.\n\n\tGkSuZenityLoader options:\n\nZCLSUS\t\tOption to Set True/False to change the output to Desired GkSuZenityLoader requirement to format the output to form a sentences from selection and should be inserted inside a Text-dialog. ;


 
 ### This is the end-block-if for switches
  
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GVRIsName=True GVRIsSynopsis=True GVRIsSummary=True GVRIsDesc=True GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
		eval $( __GetVarReferenceCompWord ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( eval VTVIsArrayStyleInsert=True \
       VTVValueEntry=${StrVarList}   \
       VTVIsValueReAssign=True       \
       VTVIsValueToConvert=False     \
       VTVIsArrayStyleInsert=True    \
       ValueToVariable ) ${StrStartMain}
	fi
 
}

eval $( GFCFuncName=GkSuZenityLoader GlobalFunctionCleaning ) ; 

#unset GkSuZenityLoader ; 
function GkSuZenityLoader()
{
  function Verbosis()
  {
   #eval $( CAFunctName=Verbosis CAIsAddParent=False __Call_Argument ) ; 
   local -a ArrayArg=( $* ) ; 
   local -a __call_locality=( Verb Verbosis )
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
        echo "${StrMsg}" ;  
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo "${StrMsg}" >> ${StrDevOut} ;
      else
       echo "${StrMsg}" > ${StrDevOut} ;
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
 
	local ArrayArg=( $* ) ; 
	local __call_locality=( GSZL GkSuZenityLoader ) ; 
 local Arg0=${ArrayArg[0]};
 local StrStartMain=${GSZLFunctStart:=__main_StartServices} ; 
	local StrUser=${GSZLUser:=none} ;
	local StrApps=${GSZLApps:=/usr/local/bin/idlex} ;
	local StrAppsOpt=${GSZLAppsOpt:=''} ;
	local StrTitle=${GSZLTitle:="Select a user for Idlex"} ;
	local StrFileInfo=${GSZLFile:=/etc/passwd} ;
 local StrUserListApps=${GSZLUserListApps:=ZenityContentListing}  ; 
	local StrCol0=${GSZLCol0:="selection"} ;
	local StrCol1=${GSZLCol1:="user"} ;
	local StrRegSearch=${GSZLRegSearch:="\/bin\/bash"}
	local StrDefaultCSV=${GSZLCSV:=':'} ;
	local IntDefaultColExtr=${GSZLColExtr:=1} ;
	local BoolShowUserSelection=${GSZLSUS:=False} ;
 local BoolUpdateLdconfig=${GSZLUpdadeLdconfig:=True} ;
 local StrLdConfigUser=${GSZLLdconfigUser:=root} ;
 local StrLdconfigGreeting=${GSZLLdconfigGreeting:="Hint: Loading ldconfig on need if some module require to be loaded from ldconfig ( ex: from pip installation or easy_setup.py ) It can be accessible through Prefixed-var GSZLUpdadeLdconfig=True from GkSuZenityLoader."} ;
	local BoolShowFGSZ=${GSZShowFuncGSZ:=True} ; 
 local BoolDisplayDebug=${GSZDisplayDebug:=False} ; 
 local StrVarList="BoolDisplayDebug,StrLdConfigUser,StrUser,StrApps,StrAppsOpt,StrTitle,StrFileInfo,StrCol0,StrCol1,StrRegSearch,StrDefaultCSV,IntDefaultColExtr,BoolShowUserSelection,BoolUpdateLdconfig,StrLdconfigGreeting,BoolShowFGSZ,StrVarList";
   
 function NotificationLdConfig()
 {
		local ArrayArg=( $* ) ; 
		local __call_locality=( NLC NotificationLdConfig ) ; 
  local Arg0=${ArrayArg[0]} ;
  
  local StrTextNotification=${NLCNotifyText:="You will be prompted for password to load __APPS__ with __APPS__ user allowed: __USER__"} 
  local StrUser=${NLCAppsUser:=root} ; 
  local StrApps=${NLCAppsName:=/sbin/ldconfig} ; 
  local StrTagUser=${NLCTagUser:=__USER__} ;
  local StrTagApps=${NLCTagApps:=__APPS__} ;
  StrTextNotification=${StrTextNotification//${StrTagUser}/${StrUser}} ;
  StrTextNotification=${StrTextNotification//${StrTagApps}/${StrApps}} ;
  
  zenity --notification --text="${StrTextNotification}" ; 
 }
 
 function ScreenDisplayLdconfigHint()
 {
		local __call_locality=( SDLH ScreenDisplayLdconfigHint ) ; 
		local ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ;
  
  echo -ne "${StrLdconfigGreeting}" > /dev/stderr ; 
 }
 
 function LdconfigNotification()
 {
		local ArrayArg=( $* ) ; 
		local __call_locality=( LN LdconfigNotification ) ; 
  local Arg0=${ArrayArg[0]} ;
  NotificationLdConfig ; gksu --user ${StrLdConfigUser} ldconfig
 }
 
	function Loader()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( L Loader ) ; 
  local Arg0=${ArrayArg[0]} ; 
  eval $( eval BVTIdType=0          \
          BVTVarName=StrAppsLd      \ 
          BVTDisplayIf=${BoolDisplayDebug}        \
          BVTDisplayShowDebug=${BoolDisplayDebug} \
          BVTVarHold='StrLdconfigGreeting='${StrLdconfigGreeting}' ScreenDisplayLdconfigHint' \
          BVTBoolVarName=\${BoolUpdateLdconfig}   \
          BVTBoolCase=True           \
          BVTBoolAssertion='LdconfigNotification' \
          BVTScopeTest=local         \
          BoolVarTest ) ; 
  eval $( eval BVTIdType=0           \
          BVTDisplayIf=${BoolDisplayDebug}        \
          BVTDisplayShowDebug=${BoolDisplayDebug} \
          BVTVarName=StrLdConfigLoad \
          BVTVarHold='$( eval ${StrAppsLd} )'     \
          BVTBoolVarName=\${BoolUpdateLdconfig}   \
          BVTBoolCase=True BVTBoolAssertion='$( eval ${StrAppsLd} )' \
          BVTScopeTest=local         \
          BoolVarTest ) ; 
		gksu --user ${StrUser} ${StrApps} ${StrAppsOpt} 
	}
 
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  
 
   ### Our Rosetta-Pebble Story...  Rosetta Stone : https://en.wikipedia.org/wiki/Rosetta_Stone 
   ### This version of if user==None -> do call ZenityContenteListing to query 
   ### for a user name to load the application. It require a simple change inside 
   ### the Prefixed-variable BVTVTVTPLA for Assertion-ValueToVariable method to include
   ### a variable to receive the value... 
   ### A few way to no getting this automatically replaced by 
   ### >>> StrNewTemplateAssertion=$( BoolVarTest --get BVTVTVTPLA ) | sed 's/\(__FNCT_ASRT__\)/StrUser=__TES__ \1 __TEE__/g'
   ### Where I leave it for Super-USer, and higher-skills. 
   
   local StrNewTemplateAssertion="eval __TES__ eval __REGISTRY_ASRT__ VTVValueEntry=__VAR_ENTRY_ASRT__ ValueToVariable __TEE__ StrUser=__TES__ __FNCT_ASRT__ __TEE__ " ; 
   eval $( BVTDisplayIf="${BoolDisplayDebug}"       \
           BVTDisplayShowDebug="${BoolDisplayDebug}"\
           BVTIsPreambule=False BVTBoolCase='none'  \
           BVTIsValueToVarAssert=True               \
           BVTBoolVarName="\${StrUser:=none}"       \
           BVTVTFnctA="\${StrUserListApps}"         \
           BVTVTVVarA="${StrVarList}"               \
           BVTVTVTPLA="${StrNewTemplateAssertion}"  \
           BVTIdType=0 \
           BoolVarTest ) ; 
   local StrMsg="User inside varible StrUser:__VAR__" ;
   
   StrMsg=${StrMsg//__VAR__/${StrUser}} ; 
   VerbMsg=${StrMsg} VerbHeader="DEBUG" VerbEvalForm=False VerbFormated=True VerbState=${BoolDisplayDebug} VerbDev=/dev/stderr  Verbosis
   
   ### While this code was also being synthetized up-there 
   #if [ "${StrUser:=none}" ==  "none" ] ; then 
   # eval StrUser=$( eval VTVIsArrayStyleInsert=True   \
   #              VTVValueEntry=${StrVarList} \
   #              VTVIsValueReAssign=True     \
   #              VTVIsValueToConvert=False   \
   #              ValueToVariable ) ZenityContentListing ;
   ### This code was replaced by the content up-there
   #StrUser=$( ZCLCSV=${StrDefaultCSV} \
   #   ZCLColExtr=${IntDefaultColExtr} \
   #   ZCLFilePasswd=${StrFileInfo} \
   #   ZCLTitle=${StrTitle} \
   #   ZCLCol0=${StrCol0} \
   #   ZCLCol1=${StrCol1} \
   #   ZCLRegSearch=${StrRegSearch} \
   #   ZCLSUS=${BoolShowUserSelection} ZenityContentListing ) ; 
   #fi 
  if [ "${StrUser:=none}" == "none" ] ; then 
   echo -ne "Warning Invalid user: ${StrUser}\n" > /dev/stderr ; 
  else
  eval $( eval VTVIsArrayStyleInsert=True   \
                VTVValueEntry=${StrVarList} \
                VTVIsValueReAssign=True     \
                VTVIsValueToConvert=False   \
                ValueToVariable ) Loader ;
  fi 
  
 }
 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 local StrNameHelper="\tA General-Purpose Zenity Userlist calling gksudo and the application ;\n \tThe Fnct.D Mechanism to load the application by user right. This is \n\tdone with gksudo application made it easy to handle. \n\n";
 local StrSynopsis="\n\tSince it's becoming more and more easy to make script and development\n\tlibrary  with  Bash,  Execution  Right and User Access are  sometimes\n\tneglected. Using such script may help managing user need and dedicated\n\tacount.\n";
 local StrSummary="\n\tWhile  script aren't  easy  adding extra-command line  for security\n\tquestion,  handling  GkSuZenityLoader  only  one  Prefixed-Variable\n\tGSZLApps  allow you to  simply choose the user with Zenity List and\n\tto  confirm  password and the  application is  ready to  open  with\n\tappropriate  user restriction . \n" ; 
 local StrDescription="GSZLSUS\t[True/False], Show User Selection.\nGSZLUpdadeLdconfig\n\t\t[True/False], Ask to Application to add a ldconfig pass before\n\t\trunning the application.\nGSZLUser\t[String], apply a default selection inside the Windows listed.\nGSZLApps\t[String], The application to  run with the correct user right.\nGSZLAppsOpt\t[String], Extra  parameter to pass to  the  application, like\n\t\tverbose more option. They are appended  after the  GSZLApps in\n\t\tform : [GSZLApps] [GSZLAppsOpt]\nGSZLTitle\tString, Default  title to Zenity  Window  content-list.\nGSZLFile\t[FILE], Default  file to  search for option to search to build\n  \t\tthe Zenity  Content-list  field.  '/etc/shadow'  is good  but\n\t\trequire administrative  right to read  it.\nGSZLUserListApps\n\t\t[String], Function-Interface to use to  display the  Zenity\n\t\tContent Listing information. Can be  another function  but\n\t\trequire to pass the extra Prefixed-variable from command-line.\n\t\tOther application will require pass diretly the option to the \n\t\tGSZLUserListApps will requiert to quote the Prefixed-variable.\n\t\tExample like Zenity Content-list from GitChckBranchEngine, may\n\t\twork if  it  can disable the  checkout action  after and will \n\t\trequire to use  the FuncStart  Prefixed-variable  from \n\t\tGitChckBranchEngine ex:\n\t\tGSZLUserListApps=\"GCBEFuncStart='ZenityWindowHandler' \n\t\tGitChckBranchEngine\" . And Other variable like GCBETitle,\n\t\tGCBEText,GCBEFontSize,GCBEFontFamily,GCBEWinHeight,\n\t\tGCBEWinWidth Will require to be specified from command-line.\nGSZLCol0\t[String], Default definition for the First column, called \n\t\t'selection' it's also where the Checkbox or radio-button is \n\t\taligned-in.\nGSZLCol1\t[String], Default definition of the selected rank, in this \n\t\tcase it refer to user to load the application under NAME.\nGSZLRegSearch\t[String], The based shell to search for accessible user. They\n\t\tare using other shell like '/bin/sh' specify a shell with this\n\t\tvariable. A shell should be listed inside /etc/shells or sudo\n\t\twon't allow you to run the application. As same for user with\n\t\t/usr/sbin/nologin,  and  /bin/false can be selected.\nGSZLCSV\t[Char-quoted], Default CSV to  counts  column in  a CSV file.\n\t\t'/etc/passwd' require  double-dot CSV ':'.\nGSZLColExtr\t[Int], Default to  '1',  it's the Column from GSZLRegSearch is\n\t\trequired to display on the Zenity  Content List. Other number\n\t\twill display other lines of  GSZLFile if it's '/etc/passwd' it\n\t\tmay show you, shell-used, comment to  user, encrypted-password.\nGSZLLdconfigUser\n\t\t[String], Under which  user the ldconfig action (if choosen) will\n\t\tstart the update.  Default to root, but  somes  system  may \n\t\t'require/accept' other users.\nGSZLFunctStart\t[String], By default,  it's '__main_StartServices' and it's the\n\t\tboot-strap  function to application startup. Suggest to not \n\t\ttouch it  unless you  do  have coded  your own  \n\t\t'Main start services' .\nGSZLLdconfigGreeting\n\t\t[String], If  it's accessible,  display a  message  before\n\t\tstarting  ldconfig  update and thus may take  extra time and\n\t\tshow  behaviour  it's extra  time it's  based on  ldconfig\n\t\taction  and  not frozen  or slow  application.\n";
 #"\n\tMost simplest way to call-it\n\n\tUsing Firefox as example:\n\n\tGSZLApps=/usr/bin/firefox GkSuZenityLoader\n\n\tHaving Some library update to do before, adding GSZLUpdadeLdconfig=True\n\tto command will enhance this task.\n\n\tGSZLUpdadeLdconfig=True GSZLApps=/usr/bin/firefox GkSuZenityLoader" ;
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GVRIsName=True     \
   GVRIsSynopsis=True \
   GVRIsSummary=True  \
   GVRIsDesc=True     \
   GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
		eval $( __GetVarReferenceCompWord ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( eval VTVIsArrayStyleInsert=True   \
                VTVValueEntry=${StrVarList} \
                VTVIsValueReAssign=True     \
                VTVIsValueToConvert=False   \
                ValueToVariable ) ${StrStartMain} ;
 
 fi
}

unset UUIDHelper 
function UUIDHelper()
{
	local __call_locality=( UUIDH UUIDHelper ) ;
	local StrDefaultSwitches=${UUIDHSwitches:=-t}
 local StrDefaultApps=${UUIDHApps:=/usr/bin/uuidgen} ;
 local IsVerbosis=${UUIDHVerbose:=False} ; 
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
	#local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n" ;
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  local CmdEval="${StrDefaultApps} ${StrDefaultSwitches}"	; 
  if [ "${IsVerbosis:=False}" == "True" ] ; then
   echo -ne "UUIDHelper:\n__main_StartServices:\nCMD:[${CmdEval}]\n" > /dev/stderr ; 
  fi 
  eval "${CmdEval}" ; 
 }
  
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
		eval $( __GetVarReferenceCompWord ) ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;	
	else
  eval $( VTVIsArrayStyleInsert=True VTVIsValueReAssign=True VTVIsValueToConvert=False \
  VTVValueEntry=IsVerbosis,StrDefaultSwitches,StrDefaultApps ValueToVariable ) __main_StartServices 
	fi 
} 





### Function : GetMplayerStream()
### 
### - Filter out selected stream from Firefox browser on Ubuntu/Mint and kill active stream to get only the 
### http - stream url and load itself with mplayer... Assuming the Browser openning the stream with mplayer...
### 
### Initial idea : ps -eo pid,command | egrep -i "mplayer" | egrep "http:\/\/" | awk 'BEGIN{stream="";}{printf("%s %s\n",$1,$(NF)) ; system(sprintf("kill -9 %s",$1)); stream=$(NF); }END{ system(sprintf("mplayer -ao alsa -cache 3072 %s",stream)) }'
### ... but how ingeneer see a tire over a Tree for child use... 
### 
### 

unset GetMplayerStream
function GetMplayerStream()
{
	local ArrayArg=( $* ) ; 
	local __call_locality=( GetMplayerStream ) ;
	local StrAwkPath=${GetMplayerStreamAwkPath:=/etc/init.d/Fnct.D/awk-script/} ;
	local StrAwkScriptName=${GetMplayerStreamScriptName:=MplayerStreamTransfert.awk}
	local StrAwkApps=${GetMplayerStreamAwkApps:=/usr/bin/awk} ;
	local StrGrepApps=${GetMplayerStreamGrepApps:=/bin/egrep};
	local StrGrepOpt=${GetMplayerStreamGrepOpt:=-i};
	local StrPsOpt=${GetMplayerStreamPsOpt:=-eo pid,command};

	local StrPsApps=${GetMplayerStreamPsApps:=/bin/ps};
	local StrUrlGrep=${GetMplayerStreamUrlGrep:="http:\/\/"};
	local StrPlayerName=${GetMplayerStream:=mplayer};
	local Arg0=${ArrayArg[0]} ;
	
	function GetStreamFromPs()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( GetStreamFromPs ) ;
		local StrAppsName=${GetStreamFromPsApps:=/bin/ps} ;
		local StrAppsOpt=${GetStreamFromPsOpt:=-eo pid,command} ;
		local StrFilterAppsName=${GetStreamFromPsFName:=egrep} ;
		local StrFilterAppsOpt=${GetStreamFromPsFNOpt:=-i} ;
		local StrUrlFilter=${GetStreamFromPsUrlFilter:="http:\/\/"} ;
		local StrPlayerFilter=${GetStreamFromPsUrlPlayerName:=mplayer} ;

		${StrAppsName} ${StrAppsOpt} | ${StrFilterAppsName} ${StrFilterAppsOpt} "${StrPlayerFilter}" | ${StrFilterAppsName} ${StrUrlFilter} ; 
	}
	
	function AwkScript()
	{
		local ArrayArg=( $* ) ; 
		local __call_locality=( AwkScript ) ;
		local StrAwkPath=${AwkScriptAwkPath} ;
		local StrAwkScriptName=${AwkScriptScriptName} ;
		local StrAwkApps=${AwkScriptApps} ;
		${StrAwkApps} -f ${StrAwkPath}/${StrAwkScriptName}
	}

	#local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
	local cmdline=( ) ;
	local cmdline[0]="GetStreamFromPsUrlPlayerName=\"${StrPlayerName}\" GetStreamFromPsUrlFilter=\"${StrUrlGrep}\" GetStreamFromPsFName=\"${StrGrepApps}\" GetStreamFromPsFNOpt=\"${StrGrepOpt}\" GetStreamFromPsApps=\"${StrPsApps}\" GetStreamFromPsOpt=\"${StrPsOpt}\" GetStreamFromPs";
	local cmdline[1]="AwkScriptApps=\"${StrAwkApps}\" AwkScriptAwkPath=\"${StrAwkPath}\" AwkScriptScriptName=\"${StrAwkScriptName}\" AwkScript" ; 
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[0]} ;
			#echo -ne "Following switch are available:\n\n\t--startservices\tStart the application normally and output the package list\n\t--debug\tExpose result to be executed.\n\n" > /dev/stderr ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
		eval $( __GetVarReferenceCompWord ) ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
	elif [ "${Arg0:=--startservices}" == "debug"	] ; then 
		echo -ne "CmdLine[0]:${cmdline[0]} \nCmdLine[1]:${cmdline[1]}\n" > /dev/stderr ;
	else
		echo -ne "CmdLine[0]:${cmdline[0]} \nCmdLine[1]:${cmdline[1]}\n" > /dev/stderr ;		
	fi	
}
 
### Late-Homework for old duty... 
### Preceding some specific moment in a traveller when he have to know when the plane is going to leave , 
### I was messing around faulty compilation and try to find 
### way to randomize startup a bit and lib loading to see if it's anomalies in process or simply stack 
### hacking... See Hacking The art of exploitation from No Starch press...  
### Initial Setup on how collecting information and how generate fast random number was heavy and may
### collide whith the function FaultyProcess, rendering too much work from High-heavy precesing awk-sed-grep
### line at every ';' was also slowing this baby pentium-mmx from college Rosemont also... 


unset BuildOnFaultCompiler
function BuildOnFaultCompiler()
{
	local ArrayArg=( $* )
	local __call_locality=( BOFC ) ; 
	local StrAppsLib=${BOFCLib:=/sbin/ldconfig} ;
	local StrAppsLibOpt=${BOFCLibOpt:=-f,/etc/ld.so.conf} ;
	local StrAppsAppsFault=${BOFCAppsFault:=make} ;
	local StrAppsAppsFaultOpt=${BOFCAppsFaultOpt:=''} ;
	local IntRandomSize=${BOFCRandomSeedLevel:=20} ;
	local Arg0=${ArrayArg[0]:=--startservices}
	
	function InitLib()
	{
		local ArrayArg=( $* )
		local __call_locality=( InitLib ) ; 
		local StrApps=${InitLibInitApps:=/sbin/ldconfig} ;
		local StrAppsOpt={InitLibInitAppsOpt:=-f,/etc/ld.so.conf} ;
		local ArrayAppsOpt=${StrAppsOpt//,/ } ; 
		### ldconfig -f /etc/ld.so.conf ; 
		eval "${StrApps} ${ArrayAppsOpt[@]}" ; 
	}
	function FaultyProcess()
	{
		local ArrayArg=( $* )
		local __call_locality=( FaultyProcess ) ; 
		local StrApps=${FaultyProcessInitApps:=make} ;
		local StrAppsOpt=${FaultyProcessAppsOpt} ;
		local ArrayAppsOpt=${FaultyProcessAppsOpt[@]//,/ } ;
		eval "${StrApps} ${ArrayAppsOpt[@]}" > /dev/stderr  ; 
		return $? ; 
	}

	function Start()
	{
		local res=1 ; 
		local IntRandSize=${IntRandomSize} ; 
		local StrStarHeaderLine="********************************************************************************" ;
		local StrHeader="__StrStarHeaderLine__\n\n\tBuild Failed , sleeping __IntRand__\n\n__StrStarHeaderLine__\n" ;
		echo -ne "StartWhile\n" > /dev/stderr ;
		while [ ${res} -ne 0 ] ; do 
			local ArrayRandom=(  ) ; 
			local EndRand=$(( ( ${RANDOM} % ${IntRandSize} ) )) ; 
			local IndexRand=$(( ${RANDOM} % ${IntRandSize} )) ; 
			echo -ne "IntRandSize: ${IntRandSize}\nEndRand:${EndRand}\n" > /dev/stderr ; 
			sleep 5 ; 
			echo -ne "StartFor\n" > /dev/stderr ;
			for (( intx=0 ; intx <= ${EndRand} ; intx++ )) ; do 
				echo -ne "." > /dev/stderr ;
				local RandBaseMul=$(( ( ${IntRandSize} *  ( ${RANDOM} % 10 ) ) + 1 )) ; 
				local IntRandNum=$(( ${RANDOM} % ${RandBaseMul} )) ;
				ArrayRandom[${intx}]=${IntRandNum} ; 
			done ; 
			echo -ne "\n" > /dev/stderr ;
			local IntRand=${ArrayRandom[${IndexRand}]} ; 
			echo -ne "IntRand:${IntRand}\n" > /dev/stderr ; 
			echo -ne "StartInitLib:1\n" > /dev/stderr ;
			InitLibInitApps=${StrAppsLib} InitLibInitAppsOpt=${StrAppsLibOpt} InitLib ; 
			echo -ne "StartFaultyProcess\n" > /dev/stderr ;
			FaultyProcessInitApps=${StrAppsAppsFault} FaultyProcessAppsOpt=${StrAppsAppsFaultOpt} FaultyProcess
			res=$?  ;
			echo -ne "res return [${res}]\n" > /dev/stderr ; 
			echo -ne "StartIf\n" > /dev/stderr ;
			if [ ${res:=0} -ne 0 ] ; then 
				local StrDisplayHeader=${StrHeader//__StrStarHeaderLine__/${StrStarHeaderLine}} ;
				StrDisplayHeader=${StrHeader//__IntRand__/${IntRand}} ;
				echo -ne ${StrDisplayHeader} > /dev/stderr ; 
				echo -ne "StartInitSleepRandom\n" > /dev/stderr ;
				sleep ${IntRand} ; 
				echo -ne "StartInitLib:2\n" > /dev/stderr ;
				InitLib ;
			fi ; 
		done 

	}
	
	#local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;

	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference BuildOnFaultCompiler ;
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
		eval $( __GetVarReferenceCompWord ) ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
	else
		StrAppsLib=${StrAppsLib} StrAppsLibOpt=${StrAppsLibOpt} StrAppsLibOpt=${StrAppsLibOpt} StrAppsAppsFault=${StrAppsAppsFault} StrAppsAppsFaultOpt=${StrAppsAppsFaultOpt} IntRandomSize=${IntRandomSize} Start ; 
	fi 
} 



unset RoundRobinSwapRealloc
function RoundRobinSwapRealloc()
{
	local __call__locality=( RRSR ) ;
	local ArrayArg=( $* ) ;
	local Arg0=${ArrayArg[0]} ; 
	
	local Str=${RRSR:=}
	
	function GetSwapList()
	{
		local __call__locality=( GSL ) ;
		local ArrayArg=( $* ) ;
		ArrayListSwap=( $( swapon -s | cut -d ' ' -f 1  | grep -v "Filename" | tr '[:cntrl:]' ' ' ) ) ; 
		
	}
	function Start()
	{
		local __call__locality=( Start ) ;
		local ArrayArg=( $* ) ;
		
	}
	#local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n" 
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
	
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference RoundRobinSwapRealloc ;
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--compword" ] ; then 
		eval $( __GetVarReferenceCompWord ) ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( BuildForm=${BuildForm:=False} __GetVarReferenceList ) ;
	elif [ "${Arg0:=--startservices}" == "--swaptorealloc"	] ; then 
		GetSwapList ;
	else
		 Start ; 
	fi 
}




### Note: This function is not ready and is also reserved for FitsServices.py / SkyViewFactory.py
### and this script is a low-cost download of big file, like CSV reference required to explain
### field of low-cadence fits files from keepler2 photometer. 
unset CurlFtpContentDownload ; 
unset StrFileName StrUrlTpl StrUrl StrUserAccount StrAddr StrPathSrv StrLSTag StrLSTplCmd StrLSFilterApps StrLSFilterApps StrLSApps BoolDisplayDebug ; 
unset Verbosis ExtractSize ListFile __main_StartServices ;
 
function CurlFtpContentDownload()
{
 function Verbosis()
 {
  local -a ArrayArg=( $* ) ; 
  local -a __call_locality=( Verb Verbosis )
  local StrMsg=${VerbMsg:=__TEXT__} ; 
  local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
  local IsDisplayFormatted=${VerbFormated:=True} ;
  local IsAppendMode=${VerbAppendDev:=False} ; 
  if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
    if [ "${IsAppendMode:=False}" == "True" ] ; then 
      echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
    else  
      echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
    fi
   else
    if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
       echo "${StrMsg}" ;  
    else
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
      echo "${StrMsg}" >> ${StrDevOut} ;
     else
      echo "${StrMsg}" > ${StrDevOut} ;
     fi
    fi 
   fi 
  fi
 } 
 ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
 
 if [ "${versionCA:=0.0.0}" == "0.0.0" ] ; then 
  local -a __call_locality=( CFCD CurlFtpContentDownload ) ;
  local -a ArrayArg=( $* ) ;
  local Arg0=${ArrayArg[0]} ; 
  local StrParentApps=${__call_locality[1]} ;
  local StrStartMain=${CFCDFuncStart:=__main_StartServices} ; 
 elif [ "${versionCA:=0.0.0}" == "0.0.1" ] ; then 
  eval $( eval CAFunctName=CurlFtpContentDownload CAIsAddParent=False __Call_Argument ) ;
 elif [ "${versionCA:=0.0.0}" == "0.0.2" ] ; then 
  eval $( eval CAFunctName=CurlFtpContentDownload CAIsAddParent=False CallArgument ) ;
 fi 
  
 local StrDefaultVTVOpt=${CFCDVTVOpt:=VTVIsQuotedValue=True,VTVIsArrayStyleInsert=True,VTVIsValueReAssign=True,VTVIsValueToConvert=False,VTVIsArrayStyleInsert=True,VTVIsDebugDisplay=True} ; 
 local StrDefaultGPIOpt=${CFCDGPIOpt:=GPIIsUUIDInstance=True,GPIIsGenerateCode=True,GPIIsExecuteEval=False,GPIIsZenityHandlerOut=False,GPIIsFileHandlerOut=True,GPIRepoCreatEnabled=True,GPIRepositoryCreation=True,GPIFuncStart=__main_StartServices} ; 
 StrDefaultVTVOpt=${StrDefaultVTVOpt//,/ } ;
 StrDefaultGPIOpt=${StrDefaultGPIOpt//,/ } ;
   
 local StrFileName=${CFCDFileName:=k2_epic_Sep_2016.csv.gz} ;
 local StrUrlTpl=${CFCDUrlTpl:="ftp://__USER__@__ADDR__"} ;
 local StrUrl=${CFCDUrl:=archive.stsci.edu/pub/k2/catalogs/} ;
 local BoolDisplayDebug=${CFCDIsDisplayDebug:=False} ; 
 
 ### NCFTPLS PARSER:
 local StrLSApps=${CFCDLsApps:=/usr/bin/ncftpls} ;
 local StrLSAppsOpt=${CFCDLsAppsOpt:="-u __USER__ -l __URL__"} ;
 local StrLSFilterApps=${CFCDLsFilterApps:=ExtractSize} ;
 ### GPITpl definition for CFCDLs section
 local StrLSTplCmd=${CFCDLsTpl:="__APPS__ __APPS_OPT__ __PIPE__ __FILTER__"} ;
 #local StrLSFilterOpt=${CFCDLsFilterOpt:=}
 ### GPITagParser definition for CFCDLs
 
 local StrLSTag=${CFCDLsDef:="StrUserAccount:__USER__,StrUrl:__URL__"} ;
 ### Following Tag/Variable does not need to to be inserer inside the parser, the are commonly definied Through Prefixed-variable of GPI...
 ### StrDefaultPipe:__PIPE__,StrLSApps:__APPS__,StrLSAppsOpt:__APPS_OPT__,StrLSFilterApps:__FILTER__,StrFileName:__FILE__
 ### It's probably more GPITagFeeder that require to be feeded with exception . 
 
 ### Extracting address from URL and operator '/%' 
 local StrAddr=${StrUrl/%\/[a-zA-Z0-9\_]*} ;
 ### Extracting Server-path from erasing the address from URL.  
 local StrPathSrv=${StrUrl//${StrAddr}/} ; 
 StrPathSrv=${StrPathSrv//ftp:\/\//} ;
 StrPathSrv=${StrPathSrv//http:\/\//} ;
 
 local StrUserAccount=${CFCDUserAcc:=anonymous}
 StrUrlTpl=${StrUrlTpl//__USER__/${StrUserAccount}} ;
 StrUrlTpl=${StrUrlTpl//__ADDR__/${StrAddr}/${StrPathSrv}} ;
 
 ### Message Array Information :
 local -a ArrayMsg ; 
 ArrayMsg[0]="Value of __VARNAME__=__VARVALUE__" ; 
 
 local StrVarList="StrFileName,StrUrlTpl,StrUrl,StrUserAccount,StrAddr,StrPathSrv,StrLSTag,StrLSTplCmd,StrLSFilterApps,StrLSFilterApps,StrLSApps,BoolDisplayDebug" ; 
 ### Curl required option :
 ### --output --> file
 ###  Output is not qualifying for appending or literracy of curl is not informing 
 ### of the possible action it take on local-destination . 
 ### - Suggest to create a temporary file to drop the information inside and 
 ### to join the information to file-name.  
 ### --speed-limit, required to establish a download-weight 
 ### --speed-time and --connect-timeout will required to be specified with same information
 ### or belong to curl information it continue to download after period of time specified 
 ### in --speed-time. 
 
 function ExtractSize()
 {
  if [ "${versionCA:=0.0.0}" == "0.0.0" ] ; then 
   local __call_locality=( ES ExtractSize ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]} ; 
  elif [ "${versionCA:=0.0.0}" == "0.0.1" ] ; then 
   eval $( eval CAFunctName=ExtractSize CAIsAddParent=True __Call_Argument ) ; 
  elif [ "${versionCA:=0.0.0}" == "0.0.2" ] ; then 
   eval $( eval CAFunctName=ExtractSize CAIsAddParent=True CallArgument ) ;
  fi    
  #local __call_locality=( ES ExtractSize ) ;
  #local ArrayArg=( $* ) ;
  #local Arg0=${ArrayArg[0]} ;    
  
  VerbMsg="Entry in function"              \
  VerbHeader="${__call_locality[1]}-DEBUG" \
  VerbState=${BoolDisplayDebug}            \
  VerbEvalForm=False VerbFormated=True     \
  VerbDev=/dev/stderr                      \
  Verbosis ; 

  sed 's/\(^[rwxs\-]*[\ ]*\)\([0-9]*[\ ]*\)\([0-9]*[\ ]*\)\([0-9]*[\ ]*\)\([0-9]*\)/\5/g' | cut -d ' ' -f 1 ;
  ### Note : last command : 
  ###   cut -d ' ' -f 1 -> extract file-size
  ###   cut -d ' ' -f 5 -> extract filename
  ###   cut -d ' ' -f 1,5 -> extract file-size + filename
 }
 
 
 function ListFile()
 {
  if [ "${versionCA:=0.0.0}" == "0.0.0" ] ; then 
   local __call_locality=( LF ListFile ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]} ; 
  elif [ "${versionCA:=0.0.0}" == "0.0.1" ] ; then 
   eval $( eval CAFunctName=ListFile CAIsAddParent=True __Call_Argument ) ;
  elif [ "${versionCA:=0.0.0}" == "0.0.2" ] ; then 
   eval $( eval CAFunctName=ListFile CAIsAddParent=True CallArgument ) ; 
  fi 
  
  local StrDefaultVTVOpt=$( CurlFtpContentDownload --get StrDefaultVTVOpt ) ; 
  StrDefaultVTVOpt=${StrDefaultVTVOpt//,/ } ; 
  
  local StrDefaultGPIOpt=$( CurlFtpContentDownload --get StrDefaultGPIOpt ) ;
  StrDefaultGPIOpt=${StrDefaultGPIOpt//,/ } ; 
  
  
  ### Removed from The query and replaced by GPITagFeeder, having too
  ### much redefinition of recurrent variable and  some placement make conflicts with 
  ### internal variable of GnrlPrsrInfctr.
  ### GPITagParser=\"${StrLSTag}\" by GPITagFeeder and excess of tag where cleaned. 
  ### GPIFileName, GPIApps GPIAppsOpt GPIFilterApps are used and are not required inside
  ### The Dictionnary or GPITagParser element.  
  local StrGnrCmd="""GPITpl=\"${StrLSTplCmd}\" GPITagFeeder=\"${StrLSTag}\"  GPITagParserResult=\"StrCmdA\" GPIFileName=${StrFileName} GPIApps=${StrLSApps} GPIAppsOpt=\"${StrLSAppsOpt}\" GPIFilterApps=\"${StrLSFilterApps}\" GPIDisplayDebug=${BoolDisplayDebug} GPIParserDebug=${BoolDisplayDebug} ${StrDefaultGPIOpt} GnrlPrsrInfctr""" ;
    
  ### 
  ### A Variable-screener, used to Display information on screen, using eval of variable,
  ###  required variable are inserted inside the array and an evaluation StrEvalValue is 
  ### done by feeding name of variable and value to StrMsg.
  ### 
  StrMsgTpl=$( CurlFtpContentDownload --get ArrayMsg[0] ) ;
  local -a ArrayVarDisplay=( StrParentApps StrDefaultVTVOpt StrDefaultGPIOpt StrLSTplCmd StrLSTag StrFileName StrLSApps StrLSAppsOpt StrLSFilterApps StrGnrCmd StrUserAccount StrUrlTpl ) ; 
  local StrEvalValue ;
  for VarTypeName in ${ArrayVarDisplay[@]} ; do 
   StrMsg=${StrMsgTpl} ; 
   StrMsg=${StrMsg//__VARNAME__/${VarTypeName}} ;
   eval "local StrEvalValue=\${${VarTypeName}}" ;  
   StrMsg=${StrMsg//__VARVALUE__/${StrEvalValue}} ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;  
  done 
  
  ### Cleaning old UUID variable to allow creation of the new report:
  unset UUID ; 
  eval $( eval VTVValueEntry="${StrVarList}" ${StrDefaultVTVOpt} ValueToVariable ) $( eval ${StrGnrCmd} )  ;
  
  local StrFileRepoPath=$( GnrlPrsrInfctr --get GPIQueryRepository ) ;  
  StrMsg="UUID Log-file for Command repository:(__UUID__) file : __PATH__/__UUID__" ; 
  StrMsg=${StrMsg//__UUID__/${UUID:=None}} ; 
  StrMsg=${StrMsg//__PATH__/${StrFileRepoPath:=None}} ; 
  VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;  
  
  ###ncftpls -u ${StrUser} -l ${URL}/${StrFile} | ExtractSize ; 
  local StrMsg="StrCmdA: __CMD__" ; 
  StrMsg=${StrMsg//__CMD__/${StrCmdA}} ;
  VerbMsg=${StrMsg} VerbHeader="${__call_locality[1]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
  
 }
 
 
 function __main_StartServices()
 {
 if [ "${versionCA:=0.0.0}" == "0.0.0" ] ; then 
  local __call_locality=( CFCD CurlFtpContentDownload ) ;
  local ArrayArg=( $* ) ;
  local Arg0=${ArrayArg[0]} ; 
 elif [ "${versionCA:=0.0.0}" == "0.0.1" ] ; then 
  eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) :  
 elif [ "${versionCA:=0.0.0}" == "0.0.2" ] ; then 
  eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) :  
 fi 
  VerbMsg="Entry in function" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr Verbosis ; 
 
 }
  
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 local StrNameHelper="CurlFtpContentDownload\t\tStand for Curl Based FTP File download with time-limited or bandwith limitation. To download a file from a Big Project without high home-cost of your internet bandwith." ;
 local StrSummary="This CurlFtpContentDownload is a tool for planning downloading heavy weighted file from public domain like Mines evlation of ground of Ministeredu Canada, NASA Keepler2 project, any big file avilable on the internet for distant developper and high-cost bandwith for home use." ; 
 local StrSynopsis="Soon to fill it with lot of informations" ;
 local StrDescription="Having surdose of informations, skip this part..." ;
 
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
  GVRIIsShowCADecl=${GVRIIsShowCADecl:=False} \
  GVRIsName=True        \
  GVRIsSummary=True     \
  GVRIsSynopsis=False   \
  GVRIsDesc=False       \
  GetVarReference ${__call_locality[1]} ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( __GetVarReferenceList ) ;	
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( eval VTVValueEntry=${StrVarList} ${StrDefaultVTVOpt} ValueToVariable ) ${StrStartMain} ; 
 fi
   
}






########### ###################################################################
########### 
########### End of normal Devlopment, upcoming devlopment or missing code from 
########### old lib Devlopment was put after, Enabling it on call of 
########### /etc/init.d/Fnct.D/fnct_debian_lib imply having VarFnctLib=True 
########### before
########### 
########### like :
########### VarFnctLib=True /etc/init.d/Fnct.D/fnct_debian_lib . 
########### 
########### Warning Not supported and may cause problems. 
########### 
########### ###################################################################


if [ ${VarFnctLib:=False} == "True" ] ; then

    Debian_DPKG_update_InstallList()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=Debian_DPKG_update_InstallList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      declare -a ArrayDPKGInstalled=( $( ${DebianProg:=dpkg} ${DebianProgQuery:=--get-selections} | awk 'BEGIN{}{printf("%s ",$1)}END{}' ) ) ; 
    }

    Debian_DPKG_update_ArchivesList()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=Debian_DPKG_update_ArchivesList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      declare -a ArrayArchiveDPKG=( $( find ${DefaultRootPath:=/var/cache/apt/archives/} -printf "%p " ) ) ; 
    }

    DebianDPKGProvideSubFunctionMember()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=DebianDPKGProvideSubFunctionMember __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __search_item()
      {
        #eval $( __InitFunc ) ;
        eval $( __call_localityLocalName=__search_item __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        if [ ${ArrayArg[1]} == ${ItemQuery:=update} ] ; then 
          return 0 ;
        fi
        return 1 ;
      }
      local Template="__CREATOR___PACKAGETYPE_____PACKAGEACTION___" ; 
      local StrCreator=${Creator:=${ArrayCreator[0]}} ;
      local StrPackageType=${PackageType:=${ArrayPackageType[0]}} ;
      local StrPackageAction=${PackageAction:=update} ;
      eval $( __in_for ArrayPackageAction __search_item ItemQuery=${StrPackageAction} ) ; 
      local ErrorStatement=$? ; 
      if [ ${ErrorStatement:=1} -eq 0 ] ; then 
        echo "__TODO__" ;  
      fi
    }

    MetaUpdateList()
    {
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=MetaUpdateList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __FuncUpdate()
      {
        #eval $( __InitFunc ) ;
        eval $( __call_localityLocalName=__FuncUpdate __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        local Template="__NODE____SECTION__List" ;
        Template=${Template/__SECTION__/${ArrayArg[0]}}
      } 
      eval $( __in_for ArrayMetaList __FuncUpdate ) ; 
    }

    function __get_col()    
    { 
      #eval $( __InitFunc ) ;
      eval $( __call_localityLocalName=__get_col __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      awk -vCol=${ArrayArg[0]} 'BEGIN{}{printf("%s ",$(Col));}END{}' ; 
    } ; 

    function UpdateDpkgGetSelection()
    {
      eval $( __call_localityLocalName=UpdateDpkgGetSelection __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      declare -a ArrayPackageCurrent=( $( dpkg --get-selections | __get_col 1 ) ) ; 
    }


    function get_listfile()    
    { 
      #eval $( __InitFunc get_listfile ) ;
      eval $( __call_localityLocalName=get_listfile __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __BaseEncode64()
      {
        #eval $( __InitFunc __BaseEncode64 ) ;
        eval $( __call_localityLocalName=__BaseEncode64 __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        base64 --wrap=0 ; 
      }
      function __IfTestFile()    
      { 
        #eval $( __InitFunc __IfTestFile ) ;
        eval $( __call_localityLocalName=__IfTestFile __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        if [ -f ${ArrayArg[0]} ] ; then 
          local StrStream=$( echo "${ArrayArg[0]}" | __BaseEncode64 ) ; 
          echo -ne "${StrStream} " ;
        fi 
      } ; 
      local ArrayFileList=( $( dpkg-query --listfiles ${ArrayArg[0]} ) ) ; 
      eval $( __in_for ArrayFileList __IfTestFile ) ; 
    } ; 

    function get_search()
    {
      #eval $( __InitFunc get_search ) ;
      eval $( __call_localityLocalName=get_search __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      eval $( __in_for ArrayPackageCurrent get_listfile ) ;
    }

    function get_package_by_file()
    {
      #eval $( __InitFunc get_package_by_file ) ;
      eval $( __call_localityLocalName=get_package_by_file __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function PostFilter()
      {
        #eval $( __InitFunc PostFilter ) ;
        eval $( __call_localityLocalName=PostFilter __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        awk -vGrepReturn=${GrepReturn} -f /etc/init.d/Fnct.D/awk-script/DpKgQueryPackage.awk ; 
      }  
      local CmdEval=( ${Program:=apt-file} ${ProgramOption:=search} ${ProgramQuery:=lirc/lirc_client.h} ProgramQueryIs64=${ProgramQueryIs64:=false} "|" ${FilterProgram:=PostFilter} GrepReturn=${GrepReturn:=false} ${FilterProgramQuery:=""} ) ;
      echo "CmdLine:[${CmdEval[@]}]" ;
      #eval "${CmdEval[@]}" ; 
      eval "local IntResult=$( eval ${CmdEval[@]} )" ; 
      #echo "Return : ${IntResult}" ;
    }

    function AwkContentParsing()    
    { 
      #eval $( __InitFunc AwkContentParsing ) ; 
      eval $( __call_localityLocalName=AwkContentParsing __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      function __TinyDecode64()
      {
        #eval $( __InitFunc __TinyDecode64 ) ; 
        eval $( __call_localityLocalName=__TinyDecode64 __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        local StrBaseDecode=$( echo "${VarDecode64}" | base64 -d --wrap=0 2> /dev/null ) ; 
        local IntErrorReport=$? ;
        if [ ${IntErrorReport:=1} -eq 1 ] ; then 
          echo "${VarDecl:=local} ${VarName:=VarOut}=${VarDecode64}" ; 
        else
          echo "${VarDecl:=local} ${VarName:=VarOut}=${StrBaseDecode}" ; 
        fi 
      }
      eval $( __TinyDecode64 VarDecode64=${RecurrentTemplateSearch} VarName=StrRecurrentTemplateSearch VarDecl=${VarDecl} )  ;
      eval $( __TinyDecode64 VarDecode64=${StrQuerySearch} VarName=StrQuerySearch VarDecl=${VarDecl} )  ;
        
      
      local ProgramParserRecurrentTemplate=${StrReturnBase64DecodeTry} ;
      local CmdEval=( ${Program:=apt-file} ${ProgramOption:=search} ${StrQuerySearch} "|" ${ProgramParser:=awk} -vTemplateContent=${StrRecurrentTemplateSearch} -vVarNameOut=CmdEval -f /etc/init.d/Fnct.D/awk-script/DpKgQueryPackage.awk ) ;
      echo "CmdLine:[${CmdEval[@]}]" ; 
    }

    function libsearch_AwkContentParsing()
    {
      #eval $( __InitFunc AwkContentParsing ) ; 
      eval $( __call_localityLocalName=libsearch_AwkContentParsing __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      local StrRecurrentTemplateSearch=$( echo "dpkg --get-selections | egrep -ic %s" | base64 --wrap=0 ) ;
      local StrQuerySearch=$( echo "lirc/lirc_client.h" | base64 --wrap=0 ) ; 
      AwkContentParsing RecurrentTemplateSearch=${StrRecurrentTemplateSearch} QuerySearch=${StrQuerySearch} ; 
      
    }

    __funcZenity_DpkgList() 
    { 
        eval $( __call_localityLocalName=__funcZenity_DpkgList __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        
        ### This Cover-up the theory of problematic transfert of commune Variable name in external function
        ### being by definition to be treated ''AS'' the normal corpus of the definition of a script
        ### Where this example show a possibility that it does not... The WeFixIt by
        ### involve declaring this method inside this function by calling a declare-f and 
        ### renaming the function (incase of) and calling it inside the function like a 
        ### sub-function can be called and all variable within an external-function will 
        ### be accessible... 
        ### Noted by: Patrick Riendeau in 2003-2004 @vdl2 inc formelly know as Phromone inc.
        ### and 2010... 
        
        eval """$( declare -f LinkFuncRetOkA_B  | sed 's/\\n/\\\\n/g;s/LinkFuncRetOkA_B/localLinkFuncRetOkA_B/g' )"""
        
        function DisplayEvalCmd()
        {
          echo -ne "in DisplayEvalCmd:\n\t\tCmdLine:${StrFuncName}:[ ${CmdEval[@]} ]\n" > /dev/stderr  ;  
        }
        
        function ExecEvalCmd()
        {
          echo -ne "in ExecEvalCmd:\n" > /dev/stderr ;  
          eval "${CmdEval[@]}" ;
        }

        function ZenityProgressBar()
        {
          eval $( __call_localityLocalName=ZenityProgressBar __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
          local IntRandomState=$(( ${RANDOM} % 20 )) ;
          local CmdEval=( zenity --progress --percentage=${IntRandomState} --text="Fetching Package List" --auto-kill --pulsate ) ;
          #DisplayEvalCmd ;
          #ExecEvalCmd ;
          LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }
        
        function ZenityListPackage()
        {
          eval $( __call_localityLocalName=ZenityProgressBar __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
          zenity --list --checklist --column "Installed" --column "Package Name" ;
          #DisplayEvalCmd
          #ExecEvalCmd ;
          LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }
        
        function DpkgSortedByInstall()
        {
         eval $( __call_localityLocalName=DpkgSortedByInstall __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
         local CmdEval=( "dpkg" "--get-selections" "|" "sort" "-k2" "-r" ) ;
         #DisplayEvalCmd ;
         #ExecEvalCmd ;
         LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }

        function SedFilterConversionDpkgToZenityList()
        {
          eval $( __call_localityLocalName=DpkgSortedByInstall __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
          #sed -r -f /etc/init.d/Fnct.D/sed-script/FilterConversionDpkgToZenityList.sed ;
          local CmdEval=( "sed" "-r" "-f" "/etc/init.d/Fnct.D/sed-script/FilterConversionDpkgToZenityList.sed" ) ;
          #DisplayEvalCmd ;
          #ExecEvalCmd ;
          LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;
        }
        local CmdEval=( LFuncAction0=ZenityProgressBar LFuncAction1=DpkgSortedByInstall LinkFuncPipedA_B ) ;
        echo -ne "From Main Func:${StrFuncName}\n\n\tCmdEval:[ ${CmdEval[@]} ]\n" > /dev/stderr ;
        LFuncAction0=DisplayEvalCmd LFuncAction1=ExecEvalCmd localLinkFuncRetOkA_B ;

    }

    function get_list()  
    { 
      #eval $( __InitFunc get_list ) ; 
      eval $( __call_localityLocalName=get_list __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      local ArrayInfo=( $( find /usr/share/ -maxdepth 1 -type d -iname "man*" | tr '[:cntrl:]' ' ' ) ) ; 
      echo "${VarDecl:=local} ${ArrayName:=ArrayList}=( ${ArrayInfo[@]})" ; 
    } 
      
    function ffind()    
    { 
      #eval $( __InitFunc ffind ) ; 
      eval $( __call_localityLocalName=ffind __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      find ${ArrayArg[0]} -type f -iname "*man*" ; 
    } 

    function __ZenityProgressBar()    
    { 
      #eval $( __InitFunc ) ;  
      eval $( __call_localityLocalName=__ZenityProgressBar __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      zenity --progress --pulsate 
    } 

    function __wrap_bar_find()    
    { 
      #eval $( __InitFunc __wrap_bar_find ) ; 
      eval $( __call_localityLocalName=__wrap_bar_find __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
      eval $( get_list ArrayName=ArrayOut VarDecl=local ) ;
      eval $( __in_for ArrayOut ffind ) | __ZenityProgressBar  ;
    }


    function __BuildDpkgShowFormat ()    
    { 
     #eval $( __InitFunc __BuildDpkgShowFormat ) ; 
     eval $( __call_localityLocalName=__BuildDpkgShowFormat __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
     local DefaultTagValue="__TAG__" ;
     if [ ${StructDpkgShowFormat:=__TAG__} == "__TAG__" ] ; then 
      declare -a StructDpkgShowFormat="${DefaultTagValue}" ;
     fi 
     StructDpkgShowFormat=( $( echo "${StructDpkgShowFormat}" | sed 's/'${DefaultTagValue}'/'${ArrayDPKG_QueryHeader[${ArrayArg[0]}]}${DefaultTagValue}'/g' ) ) 
    } 

    function __BuildDpkgShowFormatXml()
    {
      eval $( __InitFunc __BuildDpkgShowFormat ) ; 
      function __functor_show_header()
      {
        #eval $( __InitFunc __BuildDpkgShowFormat ) ; 
        eval $( __call_localityLocalName=__BuildDpkgShowFormatXml __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        echo -ne "\nStyle=${Style}\n" ;     
        echo -ne "${ArrayArg[2]}" ; 
        echo -ne "\nDstyle=${Dstyle}\n" ;
      }
      eval $( __in_for ${ArrayNameDPKGQuery=ArrayDPKG_QueryHeader} __functor_show_header CCode64=$( ) ) ;
    }

    compare_package()
    {
      local ArrayArg=( $* ) ; 
      function get_name()    
      { 
        eval $( __call_localityLocalName=compare_package __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        local str="${ArrayArg[0]}" ; 
        local ArrayPackage=( ${str/_/ } ) ; 
        echo -ne "${ArrayPackage[0]} " ;  
      } 
      
      function update_package_list()
      {
        eval $( __call_localityLocalName=update_package_list __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        ${DebianProg:=dpkg} ${DebianProgQuery:=--get-selections} | awk 'BEGIN{}{printf("%s ",$1)}END{}' ; 
      }
      
      function get_specific_search()
      {
        eval $( __call_localityLocalName=get_specific_search __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        apt-file search wxPython | awk 'BEGIN{}{intlength=split($1,Array,/:/); printf("%s\n",Array[1])}END{}' | sort -u | tr '[:cntrl:]' ' '  
      }
      
      function get_specific_python()
      {
        eval $( __call_localityLocalName=get_specific_python __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        find /var/cache/apt/archives/ -iname "*.deb" -printf "%f "
      }

      function __compare_package()    
      { 
        #local ArrayArg=( $* ) ; 
        eval $( __call_localityLocalName= __call_localityDisplayFunctionEntry=1 __call_locality  ) ; 
        echo "Search for Package ${ArrayArg[0]} in Installed Package( ${#ArrayDPKGInstalled[@]} ) " ;      
        function search_package_name()    
        { 
          local ArrayArg=( $* ) ; 
          if [ "${ArrayArg[0]}" == "${ArrayArg[1]}" ] ; then 
            echo -ne "\tInstalled Package is in the list [ ${ArrayArg[0]} ]\n" ; 
            return 0 ; 
          fi
            ArrayDPKGUnInstalled[${#ArrayDPKGUnInstalled[@]}]="${ArrayArg[1]}";
            return 1 ; 
        } 
        eval $( __in_for ArrayDPKGInstalled search_package_name ${ArrayArg[0]} ) ; 
      }
      
      local ArrayPythonPackage=( $( ${ArrayArg[0]} ) ) ;
      echo -ne "\nPackage List Choosed from Function: ${ArrayArg[0]}\n\t[ ${ArrayPythonPackage[@]} ]\n" ;
      local ArrayDpkgPython=( $( eval $( __in_for ArrayPythonPackage get_name ) ) ) ;  
      local ArrayDPKGInstalled=( $( update_package_list ) ) ;    
      local ArrayDPKGUnInstalled ;
      eval $( __in_for ArrayDpkgPython __compare_package ) ;
      echo "declare -a ArrayDPKGUnInstalled=( ${ArrayDPKGUnInstalled[@]} )" ; 
    }

    function KeyAptSearch()    
    { 
     eval $( __call_localityLocalName=KAS __call_locality ); 
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=PackageArrayName FParamVarName=StrPackageArrayName FParamDefaultValue=ArrayPackage __fnctCreateLocalityFuncParam     ) ;
     
     function AptSearch()    
     { 
      eval $( __call_localityLocalName=AS __call_locality ); 
      echo -ne "Key: ${ArrayArg[0]}\n" ; 
      apt-file search ${ArrayArg[0]} ; 
     } ; 
     local CmdEval=( "eval" " $( " "__in_for" ${StrPackageArrayName:=""} "AptSearch" ")" ) ; 
     eval ${CmdEval[@]} ;
    }

    function dpkg-get-selections()
    {
     eval $( __call_localityLocalName=DPKG __call_locality ); 
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=BranchShow FParamVarName=StrBranchShow FParamDefaultValue=Left __fnctCreateLocalityFuncParam     ) ;
     
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName0 FParamVarName=ArrayCmdName[0] FParamDefaultValue=dpkg __fnctCreateLocalityFuncParam     ) ;
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName1 FParamVarName=ArrayCmdName[1] FParamDefaultValue="--get-selections" __fnctCreateLocalityFuncParam     ) ;
     
     eval local StrFuncColDisplay=\${${StrBranchShow}ColDisplay} ;
     
     function CommandCall()
     {
      eval $( __call_localityLocalName=CCall __call_locality ); 
      local CmdEval=( ${ArrayCmdName[@]} ) ;
      eval ${CmdEval[@]} ;
     }
     
     function RightColDisplay()
     {
      eval $( __call_localityLocalName=ColDisplay __call_locality ); 
      awk -vColName=${StrBranchShow:=""} -f /etc/init.d/Fnct.D/awk-script/dpkg-col-display.awk 
     }
     
     function LeftColDisplay()
     {
      eval $( __call_localityLocalName=ColDisplay __call_locality ); 
      awk -vColName=${StrBranchShow:=""} -f /etc/init.d/Fnct.D/awk-script/dpkg-col-display.awk 
     }
     
     local CmdEval=( ${CommandCall:=""} "|" ${StrFuncColDisplay:=""} ) ;
     eval ${CmdEval[@]} ;
    }

    function dpkg-set-selections()
    {
     eval $( __call_localityLocalName=DPKG __call_locality ); 
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=BranchShow FParamVarName=StrBranchShow FParamDefaultValue=Left __fnctCreateLocalityFuncParam     ) ;
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName0 FParamVarName=ArrayCmdName[0] FParamDefaultValue=dpkg __fnctCreateLocalityFuncParam     ) ;
     eval $( FParamFuncName=${StrFuncName} FParamSuffixName=CmdName1 FParamVarName=ArrayCmdName[1] FParamDefaultValue=--set-selections __fnctCreateLocalityFuncParam     ) ;
     
     function CommandCall()
     {
      eval $( __call_localityLocalName=CCall __call_locality ); 
      local CmdEval=( ${ArrayCmdName[@]} ) ;
      eval ${CmdEval[@]} 
     } 

    }
fi 




