#!/bin/bash

# Package _sub_vlc_services

unset ActivatSeServerBuffer ; 

function ActivateServerBuffer()
{
 local __call_locality=( ASB ActivateServerBuffer ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart a new FIFO-Buffer Association.\n\t--stopservices\tStop a FIFO-Buffer Association.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 
 local StrFifoDevice=${ASBFIFO:=NONE} ;
 ### Make Symbolink link from UUID-Named fifo to ASBFIFO Name. 
 ### Important for Management and later work with DoCtrlHandler.
 local BoolUUIDNaming=${ABSUUIDSymLink:=False};
 local UUID="XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX" ; 
 local BoolVerbose=${ASBVerbose:=False};
 local IsFifoMode=${ASBFIFOMode:=False} ; 
 local IsFifoContext=${ASBFIFOCtx:=False} ; 
 local StrTestApps=${ASBTestApps:=/usr/bin/test} ; 
 local StrFifoApps=${ASBFIFOApps:=/usr/bin/mkfifo};
 local StrFifoModeParam=${ASBFIFOModParam:=--mode=644};
 local StrFifoCtxParam=${ASBFIFOCtxParam:=--context=USER}
 local StrTestPatrn=${ASBAppsOptPatrn:=__FILE__}
 local StrTestSwitche=${ASBAppsOpt:=-f {StrTestPatrn}} ; 
 local StrCmdFifo="${StrFifoApps} {FIFOMODE} {FIFOCTX} {StrFifoDevice}" ;
 ### UUID Section it's not mandatory and information can come from Shell by
 ### calling with GetULoop=... GetUSeq=... GetUTimeBased=... ActivateServerBuffer 
 ### 

 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local VerboseState=${VerbState:=False} ;
		local ArrayArg=( $* ) ; 
		if [ "${VerboseState:=False}" == "True" ] ; then 
			echo -ne "VERBOSE:[ ${StrMsg} ]\n" > ${StrDevOut} ;
		fi
	}
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 

  local GetUTimeBased=${GetUTimeBased:=True} ; 
  local GetUSeq=${GetUSeq:=1}
  local GetULoop=${GetULoop:=False}
  local ArrayMsg=( ); 
  
  ArrayMsg[0]="New UUID Value issued, UUID:\${UUID} "
  
  if [ "${BoolUUIDNaming:=False}" == "True" ] ; then 
   eval UUID=$( VTVIsArrayStyleInsert=True \
    VTVValueEntry=GetUTimeBased,GetUSeq,GetULoop \
    VTVIsValueReAssign=True  \
    VTVIsValueToConvert=False \
    VTVIsArrayStyleInsert=True \
    ValueToVariable ) GetUUID
    
   eval VerbMsg=${ArrayMsg[0]} VerboseState=${BoolVerbose} Verbosis
  fi

  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=IsFifoMode,StrCmdFifo,StrFifoModeParam,IsFifoContext,StrFifoDevice,StrTestCmd,StrTestPatrn  \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) CreateSocketBuffer
 }
 
 function __main_StopServices()
 {
		local __call_locality=( Main __main_StopServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=  \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) DestroySocketBuffer
 
 }
 
 function CreateSocketBuffer()
 {
		local __call_locality=( CSB CreateSocketBuffer ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  ###IsFifoMode,StrCmdFifo,StrFifoModeParam,IsFifoContext,StrFifoDevice,StrTestCmd,StrTestPatrn,,,,,,,,,,,,
  if [ ${IsFifoMode:=True} == "True" ] ; then 
   StrCmdFifo=${StrCmdFifo//{FIFOMODE}/${StrFifoModeParam}}
  else
   StrCmdFifo=${StrCmdFifo//{FIFOMODE}/}
  fi 

  if [ ${IsFifoContext:=True} == "True" ] ; then 
   StrCmdFifo=${StrCmdFifo//{FIFOCTX}/${StrFifoCtxParam}} ;
  else
   StrCmdFifo=${StrCmdFifo//{FIFOCTX}/} ;
  fi 

  StrCmdFifo=${StrCmdFifo//{StrFifoDevice}/${StrFifoDevice}} ;
  local StrTestCmd="${StrTestApps} ${StrTestSwitche}" ;
  StrTestCmd=${StrTestCmd//{StrTestPatrn}/${StrTestPatrn}} ;
  StrTestCmd=${StrTestCmd/${StrTestPatrn}/${StrFifoDevice}} ;
  
 }
 
 function DestroySocketBuffer()
 {
		local __call_locality=( DSB DestroySocketBuffer ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  
 }
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
  GetVarReference ${__call_locality[1]} ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=IsFifoMode,StrCmdFifo,StrFifoModeParam,IsFifoContext,StrFifoDevice,StrTestCmd,StrTestPatrn \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StartServices
 elif [ "${Arg0:=--stopservices}" == "--stopservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry= \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StopServices
 fi

 
 #eval echo """${StrTestCmd} && rm -f ${StrFifoDevice} && ${StrTestApps} ${StrTestSwitche}-f ${StrFifoDevice} && rm -f ${StrFifoDevice} && mkfifo ${StrFifoDevice}""" ;    
}

unset DoCtrlHandler ;
function DoCtrlHandler()
{
  function Verbosis()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Verb Verbosis ) ; 
   local Arg0=${ArrayArg[0]} ; 
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local IsExtendedOutput=${VerbExtendedOut:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
      if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" ;  
      else
        echo "${StrMsg}" ;  
      fi
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" >> ${StrDevOut} ;
       else
         echo "${StrMsg}" >> ${StrDevOut} ;
       fi
      else
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" > ${StrDevOut} ;
       else
        echo "${StrMsg}" > ${StrDevOut} ;
       fi 
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
 if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
  local -a ArrayArg=( $* ) ;
  local -a __call_locality=( DCH DoCtrlHandler ) ;
  local Arg0="${ArrayArg[0]}" ; 
  local StrParentApps=${__call_locality[1]} ;
  local StrStartMain=${DCHFuncStart:=__main_StartServices} ; 
 elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
  eval $( eval CAFunctName=DoCtrlHandler CAIsAddParent=False __Call_Argument ) ; 
 elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
  eval $( eval CAFunctName=DoCtrlHandler UUID=${CAUUID:=None} CAIsAddDebug=True CAProvideDebug=DisplayDebug,DisplayEntry,DisplayCmd CAIsAddParent=False CallArgument ) ;
 fi  

 local StrVTVRegistry=${VCSVTVReg:=VTVIsArrayStyleInsert=True,VTVIsValueReAssign=True,VTVIsValueToConvert=False,VTVIsArrayStyleInsert=True,VTVIsQuotedValue=True} ;
 local StrPathActionState=${DCHTplActionFile:=__PATH__/__ACTION__-__SHORTFUNC__-__UUID__} ; 
 local StrAction=${DCHActionSubscription:=LOOP} ; 
 local StrUUIDReg=${DCHUUIDRegister:=None} ; 
 local BoolUnsubscribe=${DCHActionIsUnsubscr:=False} ; 
 local BoolCreateUUID=${DCHCreateUUID:=False} ; 
 local StrFunctionReg=${DCHFunctionName:=None} ; 
 
 local StrVarList="StrAction,BoolUnsubscribe,BoolCreateUUID,BoolDisplayDebug,BoolDisplayEntry,BoolDisplayCmd,StrVTVRegistry,StrParentApps" ;


 local -a ArrayMsg=() ;
 ArrayMsg[0]="Entry in function" ; 
 
 function __main_StartServices()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
   local Arg0="${ArrayArg[0]}" ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ;
  fi
 
  local StrUUID="None" ; 
  
  if [ "${BoolCreateUUID}" == "True" ] ; then 
   StrUUID=$( GetUAppsRegisterName=${StrParentApps} GetUTimeBased=True GetULoop=False GetUUID ) ; 
  fi
 
 }

 function __main_StopServices()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Main __main_StopServices ${StrParentApps} ) ;
   local Arg0="${ArrayArg[0]}" ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True __Call_Argument ) ;
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True CallArgument ) ;
  fi 
  local StrMsg="Entry in function" ; 
  VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
 } 

 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 local StrNameHelper="${__call_locality[1]}\n\tApplication to process a loop in a \n\tAudio session with VLC services and a Running \n\tVLCServer, (OldVLCServer). Require \n\tVlcServicesLayer registration.";
 local StrSynopsis="\n\tUsed to loop inside a Music session or long record like\n\trecorded Stream or recorded internet-radio, it \n\tprovide design to start a Track, loop over and\n\tover. It should own a StopServices to stop \n\tlooping.\n\n\tOther property of ${__call_locality[1]} ,\n\tto use a DoCtrlHandler receive Both \n\tServiceControllerHandler request to end and\n\tDoCtrlHandler do altering variable like\n\tIntStart/IntStop, managed by Prefixed-Variable\n\tRIASStart/RIASStop.\n";
 local StrSummary="\n\tThis application is Looping running music and only when\n\tit's playing. Using  'get_time'  from  VLC\n\tservices it will not rewind or start over if\n\tthe  pause  is  activated.\n" ; 
 local StrDescription="\n\tBecause this application require VlcServicesLayer to\n\tmake this application work. You will require to pass\n\tthis UUID to RIASVlcUUID require part of a Socket\n\tconnection, this UUID, as a result to short-cutting\n \tinformation of Socket connection to your Vlc instance,\n \tyour registration will require to fill information\n \tabout hostname, port... Don't forget ,\n\tVlcServicesLayer can register current variable or\n\tspecified in prefixed-variable and require to subscribe\n\tor fill your variable name to VSLStoreVar.\n" ;

 ### Section : Switches-Statememt 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
  ### GVRIsName set to True is the Variable handled StrNameHelper by GetVarReference and 
  ### provide a Name-Helper inside the live-documentation if we call StartSlewAnalysis --help.
  ### Extending the help by turning other variable to True will increae help. Variable are
  ### declared previously. 
  GVRIsName=True     GVRIsSummary=True  GVRIsSynopsis=True GVRIsDesc=True    GetVarReference ${__call_locality[1]} ; 
  #VerbMsg="${StrSwitchMessages}" VerbState=True       VerbEvalForm=False   VerbFormated=False    VerbExtendedOut=True VerbDev=/dev/stderr  Verbosis ;
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( __GetVarReferenceList ) ;	
 elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
  eval $( eval ${StrVTVRegistry//,/ } \
          VTVValueEntry=${StrVarList} \
          VTVWhiteListTransfert=UUID  \
          ValueToVariable ) __main_StopServices ; 
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  StrMsg=$( DoCtrlHandler --get ArrayMsg[0] ) ; 
  VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
  eval $( eval ${StrVTVRegistry//,/ } \
          VTVWhiteListTransfert=UUID  \
          VTVValueEntry=${StrVarList} \
          ValueToVariable ) ${StrStartMain} 
 fi 

  
}

unset VlcServer ;

function VLCServer()
{
 local __call_locality=( VLCS VLCServer ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--stopservices\tStop the application or service side relation.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 
 
 ### Prefixed Variable List
 local StrFifoRoot=${VLCSFIFORoot:=HOME} ;
 local IsFifoRootVar=${VLCSFIFORootVar:=True} 
 local StrFifoName=${VLCSFIFOName:=.vlc-server} ;
 local StrVLCCaller=${VLCSBIN:=\${HOME}/bin/vlc-terminal.sh} ;
 
 ### Loading playlist <--- Depedent of StrVLCCaller and this script verify the playlist parameter --->
 local StrVLCPlayList=${VLCSBINPl:=\${HOME}/Music/playlist_20160606.m3u} ;
 
 
 ### Information toward network / socket transfert 
 ### Example of Socket Handler and it's parameter 
 ### nc -4 -n -k -i 1 -I $((2 * 1024 * 1024)) -l 127.0.1.1 5080 > ${HOME}.vlc-server
 #StrAppsSocket,StrAppsCmdCaller,StrAppsParam,StrAppsBuffer,StrAppsAddrSvr,StrAppsAddrPrt,,,,,,,,,,,,,,,,
 local StrAppsSocket=${VLCSSocketHndlr:=/bin/nc} ;
 local StrAppsCmdCaller=${VLCSSocketCmd:=__APPS__ __PARAM__ -I __BUFFER__ -l __ADDR__ __PORT__} ;
 local StrAppsParam=${VLCSSocketParam:=-4 -n -k -i 1} ;
 local StrAppsBuffer=${VLCSSocketBuffer:=2097152} ;
 local StrAppsAddrSvr=${VLCSSocketAddr:=127.0.1.1} ;
 local StrAppsAddrPrt=${VLCSSocketPort:=5080} ;
 #local =${VLCS:=} ;
 #local =${VLCS:=} ;
 #local =${VLCS:=} ;
 #local =${VLCS:=} ;
 
 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsDisplayFormatted=${VerbFormated:=True} ;
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
     echo -ne "${StrMsg}\n" > ${StrDevOut} ;
   fi 
		fi
	} 
 ### Model : VerbMsg= VerbDev=/dev/stderr VerbState=True VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis

 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrFifoDevice,IsFifoMode,IsFifoContext,StrTestApps,StrFifoApps,StrFifoModeParam,StrFifoCtxParam  \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) ActivateServerBuffer
 }
 
 function __main_StopServices()
 {
		local __call_locality=( Main __main_StopServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
 
 }
 
 
 local StrMsg="" ; 
 local StrFIFODev="" ; 
 ### This section explain how the group 
 ### VLCSFIFORootVar, VLCSFIFORoot, VLCSFIFOName, is handled, 
 ###  
 ### How StrFIFODev Will Be see here to hold the 
 ### Server Services ?
 ###  ------+
 ###        /\
 ###       /  \
 ###      /    \
 ###     /      \
 ###    /        \ 
 ###   / VLCSFIFO \  FALSE
 ###   \  RootVar /----------> Not to be evaluated and hold respectively 
 ###    \ True ? /             StrFIFODev=${StrFifoRoot}/${StrFifoName}
 ###     \      /
 ###      \    /
 ###       \  /
 ###        \/
 ###        |
 ###        | TRUE
 ###        |
 ###        |
 ###        +---------> Evaluate Element like this {StrFifoRoot} is a Variable Name 
 ###                    ${StrFifoName} is the content of the ServerBuffer Name 
 ###                    and StrFIFODev will Hold a [Variable]/[And FifoName Content]
 ###  
 
 if [ ${IsFifoRootVar:=True} == "True" ] ; then 
  eval """StrFIFODev=\$${StrFifoRoot}/${StrFifoName}""" ; 
 else
  StrFIFODev=${StrFifoRoot}/${StrFifoName};
 fi 
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrFifoRoot,IsFifoRootVar,StrFifoName,StrVLCCaller,StrVLCPlayList,StrAppsSocket,StrAppsCmdCaller,StrAppsParam,StrAppsBuffer,StrAppsAddrSvr,StrAppsAddrPrt \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StartServices
 elif [ "${Arg0:=--stopservices}" == "--stopservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrFifoRoot,IsFifoRootVar,StrFifoName,StrVLCCaller,StrVLCPlayList,StrAppsSocket,StrAppsCmdCaller,StrAppsParam,StrAppsBuffer,StrAppsAddrSvr,StrAppsAddrPrt \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StopServices
	fi

 
 ### ---> Final Lines ${StrFIFODev} ; cat /home/maxiste/.vlc-server | ./bin/vlc-terminal.sh /home/maxiste/Music/playlist_20160606.m3u | nc -lk -i 1 -I $((2 * 1024 * 1024)) -p 5080 127.0.0.1 > /home/maxiste/.vlc-server
}

unset __vlc_rate ; 

function __vlc_rate()    
{ 

 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsDisplayFormatted=${VerbFormated:=True} ;
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
     echo -ne "${StrMsg}\n" > ${StrDevOut} ;
   fi 
		fi
	} 
 ### Model : VerbMsg= VerbDev=/dev/stderr VerbState=True VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis

 local StrMsg="" ; 

 local ArrayRateLevel=( ); 
 ### determining the range of random rate. 
 local IntRandRange=$(( ( ${RANDOM} % ${VLCRATE:=30} ) + 1  )) ; 
 local IntRateInsert=0 ; 
 local IntRateGet=0 ;
 local StrRandomFormat="" ; 
 local IntSleep=0 ; 
 local StrVLCCmd="${VLCCLICMD:=rate __RATE__}" ; 
 local StrSentCmd="" ; 
 ### Create the random-field olding N-range of Possible Rate.  
 for (( intx=0 ; intx <= ${IntRandRange} ; intx++ )) ; do 
  IntRateInsert=$(( 100 - ( ${RANDOM} %  ${IntRandRange} ) )) ;
  ArrayRateLevel[${#ArrayRateLevel[@]}]=${IntRateInsert} ;  
 done  ;
 echo "List or range [ ${ArrayRateLevel[@]} ] " > /dev/stderr ; 
 while [ 1 ] ; do 
  IntRateGet=$(( ${ArrayRateLevel[${RANDOM} % ${#ArrayRateLevel[@]}]} )) ; 
  if [ ${IntRateGet:=100} -eq 100 ] ; then 
   StrRandomFormat="1" ;
  else
   StrRandomFormat="0.${IntRateGet}" ;
  fi 
  IntSleep=$(( ( ${RANDOM} % ${VLCRATEDURATION:=10} ) + 1 )) ; 
  echo "Rate Fixed to ${StrRandomFormat}, for ${IntSleep} seconds " > /dev/stderr ;  
  StrSentCmd=${StrVLCCmd//__RATE__/${StrRandomFormat}} ; 
  echo "Pushing cmd:[ ${StrSentCmd} ]" > /dev/stderr ; 
  echo "${StrSentCmd}" | nc ${VLCSERVER:=192.168.0.72} ${VLCSRVPORT:=5080} 2>&1 /dev/null  ; 
  sleep ${IntSleep} ; 
 done ; 
  
}

###
### Old Section, the improvement are previous lines, all the stuff under this comment 
### are port from theses prototypes.
### 

unset OldVLCServer ;
function OldVLCServer()
{
 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsDisplayFormatted=${VerbFormated:=True} ;
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
     echo -ne "${StrMsg}\n" > ${StrDevOut} ;
   fi 
		fi
	} 
 ### Model : VerbMsg= VerbDev=/dev/stderr VerbState=True VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis
 
 local __call_locality=( OVLCS OldVLCServer ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;

 ### vlc-terminal.sh is simply a vlc loading sheet and other meter, replacing 
 ### OVLCSAppsLunch={/usr/bin/vlc OR /usr/local/bin/vlc} can just let use
 ### it for test purposes.
  
 ### Section variable declaration
 local StrVLCApps=${OVLCSAppsLunch:="""${HOME}/bin/vlc-terminal.sh"""}
 local StrVLCAppsPlaylist=${OVLCSAppsPlaylist:="""${HOME}/Music/playlist_20160606.m3u"""} ; 
 local BoolUsePlaylist=${OVLCStartPlaylist:=True} ; 
 ### It uses /bin/nc inside socket management to receive incoming vlc-cli command and 
 ### /bin/nc is a bind to /bin/nc.openbsd in Linux-Mint Distribution, depend what other 
 ### own ...
 local StrSocketApps=${OVLCSAppsSock:=/bin/nc};
 local StrVlcServerName=${OVLCServerName:=.vlc-server} ; 
 local StrSocketOption=${OVLCSAppsSockOpt:=-4 -n -k -i 3} ;
 local BoolUsingNiceNC=${OVLCSAppsSockUsingNice:=False} ; 
 local StrAppsNice=${OVLCNiceApp:=/usr/bin/nice} ; 
 local IntNicePrio=${OVLCSAppsSockNice:=-3} ; 
 local StrSocketBufferOption=${OVLCSAppsSockBuffer:=2097152};
 local StrAppsBufferOption=${OVLCSAppsBuffer:=-I};
 local StrAppsListenOption=${OVLCSAppsLiten:=-l}
 local StrSocketAddr=${OVLCSSockAddr:=127.0.1.1};
 local StrSocketPort=${OVLCSSockPort:=5080};
 local BoolDisplayCmdLine=${OVLCDisplayCmd:=False};
 local StrVTVReg=${OVLCVTVRegistry:='VTVIsArrayStyleInsert=True,VTVIsValueReAssign=True,VTVIsValueToConvert=False,VTVIsArrayStyleInsert=True,VTVIsQuotedValue=True'} ;
 
 local StrVarList="StrAppsNice,BoolUsingNiceNC,IntNicePrio,StrVLCApps,StrVLCAppsPlaylist,StrSocketApps,StrSocketOption,StrAppsBufferOption,StrSocketBufferOption,StrAppsListenOption,StrSocketAddr,StrVTVReg,BoolUsePlaylist,StrVlcServerName,StrVarList" ; 

 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  ### StrVLCApps,StrVLCAppsPlaylist,StrSocketApps,StrSocketOption,StrAppsBufferOption,StrSocketBufferOption,StrAppsListenOption,StrSocketAddr
  if [ -p ${HOME}/${StrVlcServerName} ] ; then 
   rm -f ${HOME}/${StrVlcServerName}  ;  
  else
   mkfifo ${HOME}/${StrVlcServerName} ;  
  fi 
  
  
  
  local StrCmd="""cat ${HOME}/__SOCKET_NAME__ | \
  ${StrVLCApps} __PLAYLIST__ | \
  __NICE__ ${StrSocketApps} ${StrSocketOption} \
  ${StrAppsBufferOption} ${StrSocketBufferOption} \
  ${StrAppsListenOption} ${StrSocketAddr} ${StrSocketPort} > ${HOME}/__SOCKET_NAME__ """ ; 
  
  StrCmd=${StrCmd//__SOCKET_NAME__/${StrVlcServerName}} ;
  
  if [ "${BoolUsePlaylist:=True}" == "False" ]  ; then 
   StrCmd=${StrCmd//__PLAYLIST__/} ;
  else
   StrCmd=${StrCmd//__PLAYLIST__/${StrVLCAppsPlaylist}} ;
  fi 
  
  if [ "${BoolUsingNiceNC:=False}" == "True" ] ; then  
   StrCmd=${StrCmd//__NICE__/${StrAppsNice} ${IntNicePrio}} ; 
  else
   StrCmd=${StrCmd//__NICE__/} ; 
  fi 
  
  VerbMsg=${StrCmd}    \
  VerbHeader="CMDLINE" \
  VerbState=${BoolDisplayCmdLine} \
  VerbFormated=True    \
  VerbDev=/dev/stderr  \
  Verbosis ;
  
  $( eval "${StrCmd}" ) ; 
  
 }
 
 function __main_StopServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  ### echo -ne "\n\n\tLike you see there is an application to destroy and 
  ### socket to stop.\nStay tuned to see how we can manage it with CtrlHandler 
  ### methodology.\n\n" Actual method is to terminate the Vlc-service first by 
  ### sending a 'shutdown' messages. Default information here stipulate 
  ### having correct port and addresses, but they may change and 
  ### afformentionned CtrlHandler should carry this information inside an 
  ### instance. Actually it require to shutdown the services with calling 
  ### prefixed-variable  :
  ###
  ### OVLCSSockAddr=... OVLCSSockPort=... OldVLCServer --stopservices 
  ### Which stop services like a request, not a services. 
  local IntSessionSearch=$( /bin/netstat --tcp -na | egrep "^tcp*" | gawk 'BEGIN{}{printf("%s\n",$4)}END{}' | /bin/egrep -c "${OVLCSSockAddr}:${OVLCSSockPort}" )
  local StrMsg="" ; 
  if [ ${IntSessionSearch:=0} -eq 1 ]; then 
   StrMsg="Shutting down instance found on address: ${OVLCSSockAddr}:${OVLCSSockPort}" ; 
   VerbMsg=${StrMsg} \
   VerbHeader="${__call_locality[1]}-INFO" \
   VerbState=True \
   VerbEvalForm=False\
   VerbFormated=True \
   VerbDev=/dev/stderr  Verbosis ;
   
   VSCCmd="shutdown"         \
   VSCAddr=${OVLCSSockAddr}  \
   VSCPort=${OVLCSSockPort}  \
   VlcSendCmd 1>&2 > /dev/null & 1>&2 > /dev/null ; 
  else
   StrMsg="Wrong information provided to shutdown OldVLCServer instance, review OVLCSSockAddr,OVLCSSockAddr\nServices not found on address: ${OVLCSSockAddr}:${OVLCSSockPort}" ; 
   VerbMsg=${StrMsg} \
   VerbHeader="${__call_locality[1]}-INFO" \
   VerbState=True \
   VerbEvalForm=False\
   VerbFormated=True \
   VerbDev=/dev/stderr  Verbosis ;
  fi 
  
 
 }


  
 local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 local StrNameHelper="${__call_locality[1]}\n\tApplication Create independent Network-layer to maintain the\n\tconsole out of human-hand interaction.";
 local StrSynopsis="\n\tThis application is also used to test both __old_vlc_rate, and it's \n\tnewest improvement, and uses of StartSlewAnalysis, also support VlcSendCmd\n\tand internal command FilterVlcSendCmd from StartSlewAnalysis called\n\twith :\n\n\tSSAFuncStart=FilterVlcSendCmd StartSlewAnalysis\n";
 local StrSummary="" ; 
 local StrDescription="" ;

 ### Main If-statement section .
 StrVTVReg=${StrVTVReg//,/ } ; 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
  GVRIsName=True     \
  GVRIsSummary=False \
  GVRIsSynopsis=True \
  GVRIsDesc=False    \
  GetVarReference ${__call_locality[1]} ;
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( eval VTVValueEntry="${StrVarList}" "${StrVTVReg}" \
  ValueToVariable ) __main_StartServices ; 
 elif [ "${Arg0:=--stopservices}" == "--stopservices" ] ; then 
  eval $( eval VTVValueEntry="${StrVarList}" "${StrVTVReg}" \
  ValueToVariable ) __main_StopServices ; 
 fi

}

unset VLCSetVolume ; 
function VLCSetVolume()
{
 function Verbosis()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Verb Verbosis ) ; 
   local Arg0=${ArrayArg[0]} ; 
  elif [ ${versionGPI:=0.0.0} == "0.0.1" ] ; then 
   eval $( CAFunctName=Verbosis CAIsAddParent=False __Call_Argument ) ; 
  elif [ ${versionGPI:=0.0.0} == "0.0.2" ] ; then 
   eval $( CAFunctName=Verbosis CAIsAddParent=False CallArgument ) ; 
  fi 
  local StrMsg=${VerbMsg:=__TEXT__} ; 
  local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
  local IsDisplayFormatted=${VerbFormated:=True} ;
  local IsAppendMode=${VerbAppendDev:=False} ; 
  local ArrayArg=( $* ) ; 
  if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
    if [ "${IsAppendMode:=False}" == "True" ] ; then 
      echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
    else  
      echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
    fi
   else
    if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
       echo "${StrMsg}" ;  
    else
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
      echo "${StrMsg}" >> ${StrDevOut} ;
     else
      echo "${StrMsg}" > ${StrDevOut} ;
     fi
    fi 
   fi 
  fi
 } 
 ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
 
 ### ---TOP-FUNCTION-DECLARATION---
 if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
  local -a ArrayArg=( $* ) ;
  local -a __call_locality=( VLCSV VLCSetVolume ) ;
  local StrParentApps=${__call_locality[1]} ; 
  local StrMainStart=${VLCSVFuncStart:=__main_StartServices} ;  
  local Arg0=${ArrayArg[0]} ; 
 elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
  eval $( CAFunctName=VLCSetVolume CAIsAddParent=False __Call_Argument ) ; 
 elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
  eval $( CAFunctName=VLCSetVolume CAIsAddParent=False CallArgument ) ; 
 fi 
 
 local StrTplZenityVol=${VLCSVTplZenity:="zenity --scale --text=\"__TEXT__\" --value=__VOLUME__ --min-value=__MIN_VOLUME__ --max-value=__MAX_VOLUME__ --step=__VOL_STEP__"} ;
 local StrTplParser=${VLCSVTagParser:=StrTextCLient:__TEXT__,IntVol:__VOLUME__,IntMinVol:__MIN_VOLUME__,IntMaxVol:__MAX_VOLUME__,IntStepVol:__VOL_STEP__,StrAddr:__IP__,IntPort:__PORT__,StrVolCLiCmd:__CLI_CMD__,IntNewVol:__NEWVOL__,StrAppsEcCli:__APPS_EC_OPT__,StrAppsEc:__APPS_EC__} ;
 local StrTextCLient=${VLCSVTextCli:='VLC CLient Volume Indicator'} ;
 local StrVolCLiGetCmd=${VLCSVCliGet:="__APPS_EC__ __PIPE__ __APPS__ __APPS_OPT__ __PIPE__ __FILTER__ __FILTER_OPT__"} ; 
 local StrVolCLiSetCmd=${VLCSVCliSet:="echo volume __PIPE__ __APPS__ __APPS_OPT__ __PIPE__ __FILTER__ __FILTER_OPTS__"} ; 
 local StrAppsEc=${VLCSVCLiePushCmd:=echo \"__APPS_EC_OPT__\"} ;
 local StrAppsEcCli=${VLCSVCLiCmd:=volume} ; 
 local IntMinVol=${VLCSVMinVol:=0} ;
 local IntMaxVol=${VLCSVMaxVol:=500} ;
 local IntStepVol=${VLCSVStepVol:=1} ; 
 local StrAddr=${VLCSVAddr:=127.0.0.1} ; 
 local IntPort=${VLCSVPort:=5083} ; 
 local StrVarList="StrVarList,StrTplZenityVol,StrTplParser,StrTextCLient,StrVolCLiGetCmd,StrVolCLiSetCmd,IntMinVol,IntMaxVol,IntStepVol,StrAddr,IntPort,StrAppsEc,StrAppsEcCli" ; 

  

 function __main_StartServices()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ; 
   local Arg0=${ArrayArg[0]} ;   
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ; 
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ; 
  fi  
  
  
  #eval $( "CAFunctName=VLCSetVolume CAIsAddParent=True __Call_Argument" ) ; 
  #IntVol=$( echo "volume" | nc 127.0.0.1 5083 | sed 's/[^0-9]*//g' )
  #IntNewVol=$(  zenity --scale --text="VLC CLient Volume Indicator" --value=${IntVol} --min-value=0 --max-value=500 --step=1 ) ;
  #echo "volume ${IntNewVol}" | nc 127.0.0.1 5083
  
  ### New Variable declared for use of GnrlPrsrInfctr #1, and #2
  # local StrCmdGet=${StrVolCLiGetCmd} ;  
  local StrCmdSend ; 
  ### I need to re-copy the StrTplZenityVol and parse the new copy.
  local StrCmdZenity=${StrTplZenityVol} ; 
  
  ### GnrlPrsrInfctr #1, responsible of Getting information from vlc --> StrVolCLiGetCmd
  eval $( eval VTVIsArrayStyleInsert=True \
  VTVValueEntry=${StrVarList}  \
  VTVIsValueReAssign=True      \
  VTVIsValueToConvert=False    \
  VTVIsArrayStyleInsert=True   \
  ValueToVariable ) GPIIsUUIDInstance=True      \
                    GPIIsFileHandlerOut=False   \
                    GPIIsZenityHandlerOut=True  \
                    GPIIsExecuteEval=True       \
                    GPIIsGenerateCode=False     \
                    GPIDisplayDebug=True        \
                    GPIParserDebug=True         \
                    GPITpl="${StrVolCLiGetCmd}" \
                    GPIApps=/bin/nc             \
                    GPIAppsOpt='${StrAddr} ${IntPort}' \
                    GPITagFeeder="${StrTplParser}"     \
                    GPIFilterApps='/bin/sed'           \
                    GPIFilterOpt='s/[^0-9]*//g'        \
                    GPITagParserResult='StrCmdGet'     \
                    GnrlPrsrInfctr ;
  
  VerbMsg="StrCmdGet:${StrCmdGet}, reference:UUID:${UUID}" VerbHeader="${__call_locality[0]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
  
  ### GnrlPrsrInfctr #1, responsible of Setting information for vlc --> StrVolCLiGetCmd
  ### Because IntNewVol is a new member it require to be injected on the QueryList or 
  ### using ValueToVariable can do this task. 
  
  ### Since I do need to set the volume value, it require the GUI action from Zenity
  ### to set the desired variable. I do require to parse with TagPArser the Zenity 
  ### Command, using the StrTplParser the same from GnrlPrsrInfctr #1, and #2. 
  #eval eval TPVarNameParsed="StrCmdZenity"               \
  #     TPListTag="${StrTplParser}"                       \
  #     TPIsMatchRtoL=True                                \
  #     TPDisplayParserNotice=True                        \
  #     TPDisplayDebug=True                               \
  #     TPArrayName="Array${__call_locality[0]}Tag"       \
  #     TagParser ;
  
  #VerbMsg="StrCmdZenity:${StrCmdZenity}" VerbHeader="${__call_locality[0]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis ; 
             
  #eval $( VTVIsArrayStyleInsert=True \
  #VTVValueEntry=IntNewVol \
  #VTVIsValueReAssign=True  \
  #VTVIsValueToConvert=False \
  #VTVIsArrayStyleInsert=True \
  #ValueToVariable ) GPIIsUUIDInstance=True \
  #                  GPIIsFileHandlerOut=True \
  #                  GPIIsExecuteEval=True \
  #                  GPIIsGenerateCode=False \
  #                  GPIParserDebug=True \
  #                  GPITpl="${StrVolCLiSetCmd}" \
  #                  GPIApps=/bin/nc \
  #                  GPIAppsOpt='${StrAddr} ${IntPort}' \
  #                  GPITagFeeder="${StrTplParser}" \
  #                  GPITagParserResult='StrCmdSend' \
  #                  GnrlPrsrInfctr  ; 

  #VerbMsg="StrCmdSend:${StrCmdSend}, reference:UUID:${UUID}" VerbHeader="${__call_locality[0]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis ; 
  
 
 }
 
 function __main_StopServices()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Main __main_StopServices ${StrParentApps} ) ; 
   local Arg0=${ArrayArg[0]} ;   
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( CAFunctName=__main_StopServices CAIsAddParent=True __Call_Argument ) ; 
  elif [ ${versionGPI:=0.0.0} == "0.0.2" ] ; then 
   eval $( CAFunctName=__main_StopServices CAIsAddParent=True CallArgument ) ; 
  fi  
  #eval $( "CAFunctName=VLCSetVolume CAIsAddParent=True __Call_Argument" ) ; 
  
 }
 
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--stopservices}" == "--stopservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=${StrVarList} \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StopServices  ; 
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  StrMsg="Function __FUNCT__, version versionCA=__VER_CA__, versionGPI=__VER_GPI__, versionTP=__VER_TP__" ; 
  StrMsg=${StrMsg//__FUNCT__/${StrParentApps}} ; 
  StrMsg=${StrMsg//__VER_TP__/${versionTP}} ; 
  StrMsg=${StrMsg//__VER_CA__/${versionCA}} ; 
  StrMsg=${StrMsg//__VER_GPI__/${versionGPI}} ; 
  VerbMsg="${StrMsg}" VerbHeader="LOADER" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
  eval $( eval VTVIsArrayStyleInsert=True \
  VTVValueEntry=${StrVarList} \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) ${StrStartMain} ; 
 fi
 
 
}

if [ "${versionNSS:=0.0.0}" == "0.0.0" ] ; then 
 unset NetSocketServices ; 
 unset NSSSocketApps NSSAddresses NSSPort NSSSocketAppsOpt ; 
 function NetSocketServices()
 {
  local -a ArrayArg=( $* ) ;
  local -a __call_locality=( NSS NetSocketServices ) ;
  local Arg0=${ArrayArg[0]} ; 
  local StrSocketApps=${NSSSocketApps:=/bin/nc} ; 
  local StrSocketAddr=${NSSAddresses:=127.0.0.1} ; 
  local StrSocketPort=${NSSPort:=5083} ; 
  local StrSocketAppsParam=${NSSSocketAppsOpt:=-i 3} ;
  local StrSocketBuffer=${NSSBuffer:=1024} ;
  local IsVerbose=${NSSIsVerbose:=False} ; 
  local StrBufferCmd="-O __BUFFER__" ; 
  StrBufferCmd=${StrBufferCmd//__BUFFER__/${StrSocketBuffer}} ; 
  local StrCmd="${StrSocketApps} ${StrBufferCmd} ${StrSocketAppsParam} ${StrSocketAddr} ${StrSocketPort}" ; 
  if [ "${IsVerbose:=False}" == "True" ] ; then
   echo -ne "Application ${__call_locality[1]} using following parameter:\n\tCMD:[${StrCmd}]\n" > /dev/stderr ; 
  fi
  ${StrCmd}
  #${StrSocketApps} ${StrSocketBuffer} ${StrSocketAppsParam} ${StrSocketAddr} ${StrSocketPort}  ; 
 }
fi 

if [ "${versionVSL:=0.0.0}" == "0.0.1" ] ; then 

eval $( GFCFuncName=VlcServicesLayer GlobalFunctionCleaning ) ; 
 
 function VlcServicesLayer()
 {
  function Verbosis()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Verb Verbosis ) ; 
   local Arg0=${ArrayArg[0]} ; 
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local IsExtendedOutput=${VerbExtendedOut:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
      if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" ;  
      else
        echo "${StrMsg}" ;  
      fi
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" >> ${StrDevOut} ;
       else
         echo "${StrMsg}" >> ${StrDevOut} ;
       fi
      else
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" > ${StrDevOut} ;
       else
        echo "${StrMsg}" > ${StrDevOut} ;
       fi 
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
  
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( VSL VlcServicesLayer ) ;
   local Arg0="${ArrayArg[0]}" ; 
   local StrParentApps=${__call_locality[1]} ;
   local StrStartMain=${SSAFuncStart:=__main_StartServices} ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=VlcServicesLayer CAIsAddParent=False __Call_Argument ) ; 
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=VlcServicesLayer CAIsAddParent=False CallArgument ) ;
  fi 
 
  local StrPathLoopState=${VSLLoopFile:=/var/cache/Fnct.D/Register-VSL-__UUID__} ; 
  local BoolShowEntry=${VSLShowEntry:=True} ; 
  local BoolDisplayDebug=${VSLDisplayDebug:=True} ; 
  local BoolShowInstance=${VSLShowInstance:=True} ; 
  local BoolUseBase64=${VSLUseBase64:=True} ; 
  local StrCSVVar=${VSLCsvValue=','} ;
  local StrVTVRegistry=${VSLVTVReg:=VTVIsArrayStyleInsert=True,VTVIsValueReAssign=True,VTVIsValueToConvert=False,VTVIsArrayStyleInsert=True,VTVIsQuotedValue=True} ;
  # By default theses variable are not added using hard-coding structure, 
  # but rely on uses of StrVarList method to append list of variable. 
  local StrAddr=${VSLServerAddr:=127.0.0.1} ; 
  local StrPort=${VSLServerPort:=5083} ; 
  
  local StrStorageVar=${VSLStoreVar:=StrAddr,StrPort} ; 
  local StrVarList="StrPathLoopState,BoolUseBase64,BoolShowEntry,BoolDisplayDebug,BoolShowInstance,StrVTVRegistry,StrStorageVar,StrVarList,StrCSVVar" ;
  ### This method allow adding automatically other variable to StrVarList, by uses of StrStorageVar
  StrVarList="${StrVarList},${StrStorageVar}" ; 
  
  local -a ArrayMsg ;
  ArrayMsg[0]="Entry in function" ;  
  ArrayMsg[1]="Shutdown Instance ID:__UUID__, file: __FILE__" ;
  ArrayMsg[2]="Instance ID:__UUID__" ;
  ArrayMsg[3]="Storing Layer information of UUID instance __UUID__\n\tVariable list:[__LIST__]\n\tBase64 used to store information: __ISBASE64__." ;
  ArrayMsg[4]="File Name holding information : __FILE__." ;
  ArrayMsg[5]="File Serialization:\n\tSHA1SUM: __SHA__\n\tSerialized value:[__VALUE__]\t" ; 
  ArrayMsg[6]="Received a services interruption, stopservices switches was impled or use ServiceControllerHandler was performed." ; 
  ArrayMsg[7]="Variable to Serialize: __VAR__" ; 
  
  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ;
   fi 
   
   local -A ADbgHdr ; 
   ADbgHdr["WARNING"]="${__call_locality[1]}-WARNING" ;
   ADbgHdr["ENTRY"]="${__call_locality[1]}-ENTRY" ;
   ADbgHdr["DEBUG"]="${__call_locality[1]}-DEBUG";
   ADbgHdr["INFO"]="${__call_locality[1]}-INFO" ;
   
   local StrMsg=$( VlcServicesLayer --get ArrayMsg[0] ) ;
   VerbMsg="${StrMsg}" VerbHeader=${ADbgHdr["ENTRY"]} VerbState=${BoolShowEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;  
  
   local StrUUID=$( GetUAppsRegisterName=${StrParentApps} \
                    GetUTimeBased=True \
                    GetULoop=False \
                    GetUUID ) ;
   
   StrPathLoopState=${StrPathLoopState//__UUID__/${StrUUID}}
   
   StrMsg=$( VlcServicesLayer --get ArrayMsg[4] ) ;
   StrMsg=${StrMsg//__FILE__/${StrPathLoopState}} ; 
   
   VerbMsg="${StrMsg}" VerbHeader=${ADbgHdr["WARNING"]} VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;  
   
   StrMsg=$( VlcServicesLayer --get ArrayMsg[2] ) ;
   StrMsg=${StrMsg//__UUID__/${StrUUID}} ; 
   
   VerbMsg="${StrMsg}" VerbHeader=${ADbgHdr["DEBUG"]} VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;  
  
   StrMsg=$( VlcServicesLayer --get ArrayMsg[3] ) ;
   StrMsg=${StrMsg//__UUID__/${StrUUID}} ; 
   StrMsg=${StrMsg//__LIST__/${StrStorageVar}} ; 
   StrMsg=${StrMsg//__ISBASE64__/${BoolUseBase64}} ; 

   VerbMsg="${StrMsg}" VerbHeader=${ADbgHdr["DEBUG"]} VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr Verbosis ;  
   
   StrStoreStream="" ; 
   ### Force the StorageVar to have it's ',' comma at the end. 
   
   local StrASeg ;
   local StrBSeg ;
   local StrValue ; 
   local StrConv ;
   local StrSha1Sum ; 
   local StrCodec="text" ; 
   
   if [ "${BoolUseBase64:=True}" == "True" ] ; then 
    StrCodec="base64" ; 
   fi 
   
   ### Important notice when using match reduction filter in Prefix/suffix
   ### substitution, to have an extra comma separator value at the end.
   StrASeg=$( echo ${StrStorageVar} | sed 's/$/,/g ; s/[,]\{1,\}$/,/g' ; ) ;
   while [ ${StrASeg:=None} != "None" ] ; do 
    ### Notice, since some test confirming uses of caracter exclusion work
    ### in shell uses and confirm it does propagating the carret '^' correctly !
    ### Why not using a prefix-matching reduccing method of bash filtering 
    ### anything but 'comma' value as pattern between match like this :
    ### Where Var="Value1,Value2," 
    ### Var1=${Var/%,[^]*}, Var1 give value : Value1, Var stay the same
    ### and Var="${Var/#${Var1},}" ; Var leave, "Value2," and next iteration 
    ### Var will be empty 
    
    StrBSeg=${StrASeg/%${StrCSVVar}[^${StrCSVVar}]*} ; 
    StrBSeg=${StrBSeg//${StrCSVVar}/} ; 
    
    StrMsg=$( VlcServicesLayer --get ArrayMsg[7] ) ;
    StrMsg=${StrMsg//__VAR__/${StrBSeg}} ;
    VerbMsg="${StrMsg}" VerbHeader=${ADbgHdr["DEBUG"]} VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;   
    
    if [ "${BoolUseBase64:=True}" == "True" ] ; then 
     eval "StrValue=\${${StrBSeg}}" ;
     StrStoreStream="${StrStoreStream}${StrBSeg}:__CODEC__:__VALUE__," ; 
     StrBaseConv=$( echo "${StrValue}" | base64 --wrap=0 ) ;
     StrStoreStream=${StrStoreStream//__VALUE__/${StrBaseConv}} ; 
    else
     StrStoreStream="${StrStoreStream}${StrBSeg}:__CODEC__:__VALUE__," ; 
     StrStoreStream=${StrStoreStream//__VALUE__/${StrValue}} ; 
    fi
    StrStoreStream=${StrStoreStream//__CODEC__/${StrCodec}} ; 
    StrASeg="${StrASeg/#${StrBSeg}${StrCSVVar}}" ; 
   done 
   
   StrSha1Sum=$( echo ${StrStoreStream} | /usr/bin/sha1sum |  cut -d ' ' -f 1 ) ; 
   StrMsg=$( VlcServicesLayer --get ArrayMsg[5] ) ;
   StrMsg=${StrMsg//__SHA__/${StrSha1Sum}} ; 
   StrMsg=${StrMsg//__VALUE__/${StrStoreStream}} ; 
   
   ### Adding Sha1Sum to StrStoreStream :
   StrStoreStream="${StrSha1Sum}\n${StrStoreStream}\n" ; 
   VerbMsg="${StrMsg}" VerbHeader=${ADbgHdr["DEBUG"]} VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;  
   
   VerbMsg="${StrStoreStream}" VerbDev=${StrPathLoopState} VerbExtendedOut=True VerbState=True VerbEvalForm=False VerbFormated=False Verbosis ;  
   
  }
  
  function __main_StopServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StopServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True CallArgument ) ;
   fi 
   StrMsg=$( VlcServicesLayer --get ArrayMsg[0] )
   
   VerbMsg="${StrMsg}"        \
   VerbHeader="${__call_locality[1]}-ENTRY" \
   VerbState=${BoolShowEntry} \
   VerbEvalForm=False         \
   VerbFormated=True          \
   VerbDev=/dev/stderr        \
   Verbosis ;
   
   ### Stop services, based on creation of a file named in '${StrPathLoopState}'  and
   ### resposible to loop inside __main_StartServices unless the file exist. 
   ###
   ### Example to shutdown a current session:
   ### UUID=9589a8be-b766-11e6-8b1d-001e4c8856d6  StartSlewAnalysis --stopservices 
   ### will erase the file inside /var/cache/Fnct.D/Loop-SSA-9589a8be-b766-11e6-8b1d-001e4c8856d6
   ### be sure you are launched it from same user permission. 
   ###
   local StrUUID=${UUID} ;
   if [ "${StrUUID:=None}" == "None" ] ; then 
    StrUUID=${StrUUIDInstance} ; 
   fi # End-IF ("${StrUUID:=None}" == "None")
   local StrPathLoopState=${StrPathLoopState//__UUID__/${StrUUID}} ; 
   
   StrMsg=$( VlcServicesLayer --get ArrayMsg[1] ) ;
   StrMsg=${StrMsg//__UUID__/${StrUUID}} ; 
   StrMsg=${StrMsg//__FILE__/${StrPathLoopState}} ; 
   
   VerbMsg=${StrMsg}   \
   VerbHeader=DEBUG    \
   VerbState=True      \
   VerbEvalForm=False  \
   VerbFormated=True   \
   VerbDev=/dev/stderr \
   Verbosis ;
   
   if [ -f ${StrPathLoopState} ] ; then 
    rm -f ${StrPathLoopState} ; 
    StrMsg=$( VlcServicesLayer --get ArrayMsg[6] ) ;
    VerbMsg="${StrMsg}"    \
    VerbHeader=SESSION-END \
    VerbState=True         \
    VerbEvalForm=False     \
    VerbFormated=True      \
    VerbDev=/dev/stderr  Verbosis ;
    
   fi ; # End-IF ( -f ${StrPathLoopState} )
      
  } 
 
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  local StrNameHelper="${__call_locality[1]}\t\tTo create Persistent Register information for application requiring Socket connection.";
  local StrSummary="" ; 
  local StrSynopsis="";
  local StrDescription="" ;
   
   ### Section : Switches-Statememt 
   if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    ### GVRIsName set to True is the Variable handled StrNameHelper by GetVarReference and 
    ### provide a Name-Helper inside the live-documentation if we call StartSlewAnalysis --help.
    ### Extending the help by turning other variable to True will increae help. Variable are
    ### declared previously. 
    GVRIsName=True     \
    GVRIsSummary=False  \
    GVRIsSynopsis=False \
    GVRIsDesc=False     \
    GetVarReference ${__call_locality[1]} ; 
    VerbMsg="${StrSwitchMessages}" \
    VerbState=True       \
    VerbEvalForm=False   \
    VerbFormated=False   \
    VerbExtendedOut=True \
    VerbDev=/dev/stderr  \
    Verbosis ;
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ;
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    eval $( __GetVarReferenceList ) ;	
   elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
    eval $( eval ${StrVTVRegistry//,/ } \
            VTVValueEntry=${StrVarList} \
            VTVWhiteListTransfert=UUID  \
            ValueToVariable ) __main_StopServices ; 
   elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
    StrMsg=$( VlcServicesLayer --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    ### This is the main-boot strap and should load __main_StartServices unless 
    ### It receive from prompt a Prefixed-Variable SSAFuncStart=Function. Every
    ### application made from CallArgument does have it's entry in form [SHORT-NAME]Func=${StrStartMain} ;
    eval $( eval ${StrVTVRegistry//,/ } \
            VTVValueEntry=${StrVarList} \
            ValueToVariable ) ${StrStartMain} 
   fi 
   ### End-Section : Switches-Statememt  
 
 
 }

fi 

if [ "${versionVSC:=0.0.0}" == "0.0.0" ] ; then 
 unset VlcSendCmd ; 
 unset VSCAddr VSCPort VSCCmd ; 
 function VlcSendCmd()
 {
    
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( VSC VlcSendCmd ) ;
    local Arg0=${ArrayArg[0]} ; 
    local StrAddr=${VSCAddr:=none} ; 
    local StrPort=${VSCPort:=none} ; 
    local StrQueueCmd=${VSCCmd:='help'} ;
    local BoolDisplayDebug=${VSCVerbose:='False'} ;  
    local StrCacheRefTpl="/var/cache/Fnct.D/Register-VSL-__UUID__" ; 
    local StrCacheReference ; 
    local StrContent;
    local StrSig; 
    local StrSha1Sum ;
    local BoolRejectSigErr=False ;
    local BoolProcessErr=False ; 
    local IntCountCall=0 ;
    local -a ArrayErrMsg ; 
    local -a ArrayErrProcMsg ; 
    local -a ArrayOutMsg ; 
    if [ "${UUID:=None}" != "None" ] ; then 
     StrCacheReference=${StrCacheRefTpl/__UUID__/${UUID}} ;
     ArrayOutMsg[${#ArrayOutMsg[@]}]="UUID Instance discovered:\n\tUUID: ${UUID}\n\tfile ${StrCacheReference} will be used as instance-registration.\n" ; 
     StrContent=$( eval GBLDFileStoreInfo=${StrCacheReference} GBLDAction=GetContent GetterByLineData ) ;  
     StrSig=$( eval GBLDFileStoreInfo=${StrCacheReference} GBLDAction=GetHeader GetterByLineData ) ;  
     StrSha1Sum=$( eval GBLDFileStoreInfo=${StrCacheReference} GBLDAction=ShaSum1Content GetterByLineData  ) 
     
     if [ -f ${StrCacheReference} ] ; then 
     
      ### Counting Number of CSV by reducing the String from them and calculating 
      ### the final-length after reduction. 
      local StrContentStrip=${StrContent//,/} ; 
      local IntContentStrip=$(( ${#StrContent} - ${#StrContentStrip} )) ; 
      
      if [ "${StrSig}" == "${StrSha1Sum}" ] ; then 
       StrASeg=$( echo ${StrContent} | sed 's/$/,/g ; s/[,]\{1,\}$/,/g' ; ) ;
       for(( IntA=0 ; IntA <= ${IntContentStrip}-1 ; IntA++ )) ; do 
        IntCountCall=$((${IntCountCall}+1)) ; 
        StrBSeg=${StrASeg/%,[^,]*} ; 
        ArrayOutMsg[${#ArrayOutMsg[@]}]="Status StrASeg: [${StrASeg}]\nPart Extracted:\n\tStrBSeg: [${StrBSeg}]\n" ;
        StrASeg=${StrASeg/#${StrBSeg},} ; 
        ArrayOutMsg[${#ArrayOutMsg[@]}]="Status StrASeg:\n\tAfter cleaning, [${StrASeg}]\n" ;
        
        local -a ArrayVarCreation ;
        ### Format of each Serialized chunk is made from :
        ### 0 addr : Variable name 
        ### 1 addr : codec type (base64/text) 
        ### 2 addr : Value. 
        ### And should clean odd-csv
        StrCSeg=$( echo ${StrBSeg} | sed 's/,\{1,\}$//g' )  ; 
        #StrCSeg=${StrBSeg} ; 
        ### Ensure the algorithm of match-substitution by alterning prefix/suffix
        ### have a separator at the end. 
        StrCSeg=$( echo ${StrCSeg} | sed 's/$/:/g ; s/[:]\{1,\}$/:/g' ) ;
        for(( IntB=0 ; IntB <= 2 ; IntB++ )) ; do 
         StrDSeg=${StrCSeg/%:[^:]*} ;
         ArrayVarCreation[${IntB}]=$( echo ${StrDSeg} | sed 's/[:]\{1,\}$//g' ) ; 
         StrCSeg=${StrCSeg/#${StrDSeg}:} ; 
        done 
        ### Variable Creation from De-Serialization . 
        ArrayOutMsg[${#ArrayOutMsg[@]}]="\t\tExtracting variable:${ArrayVarCreation[0]}\n"  ; 
        ArrayOutMsg[${#ArrayOutMsg[@]}]="\t\tVariable Codec:${ArrayVarCreation[1]}\n" ;
        if [ "${ArrayVarCreation[1]}" == "base64" ] ; then 
         StrValue=$( echo ${ArrayVarCreation[2]} | base64 -d ) ; 
         ArrayOutMsg[${#ArrayOutMsg[@]}]="\tBase64 Conversion, Value: [${ArrayVarCreation[2]}] converted in [${StrValue}]\n" ;
         eval "${ArrayVarCreation[0]}=${StrValue}" ;
        elif [ "${ArrayVarCreation[1]}" == "text" ] ; then 
         ### Require to remove current value of variable:
         unset ${ArrayVarCreation[0]} ; 
         eval "${ArrayVarCreation[0]}=${ArrayVarCreation[2]}" ;
        fi 
        eval "StrEval=\"[ ${ArrayVarCreation[0]} ; \${${ArrayVarCreation[0]}} ]\"" ; 
        ArrayOutMsg[${#ArrayOutMsg[@]}]="Variable created:[${StrEval}]\n" ;
        if [ ${IntCountCall} -gt $((${IntContentStrip}+1)) ] ; then 
         ArrayErrProcMsg[${#ArrayErrProcMsg[@]}]="Breaking Code for abnormal looping\n\tExcess number of parameter to filter set to ${IntContentStrip}, it already excess the limit.\n" ; 
         BoolProcessErr=True ; 
         break ; 
        fi 
       done ; 
    
      else
      ArrayErrMsg[${#ArrayErrMsg[@]}]="Rejected UUID References, SHA1SUM does not match with Registration.\nFill out another VlcServicesLayer with news parameter and start this application with UUID instance id.\n"
      ArrayErrProcMsg[${#ArrayErrProcMsg[@]}]="Signature rejection.\n" ; 
      BoolRejectSigErr=True ;
      BoolProcessErr=True ;
      fi 
     else
      ArrayErrMsg[${#ArrayErrMsg[@]}]="Warning UUID value: ${UUID} is not existing inside Fnct.D cache.\n\tPlease, register one properly with VlCServicesLayer\n\tand use it's UUID instance as UUID value.\n" ; 
      ArrayErrProcMsg[${#ArrayErrProcMsg[@]}]="File missing or read-access problems.\n" ; 
      BoolRejectSigErr=True ; 
      BoolProcessErr=True ;
     fi 
    fi 
    
    if [ ${BoolRejectSigErr:=False} == "True" ] ; then 
     ### Display All the error messages, encountered. 
     if [ ${BoolDisplayDebug:=False} == "True" ] ; then 
      for (( intMsg=0; intMsg<=${#ArrayErrMsg[@]}-1 ; intMsg++ )) ; do 
       echo -ne "${ArrayErrMsg[${intMsg}]}" > /dev/stderr  ; 
      done 
     fi
    else
     echo "${StrQueueCmd}" | NSSAddresses=${StrAddr} NSSPort=${StrPort} NetSocketServices  ; 
    fi 
    
    if [ "${BoolProcessErr:=False}" == "True" ] ; then 
     ### Process come in error, throwing error . 
     if [ ${BoolDisplayDebug:=False} == "True" ] ; then 
      echo -ne "Error occur during processing the request.\n" > /dev/stderr ; 
      for (( intMsg=0; intMsg<=${#ArrayErrProcMsg[@]}-1 ; intMsg++ )) ; do 
       echo -ne "${ArrayErrProcMsg[${intMsg}]}" > /dev/stderr  ; 
      done 
     fi
    else
     # Everything went OK, display all the verbose. 
     if [ ${BoolDisplayDebug:=False} == "True" ] ; then 
      for (( intMsg=0; intMsg<=${#ArrayOutMsg[@]}-1 ; intMsg++ )) ; do 
       echo -ne "${ArrayOutMsg[${intMsg}]}" > /dev/stderr  ; 
      done 
     fi
    fi 

 }
fi 
if [ "${versionVSC:=0.0.0}" == "0.0.1" ] ; then 
 
 eval $( GFCFuncName=VlcSendCmd GlobalFunctionCleaning ) ; 

 function VlcSendCmd()
 {
  function Verbosis()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Verb Verbosis ) ; 
   local Arg0=${ArrayArg[0]} ; 
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local IsExtendedOutput=${VerbExtendedOut:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
      if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" ;  
      else
        echo "${StrMsg}" ;  
      fi
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" >> ${StrDevOut} ;
       else
         echo "${StrMsg}" >> ${StrDevOut} ;
       fi
      else
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" > ${StrDevOut} ;
       else
        echo "${StrMsg}" > ${StrDevOut} ;
       fi 
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
  
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( VCS VlcSendCmd ) ;
   local Arg0="${ArrayArg[0]}" ; 
   local StrParentApps=${__call_locality[1]} ;
   local StrStartMain=${SSAFuncStart:=__main_StartServices} ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=VlcSendCmd CAIsAddParent=False __Call_Argument ) ; 
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=VlcSendCmd CAIsAddParent=False CallArgument ) ;
  fi 
 
  local StrAddr=${VSCAddr:=none} ; 
  local StrPort=${VSCPort:=none} ; 
  local StrQueueCmd=${VSCCmd:='help'} ;
  local BoolShowUUID=${VCSShowUUID:=True} ;
  local BoolShowEntry=${VCSShowEntry:=True} ;
  local BoolDisplayDebug=${VCSDisplayDebug:=True} ;
  local BoolShowInstance=${VCSShowInstance:=True} ;
  local StrCacheRefTpl=${VCSCacheRefTpl:=/var/cache/Fnct.D/Register-VSL-__UUID__};
  local StrVTVRegistry=${VCSVTVReg:=VTVIsArrayStyleInsert=True,VTVIsValueReAssign=True,VTVIsValueToConvert=False,VTVIsArrayStyleInsert=True,VTVIsQuotedValue=True} ;
  local StrVarList="VSCAddr,VSCPort,VSCCmd,BoolShowUUID,BoolShowEntry,BoolDisplayDebug,BoolShowInstance,StrVTVRegistry,StrCacheRefTpl" ;
  
  local -a ArrayMsg ;
  ArrayMsg[0]="Entry in function" ;  
  ArrayMsg[1]="Instance ID:__UUID__" ;
  ArrayMsg[2]="UUID Instance discovered:\n\tUUID: __UUID__\n\tfile __CACHE__ will be used as instance-registration.\n" ;
  ArrayMsg[3]="" ; 
  ArrayMsg[4]="" ;
  ArrayMsg[5]="" ; 
  ArrayMsg[6]="" ; 
  ArrayMsg[7]="Variable created:[__EVAL__]\n" ; 
  ArrayMsg[8]="Rejected UUID References, SHA1SUM does not match with Registration.\nFill out another VlcServicesLayer with news parameter and start this application with UUID instance id.\n"  ;
  ArrayMsg[9]="" ; 


  function __main_StopServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StopServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True CallArgument ) ;
   fi 
   StrMsg=$( VlcSendCmd --get ArrayMsg[0] ) ;
   
   VerbMsg="${StrMsg}"        \
   VerbHeader="${__call_locality[1]}-ENTRY" \
   VerbState=${BoolShowEntry} \
   VerbEvalForm=False         \
   VerbFormated=True          \
   VerbDev=/dev/stderr        \
   Verbosis ;
   
  
  }

  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ;
   fi 
   local StrMsg=$( VlcSendCmd --get ArrayMsg[0] ) ;
   local -A ADbgHdr ; 
   ADbgHdr["ENTRY"]="${__call_locality[1]}-ENTRY" ;
   ADbgHdr["DEBUG"]="${__call_locality[1]}-DEBUG";
   ADbgHdr["INFO"]="${__call_locality[1]}-INFO" ;
   
   
   VerbMsg="${StrMsg}"    \
   VerbHeader=${ADbgHdr["ENTRY"]} \
   VerbState=${BoolShowEntry} \
   VerbEvalForm=False     \
   VerbFormated=True      \
   VerbDev=/dev/stderr    \
   Verbosis ;
   
   local StrCacheReference ; 
   local StrContent;
   local StrSig; 
   local StrSha1Sum ;
   local BoolRejectSigErr=False ;
   local IntCountCall=0 ;
   if [ "${UUID:=None}" != "None" ] ; then 
    StrCacheReference=${StrCacheRefTpl/__UUID__/${UUID}} ;
    ###ArrayMsg[2] 
    ###__UUID__${UUID} 
    ###__CACHE__ ${StrCacheReference}
    
    
    StrContent=$( eval GBLDFileStoreInfo=${StrCacheReference} GBLDAction=GetContent GetterByLineData ) ;  
    StrSig=$( eval GBLDFileStoreInfo=${StrCacheReference} GBLDAction=GetHeader GetterByLineData ) ;  
    StrSha1Sum=$( eval GBLDFileStoreInfo=${StrCacheReference} GBLDAction=ShaSum1Content GetterByLineData  ) 
    
    ### Counting Number of CSV by reducing the String from them and calculating 
    ### the final-length after reduction. 
    local StrContentStrip=${StrContent//,/} ; 
    local IntContentStrip=$(( ${#StrContent} - ${#StrContentStrip} )) ; 
    
    if [ "${StrSig}" != "${StrSha1Sum}" ] ; then 
     BoolRejectSigErr=True ; 
    else
     StrASeg=$( echo ${StrContent} | sed 's/$/,/g ; s/[,]\{1,\}$/,/g' ; ) ;
     for(( IntA=0 ; IntA <= ${IntContentStrip}-1 ; IntA++ )) ; do 
      IntCountCall=$((${IntCountCall}+1)) ; 
      StrBSeg=${StrASeg/%,[^,]*} ; 
      ArrayMsg[3]
      echo -ne "Status StrASeg: [${StrASeg}]\nPart Extracted:\n\tStrBSeg: [${StrBSeg}]\n" ; 
      StrASeg=${StrASeg/#${StrBSeg},} ; 
      ArrayMsg[4]
      echo -ne "Status StrASeg:\n\tAfter cleaning, [${StrASeg}]\n" ; 
      
      local -a ArrayVarCreation ;
      ### Format of each Serialized chunk is made from :
      ### 0 addr : Variable name 
      ### 1 addr : codec type (base64/text) 
      ### 2 addr : Value. 
      ### And should clean odd-csv
      StrCSeg=$( echo ${StrBSeg} | sed 's/$,\{1,\}//g' )  ; 
      #StrCSeg=${StrBSeg} ; 
      ### Ensure the algorithm of match-substitution by alterning prefix/suffix
      ### have a separator at the end. 
      StrCSeg=$( echo ${StrCSeg} | sed 's/$/:/g ; s/[:]\{1,\}$/:/g' ) ;
      for(( IntB=0 ; IntB <= 2 ; IntB++ )) ; do 
       StrDSeg=${StrCSeg/%:[^:]*} ;
       ArrayVarCreation[${IntB}]=$( echo ${StrDSeg} | sed 's/[:]\{1,\}$//g' ) ; 
       StrCSeg=${StrCSeg/#${StrDSeg}:} ; 
      done 
      ### Variable Creation from De-Serialization . 
      ArrayMsg[5]
      echo -ne "\t\tExtracting variable:${ArrayVarCreation[0]}\n"  ; 
      echo -ne "\t\tVariable Codec:${ArrayVarCreation[1]}\n" ; 
      if [ "${ArrayVarCreation[1]}" == "base64" ] ; then 
       StrValue=$( echo ${ArrayVarCreation[2]} | base64 -d ) ; 
       ArrayMsg[6]
       echo -ne "\tBase64 Conversion, Value: [${ArrayVarCreation[2]}] converted in [${StrValue}]\n" ; 
       eval "${ArrayVarCreation[0]}=${StrValue}" ;
      elif [ "${ArrayVarCreation[1]}" == "text" ] ; then 
       ### Require to remove current value of variable:
       unset ${ArrayVarCreation[0]} ; 
       eval "${ArrayVarCreation[0]}=${ArrayVarCreation[2]}" ;
      fi 
      eval "StrEval=\"[ ${ArrayVarCreation[0]} ; \${${ArrayVarCreation[0]}} ]\"" ; 
      ArrayMsg[7]
      __EVAL__ ${StrEval}
      
     done ; 
  
    fi 
   fi 
   
   if [ ${BoolRejectSigErr:=False} == "True" ] ; then 
   
    StrMsg=$( VlcSendCmd --get ArrayMsg[8] ) ;
    VerbMsg="${StrMsg}" VerbHeader=${ADbgHdr["DEBUG"]} VerbState=${BoolDisplayDebug} VerbEvalForm=False  VerbFormated=True VerbDev=/dev/stderr Verbosis
   else
    echo "${StrQueueCmd}" | NSSAddresses=${StrAddr} NSSPort=${StrPort} NetSocketServices  ; 
   fi 

  }  
   
   local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
   local StrNameHelper="${__call_locality[1]}\n\tApplication to send command to a running instance of OldVlcServer\n\tVlcServer and/or SocketServer instance.";
   local StrSummary="\n\tThis application is the main method to send an arbritrary command to a \n\trunning instance of a Fnct.D Socket familly server. It consist of a Unix \n\tapplication wrapped with Registration factory and Prefixed-variable command\n\tto make the life easier to talk to a common instance of VLC-cli interface \n\twrapped in a Unix-named-pipe designed by Fnct.D Socket familly server, and \n\tto answer to it's request.\n" ; 
   local StrSynopsis="\n\tUsed by application like StartSlewAnalysis, VLCSetVolume, __old_vlc_rate,\n \tthis application can act on a playlist of VLC-Media and Video instance of\n\tVLC, as long it was properly configured with one of the Fnct.D Socket \n\tfamilly server. \n\n\tVlcSendCmd work in 2 differents mode:\n\t- stand-alone request with all the parameter :\n\tex: \n\t VSCAddr=127.0.0.1 VSCPort=5083 VSCCmd=\"get_time\" VlcSendCmd ;\n\t - Will query the actual media/song and report the current song.\n\n\t- With UUID registration. \n\t(warning following UUID example is not valid )\n\tex:\n\t UUID=23835b46-260d-11e7-8b1d-001e4c8856d6  VlcSendCmd ;\n\t - This was designed with VlcServicesLayer to send a command to\n\t shutdown the vlc on address 127.0.0.1 port 5083, command is 'shutdown'\n\t and equivalent to :\n\t VSCAddr=127.0.0.1 VSCPort=5083 VSCCmd=\"shutdown\" VlcSendCmd ;\n\n";
   local StrDescription="" ;

   
   ### Section : Switches-Statememt 
   if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    ### GVRIsName set to True is the Variable handled StrNameHelper by GetVarReference and 
    ### provide a Name-Helper inside the live-documentation if we call StartSlewAnalysis --help.
    ### Extending the help by turning other variable to True will increae help. Variable are
    ### declared previously. 
    GVRIsName=True     \
    GVRIsSummary=True  \
    GVRIsSynopsis=True \
    GVRIsDesc=False     \
    GetVarReference ${__call_locality[1]} ; 
    VerbMsg="${StrSwitchMessages}" \
    VerbState=True       \
    VerbEvalForm=False   \
    VerbFormated=False   \
    VerbExtendedOut=True \
    VerbDev=/dev/stderr  \
    Verbosis ;
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ;
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    eval $( __GetVarReferenceList ) ;	
   elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
    eval $( eval ${StrVTVRegistry//,/ } \
            VTVValueEntry=${StrVarList} \
            VTVWhiteListTransfert=UUID  \
            ValueToVariable ) __main_StopServices ; 
   elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
    StrMsg=$( VlcSendCmd --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    eval $( eval ${StrVTVRegistry//,/ } \
            VTVWhiteListTransfert=UUID  \
            VTVValueEntry=${StrVarList} \
            ValueToVariable ) ${StrStartMain} 
   fi 
   ### End-Section : Switches-Statememt 
 }

fi #End-if versionVSC==0.0.1


if [ "${versionSSA:=0.0.0}" == "0.0.1" ] ; then 
 
 eval $( GFCFuncName=StartSlewAnalysis GlobalFunctionCleaning ) ; 
 
 function StartSlewAnalysis()
 {

   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( SSA StartSlewAnalysis ) ;
   local Arg0=${ArrayArg[0]} ;   
   local IntSleep=$( VSCCmd="get_length" VSCAddr=127.0.0.1 VSCPort=5083  VlcSendCmd | sed -r 's/[^0-9]*//g'  ) ; 
   local StrDate; 
   local IntStartTimer;
   local IntStopTimer;
   local IntTTimer ; 
   local IntSleepCalc ; 
   while [ 1 ] ; do 
    ### GODFormat="%Y%m%d %H:%M:%S" GODShowEvalCmd=False GODShowParsing=False GODShowVersion=False GODVerbose=False GetOtherDate
    IntStartTimer=${SECONDS} ; 
    StrDate=$( /bin/date +"%Y%m%d %H:%M:%S" ) ; 
    echo -ne "date:${StrDate}\nSong of ${IntSleep} sec(s)\n" ; 
    VSCCmd="seek 0" VSCAddr=127.0.0.1 VSCPort=5083 VlcSendCmd 2>&1> /dev/null  ; 
    IntStopTimer=${SECONDS};
    IntTTimer=$(( ${IntStopTimer} - ${IntStartTimer} )) ;
    IntSleepCalc=$(( ${IntSleep}-${IntTTimer} )) ; 
    echo -ne "Application latency of ${IntTTimer} sec(s), compensing sleep of ${IntSleepCalc} sec(s) \n" ; 
    sleep ${IntSleepCalc} ;
    ### This slew rate-second interleave can not be introduced to 
    ### to sleep, first it's random ( as long you're not leaving the application __old_vlc_rate )
    ### open for all the posibility used for a song of N-seconds and N-possibility to shift
    ### reducing the Prefixed-variable of random-time duration can possibly give an exact
    ### slew-rate. Calling FIR ( Finite Impulse Response ) , a FIR method 
    ### constantly reduce the remainder based on actual summation of the result. 
    ### But basically it should not help in this case. 
    
    ### Uses of IntStartCmd, IntStopCmd, IntTTime
    ### to get the time lost querying the services 
    ### or the latency after sleeping , This information
    ### is important and more we can estimate when the 
    ### application sucessfully taked the command get_time
    ### and calculating the the nearest point to know 
    ### what slew-rate can cause. Estimating the application
    ### can't get information instantly It suppose the latency
    ### of the application should be substracted from IntCurrent
    ### to pretend knowing by-seconds the actuall location get
    ### was the same speed N seconds ago... 
    
    local IntStartCmd=${SECONDS} ; 
    local IntCurrent=$( VSCCmd="get_time" VSCAddr=127.0.0.1 VSCPort=5083  VlcSendCmd | sed -r 's/[^0-9]*//g' )  ; 
    local IntStopCmd=${SECONDS} ; 
    local IntTTime=$(( ${IntStopCmd}-${IntStartCmd} )) ;
    
    local IntSeekEnd=$(( ${IntCurrent} - ${IntTTime} )) ; 
    local IntSlewRateSec=$(( ${IntSleep} - ${IntSeekEnd} )) ; 
    echo -ne "TimeDuration : ${IntSleep} sec(s)\nRewind at Position : ${IntSeekEnd} sec(s)\nApps Latency : ${IntTTime} sec(s)\nRandom Rate causing a Decalibation of the end by ${IntSlewRateSec} sec(s) early, for song of ${IntSleep} sec(s)\n" ; 
   done 
 }
fi 

if [ "${versionSSA:=0.0.0}" == "0.0.2" ] ; then 
 
 eval $( GFCFuncName=StartSlewAnalysis GlobalFunctionCleaning ) ; 
 
 function StartSlewAnalysis()
 {
  function Verbosis()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Verb Verbosis ) ; 
   local Arg0=${ArrayArg[0]} ; 
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local IsExtendedOutput=${VerbExtendedOut:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
      if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" ;  
      else
        echo "${StrMsg}" ;  
      fi
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
         echo -ne "${StrMsg}" >> ${StrDevOut} ;
       else
         echo "${StrMsg}" >> ${StrDevOut} ;
       fi
      else
       if [ "${IsExtendedOutput:=False}" == "True" ] ; then 
        echo -ne "${StrMsg}" > ${StrDevOut} ;
       else
        echo "${StrMsg}" > ${StrDevOut} ;
       fi 
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
  
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( SSA StartSlewAnalysis ) ;
   local Arg0="${ArrayArg[0]}" ; 
   local StrParentApps=${__call_locality[1]} ;
   local StrStartMain=${SSAFuncStart:=__main_StartServices} ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=StartSlewAnalysis CAIsAddParent=False __Call_Argument ) ; 
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=StartSlewAnalysis CAIsAddParent=False CallArgument ) ;
  fi 
 
  local StrPathLoopState=${SSALoopFile:=/var/cache/Fnct.D/Loop-SSA-__UUID__} ; 
  local BoolShowEntry=${SSAShowEntry:=False} ; 
  local BoolDisplayDebug=${SSADisplayDebug:=False} ; 
  local BoolShowInstance=${SSAShowInstance:=True} ; 
  local BoolShowVersion=${SSAShowVersion:=True} ; 
  local IntSleepPeriod=${SSAPeriodAnalysis:=2} ; 
  local StrVTVRegistry=${SSAVTVReg:=VTVIsArrayStyleInsert=True,VTVIsValueReAssign=True,VTVIsValueToConvert=False,VTVIsArrayStyleInsert=True,VTVIsQuotedValue=True} ;
  local StrAddr=${SSAServerAddr:=127.0.0.1} ; 
  local StrPort=${SSAServerPort:=5083} ; 
  local StrVarList="StrPathLoopState,BoolShowVersion,BoolShowEntry,BoolDisplayDebug,BoolShowInstance,StrAddr,StrPort,StrParentApps,IntSleepPeriod,StrVTVRegistry,StrVTVRegistry" ;
  
  local -a ArrayMsg ;
  ArrayMsg[0]="Entry in function" ;  
  ArrayMsg[1]="Shutdown Instance ID:__UUID__, file: __FILE__" ;
  ArrayMsg[2]="Instance ID:__UUID__" ;
  ArrayMsg[3]="date:__DATE__\nSong of __DUR__ sec(s)\n\tNumber of period for latency estimation: __PERDIOD__\n\tNb seconds first period: __PER_SLEEP__ sec(s).\n" ; 
  ArrayMsg[4]="Application latency of __TIMER__ sec(s). Should compensate sleep of ( __SLEEP_PERIOD__ period of average of __PERIOD_SLEEP__ sec(s) ) and having a total of __SLEEP_CALC__ sec(s) \n" 
  ArrayMsg[5]="TimeDuration : __DUR__ sec(s)\nTotal Application Sleep: __SLEEP__sec(s)\nApplication Latency : __LATENCY__ sec(s)\nRandom Rate causing a Decalibation of the end by __SLEW_SEC__ sec(s) early/lately.\nSong effectively last: __SONG_LENGTH__ sec(s).\n" ; 
  ArrayMsg[6]="Received a services interruption, stopservices switches was impled or use ServiceControllerHandler was performed." ; 
  ArrayMsg[7]="\nSleep Report : __INT_PSUM__ sec(s).\nPeriod Changed to __INT_PSLEEP__ sec(s).\nSong position at __INT_STP__ sec(s)\nSleep Period Desynchronised by: __INT_DESYNC__ sec(s).\nJitter by __INT_JITTER__ sec(s) from estimated End-point.\nSlew from Jitterisation a song of __INT_SRS__ sec(s) long instead.\nRunning Free __INT__RUN__ sec(s).\nApplication Average Latency: __INT_LATENCY__ sec(s)\nMoment to rewind the song at: __INT_REWND__ sec(s)\n" ; 
  ArrayMsg[8]="cycle __INT_CURR__ of __INT_TOTAL__\nAction: Sleep Period __INT_COST__ sec(s)."
  ArrayMsg[9]="Timer updated\nSleep and application cost: __INT_COST__ sec(s), predicate should en at __INT_SONG_TIME__ sec(s)."


  function VersionApps()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( VA VersionApps ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=VersionApps CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=VersionApps CAIsAddParent=True CallArgument ) ;
   fi     
   StrEvalCmd="""
   StrMsg=\"Application:__FUNCT__ , version:( versionTP:__VER_TP__ versionVTV:__VER_VTV__, versionCA:__VER_CA__, versionBVT:__VER_BVT__)\" ; 
   StrMsg=\${StrMsg//__VER_CA__/\${versionCA}} ;
   StrMsg=\${StrMsg//__VER_TP__/\${versionTP}} ;
   StrMsg=\${StrMsg//__VER_VTV__/\${versionVTV}} ;
   StrMsg=\${StrMsg//__VER_BVT__/\${versionBVT}} ;
   StrMsg=\${StrMsg//__FUNCT__/\${__call_locality[1]}} ;
   VerbMsg=\${StrMsg} VerbHeader=\"VERSION\" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
   """ ; 
   echo -ne "${StrEvalCmd}" ; 
  }

  function FilterVlcSendCmd()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( FVSC FilterVlcSendCmd ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=FilterVlcSendCmd CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=FilterVlcSendCmd CAIsAddParent=True CallArgument ) ;
    ### CallArgument is important to Generate SSAFuncStart=${StrStartMain} to 
    ### be launched with Bottom-if-statement of --startservices .
   fi 
   StrMsg=$( StartSlewAnalysis --get ArrayMsg[0] ) ;
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolShowEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   local StrFilterType=${FVSCTypeFilter:=Int}  ; 
   local StrServAddr=${FVSCAddr:=127.0.0.1} ; 
   local StrServPort=${FVSCPort:=5083} ;
   local StrServCmd=${FVSCCmd:=get_length} ; 
   ### An associative Array working with index ( ${!Array[@]}, for all key and ${Array[IndexName]} -> value  ) ; 
   local -A ArrayTypeFilter ; 
   local StrSedCmd ;
   ### Since VlcSendCmd does display lot or garbage around information like send a "volume" command will display sometimes '>' char and couple of '>>', so to 
   ### determine what we should receive like command with volume will output at least number, using a sed 's/[^0-9]//g' should remove everything except number.
   ### for String it's somewhat problematic, excessive '<' or '>' from output as to be inserted with precise Char-range. 
   
   ArrayTypeFilter["Int"]="[^0-9]*" ; 
   ArrayTypeFilter["String"]="[^A-Za-z\ \-\_\)\(]*" ; 
   StrSedCmd="/bin/sed -r 's/${ArrayTypeFilter[${StrFilterType}]}//g'" ;
   
   VSCCmd=${StrServCmd} VSCAddr=${StrServAddr} VSCPort=${StrServPort} VlcSendCmd | eval ${StrSedCmd} ; 
   ### To test is the application FilterVlcSendCmd can filter with the integer filter a request such get_length
   ### you can call it from the command-shell by passing to StartSlewAnalysis the FilterVlcSendCmd as SSAFuncStart:
   ###
   ### FVSCTypeFilter=Int FVSCAddr=127.0.0.1 FVSCPort=5083 FVSCCmd=get_length  SSAFuncStart=FilterVlcSendCmd  StartSlewAnalysis 
   ### 
  }      

  function __main_StopServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StopServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True CallArgument ) ;
   fi 
   StrMsg=$( StartSlewAnalysis --get ArrayMsg[0] )
   
   VerbMsg="${StrMsg}"        \
   VerbHeader="${__call_locality[1]}-ENTRY" \
   VerbState=${BoolShowEntry} \
   VerbEvalForm=False         \
   VerbFormated=True          \
   VerbDev=/dev/stderr        \
   Verbosis ;
   
   ### Stop services, based on creation of a file named in '${StrPathLoopState}'  and
   ### resposible to loop inside __main_StartServices unless the file exist. 
   ###
   ### Example to shutdown a current session:
   ### UUID=9589a8be-b766-11e6-8b1d-001e4c8856d6  StartSlewAnalysis --stopservices 
   ### will erase the file inside /var/cache/Fnct.D/Loop-SSA-9589a8be-b766-11e6-8b1d-001e4c8856d6
   ### be sure you are launched it from same user permission. 
   ###
   local StrUUID=${UUID} ;
   if [ "${StrUUID:=None}" == "None" ] ; then 
    StrUUID=${StrUUIDInstance} ; 
   fi # End-IF ("${StrUUID:=None}" == "None")
   local StrPathLoopState=${StrPathLoopState//__UUID__/${StrUUID}} ; 
   
   StrMsg=$( StartSlewAnalysis --get ArrayMsg[1] ) ;
   StrMsg=${StrMsg//__UUID__/${StrUUID}} ; 
   StrMsg=${StrMsg//__FILE__/${StrPathLoopState}} ; 
   
   VerbMsg=${StrMsg}   \
   VerbHeader=DEBUG    \
   VerbState=True      \
   VerbEvalForm=False  \
   VerbFormated=True   \
   VerbDev=/dev/stderr \
   Verbosis ;
   
   if [ -f ${StrPathLoopState} ] ; then 
    rm -f ${StrPathLoopState} ; 
    StrMsg=$( StartSlewAnalysis --get ArrayMsg[6] ) ;
    VerbMsg="${StrMsg}"    \
    VerbHeader=SESSION-END \
    VerbState=True         \
    VerbEvalForm=False     \
    VerbFormated=True      \
    VerbDev=/dev/stderr  Verbosis ;
    
   fi ; # End-IF ( -f ${StrPathLoopState} )
      
  }

  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ;
   fi 
   local StrMsg=$( StartSlewAnalysis --get ArrayMsg[0] ) ;
   local -A ADbgHdr ; 
   ADbgHdr["ENTRY"]="${__call_locality[1]}-ENTRY" ;
   ADbgHdr["DEBUG"]="${__call_locality[1]}-DEBUG";
   ADbgHdr["INFO"]="${__call_locality[1]}-INFO" ;
   
   local IntSongLength ; 
   local IntAvgTTimer=0 ; 
   local IntSumTTimer=0 ; 
   local IntCountAppsTimed=0 ; 
   local IntTTimer=0 ; 
   local IntStartTimer=0 ;
   local IntStopTimer=0 ;
   local IntSongJitter=0 ;
   local IntLastJitter=0 ; 
   local IntSongMiss=0 ; 
   local StrDate; 
   local IntSleepCalc ; 
   local StrMsg ;
   local IntPeriodSleep ; 
   local IntOverflowPeriod ;
   local IntUnderflowPeriod ; 
   local IntPredictSleep ;  
   local IntAppsSleepTimerRef ;
   local IntAppsSleepTimerRes ;
   local IntTimeCost ; 
   local IntPeriodSum ;
   local IntSongTime ; 
   local IntSongLoc ; 
   local IntSongDiff ;
   local IntStartCmd ; 
   local IntStopCmd ; 
   local IntRunLengthCorr ; 
   
   VerbMsg="${StrMsg}"    \
   VerbHeader=${ADbgHdr["ENTRY"]} \
   VerbState=${BoolShowEntry} \
   VerbEvalForm=False     \
   VerbFormated=True      \
   VerbDev=/dev/stderr    \
   Verbosis ;

   ### Loop Registration:
   ### Create a UUID Instance and store-it with a touch command . 
   ### - This is controlled with the while and will end if the 
   ### file is erased by calling __main_StopServices with the UUID Instance. 
   local StrUUID=$( GetUAppsRegisterName=${StrParentApps} \
                    GetUTimeBased=True \
                    GetULoop=False \
                    GetUUID ) ; 
   local BoolStopProcess=False ; 
   
   StrPathLoopState=${StrPathLoopState//__UUID__/${StrUUID}}
   StrMsg=$( StartSlewAnalysis --get ArrayMsg[2] ) ;
   StrMsg=${StrMsg//__UUID__/${StrUUID}} ; 
   
   VerbMsg="${StrMsg}"  \
   VerbHeader=${ADbgHdr["DEBUG"]}  \
   VerbState=${BoolShowInstance} \
   VerbEvalForm=False   \
   VerbFormated=True    \
   VerbDev=/dev/stderr  \
   Verbosis ;
   local -a ArrayMsgTpl  ;
   
   ### This tiny array avoid re-calling the StartSlewAnalysis many time
   ### inside the main loop and slowing the application . 
   ArrayMsgTpl[0]=$( StartSlewAnalysis --get ArrayMsg[3] ) ; 
   ArrayMsgTpl[1]=$( StartSlewAnalysis --get ArrayMsg[4] ) ; 
   ArrayMsgTpl[2]=$( StartSlewAnalysis --get ArrayMsg[5] ) ; 
   ArrayMsgTpl[3]=$( StartSlewAnalysis --get ArrayMsg[7] ) ; 
   ArrayMsgTpl[4]=$( StartSlewAnalysis --get ArrayMsg[8] ) ;
   ArrayMsgTpl[5]=$( StartSlewAnalysis --get ArrayMsg[9] ) ;
  
   /bin/touch ${StrPathLoopState} ; 

   if [ ! -f ${StrPathLoopState} ] ; then 
     BoolStopProcess=True ;
   else
    ### Timer for Application    
    IntStartTimer=${SECONDS} ; 
    ###
    ### Query the length of the song.
    ###
    local IntSleep=$( \
     FVSCTypeFilter=Int   \
     FVSCCmd="get_length" \
     FVSCAddr=${StrAddr}  \
     FVSCPort=${StrPort}  \
     FilterVlcSendCmd     ) ; 
     ### Timer for Application    
     IntStopTimer=${SECONDS};
     IntTTimer=$(( ${IntStopTimer} - ${IntStartTimer} )) ;
     IntSumTTimer=$(( ${IntSumTTimer} + ${IntTTime} )) ; 
     ### Updating Average latency by application by increasing by one IntCountAppsTimed 
     ### (one more apps calculed ), updating the IntAvgTTimer. 
     IntCountAppsTimed=$(( ${IntCountAppsTimed} + 1 )) ; 
     IntAvgTTimer=$(( ${IntSumTTimer} / ${IntCountAppsTimed} )) ; 
   fi 
  
   
   ### 
   VerbMsg="BoolStopProcess status: ${BoolStopProcess}" \
   VerbHeader=${ADbgHdr["DEBUG"]}  \
   VerbState=${BoolDisplayDebug} \
   VerbEvalForm=False  \
   VerbFormated=True   \
   VerbDev=/dev/stderr \
   Verbosis ;
   while [ "${BoolStopProcess:=False}" != "True"  ] ; do 
   
    ### Reset some indicator.
    ### IntSumTTimer is not resetted because it's a continuous 
    ### application latency time-compensation that is combined with 
    ### a Speed-adjustment of a current song that to change it's end
    ### position. Having a more precise information for application
    ### latency reduce imprecision for variable-speed adjustement. 
    IntSlewRateSec=0 ; 
    
    IntAvgTTimer=$(( ${IntSumTTimer} / ${IntCountAppsTimed} )) ; 
    IntSleepCalc=$(( ${IntSleep} )) ; 

    ### 
    ### PeriodSleep    
    ### Must represent 
    ### the total elapsed time including Sleep period and application latency to 
    ### represent the closest as possible the length of the song. 
    #IntPeriodSleep=$(( ( ${IntSleep} / ${IntSleepPeriod} ) - ( ${IntAvgTTimer} * ( ${IntSleepPeriod} - 1 ) ) )) ; 
    IntPeriodSleep=$(( ( ${IntSleep} - ( ${IntAvgTTimer} * ( ${IntSleepPeriod} - 1 ) ) ) / ${IntSleepPeriod} )) ; 
    IntOverflowPeriod=$(( ${IntPeriodSleep} + ( ${IntPeriodSleep} / ${IntSleepPeriod} ) )) ; 
    IntUnderflowPeriod=$(( ${IntPeriodSleep} - ( ${IntPeriodSleep} / ${IntSleepPeriod} ) )) ; 
    


   
    if [ ! -f ${StrPathLoopState} ] ; then 
     BoolStopProcess=True ;
    else
     ### Timer for Application    
     IntStartTimer=${SECONDS} ; 
     StrMsg="Action: Seek Information\n\tBoolStopProcess status: __BOOL__" ; 
     StrMsg=${StrMsg//__BOOL__/${BoolStopProcess}} ; 
     
     VerbMsg=${StrMsg}   \
     VerbHeader=${ADbgHdr["DEBUG"]} \
     VerbState=${BoolDisplayDebug}  \
     VerbEvalForm=False  \
     VerbFormated=True   \
     VerbDev=/dev/stderr \
     Verbosis ;
     StrDate=$( /bin/date +"%Y%m%d %H:%M:%S,\nSHELL-SECONDS REF:${SECONDS} sec(s),\nUNIX TimeStamp:%s" ) ; 
     StrMsg=${ArrayMsgTpl[0]} ; 
     StrMsg=${StrMsg//__DATE__/${StrDate}} ; 
     StrMsg=${StrMsg//__DUR__/${IntSleep}} ; 
     StrMsg=${StrMsg//__PERDIOD__/${IntSleepPeriod}} ; 
     StrMsg=${StrMsg//__PER_SLEEP__/${IntPeriodSleep}} ; 
     
     VerbMsg="${StrMsg}"  \
     VerbHeader=${ADbgHdr["DEBUG"]} \
     VerbState=${BoolDisplayDebug}  \
     VerbEvalForm=False   \
     VerbFormated=True    \
     VerbDev=/dev/stderr 
     Verbosis ;
     
     ###Don't really need to replace this command by FilterVlcSendCmd, it
     ### gather the content in the /dev/null, so no filtering required. 
     VSCCmd="seek 0" VSCAddr=127.0.0.1 VSCPort=5083 VlcSendCmd 2>&1> /dev/null  ; 
     ### Application Latency
     ### Timer for Application    
     IntStopTimer=${SECONDS};
     IntTTimer=$(( ${IntStopTimer} - ${IntStartTimer} )) ;
     IntSumTTimer=$(( ${IntSumTTimer} + ${IntTTime} )) ; 
     ### Updating Average latency by application by increasing by one IntCountAppsTimed 
     ### (one more apps calculed ), updating the IntAvgTTimer. 
     IntCountAppsTimed=$(( ${IntCountAppsTimed} + 1 )) ; 
     IntAvgTTimer=$(( ${IntSumTTimer} / ${IntCountAppsTimed} )) ; 

   fi # End-IF (! -f ${StrPathLoopState})
    
    StrMsg=${ArrayMsgTpl[1]} ; 
    StrMsg=${StrMsg//__TIMER__/${IntTTimer}} ; 
    StrMsg=${StrMsg//__SLEEP_PERIOD__/${IntSleepPeriod}} ;
    StrMsg=${StrMsg//__PERIOD_SLEEP__/${IntPeriodSleep} } ;
    StrMsg=${StrMsg//__SLEEP_CALC__/${IntSleepCalc}} ;
    
    ### Message information for application latency and sleep information
    VerbMsg="${StrMsg}"            \
    VerbHeader=${ADbgHdr["DEBUG"]} \
    VerbState=${BoolDisplayDebug}  \
    VerbEvalForm=False   \
    VerbFormated=True    \
    VerbDev=/dev/stderr  \
    Verbosis ;
    
    IntSeekEnd=${IntSleep} ; 
    ### Sleep time will depend of this IntTimeCost to compute the 
    ### period expressed in 1-real first-interleave, 2,recurrent-adapted period to sleep. 
    IntTimeCost=${IntPeriodSleep} ; 
    IntCumulSongTime=0 ; 
    IntPeriodSum=0 ;
    
    for (( intSleepSeq=0 ; intSleepSeq <= ${IntSleepPeriod}-1 ; intSleepSeq++ )) ; do 
    
     ### IntSongTime should predict in ${SECONDS} + PERIOD-SLEEP - 
     ### AverageAppsLatency where it should end sleeping. IntTimeCost does 
     ### substract AverageAppsLatency, so it should be added ; Since It 
     ### schedule to sleep and perform a get_time on the song and do have to 
     ### last as it was specified inside TimeCost calculation. 
     
     IntSongTime=$(( ${SECONDS} + ${IntTimeCost}  )) ; 
     
     ### Cumulate Sleep by loop and report the overall Sleep duration. 
     IntPeriodSum=$(( ${IntPeriodSum} + ${IntTimeCost} + ${IntAvgTTimer} )) ; 
     
     IntAppsSleepTimerRef=${SECONDS} ; 
     if [ ! -f ${StrPathLoopState} ] ; then 
       BoolStopProcess=True ;
     else
      StrMsg=${ArrayMsgTpl[4]} ; 
      StrMsg=${StrMsg//__INT_CURR__/${intSleepSeq}} ; 
      StrMsg=${StrMsg//__INT_TOTAL__/$(( ${IntSleepPeriod}-1 ))} ; 
      StrMsg=${StrMsg//__INT_COST__/${IntTimeCost}} ; 

      VerbMsg=${StrMsg} \
      VerbHeader=${ADbgHdr["DEBUG"]} \
      VerbState=${BoolDisplayDebug}  \
      VerbEvalForm=False  \
      VerbFormated=True   \
      VerbDev=/dev/stderr \
      Verbosis ;
      if [ ${IntTimeCost} -gt 0 ] ; then  
       /bin/sleep ${IntTimeCost} ;
      fi ; # End-IF (${IntTimeCost} -gt 0)
      ### New location of song .
      ### After next command to query the song
      ### time-left we should fall on ${SECONDS}+${IntAvgTTimer} . 
      IntSongLoc=${SECONDS}; 
      
      #IntCumulSongTime=$(( ${IntCumulSongTime} + ${IntTimeCost} )) ; 
     fi ; # End-IF (! -f ${StrPathLoopState})  
     
     if [ ! -f ${StrPathLoopState} ] ; then 
      BoolStopProcess=True ;
     else
      ### Timer for Application    
      VerbMsg="Sleep end after shell-second ${IntSongLoc}\nAction: Updating Timer" \
      VerbHeader=${ADbgHdr["DEBUG"]} \
      VerbState=${BoolDisplayDebug} \
      VerbEvalForm=False \
      VerbFormated=True \
      VerbDev=/dev/stderr \
      Verbosis ;
      IntStartTimer=${SECONDS} ; 
      IntSongLength=$( \
          FVSCTypeFilter=Int   \
          FVSCCmd="get_time"   \
          FVSCAddr=${StrAddr}  \
          FVSCPort=${StrPort}  \
          FilterVlcSendCmd     ) ; 
      ### Timer for Application    
      IntStopTimer=${SECONDS};
      IntTTimer=$(( ${IntStopTimer} - ${IntStartTimer} )) ;
      ### Getting Time from moment it start the read:
      IntSumTTimer=$(( ${IntSumTTimer} + ${IntTTime} )) ; 
      
      ### Updating Average latency by application by increasing by one IntCountAppsTimed 
      ### (one more apps calculed ), updating the IntAvgTTimer. 
      IntCountAppsTimed=$(( ${IntCountAppsTimed} + 1 )) ; 
      IntAvgTTimer=$(( ${IntSumTTimer} / ${IntCountAppsTimed} )) ; 
      IntAppsSleepTimerRes=$(( ${IntSongTime} - ${IntAppsSleepTimerRef} )) ; 

      VerbMsg="Last timer take ${IntTTimer} sec(s) to query get_time information." \
      VerbHeader=${ADbgHdr["DEBUG"]} \
      VerbState=${BoolDisplayDebug}  \
      VerbEvalForm=False  \
      VerbFormated=True   \
      VerbDev=/dev/stderr \
      Verbosis ;
      IntSongLength=$(( ${IntSongLength} + ${IntAvgTTimer} )) ; 

      
      StrMsg=${ArrayMsgTpl[5]} ; 
      StrMsg=${StrMsg//__INT_COST__/${IntTimeCost}} ; 
      StrMsg=${StrMsg//__INT_SONG_TIME__/${IntAppsSleepTimerRes}} ; 
      
      VerbMsg=${StrMsg} \
      VerbHeader=${ADbgHdr["INFO"]} \
      VerbState=${BoolDisplayDebug}  \
      VerbEvalForm=False  \
      VerbFormated=True   \
      VerbDev=/dev/stderr \
      Verbosis ;
      
      ### Definition of where the application should be launched if
      ### it have to rewind the song to pos-0 including the 
      ### application latency to not excess the song-duration or it
      ### if your song is inside a playlist you can jump to next
      ### song and starts statistic over something else. 
      IntSeekEnd=$(( ${IntSleep} - ${IntAvgTTimer} )) ; 
      
      ### Now Estimating the decay 
      ### By comparing the Estimated IntSongTime end reported
      ### in Bash-Seconds since the terminal is open to real 
      ### IntSongLength from IntSongLoc Where both where calibrated
      ### to almost-instant moment where a get_time occurs and 
      ### it's last sleep time. 
       
      IntSongMiss=$(( ( ${IntSongLength} - ${IntPeriodSum} ) )) ; 
      IntLastJitter=${IntSongJitter} ; 
      IntSongJitter=$(( ( ${IntSongLoc} - ${IntSongTime} ) + ${IntSongMiss} )) ;
      
      if [ ${IntLastJitter:=0} -gt 0 ] ; then 
       if [ ${IntSongJitter} -gt  ${IntLastJitter} ] ; then 
        IntSlewRateSec=$(( ( ${IntSlewRateSec} + ( ( ${IntSongJitter} - ${IntLastJitter} ) + ${IntSlewRateSec} ) ) / 2  )) ;
       fi 
      fi
      
      ### END-OF-Analysis part:
      
      ### Require to re-apply some important verification after having 
      ### IntAvgTTimer being changed to re-estimate PeriodSleep, 
      ### temporary OverflowPeriod and UnderflowPeriod limits.
      
      IntPeriodSleep=$(( ( ${IntSleep} - ( ${IntAvgTTimer} * ( ${IntSleepPeriod} - 1 ) ) ) / ${IntSleepPeriod} )) ; 
      IntOverflowPeriod=$(( ${IntPeriodSleep} + ( ${IntPeriodSleep} / ${IntSleepPeriod} ) )) ; 
      IntUnderflowPeriod=$(( ${IntPeriodSleep} - ( ${IntPeriodSleep} / ${IntSleepPeriod} ) )) ; 

      ### IntRunLengthCorr
      ### - What remain free to schedule sleep or launching something else. 
      ### Assumming this process is inside a constant loop, constant 
      ### application launched will cost IntSleepPeriod-1 times the timer-update
      ### to compare with running instance of this song. And do depend of 
      ### IntSeekEnd that do have reserved few seconds to rewind the song.
      ### Called RunningLength Correction, it's the period that require to 
      ### test against bigger sleep changes from IntTimeCost. 
      
      IntRunLengthCorr=$(( ( ${IntSleep} - ${IntSongLength} ) - ( ( ( ${IntSleepPeriod}-1 ) - (${intSleepSeq}+1) ) * ${IntAvgTTimer} ) )) ; 
      
      if [ ${IntSongJitter} -gt 0 ] ; then 
       VerbMsg="IntTimeCost based on Jitter higher than 0 to ${IntSongJitter} sec(s)" VerbHeader=${ADbgHdr["DEBUG"]} VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr Verbosis ;
       IntTimeCost=$(( ( ${IntPeriodSleep} - ${IntAvgTTimer} ) + ( ${IntSlewRateSec} / ${IntSleepPeriod} )  )) ;        
      elif [ ${IntSongJitter} -lt 0 ] ; then 
       VerbMsg="IntTimeCost based on Jitter lower than 0 to ${IntSongJitter} sec(s)" VerbHeader=${ADbgHdr["DEBUG"]} VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr Verbosis ;
       IntTimeCost=$(( $( ${IntPeriodSleep} - ${IntAvgTTimer} ) - ( ${IntSlewRateSec} / ${IntSleepPeriod} ) )) ;        
      else
       VerbMsg="IntTimeCost based on Jitter relatively null." VerbHeader=${ADbgHdr["DEBUG"]} VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr Verbosis ;
       IntTimeCost=$(( ${IntPeriodSleep} - ${IntAvgTTimer} )) ;        
      fi 
      
      IntPredictSleep=$(( ${IntPeriodSum} + ${IntTimeCost} + ${IntAvgTTimer}  )) ; 

       #if [ ${IntTimeCost} -gt ${IntOverflowPeriod} ] ; then 
       
       #fi 
      if [ ${intSleepSeq} -lt $(( ${IntSleepPeriod}-1 )) ] ; then 
       if [ ${IntTimeCost} -gt ${IntOverflowPeriod} ] ; then 
        VerbMsg="IntTimeCost is being Overestimated inside a normal condition, take default setting to ${IntOverflowPeriod}." VerbHeader=${ADbgHdr["DEBUG"]} VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr Verbosis ;
        IntTimeCost=${IntOverflowPeriod} ;
       elif [ ${IntTimeCost} -lt ${IntUnderflowPeriod} ] ; then 
        VerbMsg="IntTimeCost is being Underestimated inside a normal condition, take default setting to ${IntUnderflowPeriod}." VerbHeader=${ADbgHdr["DEBUG"]} VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr Verbosis ;
        IntTimeCost=${IntUnderflowPeriod} ;
       fi
      elif [ ${intSleepSeq} -eq $(( ${IntSleepPeriod}-1 )) ] ; then
       if [ ${IntPredictSleep} -gt ${IntRunLengthCorr}  ] ; then 
        VerbMsg="Predicate Sleep (total of ${IntPredictSleep} sec(s)) is higher than Running free song." VerbHeader=${ADbgHdr["DEBUG"]} VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr Verbosis ;
        IntTimeCost=$(( ${IntRunLengthCorr} - ${IntAvgTTimer} )) ;
       fi 
       if [ ${IntTimeCost} -gt ${IntRunLengthCorr} ] ; then 
        VerbMsg="IntTimeCost ( next sleep + apps latency : ${IntTimeCost} sec(s)) is higher than Running free song." VerbHeader=${ADbgHdr["DEBUG"]} VerbState=${BoolDisplayDebug} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr Verbosis ;
        IntTimeCost=$(( ${IntRunLengthCorr} - ${IntAvgTTimer} )) ;
       fi 
      fi 
      
      if [ ${intSleepSeq} -lt $(( ${IntSleepPeriod}-1 )) ] ; then 
       StrMsg=${ArrayMsgTpl[3]} ; 
       StrMsg=${StrMsg//__INT_PSUM__/${IntPeriodSum}} ; 
       StrMsg=${StrMsg//__INT_PSLEEP__/${IntTimeCost}} ; 
       StrMsg=${StrMsg//__INT_STP__/${IntSongLength}} ; 
       StrMsg=${StrMsg//__INT_JITTER__/${IntSlewRateSec}} ; 
       StrMsg=${StrMsg//__INT_DESYNC__/${IntSongMiss}} ; 
       StrMsg=${StrMsg//__INT_SRS__/$(( ${IntSleep} - ${IntSlewRateSec} )) } ; 
       StrMsg=${StrMsg//__INT__RUN__/${IntRunLengthCorr}} ; 
       StrMsg=${StrMsg//__INT_LATENCY__/${IntAvgTTimer}} ; 
       StrMsg=${StrMsg//__INT_REWND__/${IntSeekEnd}} ; 

       VerbMsg=${StrMsg} \
       VerbHeader=${ADbgHdr["INFO"]} \
       VerbState=${BoolDisplayDebug} \
       VerbEvalForm=False  \
       VerbFormated=True   \
       VerbDev=/dev/stderr \
       Verbosis ;
      fi ; # End-IF ( ${intSleepSeq} -gt $(( ${IntSleepPeriod}-1 )) )
      
     fi ; # End-IF ( ! -f ${StrPathLoopState} ) 
    done 
    
    ### Cumulate Sleep by loop and report the overall Sleep duration. 
    #IntPeriodSum=$(( ${IntPeriodSum} + ${IntTimeCost} + ${IntAvgTTimer} )) ; 

    if [ ! -f ${StrPathLoopState} ] ; then 
     BoolStopProcess=True ;
    else
     StrMsg=${ArrayMsgTpl[2]} ;
     StrMsg=${StrMsg//__DUR__/${IntSleep}} ;  
     StrMsg=${StrMsg//__SLEEP__/${IntPeriodSum}} ;  
     StrMsg=${StrMsg//__LATENCY__/${IntAvgTTimer}} ;  
     StrMsg=${StrMsg//__SLEW_SEC__/${IntSlewRateSec}} ;  
     StrMsg=${StrMsg//__SONG_LENGTH__/$(( ( ${IntSleep} - ${IntSlewRateSec} ) ))} ;  
     
     VerbMsg="${StrMsg}"           \
     VerbHeader=${ADbgHdr["INFO"]} \
     VerbState=${BoolDisplayDebug} \
     VerbEvalForm=False  \
     VerbFormated=True   \
     VerbDev=/dev/stderr \
     Verbosis ;
    fi ; # End-IF ( ! -f ${StrPathLoopState} ) 
   
   done   
  
  }  
   
   local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
   local StrNameHelper="${__call_locality[1]}\t\tApplication to verify and use Network services of VLCServer/OldVLCServer.";
   local StrSummary="" ; 
   local StrSynopsis="";
   local StrDescription="" ;
   
   ### Section : Switches-Statememt 
   if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    ### GVRIsName set to True is the Variable handled StrNameHelper by GetVarReference and 
    ### provide a Name-Helper inside the live-documentation if we call StartSlewAnalysis --help.
    ### Extending the help by turning other variable to True will increae help. Variable are
    ### declared previously. 
    GVRIsName=True     \
    GVRIsSummary=False  \
    GVRIsSynopsis=False \
    GVRIsDesc=False     \
    GetVarReference ${__call_locality[1]} ; 
    VerbMsg="${StrSwitchMessages}" \
    VerbState=True       \
    VerbEvalForm=False   \
    VerbFormated=False   \
    VerbExtendedOut=True \
    VerbDev=/dev/stderr  \
    Verbosis ;
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ;
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    eval $( __GetVarReferenceList ) ;	
   elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
    eval $( eval ${StrVTVRegistry//,/ } \
            VTVValueEntry=${StrVarList} \
            VTVWhiteListTransfert=UUID  \
            ValueToVariable ) __main_StopServices ; 
   elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
    if [ "${BoolShowVersion:=False}" == "True" ] ; then 
     eval $( eval VersionApps ) ; 
    fi 
    StrMsg=$( StartSlewAnalysis --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    ### This is the main-boot strap and should load __main_StartServices unless 
    ### It receive from prompt a Prefixed-Variable SSAFuncStart=Function. Every
    ### application made from CallArgument does have it's entry in form [SHORT-NAME]Func=${StrStartMain} ;
    eval $( eval ${StrVTVRegistry//,/ } \
            VTVValueEntry=${StrVarList} \
            ValueToVariable ) ${StrStartMain} 
   fi 
   ### End-Section : Switches-Statememt 
 }

fi ; # End-IF ("${versionSSA:=0.0.0}" == "0.0.2")

### This is also a not Friendly version of VLC-RATE example use to compare
### simple but not easy to handle version. 
### 
unset __old_vlc_rate ; 
function __old_vlc_rate()    
{
  ### Shortcut, primitive to make easier uses of 
  ### NetworkClientConnection.awk as NC replacement.
  ### 
  ### Definition : NccRe, stand for 
  ### Network Client Connection Receipt Required
  ### 
  function NccRe()
  { 
    gawk -vNCCCmd="${*}"                 \
     -vNCCVerbose=false                  \
     -vNSSTimeOut=${NRTimeOut:=2500}     \
     -vNSSPort=${NRPort:=5083}           \
     -vNCCIsReturn=true                  \
     -vNSSAddresses=${NRAddr:=127.0.0.1} \
     -f ${NRConnectionScript:=/etc/init.d/Fnct.D/awk-script/NetworkClientConnection.awk} ; 
  }

  ### Shortcut, primitive to make easier uses of 
  ### NetworkClientConnection.awk as NC replacement.
  ### 
  ### Definition : NccNr, stand for 
  ### Network Client Connection No Receipt Required
  ### 
  ### 
  function NccNr()
  { 
    gawk -vNCCCmd="${*}"                 \
    -vNCCVerbose=false                   \
    -vNSSTimeOut=${NNTimeOut:=3000}      \
    -vNSSPort=${NNPort:=5083}            \
    -vNCCIsReturn=false                  \
    -vNSSAddresses=${NNAddr:=127.0.0.1}  \
    -f ${NNConnectionScript:=/etc/init.d/Fnct.D/awk-script/NetworkClientConnection.awk} ; 
  }  
  
 local ArrayRateLevel=( ); 
 ### determining the range of random rate. 
 ### VLCCHUNKRATE -> Number of Possible Rate Level inside ArrayRateLevel
 ### And it is not fixed, the application should remain Random-Result returned 
 ### It short, it should sound-like old turn-table having 15-12 or 33 turn and 
 ### should had problem to keep-it constant... Also another suggested reason to
 ### produce this effect, to keep human listening and  having problem to guess
 ### instantly the couple note inside a music... Even by singing in a karaoke
 ### we should ear more the person rather than the voice of the singer.
 
 local BoolFixedCR=${VLCFIXEDCHUNKRATE:=False} ; 
 
 local IntRandRange ; 
 
 if [ "${BoolFixedCR:=False}" == "True" ] ; then 
  IntRandRange=${VLCCHUNKRATE:=30} ; 
 else
  IntRandRange=$(( ( ${RANDOM} % ${VLCCHUNKRATE:=30} ) + 1  )) ; 
 fi 
 
 local IntRateInsert=0 ; 
 local IntRateGet=0 ;
 local StrRandomFormat="" ; 
 local IntSleep=0 ; 
 local IntNccTimeOut=${VLCNCCNCTIMEOUT:=3000} ; 
 local StrAppsClac=${VLCCalculator:=/usr/bin/bc} ; 
 local StrCalculatorCmd=${VLCCalcCmd:=echo \"scale=2 ;__RATE__ / 100\" \| __APPS__} ;
 local StrVLCCmd="${VLCRATECMD:=rate __RATE__}" ; 
 local StrSentCmd="" ;
 local IntHighestRate=${VLCRATEHIGHESTRATE:=100} ;    
 local IntLowestRate=${VLCRATELOWESTRATE:=70};
 local IntSleep=${VLCSleepTime:=5} ; 
 local BoolVerb=${Verbose:=True} ;
 local IntSocketTimeExpr=${VLCSOCKETCLOSESEC:=3} ; 
 local IntMicroTimer=${VLCPRECISETIME:=0.1} ; 
 local BoolNCinSubProcess=${VLCNCINSUBPROCESS:=False} ; 
 local IntDefaulNice=${VLCNICENC:=0} ; 
 local StrAwkEngine=${VLCAWKENGINECONNECTION:=/etc/init.d/Fnct.D/awk-script/NetworkClientConnection.awk} ; 
 local BoolVlcUseAwk=${VLCENGINEISAWK:=False} ; 
 local StrParserCalcCmd ; 
 local IntRateInsert ; 
 local -a ArrayMsg=( )
 local StrDisplayHeader="DEBUG" ; 
 ArrayMsg[0]="Nb Item: __ITEM__ , List or range [ __ARRAY__ ] " ;
 ArrayMsg[1]="Rate Fixed to __RATE__, for __SEC__ seconds" ;
 ArrayMsg[2]="Pushing VLC-Cli command:[ __CMD__ ]"
 ArrayMsg[3]="Highest Rate :[ __INT__ ]"
 ArrayMsg[4]="Lowest Rate :[ __INT__ ]"
 ArrayMsg[5]="Period Duration Max :[ __INT__ ]"
 ArrayMsg[6]="Building  __ITEM__ random item(s) " ;
 ArrayMsg[7]="Waiting for __INT__ sec(s)."
 ArrayMsg[8]="START NEW SETTING" ; 
 ArrayMsg[9]="SLEEP PERIOD: __PERIOD__ sec(s).\n\tEntry at __ENTRY__ sec(s)\n\tTo end at __EXIT__ sec(s)\n\tApplication Calibration require __INT_AVG__ sec(s)." ;
 ArrayMsg[10]="Jitter factor: __INT_JITTER__ sec(s).\n\tLast application cost __INT_LATENCY__ sec(s)\n\tSleep delayed by __INT_AVG__ sec(s).\n" ; 
 ArrayMsg[11]="Lately setting, Late by __INT_JITTER__ sec(s)." 
 ArrayMsg[12]="Early setting In Advance of __INT_JITTER__ sec(s)."
 ArrayMsg[13]="Query Size of Array ArrayRateLevel, get __ITEM__" ; 
 ArrayMsg[14]="Query Random number inside Arrayfr from IntModulo, Item number __MODULO__ will be choosed " ; 
 ArrayMsg[15]="Application using Awk Script NetworkClientConnection.awk as Connection."
 ArrayMsg[16]="Application using VlcSendCmd or NC as Connection Engine."
 ArrayMsg[17]="Awk Script TimeOut adjusted to __INT__ msec." ; 
 
 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE}
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
			echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
		fi
	}
 
 IntNccTimeDrift=${IntNccTimeOut} ; 
 
 StrMsg=${ArrayMsg[16]} ;
 if [ "${BoolVlcUseAwk:=False}" == "True" ] ; then 
  StrMsg=${ArrayMsg[15]} ;
 fi 
 VerbMsg=${StrMsg} VerbHeader=${StrDisplayHeader} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis
 
 StrMsg=${ArrayMsg[3]//__INT__/${IntHighestRate}} ;
 VerbMsg=${StrMsg} VerbHeader=${StrDisplayHeader} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis
 
 StrMsg=${ArrayMsg[4]//__INT__/${IntLowestRate}} ; 
 VerbMsg=${StrMsg} VerbHeader=${StrDisplayHeader} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis
 
 StrMsg=${ArrayMsg[5]//__INT__/${VLCRATEDURATION}} ; 
 VerbMsg=${StrMsg} VerbHeader=${StrDisplayHeader} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis

 StrMsg=${ArrayMsg[6]//__ITEM__/${IntRandRange}} ; 
 VerbMsg=${StrMsg} VerbHeader=${StrDisplayHeader} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis
 
 StrMsg=${ArrayMsg[7]//__INT__/${IntSleep}} ; 
 VerbMsg=${StrMsg} VerbHeader=${StrDisplayHeader} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis
 /bin/sleep ${IntSleep} ; 
 
 ### Create the random-field olding N-range of Possible Rate.  
 local IntX=0;
 while [ ${IntX} -ne ${IntRandRange} ] ; do 
 ### Retreiving for_loop and adding while to control lowest and highest rate. 
 #for (( IntX=0 ; IntX <= ${IntRandRange} ; IntX++ )) ; do 
  IntRateInsert=$(( ${IntHighestRate} - ( ${RANDOM} %  ${IntRandRange} ) )) ;
  ### A Direct convertion of rate 0-100 to 0.0 to 1.0 is performed. 
  if [ ${IntRateInsert} -ge ${IntLowestRate} -a ${IntRateInsert} -le ${IntHighestRate} ] ; then
   ### First we getting a copy of the Parser-Command for calculation ;
   StrParserCalcCmd=${StrCalculatorCmd} ;
   StrParserCalcCmd=${StrParserCalcCmd//__RATE__/${IntRateInsert}} ;
   StrParserCalcCmd=${StrParserCalcCmd//__APPS__/${StrAppsClac}} ;
   StrRateFmt=$( eval "${StrParserCalcCmd}" ) ; 
   ### Old-Version StrRateFmt=$( echo "scale=2 ;${IntRateInsert} / 100" | ${StrAppsClac} ) ;
   ArrayRateLevel[${#ArrayRateLevel[@]}]="${StrRateFmt}" ;  
   ### We do confirm having 2  criteron meet to having a rate not higher than and lower than
   ### we can increase the counter until it meet the Range of selected item. 
   IntX=$(( ${IntX} + 1 )) ; 
  fi
 done  ;
 StrMsg=${ArrayMsg[0]//__ARRAY__/${ArrayRateLevel[@]}}
 StrMsg=${StrMsg//__ITEM__/${#ArrayRateLevel[@]}}
 ### Forced Message
 VerbHeader=${StrDisplayHeader} VerbMsg=${StrMsg} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis
 
 #echo "List or range [ ${ArrayRateLevel[@]} ] " > /dev/stderr ; 
 local IntTimeInterleave ; 
 local intCountTic ; 
 local IntModulo ;
 local IntStartTimer ; 
 local IntStopTimer ; 
 local IntTTimer=0 ;
 local IntSumTTimer ;
 local IntCountTimedCall=0 ; 
 local IntAvgTTimer=0 ;
 local IntOldAvg=0 ;  
 local IntSecJitter=0 ; 
 local IntEntrySec ; 
 local BoolWarnSleepMsg ; 
 ### Uses of bash ${SECONDS} is shortest device to represent a delay 
 ### since it's produce the number of seconds since the /bin/bash is 
 ### running it's something close to quantum-moment and fastest way 
 ### to rely on time.  
 while [ 1 ] ; do 

### Timer for Application
  IntStartTimer=${SECONDS} ; 
  IntModulo=$(( ${RANDOM} % ${#ArrayRateLevel[@]}  ))
  StrMsg=${ArrayMsg[13]} ; 
  StrMsg=${StrMsg//__ITEM__/${#ArrayRateLevel[@]}}
  VerbMsg=${StrMsg} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis
  
  StrMsg=${ArrayMsg[14]} ; 
  StrMsg=${StrMsg//__MODULO__/${IntModulo}} ; 
  
  VerbMsg=${StrMsg} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis
  StrRateGet=${ArrayRateLevel[${IntModulo}]}; 
### Timer for Application
  IntStopTimer=${SECONDS} ; 
  IntTTimer=$(( ${IntStopTimer} - ${IntStartTimer} )) ; 
  IntSumTTimer=$(( ${IntSumTTimer} + ${IntTTimer} )) ; 
  IntCountTimedCall=$(( ${IntCountTimedCall} + 1 ))  ; 
  
  
### Timer for Application
  IntStartTimer=${SECONDS} ; 
  
  #if [ ${IntRateGet:=100} -ge 100 ] ; then 
  ###StrRandomFormat=$( echo "scale=2 ;${IntRateGet} / 100" | bc ) ;
  ### Previous line required to perform a format where is no longer needed but later option can
  ### perform adaptation.
  StrRandomFormat=${StrRateGet} ; 
  #else
  # StrRandomFormat="0.${IntRateGet}" ;
  #fi 
  IntSleep=$(( ( ${RANDOM} % ${VLCRATEDURATION:=10} ) + 1 )) ; 
  #echo "Rate Fixed to ${StrRandomFormat}, for ${IntSleep} seconds " > /dev/stderr ;  
  StrMsg=${ArrayMsg[8]} ; 
  VerbMsg=${StrMsg} VerbHeader=${StrDisplayHeader} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis
  
  StrMsg=${ArrayMsg[1]//__RATE__/${StrRandomFormat}}
  StrMsg=${StrMsg//__SEC__/${IntSleep}}
  ### Forced Message
  VerbHeader=${StrDisplayHeader} VerbMsg=${StrMsg} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis
  
  StrSentCmd=${StrVLCCmd//__RATE__/${StrRandomFormat}} ; 
  
  StrMsg=${ArrayMsg[2]//__CMD__/${StrSentCmd}}
  ### Forced Message
  VerbHeader=${StrDisplayHeader} VerbMsg=${StrMsg} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis
  #echo "Pushing VLC-Cli comand:[ ${StrSentCmd} ]" > /dev/stderr ; 
  ### Forced Message
  
  ### Implementing the BASH SECONDS interface:
  ### Since the Variable ${SECONDS} represent the nb-second since the shell is 
  ### open it can be used in a while and a predicate timer of SECONDS + IntSleep 
  ### to let the command being pushed in correct time, replacing the sleep.
  ### this is also good when The push command is a process send in parallel and 
  ### require the Internal command called NC to wait appropriate time to talk2
  ### to the services and not pushing tiny interleave like 3 sec @ .98, 2 sec @ 1.01
  ### and 1 sec @ .90, both instance of 3 sec, 2 and 1  sec will have expired with 
  ### sleep and will push 3 instance opening  the interface. While a while with 
  ### SECONDS + IntSleep will correctly wait. So it supress the sleep having no
  ### chance to caliber from Closing Socket time variable 
  ### (IntSocketTimeExpr) + IntSleep to not represent the real interleave... 
  
  ### 
  ### If The IntAvgTTimer is not initalized, it use IntTTimer as indice over
  ### delay, if not it does uses overall-delay of application latency to 
  ### calibrate the delay. 
  ### 
  if [ ${IntAvgTTimer:=0} -eq 0 ] ; then 
    IntTimeInterleave=$(( ( ${SECONDS} + ${IntSleep} )  )) ; 
  elif [ ${IntAvgTTimer} -gt 0 ] ; then 
    IntTimeInterleave=$(( ( ${SECONDS} + ${IntSleep} ) )) ; 
  elif [ ${IntAvgTTimer} -lt 0 ] ; then 
    IntTimeInterleave=$(( ( ${SECONDS} + ${IntSleep} ) - ${IntAvgTTimer//-/} )) ; 
  fi
### Timer for Application
  IntStopTimer=${SECONDS} ; 
  IntTTimer=$(( ${IntStopTimer} - ${IntStartTimer} )) ; 
  IntSumTTimer=$(( ${IntSumTTimer} + ${IntTTimer} )) ; 
  IntCountTimedCall=$(( ${IntCountTimedCall} + 1 ))  ; 
  
    
  ### Ultimately, if the application take more time than Application latency it
  ### does create this phenomenom to reduce from ${SECONDS} the excess of time
  ### to inquiry a Prior than now to wait and does come the while with already
  ### dead interleave and should pass through... 
  
  ### Sleeper-section of __old_vlc_rate 
  ### based on : Is IntTimeInterleave had issues with a lowest
  ### value, if not it sleep. 
  ### as example if on assignation of IntTimeInterleave ${SECONDS}
  ### was 9999 sec. and Request of IntSleep was for 6 seconds, and
  ### IntAvgTTimer for application latency was of 12 sec it does 
  ### give IntTimeInterleave a value of 9993 seconds and 
  ### pass this while loop it directly go over, because here ${SECONDS}
  ### are all over 9999 sec., 10000 sec. ... 
  BoolWarnSleepMsg=False ;
  IntEntrySec=${SECONDS} 
  StrMsg=${ArrayMsg[9]} ;
  while [ ${IntTimeInterleave} -ge ${SECONDS} ] ; do 
   StrMsg=${StrMsg//__PERIOD__/$(( ${IntTimeInterleave} - ${IntEntrySec} ))} ; 
   StrMsg=${StrMsg//__ENTRY__/${IntEntrySec}} ; 
   StrMsg=${StrMsg//__EXIT__/${IntTimeInterleave}} ;
   StrMsg=${StrMsg//__INT_AVG__/${IntAvgTTimer}} ;
    
   if [ "${BoolWarnSleepMsg:=False}" == "False" ] ; then 
    VerbMsg=${StrMsg} VerbHeader=${StrDisplayHeader} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis ; 
    BoolWarnSleepMsg=True ; 
   fi 
   
   ### 2017-01-26
   ### Does re-accept to handle sleep with such fraction value
   ### since it have always support it... Really ! 
   /bin/sleep ${IntMicroTimer} ;
  done 
  
  ### Note: 
  ### replacement of '2>&1' by '2>&1>' does : 
  ### suppress all error message but does not remove the fact nc still sending 
  ### 
  ### error message : 
  ###     'nc: getaddrinfo: Servname not supported for ai_socktype' 
  ### 
  ### The message is still valid when a TCP/IP connection is made with to an 
  ### address. Managing it localy with 127.0.0.1 It does having background 
  ### configuration to remove explicit services like resolution name because 
  ### all network configuration made local address exempt of name resolution
  ### layer, making it hard to reduce access time it's common choice for many
  ### internal or virtual/loopback interface but because the information is
  ### sended, we assume it's working . Except nc still bsd/netbsd application
  ### where it's code still depend of presence of such facility. Such method
  ### require to alter the system by altering the resolv.conf, hosts and IP
  ### layer information to tell to nc to not force the resolution. Parameter  
  ### like -n 'seems to be ineffective'. There is some trick like using TOS
  ### where some of them force NC to not add the resolution... question of 
  ### URGENCY we do not spend time to ask to DNS for something URGENT.
  ### 
  ### For the moment expecting having no return error is good for establishing 
  ### a constant connection with know command may reduce the output in debug
  ### ... 
  ### 
  ### Discover parameter -i 'was set to 1' for 'delay time'. Not agreed from
  ### design to be "second" as delay, but __old_vlc_rate invite to understand
  ### sending 1 echo to be one line does not making sense to increase it until 
  ### Sat-Nov-26-2016 ( where at this point myself stand out of problem for ever )
  ### still have to joggle with impaired translation. So called option '-i' using 
  ### an  `echo "help" | nc -i 1 127.0.0.1 5083` Which is my server does not 
  ### transmit the whole help, even `echo "help" | nc 127.0.0.1 5083` with no '-i'
  ### option and buffer is empty with this line Guessing until I get all the help
  ### take '-i 3' and buffer is not empty from previous attempt... but belong to 
  ### help of netcat:
  ### --------------------------------------------------------------------------------------
  ### 
  ### NC(1)                                                  BSD General Commands Manual                                                 NC(1)
  ### 
  ### NAME
  ###      nc — arbitrary TCP and UDP connections and listens
  ### ....
  ###     Many lines not cited  
  ### ....
  ### 
  ### -i interval
  ###    Specifies a delay time interval between lines of text sent and received.  Also causes a delay time between connections to
  ###    multiple ports.
  ### 
  ### --------------------------------------------------------------------------------------
  ### 
  ### It make sensitive to a quantity, it not making 3 seconds every line and not making 
  ### +/- 15 seconds for 60 to 70 lines.... 
  ### - So there is criteron being 'interval between lines of text sent and received' 
  ### is compromising and making less cutted gap during rate-shift. 
  ### 
  ### So the interval is increased and developped a thread with a expiration mechanism based
  ### on bash ${SECONDS}, to analyse latency of connection.
  ### 
  
  ### Added Timer for compensating delay, to be reduced from next while-cycle from this latency.
  ### application can sometimes take 5 to 15 sec to produce the action ( whitout Call_Argument IsUseMRU (Most Recent Unit) 
  ### where is accelerate some application like TagParse to look inside a Hash-field for identical call )
  ### So at this point most of the application is sleep by counting should sonly ensure it sleep for 
  ### it's required time. 
  
  IntStartTimer=${SECONDS} ; 
  ### TimeOut configuration based on IntSecJitter
  ### or the famous Jitter factor bringing 
  ### Application Calibration to remain delayed by
  ### fews seconds in network-connection . 
  ### Since the Awk-script worry for TimeOut in
  ### network-connection, we can play with majored
  ### value of IntAvgTTimer (being integer) we can
  ### only afford to Interpret as 1 sec or 1000 msec.
  ### This application can divide by 2 the IntAvgTTimer
  ### giving for 1 sec of calibration almost 500 msec 
  ### added to execution-time . This resolution can
  ### be increased with cumulative delay but does 
  ### reset to default if it goes lower than 0 ; 
  if [ ${IntSecJitter:=0} -lt 0 ] ; then 
   IntNccTimeDrift=${IntNccTimeOut} ;
  fi
  if [ ${IntSecJitter:=0} -gt 0 ] ; then 
    IntNccTimeDrift=$(( ${IntNccTimeOut} + ( ( ${IntSecJitter} * 1000 ) / 2  ) )) ; 
    StrMsg=${ArrayMsg[17]} ;
    StrMsg=${StrMsg//__INT__/${IntNccTimeDrift}} ; 
    VerbMsg=${StrMsg} VerbHeader=${StrDisplayHeader} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis ; 
  fi 

  if [ "${BoolNCinSubProcess:=False}" == "True" ] ; then 
    if [ "${BoolVlcUseAwk:=False}" == "True" ] ; then 
      NNTimeOut=${IntNccTimeDrift} \
      NNConnectionScript=${StrAwkEngine} \
      NNAddr=${VLCSERVER:=192.168.0.72} \
      NNPort=${VLCSRVPORT:=5080} \
      /usr/bin/nice ${IntDefaulNice} NccNr ${StrSentCmd} ; 
      #nc -i ${IntSocketTimeExpr} -4 -n ${VLCSERVER:=192.168.0.72} ${VLCSRVPORT:=5080}  2>&1> /dev/null & 
    else
     echo "${StrSentCmd}" | /usr/bin/nice ${IntDefaulNice} \
                            nc -i ${IntSocketTimeExpr} -4 -n \
                            ${VLCSERVER:=192.168.0.72} \
                            ${VLCSRVPORT:=5080}  2>&1> /dev/null & 
    fi 
  else  
    if [ "${BoolVlcUseAwk:=False}" == "True" ] ; then 
     NNTimeOut=${IntNccTimeDrift}       \
     NNConnectionScript=${StrAwkEngine} \
     NNAddr=${VLCSERVER:=192.168.0.72}  \
     NNPort=${VLCSRVPORT:=5080}         \
     NccNr ${StrSentCmd} ; 
    else
     echo "${StrSentCmd}" | /usr/bin/nice ${IntDefaulNice} nc -i ${IntSocketTimeExpr} -4 -n ${VLCSERVER:=192.168.0.72} ${VLCSRVPORT:=5080}  2>&1> /dev/null ; 
    fi
  fi 
  IntStopTimer=${SECONDS} ; 
  IntTTimer=$(( ${IntStopTimer} - ${IntStartTimer} )) ; 
  IntSumTTimer=$(( ${IntSumTTimer} + ${IntTTimer} )) ; 
  IntCountTimedCall=$(( ${IntCountTimedCall} + 1 ))  ; 
  
  ### Lately test, come to late so far it does not respect the delay.
  ### By adding the latency to ${IntStopTimer}, and comparing with IntTimeInterleave
  ### it should be lower if this call will be handled lately by having fews seconds
  ### late or it will not complain because we are under or at-least on time. 
  ### IntAvgTTimer to change the speed-variation of a song 
  IntSecJitter=$(( ${IntStopTimer} - ${IntTimeInterleave} )) ;
  if [ ${IntSecJitter} -gt 0 ] ; then 
   StrMsg=${ArrayMsg[11]} ; 
   StrMsg=${StrMsg//__INT_JITTER__/${IntSecJitter}} ; 
  elif [ ${IntSecJitter} -le 0 ] ; then 
   StrMsg=${ArrayMsg[12]} ; 
   StrMsg=${StrMsg//__INT_JITTER__/${IntSecJitter}} ; 
  fi 
  VerbMsg=${StrMsg} VerbHeader=${StrDisplayHeader} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis ; 

  ### Generally, average is a division of iteration-lenght over frequency. 
  IntOldAvg=${IntAvgTTimer} ; 
  IntAvgTTimer=$(( ${IntSumTTimer} / ${IntCountTimedCall} )) ; 
  ### considering old information and Jitter. 
  if [ ${IntAvgTTimer} -gt 0 ] ; then 
   IntAvgTTimer=$(( ${IntAvgTTimer} - ${IntSecJitter//-/} )) ; 
  elif [ ${IntAvgTTimer} -le 0 ] ; then 
   IntAvgTTimer=$(( ${IntAvgTTimer} + ${IntSecJitter//-/} )) ; 
  fi 
  
  StrMsg=${ArrayMsg[10]} ; 
  StrMsg=${StrMsg//__INT_LATENCY__/${IntTTimer}} ;
  StrMsg=${StrMsg//__INT_JITTER__/${IntSecJitter}} ;
  StrMsg=${StrMsg//__INT_AVG__/${IntAvgTTimer}} ;
  
  VerbMsg=${StrMsg} VerbState=${BoolVerb} VerbHeader=${StrDisplayHeader} VerbDev=/dev/stderr Verbosis

 done ; 
  
}

###
### Video Section of _sub_vlc_services
###

if [ "${versionVF:=0.0.0}" == "0.0.0" ] ; then 

 ###
 ### Theses, are the function used to curse inside a DVD. You insert your 
 ### DVD inside the DVD-bay and you start vlc with command OldVLCServer 
 ### 'parameter not invoked'. Once the server is started, you may use 
 ### the last command  getSnapshootByGroup, and will optimally detect 
 ### changes in Video-image decoded and push N-amount of frame until 
 ### the stats of video instance tell having decoded one more frame
 ### and will get a snapshoot. Listening Aghost in the Shell of 1995
 ### version do not she do not jump at this 106 seconds, by my blog do 
 ### expose this images transformed into vector which only formed by 
 ### the brain region of layer and path structure to form what we call
 ### ambigous images of the main actress. 
 ### 
 ### command : SBGSeq=5 SBGFrameChunk=5 SBGStartTime=106  getSnapshootByGroup 
 ###
 ### or leave SBGFrameChunk by default to 0 and it will do the analyse to 
 ### clarify the number of frame to add through a command called with VlcSendCmd
 ### to process to next frame. This command as invoked will start at seconds 106,
 ### take about 5 images. 
 ###

 unset addSnapshoot
 function addSnapshoot()
 {
  local -a ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ;
  echo -ne "Add snapshoot\n" > /dev/stderr ;  
  UUID=${UUID:=3b5aea3c-260c-11e7-8b1d-001e4c8856d6} \
  VSCCmd="snapshot" \
  VlcSendCmd | 1>&2 > /dev/null  ; 
 }

 unset getStatQuery ; 
 function getStatQuery()
 { 
  local -a ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ; 
  local StrQueryFilter=${SQFilter:="video decoded"} ; 
  UUID=${UUID:=3b5aea3c-260c-11e7-8b1d-001e4c8856d6} \
  VSCCmd="stats" \
  VlcSendCmd | egrep -i "${StrQueryFilter}" | cut -d ':' -f 2 | sed 's/[\ \t]//g;s/[^0-9]//g' ; 
 }
 
 unset getVideoDecoded ; 
 function getVideoDecoded()
 { 
  local -a ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ; 
  UUID=${UUID:=3b5aea3c-260c-11e7-8b1d-001e4c8856d6} \
  SQFilter="video decoded" \
  getStatQuery ; 
 }
 
 unset getVideoDemuxRead ;
 function getVideoDemuxRead()
 { 
  local -a ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ; 
  UUID=${UUID:=3b5aea3c-260c-11e7-8b1d-001e4c8856d6} \
  SQFilter="demux bytes read" \
  getStatQuery ; 
 }

 unset getVideoInputRead ;
 function getVideoInputRead()
 { 
  local -a ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ; 
  UUID=${UUID:=3b5aea3c-260c-11e7-8b1d-001e4c8856d6} \
  SQFilter="input bytes read" \
  getStatQuery ; 
 }

 unset getVideoInputBitrate ;
 function getVideoInputBitrate()
 { 
  local -a ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ; 
  UUID=${UUID:=3b5aea3c-260c-11e7-8b1d-001e4c8856d6} \
  SQFilter="input bitrate" \
  getStatQuery ; 
 }

 unset getAudioDecoded ;
 function getAudioDecoded()
 { 
  local -a ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ; 
  UUID=${UUID:=3b5aea3c-260c-11e7-8b1d-001e4c8856d6} \
  SQFilter="audio decoded" \
  getStatQuery ; 
 }




 unset pushVideoFrame ; 

 function pushVideoFrame()
 {
  local -a ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ; 
  UUID=${UUID:=3b5aea3c-260c-11e7-8b1d-001e4c8856d6} \
  VSCCmd="frame" \
  VlcSendCmd 1>&2 > /dev/null 
 }

 unset setVideoTime ; 

 function setVideoTime()
 {
  local -a ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ; 
  local IntTime=${VTTime:=0}
  local StrCmd=${VTCmd="seek __TIME__"} ; 
  local IntTimeSet=0 ; 
  if [ "${Arg0:=None}" != "None" ] ; then 
   IntTimeSet=${Arg0} ;
  elif [ ${IntTime:=0} -ne 0 ] ; then 
   IntTimeSet=${IntTime} ;
  fi 
  echo -ne "set Video Time to ${IntTimeSet} second(s)\n" ; 
  UUID=${UUID:=3b5aea3c-260c-11e7-8b1d-001e4c8856d6} \
  VSCCmd="${StrCmd//__TIME__/${IntTimeSet}}" \
  VlcSendCmd 1>&2 > /dev/null 

 }

 unset getFrameCount ;

 function getFrameCount()
 {
  local IntStartVFC=$( UUID=${UUID:=3b5aea3c-260c-11e7-8b1d-001e4c8856d6} getVideoDecoded ) ;
  echo -ne "Video Decoded start at: ${IntStartVFC}\n" > /dev/stderr ; 
  local IntCheckVFC="${IntStartVFC}"; 
  local IntCount=0 ;
  while [ ${IntCheckVFC} -eq ${IntStartVFC} ] ; do 
   echo -ne "Pushing Frame\n" ;
   UUID=${UUID:=3b5aea3c-260c-11e7-8b1d-001e4c8856d6} pushVideoFrame ; 
   IntCheckVFC=$( UUID=${UUID:=3b5aea3c-260c-11e7-8b1d-001e4c8856d6} getVideoDecoded ); 
   echo -ne "Video Decoded now at: ${IntCheckVFC}\n" > /dev/stderr  ; 
   let IntCount=${IntCount}+1 ; 
  done 
  echo -ne "Counting ${IntCount} Frame before increasing video-decoded frame.\n" > /dev/stderr  ; 
 }

 function setVideoTimeByFrame()
 {
  local -a ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ; 
  local IntFrame=${VTBFChunk:=0}
  local StrCmd=${VTCmd="frame"} ; 
  local IntFrameSet=0 ; 
  if [ "${Arg0:=None}" != "None" ] ; then 
   IntFrameSet=${Arg0} ;
  elif [ ${IntFrame:=0} -ne 0 ] ; then 
   IntFrameSet=${IntFrame} ;
  fi 
  echo -ne "Push ${IntFrameSet} frame(s) at time to switch from video-decoded frame.\n" ; 
  for (( intx=0; intx<= ${IntFrameSet}-1; intx++ )) ; do 
   pushVideoFrame ; 
  done 

 }

 unset getSnapshootByGroup ; 
 function getSnapshootByGroup()
 {
  local -a ArrayArg=( $* ) ; 
  local Arg0=${ArrayArg[0]} ;  
  local IntTimeSequence=${SBGSeq=1} ; 
  local IntSetTime=${SBGStartTime:=0} ; 
  local IntFrameGroup=${SBGFrameChunk:=0} ; 
  ## Allow skipping test by Adding prefixed variable SBGFrameChunk
  ## to known value. of course it require to re-set to starting time 
  ## after the test done by GetFrameCount . 
  if [ ${IntFrameGroup:=0} -eq 0 ] ; then 
   IntFrameChunk=$( getFrameCount ) ; 
   VTTime=${IntSetTime} setVideoTime ; 
  else 
   echo -ne "SBGFrameChunk Set to ${IntFrameGroup} frame by chunk\nSkipping tests.\n"
   IntFrameChunk=${IntFrameGroup} ; 
  fi 
  
  VTTime=${IntSetTime} setVideoTime ; 
  echo -ne "Doing Sequence of ${IntTimeSequence} shoot, start video at ${IntSetTime} sec.\n, will skip ${IntFrameChunk} frame(s) at the time per snapshoot\n" ; 
  for (( intc=0; intc <= ${IntTimeSequence} ; intc++ )) ; do 
   ### Start with a snapshoot. 
   addSnapshoot ; 
   VTBFChunk=${IntFrameChunk} setVideoTimeByFrame  ; 
   getVideoDecoded ; 
  done ; 
 }

fi #End-if ${versionVF} == 0.0.0 
