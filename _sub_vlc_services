#!/bin/bash

# Package _sub_vlc_services

unset ActivatSeServerBuffer ; 

function ActivateServerBuffer()
{
 local __call_locality=( ASB ActivateServerBuffer ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart a new FIFO-Buffer Association.\n\t--stopservices\tStop a FIFO-Buffer Association.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 
 local StrFifoDevice=${ASBFIFO:=NONE} ;
 ### Make Symbolink link from UUID-Named fifo to ASBFIFO Name. 
 ### Important for Management and later work with DoCtrlHandler.
 local BoolUUIDNaming=${ABSUUIDSymLink:=False};
 local UUID="XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX" ; 
 local BoolVerbose=${ASBVerbose:=False};
 local IsFifoMode=${ASBFIFOMode:=False} ; 
 local IsFifoContext=${ASBFIFOCtx:=False} ; 
 local StrTestApps=${ASBTestApps:=/usr/bin/test} ; 
 local StrFifoApps=${ASBFIFOApps:=/usr/bin/mkfifo};
 local StrFifoModeParam=${ASBFIFOModParam:=--mode=644};
 local StrFifoCtxParam=${ASBFIFOCtxParam:=--context=USER}
 local StrTestPatrn=${ASBAppsOptPatrn:=__FILE__}
 local StrTestSwitche=${ASBAppsOpt:=-f {StrTestPatrn}} ; 
 local StrCmdFifo="${StrFifoApps} {FIFOMODE} {FIFOCTX} {StrFifoDevice}" ;
 ### UUID Section it's not mandatory and information can come from Shell by
 ### calling with GetULoop=... GetUSeq=... GetUTimeBased=... ActivateServerBuffer 
 ### 

 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local VerboseState=${VerbState:=False} ;
		local ArrayArg=( $* ) ; 
		if [ "${VerboseState:=False}" == "True" ] ; then 
			echo -ne "VERBOSE:[ ${StrMsg} ]\n" > ${StrDevOut} ;
		fi
	}
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 

  local GetUTimeBased=${GetUTimeBased:=True} ; 
  local GetUSeq=${GetUSeq:=1}
  local GetULoop=${GetULoop:=False}
  local ArrayMsg=( ); 
  
  ArrayMsg[0]="New UUID Value issued, UUID:\${UUID} "
  
  if [ "${BoolUUIDNaming:=False}" == "True" ] ; then 
   eval UUID=$( VTVIsArrayStyleInsert=True \
    VTVValueEntry=GetUTimeBased,GetUSeq,GetULoop \
    VTVIsValueReAssign=True  \
    VTVIsValueToConvert=False \
    VTVIsArrayStyleInsert=True \
    ValueToVariable ) GetUUID
    
   eval VerbMsg=${ArrayMsg[0]} VerboseState=${BoolVerbose} Verbosis
  fi

  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=IsFifoMode,StrCmdFifo,StrFifoModeParam,IsFifoContext,StrFifoDevice,StrTestCmd,StrTestPatrn  \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) CreateSocketBuffer
 }
 
 function __main_StopServices()
 {
		local __call_locality=( Main __main_StopServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=  \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) DestroySocketBuffer
 
 }
 
 function CreateSocketBuffer()
 {
		local __call_locality=( CSB CreateSocketBuffer ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  ###IsFifoMode,StrCmdFifo,StrFifoModeParam,IsFifoContext,StrFifoDevice,StrTestCmd,StrTestPatrn,,,,,,,,,,,,
  if [ ${IsFifoMode:=True} == "True" ] ; then 
   StrCmdFifo=${StrCmdFifo//{FIFOMODE}/${StrFifoModeParam}}
  else
   StrCmdFifo=${StrCmdFifo//{FIFOMODE}/}
  fi 

  if [ ${IsFifoContext:=True} == "True" ] ; then 
   StrCmdFifo=${StrCmdFifo//{FIFOCTX}/${StrFifoCtxParam}} ;
  else
   StrCmdFifo=${StrCmdFifo//{FIFOCTX}/} ;
  fi 

  StrCmdFifo=${StrCmdFifo//{StrFifoDevice}/${StrFifoDevice}} ;
  local StrTestCmd="${StrTestApps} ${StrTestSwitche}" ;
  StrTestCmd=${StrTestCmd//{StrTestPatrn}/${StrTestPatrn}} ;
  StrTestCmd=${StrTestCmd/${StrTestPatrn}/${StrFifoDevice}} ;
  
 }
 
 function DestroySocketBuffer()
 {
		local __call_locality=( DSB DestroySocketBuffer ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  
 }
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
  GetVarReference ${__call_locality[1]} ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=IsFifoMode,StrCmdFifo,StrFifoModeParam,IsFifoContext,StrFifoDevice,StrTestCmd,StrTestPatrn \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StartServices
 elif [ "${Arg0:=--stopservices}" == "--stopservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry= \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StopServices
 fi

 
 #eval echo """${StrTestCmd} && rm -f ${StrFifoDevice} && ${StrTestApps} ${StrTestSwitche}-f ${StrFifoDevice} && rm -f ${StrFifoDevice} && mkfifo ${StrFifoDevice}""" ;    
}

unset DoCtrlHandler ;
function DoCtrlHandler()
{
 local __call_locality=( DCH DoCtrlHandler) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 
 local GetUTimeBased=${GetUTimeBased:=True} ; 
 local GetUSeq=${GetUSeq:=1}
 local GetULoop=${GetULoop:=False}
 
 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local VerboseState=${VerbState:=False} ;
		local ArrayArg=( $* ) ; 
		if [ "${VerboseState:=False}" == "True" ] ; then 
			echo -ne "VERBOSE:[ ${StrMsg} ]\n" > ${StrDevOut} ;
		fi
	}

 eval local UUID=$( VTVIsArrayStyleInsert=True \
  VTVValueEntry=GetUTimeBased,GetUSeq,GetULoop \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) GetUUID
  
}

unset VlcServer ;

function VLCServer()
{
 local __call_locality=( VLCS VLCServer ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--stopservices\tStop the application or service side relation.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 
 
 ### Prefixed Variable List
 local StrFifoRoot=${VLCSFIFORoot:=HOME} ;
 local IsFifoRootVar=${VLCSFIFORootVar:=True} 
 local StrFifoName=${VLCSFIFOName:=.vlc-server} ;
 local StrVLCCaller=${VLCSBIN:=\${HOME}/bin/vlc-terminal.sh} ;
 
 ### Loading playlist <--- Depedent of StrVLCCaller and this script verify the playlist parameter --->
 local StrVLCPlayList=${VLCSBINPl:=\${HOME}/Music/playlist_20160606.m3u} ;
 
 
 ### Information toward network / socket transfert 
 ### Example of Socket Handler and it's parameter 
 ### nc -4 -n -k -i 1 -I $((2 * 1024 * 1024)) -l 127.0.1.1 5080 > ${HOME}.vlc-server
 #StrAppsSocket,StrAppsCmdCaller,StrAppsParam,StrAppsBuffer,StrAppsAddrSvr,StrAppsAddrPrt,,,,,,,,,,,,,,,,
 local StrAppsSocket=${VLCSSocketHndlr:=/bin/nc} ;
 local StrAppsCmdCaller=${VLCSSocketCmd:=__APPS__ __PARAM__ -I __BUFFER__ -l __ADDR__ __PORT__} ;
 local StrAppsParam=${VLCSSocketParam:=-4 -n -k -i 1} ;
 local StrAppsBuffer=${VLCSSocketBuffer:=2097152} ;
 local StrAppsAddrSvr=${VLCSSocketAddr:=127.0.1.1} ;
 local StrAppsAddrPrt=${VLCSSocketPort:=5080} ;
 #local =${VLCS:=} ;
 #local =${VLCS:=} ;
 #local =${VLCS:=} ;
 #local =${VLCS:=} ;
 
 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsDisplayFormatted=${VerbFormated:=True} ;
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
     echo -ne "${StrMsg}\n" > ${StrDevOut} ;
   fi 
		fi
	} 
 ### Model : VerbMsg= VerbDev=/dev/stderr VerbState=True VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis

 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrFifoDevice,IsFifoMode,IsFifoContext,StrTestApps,StrFifoApps,StrFifoModeParam,StrFifoCtxParam  \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) ActivateServerBuffer
 }
 
 function __main_StopServices()
 {
		local __call_locality=( Main __main_StopServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
 
 }
 
 
 local StrMsg="" ; 
 local StrFIFODev="" ; 
 ### This section explain how the group 
 ### VLCSFIFORootVar, VLCSFIFORoot, VLCSFIFOName, is handled, 
 ###  
 ### How StrFIFODev Will Be see here to hold the 
 ### Server Services ?
 ###  ------+
 ###        /\
 ###       /  \
 ###      /    \
 ###     /      \
 ###    /        \ 
 ###   / VLCSFIFO \  FALSE
 ###   \  RootVar /----------> Not to be evaluated and hold respectively 
 ###    \ True ? /             StrFIFODev=${StrFifoRoot}/${StrFifoName}
 ###     \      /
 ###      \    /
 ###       \  /
 ###        \/
 ###        |
 ###        | TRUE
 ###        |
 ###        |
 ###        +---------> Evaluate Element like this {StrFifoRoot} is a Variable Name 
 ###                    ${StrFifoName} is the content of the ServerBuffer Name 
 ###                    and StrFIFODev will Hold a [Variable]/[And FifoName Content]
 ###  
 
 if [ ${IsFifoRootVar:=True} == "True" ] ; then 
  eval """StrFIFODev=\$${StrFifoRoot}/${StrFifoName}""" ; 
 else
  StrFIFODev=${StrFifoRoot}/${StrFifoName};
 fi 
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrFifoRoot,IsFifoRootVar,StrFifoName,StrVLCCaller,StrVLCPlayList,StrAppsSocket,StrAppsCmdCaller,StrAppsParam,StrAppsBuffer,StrAppsAddrSvr,StrAppsAddrPrt \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StartServices
 elif [ "${Arg0:=--stopservices}" == "--stopservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrFifoRoot,IsFifoRootVar,StrFifoName,StrVLCCaller,StrVLCPlayList,StrAppsSocket,StrAppsCmdCaller,StrAppsParam,StrAppsBuffer,StrAppsAddrSvr,StrAppsAddrPrt \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StopServices
	fi

 
 ### ---> Final Lines ${StrFIFODev} ; cat /home/maxiste/.vlc-server | ./bin/vlc-terminal.sh /home/maxiste/Music/playlist_20160606.m3u | nc -lk -i 1 -I $((2 * 1024 * 1024)) -p 5080 127.0.0.1 > /home/maxiste/.vlc-server
}

unset __vlc_rate ; 

function __vlc_rate()    
{ 

 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsDisplayFormatted=${VerbFormated:=True} ;
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
     echo -ne "${StrMsg}\n" > ${StrDevOut} ;
   fi 
		fi
	} 
 ### Model : VerbMsg= VerbDev=/dev/stderr VerbState=True VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis

 local StrMsg="" ; 

 local ArrayRateLevel=( ); 
 ### determining the range of random rate. 
 local IntRandRange=$(( ( ${RANDOM} % ${VLCRATE:=30} ) + 1  )) ; 
 local IntRateInsert=0 ; 
 local IntRateGet=0 ;
 local StrRandomFormat="" ; 
 local IntSleep=0 ; 
 local StrVLCCmd="${VLCCLICMD:=rate __RATE__}" ; 
 local StrSentCmd="" ; 
 ### Create the random-field olding N-range of Possible Rate.  
 for (( intx=0 ; intx <= ${IntRandRange} ; intx++ )) ; do 
  IntRateInsert=$(( 100 - ( ${RANDOM} %  ${IntRandRange} ) )) ;
  ArrayRateLevel[${#ArrayRateLevel[@]}]=${IntRateInsert} ;  
 done  ;
 echo "List or range [ ${ArrayRateLevel[@]} ] " > /dev/stderr ; 
 while [ 1 ] ; do 
  IntRateGet=$(( ${ArrayRateLevel[${RANDOM} % ${#ArrayRateLevel[@]}]} )) ; 
  if [ ${IntRateGet:=100} -eq 100 ] ; then 
   StrRandomFormat="1" ;
  else
   StrRandomFormat="0.${IntRateGet}" ;
  fi 
  IntSleep=$(( ( ${RANDOM} % ${VLCRATEDURATION:=10} ) + 1 )) ; 
  echo "Rate Fixed to ${StrRandomFormat}, for ${IntSleep} seconds " > /dev/stderr ;  
  StrSentCmd=${StrVLCCmd//__RATE__/${StrRandomFormat}} ; 
  echo "Pushing cmd:[ ${StrSentCmd} ]" > /dev/stderr ; 
  echo "${StrSentCmd}" | nc ${VLCSERVER:=192.168.0.72} ${VLCSRVPORT:=5080} 2>&1 /dev/null  ; 
  sleep ${IntSleep} ; 
 done ; 
  
}

###
### Old Section, the improvement are previous lines, all the stuff under this comment 
### are port from theses prototypes.
### 

unset OldVLCServer ;
function OldVLCServer()
{
 local __call_locality=( OVLCS OldVLCServer ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 ### vlc-terminal.sh is simply a vlc loading sheet and other meter, replacing 
 ### OVLCSAppsLunch={/usr/bin/vlc OR /usr/local/bin/vlc} can just let use
 ### it for test purposes.
  
 local StrVLCApps=${OVLCSAppsLunch:="""${HOME}/bin/vlc-terminal.sh"""}
 local StrVLCAppsPlaylist=${OVLCSAppsPlaylist:="""${HOME}/Music/playlist_20160606.m3u"""} ; 
 ### It uses /bin/nc inside socket management to receive incoming vlc-cli command and 
 ### /bin/nc is a bind to /bin/nc.openbsd in Linux-Mint Distribution, depend what other 
 ### own ...
 local StrSocketApps=${OVLCSAppsSock:=/bin/nc};
 local StrSocketOption=${OVLCSAppsSockOpt:=-4 -n -k -i 3};
 local StrSocketBufferOption=${OVLCSAppsSockBuffer:=2097152};
 local StrAppsBufferOption=${OVLCSAppsBuffer:=-I};
 local StrAppsListenOption=${OVLCSAppsLiten:=-l}
 local StrSocketAddr=${OVLCSSockAddr:=127.0.1.1};
 local StrSocketPort=${OVLCSSockPort:=5080};
 local BoolDisplayCmdLine=${OVLCDisplayCmd:=False};
 
 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsDisplayFormatted=${VerbFormated:=True} ;
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
     echo -ne "${StrMsg}\n" > ${StrDevOut} ;
   fi 
		fi
	} 
 ### Model : VerbMsg= VerbDev=/dev/stderr VerbState=True VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  ### StrVLCApps,StrVLCAppsPlaylist,StrSocketApps,StrSocketOption,StrAppsBufferOption,StrSocketBufferOption,StrAppsListenOption,StrSocketAddr
  test -f ${HOME}/.vlc-server && rm -f ${HOME}/.vlc-server  ; 
  test ! -f ${HOME}/.vlc-server && mkfifo ${HOME}/.vlc-server ; 
  
  local StrCmd="""cat ${HOME}/.vlc-server | \
  ${StrVLCApps} ${StrVLCAppsPlaylist} | \
  ${StrSocketApps} ${StrSocketOption} \
  ${StrAppsBufferOption} ${StrSocketBufferOption} \
  ${StrAppsListenOption} ${StrSocketAddr} ${StrSocketPort} > ${HOME}/.vlc-server """ ; 
  
  VerbMsg=${StrCmd} VerbDev=/dev/stderr VerbState=${BoolDisplayCmdLine} VerbFormated=True VerbHeader="CMDLINE" Verbosis  
  $( eval "${StrCmd}" ) ; 
  
 }
 
 function __main_StopServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  echo -ne "\n\n\tLike you see there is an application to destroy and socket to stop.\nStay tuned to see how we can manage it with CtrlHandler methodology.\n\n" ; 
 }
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=BoolDisplayCmdLine,StrVLCApps,StrVLCAppsPlaylist,StrSocketApps,StrSocketOption,StrAppsBufferOption,StrSocketBufferOption,StrAppsListenOption,StrSocketAddr \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StartServices
 elif [ "${Arg0:=--stopservices}" == "--stopservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrVLCApps,StrVLCAppsPlaylist,StrSocketApps,StrSocketOption,StrAppsBufferOption,StrSocketBufferOption,StrAppsListenOption,StrSocketAddr \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StopServices
 fi

}

unset VLCSetVolume ; 
function VLCSetVolume()
{
 function Verbosis()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Verb Verbosis ) ; 
   local Arg0=${ArrayArg[0]} ; 
  elif [ ${versionGPI:=0.0.0} == "0.0.1" ] ; then 
   eval $( CAFunctName=Verbosis CAIsAddParent=False __Call_Argument ) ; 
  elif [ ${versionGPI:=0.0.0} == "0.0.2" ] ; then 
   eval $( CAFunctName=Verbosis CAIsAddParent=False CallArgument ) ; 
  fi 
  local StrMsg=${VerbMsg:=__TEXT__} ; 
  local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
  local IsDisplayFormatted=${VerbFormated:=True} ;
  local IsAppendMode=${VerbAppendDev:=False} ; 
  local ArrayArg=( $* ) ; 
  if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
    if [ "${IsAppendMode:=False}" == "True" ] ; then 
      echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
    else  
      echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
    fi
   else
    if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
       echo "${StrMsg}" ;  
    else
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
      echo "${StrMsg}" >> ${StrDevOut} ;
     else
      echo "${StrMsg}" > ${StrDevOut} ;
     fi
    fi 
   fi 
  fi
 } 
 ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
 
 ### ---TOP-FUNCTION-DECLARATION---
 if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
  local -a ArrayArg=( $* ) ;
  local -a __call_locality=( VLCSV VLCSetVolume ) ;
  local StrParentApps=${__call_locality[1]} ; 
  local StrMainStart=${VLCSVFuncStart:=__main_StartServices} ;  
  local Arg0=${ArrayArg[0]} ; 
 elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
  eval $( CAFunctName=VLCSetVolume CAIsAddParent=False __Call_Argument ) ; 
 elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
  eval $( CAFunctName=VLCSetVolume CAIsAddParent=False CallArgument ) ; 
 fi 
 
 local StrTplZenityVol=${VLCSVTplZenity:="zenity --scale --text=\"__TEXT__\" --value=__VOLUME__ --min-value=__MIN_VOLUME__ --max-value=__MAX_VOLUME__ --step=__VOL_STEP__"} ;
 local StrTplParser=${VLCSVTagParser:=StrTextCLient:__TEXT__,IntVol:__VOLUME__,IntMinVol:__MIN_VOLUME__,IntMaxVol:__MAX_VOLUME__,IntStepVol:__VOL_STEP__,StrAddr:__IP__,IntPort:__PORT__,StrVolCLiCmd:__CLI_CMD__,IntNewVol:__NEWVOL__,StrAppsEcCli:__APPS_EC_OPT__,StrAppsEc:__APPS_EC__} ;
 local StrTextCLient=${VLCSVTextCli:='VLC CLient Volume Indicator'} ;
 local StrVolCLiGetCmd=${VLCSVCliGet:="__APPS_EC__ __PIPE__ __APPS__ __APPS_OPT__ __PIPE__ __FILTER__ __FILTER_OPT__"} ; 
 local StrVolCLiSetCmd=${VLCSVCliSet:="echo volume __PIPE__ __APPS__ __APPS_OPT__ __PIPE__ __FILTER__ __FILTER_OPTS__"} ; 
 local StrAppsEc=${VLCSVCLiePushCmd:=echo \"__APPS_EC_OPT__\"} ;
 local StrAppsEcCli=${VLCSVCLiCmd:=volume} ; 
 local IntMinVol=${VLCSVMinVol:=0} ;
 local IntMaxVol=${VLCSVMaxVol:=500} ;
 local IntStepVol=${VLCSVStepVol:=1} ; 
 local StrAddr=${VLCSVAddr:=127.0.0.1} ; 
 local IntPort=${VLCSVPort:=5083} ; 
 local StrVarList="StrVarList,StrTplZenityVol,StrTplParser,StrTextCLient,StrVolCLiGetCmd,StrVolCLiSetCmd,IntMinVol,IntMaxVol,IntStepVol,StrAddr,IntPort,StrAppsEc,StrAppsEcCli" ; 

  

 function __main_StartServices()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ; 
   local Arg0=${ArrayArg[0]} ;   
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ; 
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ; 
  fi  
  
  
  #eval $( "CAFunctName=VLCSetVolume CAIsAddParent=True __Call_Argument" ) ; 
  #IntVol=$( echo "volume" | nc 127.0.0.1 5083 | sed 's/[^0-9]*//g' )
  #IntNewVol=$(  zenity --scale --text="VLC CLient Volume Indicator" --value=${IntVol} --min-value=0 --max-value=500 --step=1 ) ;
  #echo "volume ${IntNewVol}" | nc 127.0.0.1 5083
  
  ### New Variable declared for use of GnrlPrsrInfctr #1, and #2
  # local StrCmdGet=${StrVolCLiGetCmd} ;  
  local StrCmdSend ; 
  ### I need to re-copy the StrTplZenityVol and parse the new copy.
  local StrCmdZenity=${StrTplZenityVol} ; 
  
  ### GnrlPrsrInfctr #1, responsible of Getting information from vlc --> StrVolCLiGetCmd
  eval $( eval VTVIsArrayStyleInsert=True \
  VTVValueEntry=${StrVarList}  \
  VTVIsValueReAssign=True      \
  VTVIsValueToConvert=False    \
  VTVIsArrayStyleInsert=True   \
  ValueToVariable ) GPIIsUUIDInstance=True      \
                    GPIIsFileHandlerOut=False   \
                    GPIIsZenityHandlerOut=True  \
                    GPIIsExecuteEval=True       \
                    GPIIsGenerateCode=False     \
                    GPIDisplayDebug=True        \
                    GPIParserDebug=True         \
                    GPITpl="${StrVolCLiGetCmd}" \
                    GPIApps=/bin/nc             \
                    GPIAppsOpt='${StrAddr} ${IntPort}' \
                    GPITagFeeder="${StrTplParser}"     \
                    GPIFilterApps='/bin/sed'           \
                    GPIFilterOpt='s/[^0-9]*//g'        \
                    GPITagParserResult='StrCmdGet'     \
                    GnrlPrsrInfctr ;
  
  VerbMsg="StrCmdGet:${StrCmdGet}, reference:UUID:${UUID}" VerbHeader="${__call_locality[0]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
  
  ### GnrlPrsrInfctr #1, responsible of Setting information for vlc --> StrVolCLiGetCmd
  ### Because IntNewVol is a new member it require to be injected on the QueryList or 
  ### using ValueToVariable can do this task. 
  
  ### Since I do need to set the volume value, it require the GUI action from Zenity
  ### to set the desired variable. I do require to parse with TagPArser the Zenity 
  ### Command, using the StrTplParser the same from GnrlPrsrInfctr #1, and #2. 
  #eval eval TPVarNameParsed="StrCmdZenity"               \
  #     TPListTag="${StrTplParser}"                       \
  #     TPIsMatchRtoL=True                                \
  #     TPDisplayParserNotice=True                        \
  #     TPDisplayDebug=True                               \
  #     TPArrayName="Array${__call_locality[0]}Tag"       \
  #     TagParser ;
  
  #VerbMsg="StrCmdZenity:${StrCmdZenity}" VerbHeader="${__call_locality[0]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis ; 
             
  #eval $( VTVIsArrayStyleInsert=True \
  #VTVValueEntry=IntNewVol \
  #VTVIsValueReAssign=True  \
  #VTVIsValueToConvert=False \
  #VTVIsArrayStyleInsert=True \
  #ValueToVariable ) GPIIsUUIDInstance=True \
  #                  GPIIsFileHandlerOut=True \
  #                  GPIIsExecuteEval=True \
  #                  GPIIsGenerateCode=False \
  #                  GPIParserDebug=True \
  #                  GPITpl="${StrVolCLiSetCmd}" \
  #                  GPIApps=/bin/nc \
  #                  GPIAppsOpt='${StrAddr} ${IntPort}' \
  #                  GPITagFeeder="${StrTplParser}" \
  #                  GPITagParserResult='StrCmdSend' \
  #                  GnrlPrsrInfctr  ; 

  #VerbMsg="StrCmdSend:${StrCmdSend}, reference:UUID:${UUID}" VerbHeader="${__call_locality[0]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis ; 
  
 
 }
 
 function __main_StopServices()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Main __main_StopServices ${StrParentApps} ) ; 
   local Arg0=${ArrayArg[0]} ;   
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( CAFunctName=__main_StopServices CAIsAddParent=True __Call_Argument ) ; 
  elif [ ${versionGPI:=0.0.0} == "0.0.2" ] ; then 
   eval $( CAFunctName=__main_StopServices CAIsAddParent=True CallArgument ) ; 
  fi  
  #eval $( "CAFunctName=VLCSetVolume CAIsAddParent=True __Call_Argument" ) ; 
  
 }
 
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--stopservices}" == "--stopservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=${StrVarList} \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StopServices  ; 
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  StrMsg="Function __FUNCT__, version versionCA=__VER_CA__, versionGPI=__VER_GPI__, versionTP=__VER_TP__" ; 
  StrMsg=${StrMsg//__FUNCT__/${StrParentApps}} ; 
  StrMsg=${StrMsg//__VER_TP__/${versionTP}} ; 
  StrMsg=${StrMsg//__VER_CA__/${versionCA}} ; 
  StrMsg=${StrMsg//__VER_GPI__/${versionGPI}} ; 
  VerbMsg="${StrMsg}" VerbHeader="LOADER" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
  eval $( eval VTVIsArrayStyleInsert=True \
  VTVValueEntry=${StrVarList} \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) ${StrStartMain} ; 
 fi
 
 
}

if [ "${versionSSA:=0.0.0}" == "0.0.1" ] ; then 
 
 eval $( GFCFuncName=StartSlewAnalysis GlobalFunctionCleaning ) ; 
 
 function StartSlewAnalysis()
 {

   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( SSA StartSlewAnalysis ) ;
   local Arg0=${ArrayArg[0]} ;   
   local IntSleep=$( VSCCmd="get_length" VSCAddr=127.0.0.1 VSCPort=5083  VlcSendCmd | sed -r 's/[^0-9]*//g'  ) ; 
   local StrDate; 
   local IntStartTimer;
   local IntStopTimer;
   local IntTTimer ; 
   local IntSleepCalc ; 
   while [ 1 ] ; do 
    ### GODFormat="%Y%m%d %H:%M:%S" GODShowEvalCmd=False GODShowParsing=False GODShowVersion=False GODVerbose=False GetOtherDate
    IntStartTimer=${SECONDS} ; 
    StrDate=$( /bin/date +"%Y%m%d %H:%M:%S" ) ; 
    echo -ne "date:${StrDate}\nSong of ${IntSleep} sec(s)\n" ; 
    VSCCmd="seek 0" VSCAddr=127.0.0.1 VSCPort=5083 VlcSendCmd 2>&1> /dev/null  ; 
    IntStopTimer=${SECONDS};
    IntTTimer=$(( ${IntStopTimer} - ${IntStartTimer} )) ;
    IntSleepCalc=$(( ${IntSleep}-${IntTTimer} )) ; 
    echo -ne "Application latency of ${IntTTimer} sec(s), compensing sleep of ${IntSleepCalc} sec(s) \n" ; 
    sleep ${IntSleepCalc} ;
    ### This slew rate-second interleave can not be introduced to 
    ### to sleep, first it's random ( as long you're not leaving the application __old_vlc_rate )
    ### open for all the posibility used for a song of N-seconds and N-possibility to shift
    ### reducing the Prefixed-variable of random-time duration can possibly give an exact
    ### slew-rate. Calling FIR ( Finite Impulse Response ) , a FIR method 
    ### constantly reduce the remainder based on actual summation of the result. 
    ### But basically it should not help in this case. 
    
    ### Uses of IntStartCmd, IntStopCmd, IntTTime
    ### to get the time lost querying the services 
    ### or the latency after sleeping , This information
    ### is important and more we can estimate when the 
    ### application sucessfully taked the command get_time
    ### and calculating the the nearest point to know 
    ### what slew-rate can cause. Estimating the application
    ### can't get information instantly It suppose the latency
    ### of the application should be substracted from IntCurrent
    ### to pretend knowing by-seconds the actuall location get
    ### was the same speed N seconds ago... 
    
    local IntStartCmd=${SECONDS} ; 
    local IntCurrent=$( VSCCmd="get_time" VSCAddr=127.0.0.1 VSCPort=5083  VlcSendCmd | sed -r 's/[^0-9]*//g' )  ; 
    local IntStopCmd=${SECONDS} ; 
    local IntTTime=$(( ${IntStopCmd}-${IntStartCmd} )) ;
    
    local IntSeekEnd=$(( ${IntCurrent} - ${IntTTime} )) ; 
    local IntSlewRateSec=$(( ${IntSleep} - ${IntSeekEnd} )) ; 
    echo -ne "TimeDuration : ${IntSleep} sec(s)\nRewind at Position : ${IntSeekEnd} sec(s)\nApps Latency : ${IntTTime} sec(s)\nRandom Rate causing a Decalibation of the end by ${IntSlewRateSec} sec(s) early, for song of ${IntSleep} sec(s)\n" ; 
   done 
 }
fi 

if [ "${versionSSA:=0.0.0}" == "0.0.2" ] ; then 
 
 eval $( GFCFuncName=StartSlewAnalysis GlobalFunctionCleaning ) ; 
 
 function StartSlewAnalysis()
 {
  function Verbosis()
  {
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Verb Verbosis ) ; 
   local Arg0=${ArrayArg[0]} ; 
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   local IsExtendedOutput=${VerbExtendedOut:=False} ; 
   local ArrayArg=( $* ) ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
      if [ "${IsExtendedOutput:False}" == "True" ] ; then 
        echo -ne "${StrMsg}" ;  
      else
        echo "${StrMsg}" ;  
      fi
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       if [ "${IsExtendedOutput:False}" == "True" ] ; then 
         echo -ne "${StrMsg}" >> ${StrDevOut} ;
       else
         echo "${StrMsg}" >> ${StrDevOut} ;
       fi
      else
       if [ "${IsExtendedOutput:False}" == "True" ] ; then 
        echo -ne "${StrMsg}" > ${StrDevOut} ;
       else
        echo "${StrMsg}" > ${StrDevOut} ;
       fi 
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
  
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( SSA StartSlewAnalysis ) ;
   local Arg0="${ArrayArg[0]}" ; 
   local StrParentApps=${__call_locality[1]} ;
   local StrStartMain=${SSAFuncStart:=__main_StartServices} ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=StartSlewAnalysis CAIsAddParent=False __Call_Argument ) ; 
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=StartSlewAnalysis CAIsAddParent=False CallArgument ) ;
  fi 
 
  local StrPathLoopState=${SSALoopFile:=/var/cache/Fnct.D/Loop-SSA-__UUID__} ; 
  local BoolShowEntry=${SSAShowEntry:=False} ; 
  local BoolDisplayDebug=${SSADisplayDebug:=False} ; 
  local BoolShowInstance=${SSAShowInstance:=True} ; 
  local BoolShowVersion=${SSAShowVersion:=True} ; 
  local StrAddr=${SSAServerAddr:=127.0.0.1} ; 
  local StrPort=${SSAServerPort:=5083} ; 
  
  local -a ArrayMsg ;
  ArrayMsg[0]="Entry in function" ;  
  ArrayMsg[1]="Shutdown Instance ID:__UUID__, file: __FILE__" ;
  ArrayMsg[2]="Instance ID:__UUID__" ;
  ArrayMsg[3]="date:__DATE__\nSong of __DUR__ sec(s)\n" ; 
  ArrayMsg[4]="Application latency of __TIMER__ sec(s), compensing sleep of __SLEEP__ sec(s) \n" 
  ArrayMsg[5]="TimeDuration : __SLEEP__ sec(s)\nRewind at Position : __RWD__ sec(s)\nApps Latency : __LATENCY__ sec(s)\nRandom Rate causing a Decalibation of the end by __SLEW_SEC__ sec(s) early, for song of __DUR__ sec(s)\n" ; 
  
  local StrVarList="StrPathLoopState,BoolShowVersion,BoolShowEntry,BoolDisplayDebug,BoolShowInstance,StrAddr,StrPort,StrParentApps" ;
 
  
  function VersionApps()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( VA VersionApps ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=VersionApps CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=VersionApps CAIsAddParent=True CallArgument ) ;
   fi     
   StrEvalCmd="""
   StrMsg=\"Application:__FUNCT__ , version:( versionTP:__VER_TP__ versionVTV:__VER_VTV__, versionCA:__VER_CA__, versionBVT:__VER_BVT__)\" ; 
   StrMsg=\${StrMsg//__VER_CA__/\${versionCA}} ;
   StrMsg=\${StrMsg//__VER_TP__/\${versionTP}} ;
   StrMsg=\${StrMsg//__VER_VTV__/\${versionVTV}} ;
   StrMsg=\${StrMsg//__VER_BVT__/\${versionBVT}} ;
   StrMsg=\${StrMsg//__FUNCT__/\${__call_locality[1]}} ;
   VerbMsg=\${StrMsg} VerbHeader=\"VERSION\" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
   """ ; 
   echo -ne "${StrEvalCmd}" ; 
  }

  function FilterVlcSendCmd()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( FVSC FilterVlcSendCmd ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=FilterVlcSendCmd CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=FilterVlcSendCmd CAIsAddParent=True CallArgument ) ;
    ### CallArgument is important to Generate SSAFuncStart=${StrStartMain} to 
    ### be launched with Bottom-if-statement of --startservices .
   fi 
   StrMsg=$( StartSlewAnalysis --get ArrayMsg[0] ) ;
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolShowEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   local StrFilterType=${FVSCTypeFilter:=Int}  ; 
   local StrServAddr=${FVSCAddr:=127.0.0.1} ; 
   local StrServPort=${FVSCPort:=5083} ;
   local StrServCmd=${FVSCCmd:=get_length} ; 
   ### An associative Array working with index ( ${!Array[@]}, for all key and ${Array[IndexName]} -> value  ) ; 
   local -A ArrayTypeFilter ; 
   local StrSedCmd ;
   ### Since VlcSendCmd does display lot or garbage around information like send a "volume" command will display sometimes '>' char and couple of '>>', so to 
   ### determine what we should receive like command with volume will output at least number, using a sed 's/[^0-9]//g' should remove everything except number.
   ### for String it's somewhat problematic, excessive '<' or '>' from output as to be inserted with precise Char-range. 
   
   ArrayTypeFilter["Int"]="[^0-9]*" ; 
   ArrayTypeFilter["String"]="[^A-Za-z\ \-\_\)\(]*" ; 
   StrSedCmd="/bin/sed -r 's/${ArrayTypeFilter[${StrFilterType}]}//g'" ;
   
   VSCCmd=${StrServCmd} VSCAddr=${StrServAddr} VSCPort=${StrServPort} VlcSendCmd | eval ${StrSedCmd} ; 
   ### To test is the application FilterVlcSendCmd can filter with the integer filter a request such get_length
   ### you can call it from the command-shell by passing to StartSlewAnalysis the FilterVlcSendCmd as SSAFuncStart:
   ###
   ### FVSCTypeFilter=Int FVSCAddr=127.0.0.1 FVSCPort=5083 FVSCCmd=get_length  SSAFuncStart=FilterVlcSendCmd  StartSlewAnalysis 
   ### 
  }      

  function __main_StopServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StopServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StopServices CAIsAddParent=True CallArgument ) ;
   fi 
   StrMsg=$( StartSlewAnalysis --get ArrayMsg[0] )
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolShowEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   
   ### Stop services, based on creation of a file named in '${StrPathLoopState}'  and
   ### resposible to loop inside __main_StartServices unless the file exist. 
   ###
   ### Example to shutdown a current session:
   ### UUID=9589a8be-b766-11e6-8b1d-001e4c8856d6  StartSlewAnalysis --stopservices 
   ### will erase the file inside /var/cache/Fnct.D/Loop-SSA-9589a8be-b766-11e6-8b1d-001e4c8856d6
   ### be sure you are launched it from same user permission. 
   ###
   local StrUUID=${UUID} ;
   if [ "${StrUUID:=None}" == "None" ] ; then 
    StrUUID=${StrUUIDInstance} ; 
   fi 
   local StrPathLoopState=${StrPathLoopState//__UUID__/${StrUUID}} ; 
   VerbMsg="Shutdown Instance ID:${StrUUID}, file: ${StrPathLoopState}" VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ;
   if [ -f ${StrPathLoopState} ] ; then 
    rm -f ${StrPathLoopState} ; 
   fi 
      
  }

  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local -a ArrayArg=( $* ) ;
    local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
    local Arg0="${ArrayArg[0]}" ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ;
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ;
   fi 
   StrMsg=$( StartSlewAnalysis --get ArrayMsg[0] ) ;
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=${BoolShowEntry} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;

   ### Loop Registration:
   ### Create a UUID Instance and store-it with a touch command . 
   ### - This is controlled with the while and will end if the 
   ### file is erased by calling __main_StopServices with the UUID Instance. 
   local StrUUID=$( GetUAppsRegisterName=${StrParentApps} GetUTimeBased=True GetULoop=False GetUUID ) ; 
   StrPathLoopState=${StrPathLoopState//__UUID__/${StrUUID}}
   StrMsg=$( StartSlewAnalysis --get ArrayMsg[2] ) ;
   StrMsg=${StrMsg//__UUID__/${StrUUID}} ; 
   VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-DEBUG" VerbState=${BoolShowInstance} VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
   /bin/touch ${StrPathLoopState} ; 
  
   local IntSleep=$( \
    FVSCTypeFilter=Int   \
    FVSCCmd="get_length" \
    FVSCAddr=${StrAddr}  \
    FVSCPort=${StrPort}  \
    FilterVlcSendCmd     ) ; 
   local StrDate; 
   local IntStartTimer;
   local IntStopTimer;
   local IntTTimer ; 
   local IntSleepCalc ; 
   local StrMsg ;
   
   
   local -a ArrayMsgTpl  ;
   ### This tiny array avoid re-calling the StartSlewAnalysis many time
   ### inside the main loop and slowing the application . 
   ArrayMsgTpl[0]=$( StartSlewAnalysis --get ArrayMsg[3] ) ; 
   ArrayMsgTpl[1]=$( StartSlewAnalysis --get ArrayMsg[4] ) ; 
   ArrayMsgTpl[2]=$( StartSlewAnalysis --get ArrayMsg[5] ) ; 
   
   
   while [ -f ${StrPathLoopState} ] ; do 
    ### GODFormat="%Y%m%d %H:%M:%S" GODShowEvalCmd=False GODShowParsing=False GODShowVersion=False GODVerbose=False GetOtherDate
    IntStartTimer=${SECONDS} ; 
    StrDate=$( /bin/date +"%Y%m%d %H:%M:%S" ) ; 
    StrMsg=${ArrayMsgTpl[0]} ; 
    StrMsg=${StrMsg//__DATE__/${StrDate}} ; 
    StrMsg=${StrMsg//__DUR__/${IntSleep}} ; 
   
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-INFO" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ;
    
    ###Don't really need to replace this command by FilterVlcSendCmd, it
    ### gather the content in the /dev/null, so no filtering required. 
    VSCCmd="seek 0" VSCAddr=127.0.0.1 VSCPort=5083 VlcSendCmd 2>&1> /dev/null  ; 
    IntStopTimer=${SECONDS};
    IntTTimer=$(( ${IntStopTimer} - ${IntStartTimer} )) ;
    IntSleepCalc=$(( ${IntSleep}-${IntTTimer} )) ; 
    
    StrMsg=${ArrayMsgTpl[1]} ; 
    StrMsg=${StrMsg//__TIMER__/${IntTTimer}} ; 
    StrMsg=${StrMsg//__SLEEP__/${IntSleepCalc}} ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-INFO" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ;
    /bin/sleep ${IntSleepCalc} ;
    
    local IntStartCmd=${SECONDS} ; 
    local IntCurrent=$( FVSCTypeFilter=Int FVSCCmd="get_time" FVSCAddr=${StrAddr} FVSCPort=${StrPort}  FilterVlcSendCmd ) ;

    local IntStopCmd=${SECONDS} ; 
    local IntTTime=$(( ${IntStopCmd}-${IntStartCmd} )) ;
    
    local IntSeekEnd=$(( ${IntCurrent} - ${IntTTime} )) ; 
    local IntSlewRateSec=$(( ${IntSleep} - ${IntSeekEnd} )) ; 
    
    StrMsg=${ArrayMsgTpl[2]} ;
    StrMsg=${StrMsg//__SLEEP__/${IntSleep}} ;  
    StrMsg=${StrMsg//__RWD__/${IntSeekEnd}} ;  
    StrMsg=${StrMsg//__LATENCY__/${IntTTime}} ;  
    StrMsg=${StrMsg//__SLEW_SEC__/${IntSlewRateSec}} ;  
    StrMsg=${StrMsg//__DUR__/${IntSleep}} ;  
  
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-INFO" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ;
   done   
  }  
   
   local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrStopSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
   local StrNameHelper="StartSlewAnalysis\t\tApplication to verify and use Network services of VLCServer/OldVLCServer.";
   local StrSummary="" ; 
   local StrSynopsis="";
   local StrDescription="" ;
   
   
   if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    ### GVRIsName set to True is the Variable handled StrNameHelper by GetVarReference and 
    ### provide a Name-Helper inside the live-documentation if we call StartSlewAnalysis --help.
    ### Extending the help by turning other variable to True will increae help. Variable are
    ### declared previously. 
    GVRIsName=True     \
    GVRIsSummary=False  \
    GVRIsSynopsis=False \
    GVRIsDesc=False     \
    GetVarReference ${__call_locality[1]} ; 
    echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
   elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
    eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
    echo -ne """${ArgGet}\n""" ;
   elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
    eval $( __GetVarReferenceList ) ;	
   elif [ "${Arg0:=--startservices}" == "--stopservices" ] ; then 
    eval $( eval \
      VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      VTVIsWhiteList=True         \
      VTVWhiteListTransfert=UUID  \
      ValueToVariable ) __main_StopServices ; 
   elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
    if [ "${BoolShowVersion:=False}" == "True" ] ; then 
     eval $( eval VersionApps ) ; 
    fi 
    StrMsg=$( StartSlewAnalysis --get ArrayMsg[0] ) ; 
    VerbMsg="${StrMsg}" VerbHeader="${__call_locality[1]}-ENTRY" VerbState=True VerbEvalForm=False VerbFormated=True VerbDev=/dev/stderr  Verbosis ;
    ### This is the main-boot strap and should load __main_StartServices unless 
    ### It receive from prompt a Prefixed-Variable SSAFuncStart=Function. Every
    ### application made from CallArgument does have it's entry in form [SHORT-NAME]Func=${StrStartMain} ;
    eval $( eval \
      VTVIsArrayStyleInsert=True  \
      VTVValueEntry=${StrVarList} \
      VTVIsValueReAssign=True     \
      VTVIsValueToConvert=False   \
      ValueToVariable ) ${StrStartMain} 
   fi 
 }

fi 

### This is also a not Friendly version of VLC-RATE example use to compare
### simple but not easy to handle version. 
### 
unset __old_vlc_rate ; 
function __old_vlc_rate()    
{ 
 local ArrayRateLevel=( ); 
 ### determining the range of random rate. 
 ### VLCCHUNKRATE -> Number of Possible Rate Level inside ArrayRateLevel
 ### And it is not fixed, the application should remain Random-Result returned 
 ### It short, it should sound-like old turn-table having 15-12 or 33 turn and 
 ### should had problem to keep-it constant... Also another suggested reason to
 ### produce this effect, to keep human listening and  having problem to guess
 ### instantly the couple note inside a music... Even by singing in a karaoke
 ### we should ear more the person rather than the voice of the singer.
 
 local IntRandRange=$(( ( ${RANDOM} % ${VLCCHUNKRATE:=30} ) + 1  )) ; 
 local IntRateInsert=0 ; 
 local IntRateGet=0 ;
 local StrRandomFormat="" ; 
 local IntSleep=0 ; 
 local StrAppsClac=${VLCCalculator:=/usr/bin/bc} ; 
 local StrCalculatorCmd=${VLCCalcCmd:=echo \"scale=2 ;__RATE__ / 100\" \| __APPS__} ;
 local StrVLCCmd="${VLCRATECMD:=rate __RATE__}" ; 
 local StrSentCmd="" ;
 local IntHighestRate=${VLCRATEHIGHESTRATE:=100} ;    
 local IntLowestRate=${VLCRATELOWESTRATE:=70};
 local IntSleep=${VLCSleepTime:=5} ; 
 local BoolVerb=${Verbose:=True} ;
 local IntSocketTimeExpr=${VLCSOCKETCLOSESEC:=3} ; 
 local IntTimeCLick=${VLCTIMECLICK:=10000} ; 
 local BoolNCinSubProcess=${VLCNCINSUBPROCESS:=False} ; 
 local StrParserCalcCmd ; 
 local IntRateInsert ; 
 local ArrayMsg=( )
 local StrDisplayHeader="DEBUG" ; 
 ArrayMsg[0]="Nb Item: __ITEM__ , List or range [ __ARRAY__ ] " ;
 ArrayMsg[1]="Rate Fixed to __RATE__, for __SEC__ seconds" ;
 ArrayMsg[2]="Pushing VLC-Cli command:[ __CMD__ ]"
 ArrayMsg[3]="Highest Rate :[ __INT__ ]"
 ArrayMsg[4]="Lowest Rate :[ __INT__ ]"
 ArrayMsg[5]="Period Duration Max :[ __INT__ ]"
 ArrayMsg[6]="Building  __ITEM__ random item(s) " ;
 ArrayMsg[7]="Waiting for __INT__ sec(s)."
 
 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE}
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
			echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
		fi
	}
 
 StrMsg=${ArrayMsg[3]//__INT__/${IntHighestRate}} ;
 VerbMsg=${StrMsg} VerbHeader=${StrDisplayHeader} VerbState=True VerbDev=/dev/stderr Verbosis
 
 StrMsg=${ArrayMsg[4]//__INT__/${IntLowestRate}} ; 
 VerbMsg=${StrMsg} VerbHeader=${StrDisplayHeader} VerbState=True VerbDev=/dev/stderr Verbosis
 
 StrMsg=${ArrayMsg[5]//__INT__/${VLCRATEDURATION}} ; 
 VerbMsg=${StrMsg} VerbHeader=${StrDisplayHeader} VerbState=True VerbDev=/dev/stderr Verbosis

 StrMsg=${ArrayMsg[6]//__ITEM__/${IntRandRange}} ; 
 VerbMsg=${StrMsg} VerbHeader=${StrDisplayHeader} VerbState=True VerbDev=/dev/stderr Verbosis
 
 StrMsg=${ArrayMsg[7]//__INT__/${IntSleep}} ; 
 VerbMsg=${StrMsg} VerbHeader=${StrDisplayHeader} VerbState=True VerbDev=/dev/stderr Verbosis
 sleep ${IntSleep} ; 
 
 ### Create the random-field olding N-range of Possible Rate.  
 local IntX=0;
 while [ ${IntX} -ne ${IntRandRange} ] ; do 
 ### Retreiving for_loop and adding while to control lowest and highest rate. 
 #for (( IntX=0 ; IntX <= ${IntRandRange} ; IntX++ )) ; do 
  IntRateInsert=$(( ${IntHighestRate} - ( ${RANDOM} %  ${IntRandRange} ) )) ;
  ### A Direct convertion of rate 0-100 to 0.0 to 1.0 is performed. 
  if [ ${IntRateInsert} -ge ${IntLowestRate} -a ${IntRateInsert} -le ${IntHighestRate} ] ; then
   ### First we getting a copy of the Parser-Command for calculation ;
   StrParserCalcCmd=${StrCalculatorCmd} ;
   StrParserCalcCmd=${StrParserCalcCmd//__RATE__/${IntRateInsert}} ;
   StrParserCalcCmd=${StrParserCalcCmd//__APPS__/${StrAppsClac}} ;
   StrRateFmt=$( eval "${StrParserCalcCmd}" ) ; 
   ### Old-Version StrRateFmt=$( echo "scale=2 ;${IntRateInsert} / 100" | ${StrAppsClac} ) ;
   ArrayRateLevel[${#ArrayRateLevel[@]}]="${StrRateFmt}" ;  
   ### We do confirm having 2  criteron meet to having a rate not higher than and lower than
   ### we can increase the counter until it meet the Range of selected item. 
   IntX=$(( ${IntX} + 1 )) ; 
  fi
 done  ;
 StrMsg=${ArrayMsg[0]//__ARRAY__/${ArrayRateLevel[@]}}
 StrMsg=${StrMsg//__ITEM__/${#ArrayRateLevel[@]}}
 ### Forced Message
 VerbHeader=${StrDisplayHeader} VerbMsg=${StrMsg} VerbState=True VerbDev=/dev/stderr Verbosis
 
 #echo "List or range [ ${ArrayRateLevel[@]} ] " > /dev/stderr ; 
 local IntTimeInterleave ; 
 local intCountTic ; 
 local IntModulo ;
 local IntStartTimer ; 
 local IntStopTimer ; 
 local IntTTimer=0 ;
 ### Uses of bash ${SECONDS} is shortest device to represent a delay 
 ### since it's produce the number of seconds since the /bin/bash is 
 ### running it's something close to quantum-moment and fastest way 
 ### to rely on time.  
 while [ 1 ] ; do 

  IntModulo=$(( ${RANDOM} % ${#ArrayRateLevel[@]}  ))
  StrMsg="Query Size of Array ArrayRateLevel, get ${#ArrayRateLevel[@]}" ;
  VerbMsg=${StrMsg} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis
  
  StrMsg="Query Random number inside Arrayfr from IntModulo, Item number ${IntModulo} will be choosed " ;
  VerbMsg=${StrMsg} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis
  StrRateGet=${ArrayRateLevel[${IntModulo}]}; 
  
  
  #if [ ${IntRateGet:=100} -ge 100 ] ; then 
  ###StrRandomFormat=$( echo "scale=2 ;${IntRateGet} / 100" | bc ) ;
  ### Previous line required to perform a format where is no longer needed but later option can
  ### perform adaptation.
  StrRandomFormat=${StrRateGet} ; 
  #else
  # StrRandomFormat="0.${IntRateGet}" ;
  #fi 
  IntSleep=$(( ( ${RANDOM} % ${VLCRATEDURATION:=10} ) + 1 )) ; 
  #echo "Rate Fixed to ${StrRandomFormat}, for ${IntSleep} seconds " > /dev/stderr ;  
  StrMsg=${ArrayMsg[1]//__RATE__/${StrRandomFormat}}
  StrMsg=${StrMsg//__SEC__/${IntSleep}}
  ### Forced Message
  VerbHeader=${StrDisplayHeader} VerbMsg=${StrMsg} VerbState=True VerbDev=/dev/stderr Verbosis
  
  StrSentCmd=${StrVLCCmd//__RATE__/${StrRandomFormat}} ; 
  
  StrMsg=${ArrayMsg[2]//__CMD__/${StrSentCmd}}
  ### Forced Message
  VerbHeader=${StrDisplayHeader} VerbMsg=${StrMsg} VerbState=True VerbDev=/dev/stderr Verbosis
  #echo "Pushing VLC-Cli comand:[ ${StrSentCmd} ]" > /dev/stderr ; 
  ### Forced Message
  
  ### Implementing the BASH SECONDS interface:
  ### Since the Variable ${SECONDS} represent the nb-second since the shell is 
  ### open it can be used in a while and a predicate timer of SECONDS + IntSleep 
  ### to let the command being pushed in correct time, replacing the sleep.
  ### this is also good when The push command is a process send in parallel and 
  ### require the Internal command called NC to wait appropriate time to talk2
  ### to the services and not pushing tiny interleave like 3 sec @ .98, 2 sec @ 1.01
  ### and 1 sec @ .90, both instance of 3 sec, 2 and 1  sec will have expired with 
  ### sleep and will push 3 instance opening  the interface. While a while with 
  ### SECONDS + IntSleep will correctly wait. So it supress the sleep having no
  ### chance to caliber from Closing Socket time variable 
  ### (IntSocketTimeExpr) + IntSleep to not represent the real interleave... 
  IntTimeInterleave=$(( ( ${SECONDS} + ${IntSleep} ) - ${IntTTimer} )) ; 
  
  while [ ${IntTimeInterleave} -ge ${SECONDS} ] ; do 
   intCountTic=0;
   for ((intCT=0 ; intCT <= ${IntTimeCLick} ; intCT++ )) ; do 
    let intCountTic=intCountTic+1 ; 
    #intCountTic=$(( ${intCountTic} + 1 )) ;
    ### It supressing the /bin/sleep call which is at least
    ### less external call. Dealing with Tinyer interleave like 
    ### having milliseconds acces require a quantumic variable
    ### operate by bash to update like ${MILLISEC} which is not 
    ### existing actually, having application that master this 
    ### can be kernel module creating device to read from /dev/...
    ### So calibrating the  IntTimeCLick from VLCTIMECLICK and
    ### boosting value from VLCRATEDURATION can be possible. 
    ### Question mind me: Does a simple for command to increase
    ### a counter will turn slower in a higher load-average from  
    ### many call made early by application that voluntary slow
    ### slow your system ?
   done 
  done 
  
  ### Note: 
  ### replacement of '2>&1' by '2>&1>' does : 
  ### suppress all error message but does not remove the fact nc still sending 
  ### 
  ### error message : 
  ###     'nc: getaddrinfo: Servname not supported for ai_socktype' 
  ### 
  ### The message is still valid when a TCP/IP connection is made with to an 
  ### address. Managing it localy with 127.0.0.1 It does having background 
  ### configuration to remove explicit services like resolution name because 
  ### all network configuration made local address exempt of name resolution
  ### layer, making it hard to reduce access time it's common choice for many
  ### internal or virtual/loopback interface but because the information is
  ### sended, we assume it's working . Except nc still bsd/netbsd application
  ### where it's code still depend of presence of such facility. Such method
  ### require to alter the system by altering the resolv.conf, hosts and IP
  ### layer information to tell to nc to not force the resolution. Parameter  
  ### like -n 'seems to be ineffective'. There is some trick like using TOS
  ### where some of them force NC to not add the resolution... question of 
  ### URGENCY we do not spend time to ask to DNS for something URGENT.
  ### 
  ### For the moment expecting having no return error is good for establishing 
  ### a constant connection with know command may reduce the output in debug
  ### ... 
  ### 
  ### Discover parameter -i 'was set to 1' for 'delay time'. Not agreed from
  ### design to be "second" as delay, but __old_vlc_rate invite to understand
  ### sending 1 echo to be one line does not making sense to increase it until 
  ### Sat-Nov-26-2016 ( where at this point myself stand out of problem for ever )
  ### still have to joggle with impaired translation. So called option '-i' using 
  ### an  `echo "help" | nc -i 1 127.0.0.1 5083` Which is my server does not 
  ### transmit the whole help, even `echo "help" | nc 127.0.0.1 5083` with no '-i'
  ### option and buffer is empty with this line Guessing until I get all the help
  ### take '-i 3' and buffer is not empty from previous attempt... but belong to 
  ### help of netcat:
  ### --------------------------------------------------------------------------------------
  ### 
  ### NC(1)                                                  BSD General Commands Manual                                                 NC(1)
  ### 
  ### NAME
  ###      nc  arbitrary TCP and UDP connections and listens
  ### ....
  ###     Many lines not cited  
  ### ....
  ### 
  ### -i interval
  ###    Specifies a delay time interval between lines of text sent and received.  Also causes a delay time between connections to
  ###    multiple ports.
  ### 
  ### --------------------------------------------------------------------------------------
  ### 
  ### It make sensitive to a quantity, it not making 3 seconds every line and not making 
  ### +/- 15 seconds for 60 to 70 lines.... 
  ### - So there is criteron being 'interval between lines of text sent and received' 
  ### is compromising and making less cutted gap during rate-shift. 
  ### 
  ### So the interval is increased and developped a thread with a expiration mechanism based
  ### on bash ${SECONDS}, to analyse latency of connection.
  ### 
  
  ### Added Timer for compensating delay, to be reduced from next while-cycle from this latency.
  ### application can sometimes take 5 to 15 sec to produce the action ( whitout Call_Argument IsUseMRU (Most Recent Unit) 
  ### where is accelerate some application like TagParse to look inside a Hash-field for identical call )
  ### So at this point most of the application is sleep by counting should sonly ensure it sleep for 
  ### it's required time. 
  IntStartTimer=${SECONDS} ; 
  if [ "${BoolNCinSubProcess:=False}" == "True" ] ; then 
    echo "${StrSentCmd}" | nc -i ${IntSocketTimeExpr} -4 -n ${VLCSERVER:=192.168.0.72} ${VLCSRVPORT:=5080}  2>&1> /dev/null & 
  else  
    echo "${StrSentCmd}" | nc -i ${IntSocketTimeExpr} -4 -n ${VLCSERVER:=192.168.0.72} ${VLCSRVPORT:=5080}  2>&1> /dev/null ; 
  fi 
  IntStoptTimer=${SECONDS} ; 
  IntTTimer=$(( ${IntStoptTimer} - ${IntStartTimer} )) ; 
  #sleep ${IntSleep} ; 
 done ; 
  
}
