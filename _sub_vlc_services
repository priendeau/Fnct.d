
unset ActivatSeServerBuffer ; 

function ActivateServerBuffer()
{
 local __call_locality=( ASB ActivateServerBuffer ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart a new FIFO-Buffer Association.\n\t--stopservices\tStop a FIFO-Buffer Association.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 
 local StrFifoDevice=${ASBFIFO:=NONE} ;
 ### Make Symbolink link from UUID-Named fifo to ASBFIFO Name. 
 ### Important for Management and later work with DoCtrlHandler.
 local BoolUUIDNaming=${ABSUUIDSymLink:=False};
 local UUID="XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX" ; 
 local BoolVerbose=${ASBVerbose:=False};
 local IsFifoMode=${ASBFIFOMode:=False} ; 
 local IsFifoContext=${ASBFIFOCtx:=False} ; 
 local StrTestApps=${ASBTestApps:=/usr/bin/test} ; 
 local StrFifoApps=${ASBFIFOApps:=/usr/bin/mkfifo};
 local StrFifoModeParam=${ASBFIFOModParam:=--mode=644};
 local StrFifoCtxParam=${ASBFIFOCtxParam:=--context=USER}
 local StrTestPatrn=${ASBAppsOptPatrn:=__FILE__}
 local StrTestSwitche=${ASBAppsOpt:=-f {StrTestPatrn}} ; 
 local StrCmdFifo="${StrFifoApps} {FIFOMODE} {FIFOCTX} {StrFifoDevice}" ;
 ### UUID Section it's not mandatory and information can come from Shell by
 ### calling with GetULoop=... GetUSeq=... GetUTimeBased=... ActivateServerBuffer 
 ### 

 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local VerboseState=${VerbState:=False} ;
		local ArrayArg=( $* ) ; 
		if [ "${VerboseState:=False}" == "True" ] ; then 
			echo -ne "VERBOSE:[ ${StrMsg} ]\n" > ${StrDevOut} ;
		fi
	}
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 

  local GetUTimeBased=${GetUTimeBased:=True} ; 
  local GetUSeq=${GetUSeq:=1}
  local GetULoop=${GetULoop:=False}
  local ArrayMsg=( ); 
  
  ArrayMsg[0]="New UUID Value issued, UUID:\${UUID} "
  
  if [ "${BoolUUIDNaming:=False}" == "True" ] ; then 
   eval UUID=$( VTVIsArrayStyleInsert=True \
    VTVValueEntry=GetUTimeBased,GetUSeq,GetULoop \
    VTVIsValueReAssign=True  \
    VTVIsValueToConvert=False \
    VTVIsArrayStyleInsert=True \
    ValueToVariable ) GetUUID
    
   eval VerbMsg=${ArrayMsg[0]} VerboseState=${BoolVerbose} Verbosis
  fi

  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=IsFifoMode,StrCmdFifo,StrFifoModeParam,IsFifoContext,StrFifoDevice,StrTestCmd,StrTestPatrn  \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) CreateSocketBuffer
 }
 
 function __main_StopServices()
 {
		local __call_locality=( Main __main_StopServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=  \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) DestroySocketBuffer
 
 }
 
 function CreateSocketBuffer()
 {
		local __call_locality=( CSB CreateSocketBuffer ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  ###IsFifoMode,StrCmdFifo,StrFifoModeParam,IsFifoContext,StrFifoDevice,StrTestCmd,StrTestPatrn,,,,,,,,,,,,
  if [ ${IsFifoMode:=True} == "True" ] ; then 
   StrCmdFifo=${StrCmdFifo//{FIFOMODE}/${StrFifoModeParam}}
  else
   StrCmdFifo=${StrCmdFifo//{FIFOMODE}/}
  fi 

  if [ ${IsFifoContext:=True} == "True" ] ; then 
   StrCmdFifo=${StrCmdFifo//{FIFOCTX}/${StrFifoCtxParam}} ;
  else
   StrCmdFifo=${StrCmdFifo//{FIFOCTX}/} ;
  fi 

  StrCmdFifo=${StrCmdFifo//{StrFifoDevice}/${StrFifoDevice}} ;
  local StrTestCmd="${StrTestApps} ${StrTestSwitche}" ;
  StrTestCmd=${StrTestCmd//{StrTestPatrn}/${StrTestPatrn}} ;
  StrTestCmd=${StrTestCmd/${StrTestPatrn}/${StrFifoDevice}} ;
  
 }
 
 function DestroySocketBuffer()
 {
		local __call_locality=( DSB DestroySocketBuffer ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  
 }
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
  GetVarReference ${__call_locality[1]} ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=IsFifoMode,StrCmdFifo,StrFifoModeParam,IsFifoContext,StrFifoDevice,StrTestCmd,StrTestPatrn \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StartServices
 elif [ "${Arg0:=--stopservices}" == "--stopservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry= \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StopServices
 fi

 
 #eval echo """${StrTestCmd} && rm -f ${StrFifoDevice} && ${StrTestApps} ${StrTestSwitche}-f ${StrFifoDevice} && rm -f ${StrFifoDevice} && mkfifo ${StrFifoDevice}""" ;    
}

unset DoCtrlHandler ;
function DoCtrlHandler()
{
 local __call_locality=( DCH DoCtrlHandler) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 
 local GetUTimeBased=${GetUTimeBased:=True} ; 
 local GetUSeq=${GetUSeq:=1}
 local GetULoop=${GetULoop:=False}
 
 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local VerboseState=${VerbState:=False} ;
		local ArrayArg=( $* ) ; 
		if [ "${VerboseState:=False}" == "True" ] ; then 
			echo -ne "VERBOSE:[ ${StrMsg} ]\n" > ${StrDevOut} ;
		fi
	}

 eval local UUID=$( VTVIsArrayStyleInsert=True \
  VTVValueEntry=GetUTimeBased,GetUSeq,GetULoop \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) GetUUID
  
}

unset VlcServer ;

function VLCServer()
{
 local __call_locality=( VLCS VLCServer ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--stopservices\tStop the application or service side relation.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 
 
 ### Prefixed Variable List
 local StrFifoRoot=${VLCSFIFORoot:=HOME} ;
 local IsFifoRootVar=${VLCSFIFORootVar:=True} 
 local StrFifoName=${VLCSFIFOName:=.vlc-server} ;
 local StrVLCCaller=${VLCSBIN:=\${HOME}/bin/vlc-terminal.sh} ;
 
 ### Loading playlist <--- Depedent of StrVLCCaller and this script verify the playlist parameter --->
 local StrVLCPlayList=${VLCSBINPl:=\${HOME}/Music/playlist_20160606.m3u} ;
 
 
 ### Information toward network / socket transfert 
 ### Example of Socket Handler and it's parameter 
 ### nc -4 -n -k -i 1 -I $((2 * 1024 * 1024)) -l 127.0.1.1 5080 > ${HOME}.vlc-server
 #StrAppsSocket,StrAppsCmdCaller,StrAppsParam,StrAppsBuffer,StrAppsAddrSvr,StrAppsAddrPrt,,,,,,,,,,,,,,,,
 local StrAppsSocket=${VLCSSocketHndlr:=/bin/nc} ;
 local StrAppsCmdCaller=${VLCSSocketCmd:=__APPS__ __PARAM__ -I __BUFFER__ -l __ADDR__ __PORT__} ;
 local StrAppsParam=${VLCSSocketParam:=-4 -n -k -i 1} ;
 local StrAppsBuffer=${VLCSSocketBuffer:=2097152} ;
 local StrAppsAddrSvr=${VLCSSocketAddr:=127.0.1.1} ;
 local StrAppsAddrPrt=${VLCSSocketPort:=5080} ;
 #local =${VLCS:=} ;
 #local =${VLCS:=} ;
 #local =${VLCS:=} ;
 #local =${VLCS:=} ;
 
 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsDisplayFormatted=${VerbFormated:=True} ;
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
     echo -ne "${StrMsg}\n" > ${StrDevOut} ;
   fi 
		fi
	} 
 ### Model : VerbMsg= VerbDev=/dev/stderr VerbState=True VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis

 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrFifoDevice,IsFifoMode,IsFifoContext,StrTestApps,StrFifoApps,StrFifoModeParam,StrFifoCtxParam  \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) ActivateServerBuffer
 }
 
 function __main_StopServices()
 {
		local __call_locality=( Main __main_StopServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
 
 }
 
 
 local StrMsg="" ; 
 local StrFIFODev="" ; 
 ### This section explain how the group 
 ### VLCSFIFORootVar, VLCSFIFORoot, VLCSFIFOName, is handled, 
 ###  
 ### How StrFIFODev Will Be see here to hold the 
 ### Server Services ?
 ###  ------+
 ###        /\
 ###       /  \
 ###      /    \
 ###     /      \
 ###    /        \ 
 ###   / VLCSFIFO \  FALSE
 ###   \  RootVar /----------> Not to be evaluated and hold respectively 
 ###    \ True ? /             StrFIFODev=${StrFifoRoot}/${StrFifoName}
 ###     \      /
 ###      \    /
 ###       \  /
 ###        \/
 ###        |
 ###        | TRUE
 ###        |
 ###        |
 ###        +---------> Evaluate Element like this {StrFifoRoot} is a Variable Name 
 ###                    ${StrFifoName} is the content of the ServerBuffer Name 
 ###                    and StrFIFODev will Hold a [Variable]/[And FifoName Content]
 ###  
 
 if [ ${IsFifoRootVar:=True} == "True" ] ; then 
  eval """StrFIFODev=\$${StrFifoRoot}/${StrFifoName}""" ; 
 else
  StrFIFODev=${StrFifoRoot}/${StrFifoName};
 fi 
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrFifoRoot,IsFifoRootVar,StrFifoName,StrVLCCaller,StrVLCPlayList,StrAppsSocket,StrAppsCmdCaller,StrAppsParam,StrAppsBuffer,StrAppsAddrSvr,StrAppsAddrPrt \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StartServices
 elif [ "${Arg0:=--stopservices}" == "--stopservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrFifoRoot,IsFifoRootVar,StrFifoName,StrVLCCaller,StrVLCPlayList,StrAppsSocket,StrAppsCmdCaller,StrAppsParam,StrAppsBuffer,StrAppsAddrSvr,StrAppsAddrPrt \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StopServices
	fi

 
 ### ---> Final Lines ${StrFIFODev} ; cat /home/maxiste/.vlc-server | ./bin/vlc-terminal.sh /home/maxiste/Music/playlist_20160606.m3u | nc -lk -i 1 -I $((2 * 1024 * 1024)) -p 5080 127.0.0.1 > /home/maxiste/.vlc-server
}

unset __vlc_rate ; 

function __vlc_rate()    
{ 

 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsDisplayFormatted=${VerbFormated:=True} ;
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
     echo -ne "${StrMsg}\n" > ${StrDevOut} ;
   fi 
		fi
	} 
 ### Model : VerbMsg= VerbDev=/dev/stderr VerbState=True VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis

 local StrMsg="" ; 

 local ArrayRateLevel=( ); 
 ### determining the range of random rate. 
 local IntRandRange=$(( ( ${RANDOM} % ${VLCRATE:=30} ) + 1  )) ; 
 local IntRateInsert=0 ; 
 local IntRateGet=0 ;
 local StrRandomFormat="" ; 
 local IntSleep=0 ; 
 local StrVLCCmd="${VLCCLICMD:=rate __RATE__}" ; 
 local StrSentCmd="" ; 
 ### Create the random-field olding N-range of Possible Rate.  
 for (( intx=0 ; intx <= ${IntRandRange} ; intx++ )) ; do 
  IntRateInsert=$(( 100 - ( ${RANDOM} %  ${IntRandRange} ) )) ;
  ArrayRateLevel[${#ArrayRateLevel[@]}]=${IntRateInsert} ;  
 done  ;
 echo "List or range [ ${ArrayRateLevel[@]} ] " > /dev/stderr ; 
 while [ 1 ] ; do 
  IntRateGet=$(( ${ArrayRateLevel[${RANDOM} % ${#ArrayRateLevel[@]}]} )) ; 
  if [ ${IntRateGet:=100} -eq 100 ] ; then 
   StrRandomFormat="1" ;
  else
   StrRandomFormat="0.${IntRateGet}" ;
  fi 
  IntSleep=$(( ( ${RANDOM} % ${VLCRATEDURATION:=10} ) + 1 )) ; 
  echo "Rate Fixed to ${StrRandomFormat}, for ${IntSleep} seconds " > /dev/stderr ;  
  StrSentCmd=${StrVLCCmd//__RATE__/${StrRandomFormat}} ; 
  echo "Pushing cmd:[ ${StrSentCmd} ]" > /dev/stderr ; 
  echo "${StrSentCmd}" | nc ${VLCSERVER:=192.168.0.72} ${VLCSRVPORT:=5080} 2>&1 /dev/null  ; 
  sleep ${IntSleep} ; 
 done ; 
  
}

###
### Old Section, the improvement are previous lines, all the stuff under this comment 
### are port from theses prototypes.
### 

unset OldVLCServer ;
function OldVLCServer()
{
 local __call_locality=( OVLCS OldVLCServer ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 ### vlc-terminal.sh is simply a vlc loading sheet and other meter, replacing 
 ### OVLCSAppsLunch={/usr/bin/vlc OR /usr/local/bin/vlc} can just let use
 ### it for test purposes.
  
 local StrVLCApps=${OVLCSAppsLunch:="""${HOME}/bin/vlc-terminal.sh"""}
 local StrVLCAppsPlaylist=${OVLCSAppsPlaylist:="""${HOME}/Music/playlist_20160606.m3u"""} ; 
 ### It uses /bin/nc inside socket management to receive incoming vlc-cli command and 
 ### /bin/nc is a bind to /bin/nc.openbsd in Linux-Mint Distribution, depend what other 
 ### own ...
 local StrSocketApps=${OVLCSAppsSock:=/bin/nc};
 local StrSocketOption=${OVLCSAppsSockOpt:=-4 -n -k -i 1};
 local StrSocketBufferOption=${OVLCSAppsSockBuffer:=2097152};
 local StrAppsBufferOption=${OVLCSAppsBuffer:=-I};
 local StrAppsListenOption=${OVLCSAppsLiten:=-l}
 local StrSocketAddr=${OVLCSSockAddr:=127.0.1.1};
 local StrSocketPort=${OVLCSSockPort:=5080};
 local BoolDisplayCmdLine=${OVLCDisplayCmd:=False};
 
 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsDisplayFormatted=${VerbFormated:=True} ;
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
     echo -ne "${StrMsg}\n" > ${StrDevOut} ;
   fi 
		fi
	} 
 ### Model : VerbMsg= VerbDev=/dev/stderr VerbState=True VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  ### StrVLCApps,StrVLCAppsPlaylist,StrSocketApps,StrSocketOption,StrAppsBufferOption,StrSocketBufferOption,StrAppsListenOption,StrSocketAddr
  test -f ${HOME}/.vlc-server && rm -f ${HOME}/.vlc-server  ; 
  test ! -f ${HOME}/.vlc-server && mkfifo ${HOME}/.vlc-server ; 
  
  local StrCmd="""cat ${HOME}/.vlc-server | \
  ${StrVLCApps} ${StrVLCAppsPlaylist} | \
  ${StrSocketApps} ${StrSocketOption} \
  ${StrAppsBufferOption} ${StrSocketBufferOption} \
  ${StrAppsListenOption} ${StrSocketAddr} ${StrSocketPort} > ${HOME}/.vlc-server """ ; 
  
  VerbMsg=${StrCmd} VerbDev=/dev/stderr VerbState=${BoolDisplayCmdLine} VerbFormated=True VerbHeader="CMDLINE" Verbosis  
  $( eval "${StrCmd}" ) ; 
  
 }
 
 function __main_StopServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  echo -ne "\n\n\tLike you see there is an application to destroy and socket to stop.\nStay tuned to see how we can manage it with CtrlHandler methodology.\n\n" ; 
 }
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=BoolDisplayCmdLine,StrVLCApps,StrVLCAppsPlaylist,StrSocketApps,StrSocketOption,StrAppsBufferOption,StrSocketBufferOption,StrAppsListenOption,StrSocketAddr \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StartServices
 elif [ "${Arg0:=--stopservices}" == "--stopservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrVLCApps,StrVLCAppsPlaylist,StrSocketApps,StrSocketOption,StrAppsBufferOption,StrSocketBufferOption,StrAppsListenOption,StrSocketAddr \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StopServices
 fi

}

unset __old_vlc_rate ; 
function __old_vlc_rate()    
{ 
 local ArrayRateLevel=( ); 
 ### determining the range of random rate. 
 ### VLCCHUNKRATE -> Number of Possible Rate Level inside ArrayRateLevel
 ### And it is not fixed, the application should remain Random-Result returned 
 ### It short, it should sound-like old turn-table having 15-12 or 33 turn and 
 ### should had problem to keep-it constant... Also another suggested reason to
 ### produce this effect, to keep human listening and  having problem to guess
 ### instantly the couple note inside a music... Even by singing in a karaoke
 ### we should ear more the person rather than the voice of the singer.
 
 local IntRandRange=$(( ( ${RANDOM} % ${VLCCHUNKRATE:=30} ) + 1  )) ; 
 local IntRateInsert=0 ; 
 local IntRateGet=0 ;
 local StrRandomFormat="" ; 
 local IntSleep=0 ; 
 local StrVLCCmd="${VLCRATECMD:=rate __RATE__}" ; 
 local StrSentCmd="" ;
 local IntHighestRate=${VLCRATEHIGHESTRATE:=100} ;    
 local IntLowestRate=${VLCRATELOWESTRATE:=70};
 local BoolVerb=${Verbose:=True} ;
 local ArrayMsg=( )
 local StrDisplayHeader="DEBUG" ; 
 ArrayMsg[0]="List or range [ __ARRAY__ ], Nb Item: __ITEM__" ;
 ArrayMsg[1]="Rate Fixed to __RATE__, for __SEC__ seconds" ;
 ArrayMsg[2]="Pushing VLC-Cli command:[ __CMD__ ]"
 ArrayMsg[3]="Highest Rate :[ __INT__ ]"
 ArrayMsg[4]="Lowest Rate :[ __INT__ ]"
 
 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE}
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
			echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
		fi
	}
 
 ### Create the random-field olding N-range of Possible Rate.  
 intx=0;
 StrMsg=${ArrayMsg[3]//__INT__/${IntHighestRate}} ;
 VerbHeader=${StrDisplayHeader} VerbMsg=${StrMsg} VerbState=True VerbDev=/dev/stderr Verbosis
 
 StrMsg=${ArrayMsg[4]//__INT__/${IntLowestRate}} ; 
 VerbHeader=${StrDisplayHeader} VerbMsg=${StrMsg} VerbState=True VerbDev=/dev/stderr Verbosis
 while [ ${intx} -ne ${IntRandRange} ] ; do 
 ### Retreiving for_loop and adding while to control lowest and highest rate. 
 #for (( intx=0 ; intx <= ${IntRandRange} ; intx++ )) ; do 
  IntRateInsert=$(( ${IntHighestRate} - ( ${RANDOM} %  ${IntRandRange} ) )) ;
  ### A Direct convertion of rate 0-100 to 0.0 to 1.0 is performed. 
  if [ ${IntRateInsert} -ge ${IntLowestRate} -a ${IntRateInsert} -le ${IntHighestRate} ] ; then 
   StrRateFmt=$( echo "scale=2 ;${IntRateInsert} / 100" | bc ) ;
   ArrayRateLevel[${#ArrayRateLevel[@]}]="${StrRateFmt}" ;  
   intx=$(( ${intx} + 1 )) ; 
  fi
 done  ;
 StrMsg=${ArrayMsg[0]//__ARRAY__/${ArrayRateLevel[@]}}
 StrMsg=${StrMsg//__ITEM__/${#ArrayRateLevel[@]}}
 ### Forced Message
 VerbHeader=${StrDisplayHeader} VerbMsg=${StrMsg} VerbState=True VerbDev=/dev/stderr Verbosis
 #echo "List or range [ ${ArrayRateLevel[@]} ] " > /dev/stderr ; 
 while [ 1 ] ; do 

  local IntModulo=$(( ${RANDOM} % ${#ArrayRateLevel[@]}  ))
  StrMsg="Query Size of Array ArrayRateLevel, get ${#ArrayRateLevel[@]}" ;
  VerbMsg=${StrMsg} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis
  
  StrMsg="Query Random number inside Arrayfr from IntModulo, Item number ${IntModulo} will be choosed " ;
  VerbMsg=${StrMsg} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis
  StrRateGet=${ArrayRateLevel[${IntModulo}]}; 
  
  
  #if [ ${IntRateGet:=100} -ge 100 ] ; then 
  ###StrRandomFormat=$( echo "scale=2 ;${IntRateGet} / 100" | bc ) ;
  ### Previous line required to perform a format where is no longer needed but later option can
  ### perform adaptation.
  StrRandomFormat=${StrRateGet} ; 
  #else
  # StrRandomFormat="0.${IntRateGet}" ;
  #fi 
  IntSleep=$(( ( ${RANDOM} % ${VLCRATEDURATION:=10} ) + 1 )) ; 
  #echo "Rate Fixed to ${StrRandomFormat}, for ${IntSleep} seconds " > /dev/stderr ;  
  StrMsg=${ArrayMsg[1]//__RATE__/${StrRandomFormat}}
  StrMsg=${StrMsg//__SEC__/${IntSleep}}
  ### Forced Message
  VerbHeader=${StrDisplayHeader} VerbMsg=${StrMsg} VerbState=True VerbDev=/dev/stderr Verbosis
  
  StrSentCmd=${StrVLCCmd//__RATE__/${StrRandomFormat}} ; 
  
  StrMsg=${ArrayMsg[2]//__CMD__/${StrSentCmd}}
  ### Forced Message
  VerbHeader=${StrDisplayHeader} VerbMsg=${StrMsg} VerbState=True VerbDev=/dev/stderr Verbosis
  #echo "Pushing VLC-Cli comand:[ ${StrSentCmd} ]" > /dev/stderr ; 
  ### Forced Message
  echo "${StrSentCmd}" | nc -4 -n ${VLCSERVER:=192.168.0.72} ${VLCSRVPORT:=5080}  2>&1 /dev/null  ; 
  sleep ${IntSleep} ; 
 done ; 
  
}
