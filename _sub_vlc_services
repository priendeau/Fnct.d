#!/bin/bash

# Package _sub_vlc_services

unset ActivatSeServerBuffer ; 

function ActivateServerBuffer()
{
 local __call_locality=( ASB ActivateServerBuffer ) ;
 local ArrayArg=( $* ) ; 
 local Arg0=${ArrayArg[0]} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart a new FIFO-Buffer Association.\n\t--stopservices\tStop a FIFO-Buffer Association.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 
 local StrFifoDevice=${ASBFIFO:=NONE} ;
 ### Make Symbolink link from UUID-Named fifo to ASBFIFO Name. 
 ### Important for Management and later work with DoCtrlHandler.
 local BoolUUIDNaming=${ABSUUIDSymLink:=False};
 local UUID="XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX" ; 
 local BoolVerbose=${ASBVerbose:=False};
 local IsFifoMode=${ASBFIFOMode:=False} ; 
 local IsFifoContext=${ASBFIFOCtx:=False} ; 
 local StrTestApps=${ASBTestApps:=/usr/bin/test} ; 
 local StrFifoApps=${ASBFIFOApps:=/usr/bin/mkfifo};
 local StrFifoModeParam=${ASBFIFOModParam:=--mode=644};
 local StrFifoCtxParam=${ASBFIFOCtxParam:=--context=USER}
 local StrTestPatrn=${ASBAppsOptPatrn:=__FILE__}
 local StrTestSwitche=${ASBAppsOpt:=-f {StrTestPatrn}} ; 
 local StrCmdFifo="${StrFifoApps} {FIFOMODE} {FIFOCTX} {StrFifoDevice}" ;
 ### UUID Section it's not mandatory and information can come from Shell by
 ### calling with GetULoop=... GetUSeq=... GetUTimeBased=... ActivateServerBuffer 
 ### 

 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local VerboseState=${VerbState:=False} ;
		local ArrayArg=( $* ) ; 
		if [ "${VerboseState:=False}" == "True" ] ; then 
			echo -ne "VERBOSE:[ ${StrMsg} ]\n" > ${StrDevOut} ;
		fi
	}
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 

  local GetUTimeBased=${GetUTimeBased:=True} ; 
  local GetUSeq=${GetUSeq:=1}
  local GetULoop=${GetULoop:=False}
  local ArrayMsg=( ); 
  
  ArrayMsg[0]="New UUID Value issued, UUID:\${UUID} "
  
  if [ "${BoolUUIDNaming:=False}" == "True" ] ; then 
   eval UUID=$( VTVIsArrayStyleInsert=True \
    VTVValueEntry=GetUTimeBased,GetUSeq,GetULoop \
    VTVIsValueReAssign=True  \
    VTVIsValueToConvert=False \
    VTVIsArrayStyleInsert=True \
    ValueToVariable ) GetUUID
    
   eval VerbMsg=${ArrayMsg[0]} VerboseState=${BoolVerbose} Verbosis
  fi

  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=IsFifoMode,StrCmdFifo,StrFifoModeParam,IsFifoContext,StrFifoDevice,StrTestCmd,StrTestPatrn  \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) CreateSocketBuffer
 }
 
 function __main_StopServices()
 {
		local __call_locality=( Main __main_StopServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=  \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) DestroySocketBuffer
 
 }
 
 function CreateSocketBuffer()
 {
		local __call_locality=( CSB CreateSocketBuffer ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  ###IsFifoMode,StrCmdFifo,StrFifoModeParam,IsFifoContext,StrFifoDevice,StrTestCmd,StrTestPatrn,,,,,,,,,,,,
  if [ ${IsFifoMode:=True} == "True" ] ; then 
   StrCmdFifo=${StrCmdFifo//{FIFOMODE}/${StrFifoModeParam}}
  else
   StrCmdFifo=${StrCmdFifo//{FIFOMODE}/}
  fi 

  if [ ${IsFifoContext:=True} == "True" ] ; then 
   StrCmdFifo=${StrCmdFifo//{FIFOCTX}/${StrFifoCtxParam}} ;
  else
   StrCmdFifo=${StrCmdFifo//{FIFOCTX}/} ;
  fi 

  StrCmdFifo=${StrCmdFifo//{StrFifoDevice}/${StrFifoDevice}} ;
  local StrTestCmd="${StrTestApps} ${StrTestSwitche}" ;
  StrTestCmd=${StrTestCmd//{StrTestPatrn}/${StrTestPatrn}} ;
  StrTestCmd=${StrTestCmd/${StrTestPatrn}/${StrFifoDevice}} ;
  
 }
 
 function DestroySocketBuffer()
 {
		local __call_locality=( DSB DestroySocketBuffer ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  
 }
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
  GetVarReference ${__call_locality[1]} ; 
  echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
 elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
  eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
  echo -ne """${ArgGet}\n""" ;
 elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
  eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=IsFifoMode,StrCmdFifo,StrFifoModeParam,IsFifoContext,StrFifoDevice,StrTestCmd,StrTestPatrn \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StartServices
 elif [ "${Arg0:=--stopservices}" == "--stopservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry= \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StopServices
 fi

 
 #eval echo """${StrTestCmd} && rm -f ${StrFifoDevice} && ${StrTestApps} ${StrTestSwitche}-f ${StrFifoDevice} && rm -f ${StrFifoDevice} && mkfifo ${StrFifoDevice}""" ;    
}

unset DoCtrlHandler ;
function DoCtrlHandler()
{
 local __call_locality=( DCH DoCtrlHandler) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 
 local GetUTimeBased=${GetUTimeBased:=True} ; 
 local GetUSeq=${GetUSeq:=1}
 local GetULoop=${GetULoop:=False}
 
 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local VerboseState=${VerbState:=False} ;
		local ArrayArg=( $* ) ; 
		if [ "${VerboseState:=False}" == "True" ] ; then 
			echo -ne "VERBOSE:[ ${StrMsg} ]\n" > ${StrDevOut} ;
		fi
	}

 eval local UUID=$( VTVIsArrayStyleInsert=True \
  VTVValueEntry=GetUTimeBased,GetUSeq,GetULoop \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) GetUUID
  
}

unset VlcServer ;

function VLCServer()
{
 local __call_locality=( VLCS VLCServer ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--stopservices\tStop the application or service side relation.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 
 
 ### Prefixed Variable List
 local StrFifoRoot=${VLCSFIFORoot:=HOME} ;
 local IsFifoRootVar=${VLCSFIFORootVar:=True} 
 local StrFifoName=${VLCSFIFOName:=.vlc-server} ;
 local StrVLCCaller=${VLCSBIN:=\${HOME}/bin/vlc-terminal.sh} ;
 
 ### Loading playlist <--- Depedent of StrVLCCaller and this script verify the playlist parameter --->
 local StrVLCPlayList=${VLCSBINPl:=\${HOME}/Music/playlist_20160606.m3u} ;
 
 
 ### Information toward network / socket transfert 
 ### Example of Socket Handler and it's parameter 
 ### nc -4 -n -k -i 1 -I $((2 * 1024 * 1024)) -l 127.0.1.1 5080 > ${HOME}.vlc-server
 #StrAppsSocket,StrAppsCmdCaller,StrAppsParam,StrAppsBuffer,StrAppsAddrSvr,StrAppsAddrPrt,,,,,,,,,,,,,,,,
 local StrAppsSocket=${VLCSSocketHndlr:=/bin/nc} ;
 local StrAppsCmdCaller=${VLCSSocketCmd:=__APPS__ __PARAM__ -I __BUFFER__ -l __ADDR__ __PORT__} ;
 local StrAppsParam=${VLCSSocketParam:=-4 -n -k -i 1} ;
 local StrAppsBuffer=${VLCSSocketBuffer:=2097152} ;
 local StrAppsAddrSvr=${VLCSSocketAddr:=127.0.1.1} ;
 local StrAppsAddrPrt=${VLCSSocketPort:=5080} ;
 #local =${VLCS:=} ;
 #local =${VLCS:=} ;
 #local =${VLCS:=} ;
 #local =${VLCS:=} ;
 
 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsDisplayFormatted=${VerbFormated:=True} ;
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
     echo -ne "${StrMsg}\n" > ${StrDevOut} ;
   fi 
		fi
	} 
 ### Model : VerbMsg= VerbDev=/dev/stderr VerbState=True VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis

 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrFifoDevice,IsFifoMode,IsFifoContext,StrTestApps,StrFifoApps,StrFifoModeParam,StrFifoCtxParam  \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) ActivateServerBuffer
 }
 
 function __main_StopServices()
 {
		local __call_locality=( Main __main_StopServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
 
 }
 
 
 local StrMsg="" ; 
 local StrFIFODev="" ; 
 ### This section explain how the group 
 ### VLCSFIFORootVar, VLCSFIFORoot, VLCSFIFOName, is handled, 
 ###  
 ### How StrFIFODev Will Be see here to hold the 
 ### Server Services ?
 ###  ------+
 ###        /\
 ###       /  \
 ###      /    \
 ###     /      \
 ###    /        \ 
 ###   / VLCSFIFO \  FALSE
 ###   \  RootVar /----------> Not to be evaluated and hold respectively 
 ###    \ True ? /             StrFIFODev=${StrFifoRoot}/${StrFifoName}
 ###     \      /
 ###      \    /
 ###       \  /
 ###        \/
 ###        |
 ###        | TRUE
 ###        |
 ###        |
 ###        +---------> Evaluate Element like this {StrFifoRoot} is a Variable Name 
 ###                    ${StrFifoName} is the content of the ServerBuffer Name 
 ###                    and StrFIFODev will Hold a [Variable]/[And FifoName Content]
 ###  
 
 if [ ${IsFifoRootVar:=True} == "True" ] ; then 
  eval """StrFIFODev=\$${StrFifoRoot}/${StrFifoName}""" ; 
 else
  StrFIFODev=${StrFifoRoot}/${StrFifoName};
 fi 
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrFifoRoot,IsFifoRootVar,StrFifoName,StrVLCCaller,StrVLCPlayList,StrAppsSocket,StrAppsCmdCaller,StrAppsParam,StrAppsBuffer,StrAppsAddrSvr,StrAppsAddrPrt \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StartServices
 elif [ "${Arg0:=--stopservices}" == "--stopservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrFifoRoot,IsFifoRootVar,StrFifoName,StrVLCCaller,StrVLCPlayList,StrAppsSocket,StrAppsCmdCaller,StrAppsParam,StrAppsBuffer,StrAppsAddrSvr,StrAppsAddrPrt \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StopServices
	fi

 
 ### ---> Final Lines ${StrFIFODev} ; cat /home/maxiste/.vlc-server | ./bin/vlc-terminal.sh /home/maxiste/Music/playlist_20160606.m3u | nc -lk -i 1 -I $((2 * 1024 * 1024)) -p 5080 127.0.0.1 > /home/maxiste/.vlc-server
}

unset __vlc_rate ; 

function __vlc_rate()    
{ 

 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsDisplayFormatted=${VerbFormated:=True} ;
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
     echo -ne "${StrMsg}\n" > ${StrDevOut} ;
   fi 
		fi
	} 
 ### Model : VerbMsg= VerbDev=/dev/stderr VerbState=True VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis

 local StrMsg="" ; 

 local ArrayRateLevel=( ); 
 ### determining the range of random rate. 
 local IntRandRange=$(( ( ${RANDOM} % ${VLCRATE:=30} ) + 1  )) ; 
 local IntRateInsert=0 ; 
 local IntRateGet=0 ;
 local StrRandomFormat="" ; 
 local IntSleep=0 ; 
 local StrVLCCmd="${VLCCLICMD:=rate __RATE__}" ; 
 local StrSentCmd="" ; 
 ### Create the random-field olding N-range of Possible Rate.  
 for (( intx=0 ; intx <= ${IntRandRange} ; intx++ )) ; do 
  IntRateInsert=$(( 100 - ( ${RANDOM} %  ${IntRandRange} ) )) ;
  ArrayRateLevel[${#ArrayRateLevel[@]}]=${IntRateInsert} ;  
 done  ;
 echo "List or range [ ${ArrayRateLevel[@]} ] " > /dev/stderr ; 
 while [ 1 ] ; do 
  IntRateGet=$(( ${ArrayRateLevel[${RANDOM} % ${#ArrayRateLevel[@]}]} )) ; 
  if [ ${IntRateGet:=100} -eq 100 ] ; then 
   StrRandomFormat="1" ;
  else
   StrRandomFormat="0.${IntRateGet}" ;
  fi 
  IntSleep=$(( ( ${RANDOM} % ${VLCRATEDURATION:=10} ) + 1 )) ; 
  echo "Rate Fixed to ${StrRandomFormat}, for ${IntSleep} seconds " > /dev/stderr ;  
  StrSentCmd=${StrVLCCmd//__RATE__/${StrRandomFormat}} ; 
  echo "Pushing cmd:[ ${StrSentCmd} ]" > /dev/stderr ; 
  echo "${StrSentCmd}" | nc ${VLCSERVER:=192.168.0.72} ${VLCSRVPORT:=5080} 2>&1 /dev/null  ; 
  sleep ${IntSleep} ; 
 done ; 
  
}

###
### Old Section, the improvement are previous lines, all the stuff under this comment 
### are port from theses prototypes.
### 

unset OldVLCServer ;
function OldVLCServer()
{
 local __call_locality=( OVLCS OldVLCServer ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 ### vlc-terminal.sh is simply a vlc loading sheet and other meter, replacing 
 ### OVLCSAppsLunch={/usr/bin/vlc OR /usr/local/bin/vlc} can just let use
 ### it for test purposes.
  
 local StrVLCApps=${OVLCSAppsLunch:="""${HOME}/bin/vlc-terminal.sh"""}
 local StrVLCAppsPlaylist=${OVLCSAppsPlaylist:="""${HOME}/Music/playlist_20160606.m3u"""} ; 
 ### It uses /bin/nc inside socket management to receive incoming vlc-cli command and 
 ### /bin/nc is a bind to /bin/nc.openbsd in Linux-Mint Distribution, depend what other 
 ### own ...
 local StrSocketApps=${OVLCSAppsSock:=/bin/nc};
 local StrSocketOption=${OVLCSAppsSockOpt:=-4 -n -k -i 1};
 local StrSocketBufferOption=${OVLCSAppsSockBuffer:=2097152};
 local StrAppsBufferOption=${OVLCSAppsBuffer:=-I};
 local StrAppsListenOption=${OVLCSAppsLiten:=-l}
 local StrSocketAddr=${OVLCSSockAddr:=127.0.1.1};
 local StrSocketPort=${OVLCSSockPort:=5080};
 local BoolDisplayCmdLine=${OVLCDisplayCmd:=False};
 
 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsDisplayFormatted=${VerbFormated:=True} ;
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
     echo -ne "${StrMsg}\n" > ${StrDevOut} ;
   fi 
		fi
	} 
 ### Model : VerbMsg= VerbDev=/dev/stderr VerbState=True VerbFormated=True VerbHeader=${__call_locality[1]} Verbosis
 
 function __main_StartServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  ### StrVLCApps,StrVLCAppsPlaylist,StrSocketApps,StrSocketOption,StrAppsBufferOption,StrSocketBufferOption,StrAppsListenOption,StrSocketAddr
  test -f ${HOME}/.vlc-server && rm -f ${HOME}/.vlc-server  ; 
  test ! -f ${HOME}/.vlc-server && mkfifo ${HOME}/.vlc-server ; 
  
  local StrCmd="""cat ${HOME}/.vlc-server | \
  ${StrVLCApps} ${StrVLCAppsPlaylist} | \
  ${StrSocketApps} ${StrSocketOption} \
  ${StrAppsBufferOption} ${StrSocketBufferOption} \
  ${StrAppsListenOption} ${StrSocketAddr} ${StrSocketPort} > ${HOME}/.vlc-server """ ; 
  
  VerbMsg=${StrCmd} VerbDev=/dev/stderr VerbState=${BoolDisplayCmdLine} VerbFormated=True VerbHeader="CMDLINE" Verbosis  
  $( eval "${StrCmd}" ) ; 
  
 }
 
 function __main_StopServices()
 {
		local __call_locality=( Main __main_StartServices ) ;
		local Arg0=${ArrayArg[0]} ;
		local ArrayArg=( $* ) ; 
  echo -ne "\n\n\tLike you see there is an application to destroy and socket to stop.\nStay tuned to see how we can manage it with CtrlHandler methodology.\n\n" ; 
 }
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=BoolDisplayCmdLine,StrVLCApps,StrVLCAppsPlaylist,StrSocketApps,StrSocketOption,StrAppsBufferOption,StrSocketBufferOption,StrAppsListenOption,StrSocketAddr \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StartServices
 elif [ "${Arg0:=--stopservices}" == "--stopservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=StrVLCApps,StrVLCAppsPlaylist,StrSocketApps,StrSocketOption,StrAppsBufferOption,StrSocketBufferOption,StrAppsListenOption,StrSocketAddr \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StopServices
 fi

}

unset VLCSetVolume ; 
function VLCSetVolume()
{
 function Verbosis()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Verb Verbosis ) ; 
   local Arg0=${ArrayArg[0]} ; 
  elif [ ${versionGPI:=0.0.0} == "0.0.1" ] ; then 
   eval $( CAFunctName=Verbosis CAIsAddParent=False __Call_Argument ) ; 
  elif [ ${versionGPI:=0.0.0} == "0.0.2" ] ; then 
   eval $( CAFunctName=Verbosis CAIsAddParent=False CallArgument ) ; 
  fi 
  local StrMsg=${VerbMsg:=__TEXT__} ; 
  local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
  local IsDisplayFormatted=${VerbFormated:=True} ;
  local IsAppendMode=${VerbAppendDev:=False} ; 
  local ArrayArg=( $* ) ; 
  if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
    if [ "${IsAppendMode:=False}" == "True" ] ; then 
      echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
    else  
      echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
    fi
   else
    if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
       echo "${StrMsg}" ;  
    else
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
      echo "${StrMsg}" >> ${StrDevOut} ;
     else
      echo "${StrMsg}" > ${StrDevOut} ;
     fi
    fi 
   fi 
  fi
 } 
 ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
 
 ### ---TOP-FUNCTION-DECLARATION---
 if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
  local -a ArrayArg=( $* ) ;
  local -a __call_locality=( VLCSV VLCSetVolume ) ;
  local StrParentApps=${__call_locality[1]} ; 
  local StrMainStart=${VLCSVFuncStart:=__main_StartServices} ;  
  local Arg0=${ArrayArg[0]} ; 
 elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
  eval $( CAFunctName=VLCSetVolume CAIsAddParent=False __Call_Argument ) ; 
 elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
  eval $( CAFunctName=VLCSetVolume CAIsAddParent=False CallArgument ) ; 
 fi 
 
 local StrTplZenityVol=${VLCSVTplZenity:="zenity --scale --text=\"__TEXT__\" --value=__VOLUME__ --min-value=__MIN_VOLUME__ --max-value=__MAX_VOLUME__ --step=__VOL_STEP__"} ;
 local StrTplParser=${VLCSVTagParser:=StrTextCLient:__TEXT__,IntVol:__VOLUME__,IntMinVol:__MIN_VOLUME__,IntMaxVol:__MAX_VOLUME__,IntStepVol:__VOL_STEP__,StrAddr:__IP__,IntPort:__PORT__,StrVolCLiCmd:__CLI_CMD__,IntNewVol:__NEWVOL__,StrAppsEcCli:__APPS_EC_OPT__,StrAppsEc:__APPS_EC__} ;
 local StrTextCLient=${VLCSVTextCli:='VLC CLient Volume Indicator'} ;
 local StrVolCLiGetCmd=${VLCSVCliGet:="__APPS_EC__ __PIPE__ __APPS__ __APPS_OPT__ __PIPE__ __FILTER__ __FILTER_OPT__"} ; 
 local StrVolCLiSetCmd=${VLCSVCliSet:="echo volume __PIPE__ __APPS__ __APPS_OPT__ __PIPE__ __FILTER__ __FILTER_OPTS__"} ; 
 local StrAppsEc=${VLCSVCLiePushCmd:=echo \"__APPS_EC_OPT__\"} ;
 local StrAppsEcCli=${VLCSVCLiCmd:=volume} ; 
 local IntMinVol=${VLCSVMinVol:=0} ;
 local IntMaxVol=${VLCSVMaxVol:=500} ;
 local IntStepVol=${VLCSVStepVol:=1} ; 
 local StrAddr=${VLCSVAddr:=127.0.0.1} ; 
 local IntPort=${VLCSVPort:=5083} ; 
 local StrVarList="StrVarList,StrTplZenityVol,StrTplParser,StrTextCLient,StrVolCLiGetCmd,StrVolCLiSetCmd,IntMinVol,IntMaxVol,IntStepVol,StrAddr,IntPort,StrAppsEc,StrAppsEcCli" ; 

  

 function __main_StartServices()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Main __main_StartServices ${StrParentApps} ) ; 
   local Arg0=${ArrayArg[0]} ;   
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) ; 
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) ; 
  fi  
  
  
  #eval $( "CAFunctName=VLCSetVolume CAIsAddParent=True __Call_Argument" ) ; 
  #IntVol=$( echo "volume" | nc 127.0.0.1 5083 | sed 's/[^0-9]*//g' )
  #IntNewVol=$(  zenity --scale --text="VLC CLient Volume Indicator" --value=${IntVol} --min-value=0 --max-value=500 --step=1 ) ;
  #echo "volume ${IntNewVol}" | nc 127.0.0.1 5083
  
  ### New Variable declared for use of GnrlPrsrInfctr #1, and #2
  # local StrCmdGet=${StrVolCLiGetCmd} ;  
  local StrCmdSend ; 
  ### I need to re-copy the StrTplZenityVol and parse the new copy.
  local StrCmdZenity=${StrTplZenityVol} ; 
  
  ### GnrlPrsrInfctr #1, responsible of Getting information from vlc --> StrVolCLiGetCmd
  eval $( eval VTVIsArrayStyleInsert=True \
  VTVValueEntry=${StrVarList}  \
  VTVIsValueReAssign=True      \
  VTVIsValueToConvert=False    \
  VTVIsArrayStyleInsert=True   \
  ValueToVariable ) GPIIsUUIDInstance=True      \
                    GPIIsFileHandlerOut=False   \
                    GPIIsZenityHandlerOut=True  \
                    GPIIsExecuteEval=True       \
                    GPIIsGenerateCode=False     \
                    GPIDisplayDebug=True        \
                    GPIParserDebug=True         \
                    GPITpl="${StrVolCLiGetCmd}" \
                    GPIApps=/bin/nc             \
                    GPIAppsOpt='${StrAddr} ${IntPort}' \
                    GPITagFeeder="${StrTplParser}"     \
                    GPIFilterApps='/bin/sed'           \
                    GPIFilterOpt='s/[^0-9]*//g'        \
                    GPITagParserResult='StrCmdGet'     \
                    GnrlPrsrInfctr ;
  
  VerbMsg="StrCmdGet:${StrCmdGet}, reference:UUID:${UUID}" VerbHeader="${__call_locality[0]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
  
  ### GnrlPrsrInfctr #1, responsible of Setting information for vlc --> StrVolCLiGetCmd
  ### Because IntNewVol is a new member it require to be injected on the QueryList or 
  ### using ValueToVariable can do this task. 
  
  ### Since I do need to set the volume value, it require the GUI action from Zenity
  ### to set the desired variable. I do require to parse with TagPArser the Zenity 
  ### Command, using the StrTplParser the same from GnrlPrsrInfctr #1, and #2. 
  #eval eval TPVarNameParsed="StrCmdZenity"               \
  #     TPListTag="${StrTplParser}"                       \
  #     TPIsMatchRtoL=True                                \
  #     TPDisplayParserNotice=True                        \
  #     TPDisplayDebug=True                               \
  #     TPArrayName="Array${__call_locality[0]}Tag"       \
  #     TagParser ;
  
  #VerbMsg="StrCmdZenity:${StrCmdZenity}" VerbHeader="${__call_locality[0]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis ; 
             
  #eval $( VTVIsArrayStyleInsert=True \
  #VTVValueEntry=IntNewVol \
  #VTVIsValueReAssign=True  \
  #VTVIsValueToConvert=False \
  #VTVIsArrayStyleInsert=True \
  #ValueToVariable ) GPIIsUUIDInstance=True \
  #                  GPIIsFileHandlerOut=True \
  #                  GPIIsExecuteEval=True \
  #                  GPIIsGenerateCode=False \
  #                  GPIParserDebug=True \
  #                  GPITpl="${StrVolCLiSetCmd}" \
  #                  GPIApps=/bin/nc \
  #                  GPIAppsOpt='${StrAddr} ${IntPort}' \
  #                  GPITagFeeder="${StrTplParser}" \
  #                  GPITagParserResult='StrCmdSend' \
  #                  GnrlPrsrInfctr  ; 

  #VerbMsg="StrCmdSend:${StrCmdSend}, reference:UUID:${UUID}" VerbHeader="${__call_locality[0]}-CMDLINE" VerbEvalForm=False VerbFormated=True VerbState=True StrDevOut=/dev/stderr  Verbosis ; 
  
 
 }
 
 function __main_StopServices()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local -a ArrayArg=( $* ) ;
   local -a __call_locality=( Main __main_StopServices ${StrParentApps} ) ; 
   local Arg0=${ArrayArg[0]} ;   
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( CAFunctName=__main_StopServices CAIsAddParent=True __Call_Argument ) ; 
  elif [ ${versionGPI:=0.0.0} == "0.0.2" ] ; then 
   eval $( CAFunctName=__main_StopServices CAIsAddParent=True CallArgument ) ; 
  fi  
  #eval $( "CAFunctName=VLCSetVolume CAIsAddParent=True __Call_Argument" ) ; 
  
 }
 
 
 if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
 elif [ "${Arg0:=--stopservices}" == "--stopservices" ] ; then 
  eval $( VTVIsArrayStyleInsert=True \
  VTVValueEntry=${StrVarList} \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) __main_StopServices  ; 
 elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  StrMsg="Function __FUNCT__, version versionCA=__VER_CA__, versionGPI=__VER_GPI__, versionTP=__VER_TP__" ; 
  StrMsg=${StrMsg//__FUNCT__/${StrParentApps}} ; 
  StrMsg=${StrMsg//__VER_TP__/${versionTP}} ; 
  StrMsg=${StrMsg//__VER_CA__/${versionCA}} ; 
  StrMsg=${StrMsg//__VER_GPI__/${versionGPI}} ; 
  VerbMsg="${StrMsg}" VerbHeader="LOADER" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
  eval $( eval VTVIsArrayStyleInsert=True \
  VTVValueEntry=${StrVarList} \
  VTVIsValueReAssign=True  \
  VTVIsValueToConvert=False \
  VTVIsArrayStyleInsert=True \
  ValueToVariable ) ${StrStartMain} ; 
 fi
 
 
}

### This is also a not Friendly version of VLC-RATE example use to compare
### simple but not easy to handle version. 
### 
unset __old_vlc_rate ; 
function __old_vlc_rate()    
{ 
 local ArrayRateLevel=( ); 
 ### determining the range of random rate. 
 ### VLCCHUNKRATE -> Number of Possible Rate Level inside ArrayRateLevel
 ### And it is not fixed, the application should remain Random-Result returned 
 ### It short, it should sound-like old turn-table having 15-12 or 33 turn and 
 ### should had problem to keep-it constant... Also another suggested reason to
 ### produce this effect, to keep human listening and  having problem to guess
 ### instantly the couple note inside a music... Even by singing in a karaoke
 ### we should ear more the person rather than the voice of the singer.
 
 local IntRandRange=$(( ( ${RANDOM} % ${VLCCHUNKRATE:=30} ) + 1  )) ; 
 local IntRateInsert=0 ; 
 local IntRateGet=0 ;
 local StrRandomFormat="" ; 
 local IntSleep=0 ; 
 local StrAppsClac=${VLCCalculator:=/usr/bin/bc} ; 
 local StrCalculatorCmd=${VLCCalcCmd:=echo \"scale=2 ;__RATE__ / 100\" \| __APPS__} ;
 local StrVLCCmd="${VLCRATECMD:=rate __RATE__}" ; 
 local StrSentCmd="" ;
 local IntHighestRate=${VLCRATEHIGHESTRATE:=100} ;    
 local IntLowestRate=${VLCRATELOWESTRATE:=70};
 local BoolVerb=${Verbose:=True} ;
 local StrParserCalcCmd ; 
 local IntRateInsert ; 
 local ArrayMsg=( )
 local StrDisplayHeader="DEBUG" ; 
 ArrayMsg[0]="Nb Item: __ITEM__ , List or range [ __ARRAY__ ] " ;
 ArrayMsg[1]="Rate Fixed to __RATE__, for __SEC__ seconds" ;
 ArrayMsg[2]="Pushing VLC-Cli command:[ __CMD__ ]"
 ArrayMsg[3]="Highest Rate :[ __INT__ ]"
 ArrayMsg[4]="Lowest Rate :[ __INT__ ]"
 ArrayMsg[5]="Period Duration Max :[ __INT__ ]"
 
 function Verbosis()
	{
		local __call_locality=( Verbosis Verb );
		local StrMsg=${VerbMsg:=__TEXT__} ; 
		local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE}
		local ArrayArg=( $* ) ; 
		if [ "${IsVerboseState:=False}" == "True" ] ; then 
			echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
		fi
	}
 
 ### Create the random-field olding N-range of Possible Rate.  
 intx=0;
 StrMsg=${ArrayMsg[3]//__INT__/${IntHighestRate}} ;
 VerbHeader=${StrDisplayHeader} VerbMsg=${StrMsg} VerbState=True VerbDev=/dev/stderr Verbosis
 
 StrMsg=${ArrayMsg[4]//__INT__/${IntLowestRate}} ; 
 VerbHeader=${StrDisplayHeader} VerbMsg=${StrMsg} VerbState=True VerbDev=/dev/stderr Verbosis
 
 StrMsg=${ArrayMsg[5]//__INT__/${VLCRATEDURATION}} ; 
 VerbHeader=${StrDisplayHeader} VerbMsg=${StrMsg} VerbState=True VerbDev=/dev/stderr Verbosis

 while [ ${intx} -ne ${IntRandRange} ] ; do 
 ### Retreiving for_loop and adding while to control lowest and highest rate. 
 #for (( intx=0 ; intx <= ${IntRandRange} ; intx++ )) ; do 
  IntRateInsert=$(( ${IntHighestRate} - ( ${RANDOM} %  ${IntRandRange} ) )) ;
  ### A Direct convertion of rate 0-100 to 0.0 to 1.0 is performed. 
  if [ ${IntRateInsert} -ge ${IntLowestRate} -a ${IntRateInsert} -le ${IntHighestRate} ] ; then
   ### First we getting a copy of the Parser-Command for calculation ;
   StrParserCalcCmd=${StrCalculatorCmd} ;
   StrParserCalcCmd=${StrParserCalcCmd//__RATE__/${IntRateInsert}} ;
   StrParserCalcCmd=${StrParserCalcCmd//__APPS__/${StrAppsClac}} ;
   StrRateFmt=$( eval "${StrParserCalcCmd}" ) ; 
   ### Old-Version StrRateFmt=$( echo "scale=2 ;${IntRateInsert} / 100" | ${StrAppsClac} ) ;
   ArrayRateLevel[${#ArrayRateLevel[@]}]="${StrRateFmt}" ;  
   ### We do confirm having 2  criteron meet to having a rate not higher than and lower than
   ### we can increase the counter until it meet the Range of selected item. 
   intx=$(( ${intx} + 1 )) ; 
  fi
 done  ;
 StrMsg=${ArrayMsg[0]//__ARRAY__/${ArrayRateLevel[@]}}
 StrMsg=${StrMsg//__ITEM__/${#ArrayRateLevel[@]}}
 ### Forced Message
 VerbHeader=${StrDisplayHeader} VerbMsg=${StrMsg} VerbState=True VerbDev=/dev/stderr Verbosis
 
 sleep 2 ; 
 #echo "List or range [ ${ArrayRateLevel[@]} ] " > /dev/stderr ; 
 while [ 1 ] ; do 

  local IntModulo=$(( ${RANDOM} % ${#ArrayRateLevel[@]}  ))
  StrMsg="Query Size of Array ArrayRateLevel, get ${#ArrayRateLevel[@]}" ;
  VerbMsg=${StrMsg} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis
  
  StrMsg="Query Random number inside Arrayfr from IntModulo, Item number ${IntModulo} will be choosed " ;
  VerbMsg=${StrMsg} VerbState=${BoolVerb} VerbDev=/dev/stderr Verbosis
  StrRateGet=${ArrayRateLevel[${IntModulo}]}; 
  
  
  #if [ ${IntRateGet:=100} -ge 100 ] ; then 
  ###StrRandomFormat=$( echo "scale=2 ;${IntRateGet} / 100" | bc ) ;
  ### Previous line required to perform a format where is no longer needed but later option can
  ### perform adaptation.
  StrRandomFormat=${StrRateGet} ; 
  #else
  # StrRandomFormat="0.${IntRateGet}" ;
  #fi 
  IntSleep=$(( ( ${RANDOM} % ${VLCRATEDURATION:=10} ) + 1 )) ; 
  #echo "Rate Fixed to ${StrRandomFormat}, for ${IntSleep} seconds " > /dev/stderr ;  
  StrMsg=${ArrayMsg[1]//__RATE__/${StrRandomFormat}}
  StrMsg=${StrMsg//__SEC__/${IntSleep}}
  ### Forced Message
  VerbHeader=${StrDisplayHeader} VerbMsg=${StrMsg} VerbState=True VerbDev=/dev/stderr Verbosis
  
  StrSentCmd=${StrVLCCmd//__RATE__/${StrRandomFormat}} ; 
  
  StrMsg=${ArrayMsg[2]//__CMD__/${StrSentCmd}}
  ### Forced Message
  VerbHeader=${StrDisplayHeader} VerbMsg=${StrMsg} VerbState=True VerbDev=/dev/stderr Verbosis
  #echo "Pushing VLC-Cli comand:[ ${StrSentCmd} ]" > /dev/stderr ; 
  ### Forced Message
  echo "${StrSentCmd}" | nc -4 -n ${VLCSERVER:=192.168.0.72} ${VLCSRVPORT:=5080}  2>&1 /dev/null  ; 
  sleep ${IntSleep} ; 
 done ; 
  
}
