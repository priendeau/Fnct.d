# . /etc/init.d/Fnct.d/fnct_debian_lib
# Package _sub_PackageRepository

### Yet Another Debian package Mangler and backup-management. 
### 
### It basically move actual Debian package from archive /var/cache/apt/archives
### some-where else like /media/COMST500GB/Linux-Debian/archives/Mint-14_x86-64...
### or some NFS mounted point or any mounted partition dedicated to save or backup... 
### - It create an index of the day, inside the Destination.
###  - The index file is in a new directory of the destination, calling it Destination/index
###  - The index file-name is named on the today date or on the day executed by the manager. 
###  - The index used to drop Package into destination are accounted and the index hold 
###  - the beginnign of the transfert. 
###  - Index day used can be changed thru PkgRepoMgmtReposIndexDay, but the time of the transaction
###    remain unchanged... look weird, but may have some goal .... 
###   - Variable PkgRepoMgmtReposIndex change the Index destination. 
### 
### The Action. 
### It's A loop inside the archives, a move to the destination and a link is done between them 
### - to remain somewhat active, or become inacessible if the mount is down... not bad for nfs
### mounting detection or lazy mount with economic transfert mode while having no reason
### to leave it mounted until you need to get some update or removing stuff. 
### If the management from APT, dpkg, gdebi remove the package, it give silent error to 
### remove something not being a file but link, but are not following the source... 
### Being serious with this action, PkgRepoMgmtReposBkpAct can change the Action. 
### 
### basically work like this :
### [ cmd1 __VIRG__ cmd2 ... ] 
### 
### cmd1 should include at least 
### __SRC__ tag , it transform it into proper destication  called __DEST__ 
### __FILE__ is critical and mandatory, it loop the command and turn __FILE__ into every item to be backuped 
### 
### - __VIRG__ tag is an hack, It's required when more then one command is called, it change in into ';' . 
### ex : PkgRepoMgmtReposBkpAct="scp  __SRC__/__FILE__ root@domainname:/__DEST__ __VIRG__ rm -f __SRC__/__FILE__" PackageRepositoryMgmt
### - transfert by scp a file from Debian packages from /var/cache/apt/archives and remove it. 
### 
### 
### ... So basically, this guys had a spade in hand and Spell it: 'I.B.M.' ;) from 1901, I should live long 
### enought to work there or know what they are doing... 
### 

######################################################################
### Main Function of PackageRepositoryMgmt function
###
### Extruding the function GetDpkgInstalled out of GetIdDpkgListing
### While I was designing the GnrlPrsrInfctr or GeneralParserInfrastructure out of
### this sample from GetDpkgInstalled. I do apply uses of ValueToVAriable to this 
### _sub_PackageRepository and crafting the rest in prototyping to deliver 
###  GnrlPrsrInfctr.... 

unset GetDpkgInstalled ; 
function GetDpkgInstalled()
{
 function Verbosis()
 {
  local __call_locality=( Verbosis Verb );
  local StrMsg=${VerbMsg:=__TEXT__} ; 
  local StrDevOut=${VerbDev:=/dev/stderr} ; 
  local IsVerboseState=${VerbState:=False} ;
  local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
  local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
  local IsDisplayFormatted=${VerbFormated:=True} ;
  local ArrayArg=( $* ) ; 
  if [ "${IsVerboseState:=False}" == "True" ] ; then 
   if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
    echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
   else
    if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
     echo "${StrMsg}" ;  
    else
     echo "${StrMsg}" > ${StrDevOut} ;
    fi 
   fi 
  fi
 } ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis   
 
 if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
  local __call_locality=( GDI GetDpkgInstalled ) ;
  local ArrayArg=( $* ) ;
  local Arg0=${ArrayArg[0]} ; 
  local StrParentApps=${__call_locality[1]} ;
  local StrStartMain=${GDIFuncStart:=__main_StartServices} ;
 elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
  eval $( eval CAFunctName=GetDpkgInstalled CAIsAddParent=False __Call_Argument ) :  
 elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
  eval $( eval CAFunctName=GetDpkgInstalled CAIsAddParent=False CallArgument ) :  
 fi 
 local StrApps=${GDIDpkgApps:=/usr/bin/dpkg} ;
 local StrAppsOpt=${GDIDpkgAppsOpt:=--get-selections} ; 
 local StrFilterApps=${GDIFilterApps:=/usr/bin/gawk} ;
 local StrFilterOpt=${GDIFilterOpt:=-f __FILE__} ; 
 local StrParserResult=${GDITagParserResult:=StrCmd} ; 
 local BoolDisplayDebug=${GDIIsDisplayDebug:=False} ; 
 local StrVarList="BoolDisplayDebug,StrVarList,StrStartMain,StrParentApps,StrParserResult,StrAwkScript,StrAppsTemplate,StrApps,StrAppsOpt,StrFilterApps,StrFilterOpt,StrParserTag" ; 
 
  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local __call_locality=( Main __main_StartServices ) ;
    local ArrayArg=( $* ) ;
    local Arg0=${ArrayArg[0]} ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) :  
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) :  
   fi 
   StrMsg="Entry in function" ; 
   VerbMsg=${StrMsg} VerbHeader="DEBUG-${__call_locality[1]}" VerbEvalForm=False VerbFormated=True VerbState=${GDIIsDisplayDebug} VerbDev=/dev/stderr  Verbosis  ; 
   
   local StrMsg; 
   StrMsg="Awk-Script file: __FILE__" ; 
   StrMsg=${StrMsg//__FILE__/${StrAwkScript}} ; 
   VerbMsg=${StrMsg} VerbHeader="DEBUG-${__call_locality[1]}" VerbEvalForm=False VerbFormated=True VerbState=${GDIIsDisplayDebug} VerbDev=/dev/stderr  Verbosis  ;
   
   StrMsg="Information Variable Topo:\nStrAwkScript: ${StrAwkScript}\nStrApps: ${StrApps}\nStrAppsOpt: ${StrAppsOpt}\n" ; 
   VerbMsg=${StrMsg} VerbHeader="DEBUG-${__call_locality[1]}" VerbEvalForm=False VerbFormated=True VerbState=${GDIIsDisplayDebug} VerbDev=/dev/stderr  Verbosis  ;
   
   ###  at this moment configuration of StrCmdA is struggled somewhere because even the 
   ### UUID is not available after the execution. 
   eval $( eval VTVIsArrayStyleInsert=True \
        VTVValueEntry=${StrVarList}   \
        VTVIsValueReAssign=True       \
        VTVIsValueToConvert=False     \
        VTVIsArrayStyleInsert=True    \
        ValueToVariable ) $( eval \
                          GPITagParserResult="StrCmdA" \
                          GPIIsUUIDInstance=True \
                          GPIFileName=${StrAwkScript} \
                          GPIDpkgApps=${StrApps} \
                          GPIDpkgAppsOpt=\"${StrAppsOpt}\" \
                          GPIFilterApps=${StrFilterApps} \
                          GPIFilterOpt=\"${StrFilterOpt}\" \
                          GPIIsGenerateCode=True \
                          GPIIsExecuteEval=False \
                          GPIIsZenityHandlerOut=False \
                          GPIIsFileHandlerOut=True \
                          GPIRepoCreatEnabled=True \
                          GPIRepositoryCreation=True \
                          GPIFuncStart=__main_StartServices \
                          GPIDisplayDebug=${GDIIsDisplayDebug} \
                          GPIParserDebug=${GDIIsDisplayDebug} \
                          GnrlPrsrInfctr )  ;
   
   ### GPITagParserResult=StrParserResult 
   #StrMsg="GnrlPrsrInfctr cmdline: __CMD__" ;
   #StrMsg=${StrMsg//__CMD__/${StrCmdLineGnr}}
   #VerbMsg=${StrMsg} VerbHeader="DEBUG-${__call_locality[1]}" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis  ;
   #eval $( "${StrCmdLineGnr}" ) ; 
  
   StrMsg="Cmd-line: from variable StrCmdA:(__CMD__), UUID information repository:(__UUID__)" ; 
   StrMsg=${StrMsg//__CMD__/${StrCmdA}} ; 
   StrMsg=${StrMsg//__UUID__/${UUID}} ; 
   
   VerbMsg=${StrMsg} VerbHeader="CMDLINE-${__call_locality[1]}" VerbEvalForm=False VerbFormated=True VerbState=${GDIIsDisplayDebug} VerbDev=/dev/stderr  Verbosis  ;
   
  } 
  
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  
  
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GVRIsName=False     \
   GVRIsSynopsis=False \
   GVRIsSummary=False  \
   GVRIsDesc=False     \
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( __GetVarReferenceList ) ;	
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
   ### This variable can not be inside  the first block it require to pass
   ### by the Main function or it will query itself when a getter will be 
   ### called . 
   local StrAwkScript=$( PackageRepositoryMngmt --get PRMReposAwkLst ) ; 
   StrMsg="__FUNCT__ version versionTP=__VER_TP__, versionCA=__VER_CA__, versionGPI=__VER_GPI__" ; 
   StrMsg=${StrMsg//__FUNCT__/${__call_locality[1]}} ; 
   StrMsg=${StrMsg//__VER_CA__/${versionCA}} ; 
   StrMsg=${StrMsg//__VER_TP__/${versionTP}} ; 
   StrMsg=${StrMsg//__VER_GPI__/${versionGPI}} ; 
   VerbMsg="${StrMsg}" VerbHeader="VERSION" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 

   eval $( eval VTVIsArrayStyleInsert=True \
        VTVValueEntry=${StrVarList}   \
        VTVIsValueReAssign=True       \
        VTVIsValueToConvert=False     \
        VTVIsArrayStyleInsert=True    \
        ValueToVariable ) ${StrStartMain} ; 
  fi
}
 

 #########################################################################
 ###### Part of Snapshoot section 
 ######
 
 unset GetIdDpkgListing ; 
 function GetIdDpkgListing()
 {
  ### This is a specialized Verbosis mode :
  ###  
  ###  All condition required to set VerbState=True 
  ###  All condition required to set a message with VerbMsg=STRING
  ###  
  ###  
  ### It can be used to :
  ###  - Echo result to be passed throught Value Result .
  ###  Required :
  ###  VerbEvalForm=True VerbFormated=False 
  ###  
  ###  VerbHeader Is ineffective
  ###  
  ### -Echo result can be append to file and not overwriting the content: 
  ###  Required ;
  ###  VerbFormated=False/True VerbAppendDev=True VerbDev=[ FILENAME | UUID ]
  ###  - Appending to file also required to be unique-file were no instance of 
  ###  Verbosis may point on same-file or loss of log will be CERTAIN.
  ###  -Pointing to Same-Destination require a lock Mechanism which is 
  ###  not implemented here
  ###  
  function Verbosis()
  {
   #eval $( CAFunctName=Verbosis CAIsAddParent=False __Call_Argument ) ; 
   local -a ArrayArg=( $* ) ; 
   local -a __call_locality=( Verb Verbosis )
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
        echo "${StrMsg}" ;  
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo "${StrMsg}" >> ${StrDevOut} ;
      else
       echo "${StrMsg}" > ${StrDevOut} ;
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis

  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local __call_locality=( GIDL GetIdDpkgListing ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]} ; 
   local StrParentApps=${__call_locality[1]} ;
   local StrStartMain=${GIDLFuncStart:=__main_StartServices} ;
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=GetIdDpkgListing CAIsAddParent=False __Call_Argument ) :  
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=GetIdDpkgListing CAIsAddParent=False CallArgument ) :  
  fi   
  local StrPackageID=${GIDLPackageUUID:=DefaultID} ;
  local StrTransactionStart=${GIDLPackageStartID:=DefaultStartID} ;
  local StrFileIndex=${GIDLFileIndex:=DefautlFileIndex} ;
  local StrTplSnap=${GIDLTplSnapshoot:="ADD SNAPSHOT\nDATE:__TRANSACTION_START__:ID:__PACKAGE_ID__\n"} ; 
  local StrTplList=${GIDLTplList:="ID of listing:__PACKAGE_ID__\n"} ; 
  local StrID=${StrSnapShotUUID} ; 
  local BoolDisplayDebug=${GIDLIsDebugDisplay:=False} ; 
  local StrVarList="StrPackageID,StrTplSnap,StrTplList,StrID,StrVarList,BoolDisplayDebug,StrTransactionStart" ;
   
  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local __call_locality=( Main __main_StartServices ) ;
    local ArrayArg=( $* ) ;
    local Arg0=${ArrayArg[0]} ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) :  
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) :  
   fi   
   StrTplSnap=${StrTplSnap//__TRANSACTION_START__/${StrTransactionStart}} ; 
   StrTplSnap=${StrTplSnap//__PACKAGE_ID__/${StrPackageID}} ; 
   StrTplList=${StrTplList//__PACKAGE_ID__/${StrPackageID}} ; 

   ### Send information on /dev/stderr ; 
   #echo -ne "ID of listing:${StrPackageID}\n"  > /dev/stderr ;   
   VerbMsg=${StrTplList} VerbHeader="DEBUG-${__call_locality[1]}" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis   ; 
   
   ### Send information on File-Log ; 
   #echo -ne "ADD SNAPSHOT\nDATE:${StrTransactionStart}:ID:${StrPackageID}\n" >> ${StrIndexFile} ; 
   VerbMsg=${StrTplSnap} VerbDev=${StrIndexFile} VerbEvalForm=False VerbAppendDev=True  VerbFormated=False VerbState=True Verbosis   ; 

  }
  
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  
  
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GVRIsName=False     \
   GVRIsSynopsis=False \
   GVRIsSummary=False  \
   GVRIsDesc=False     \
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( __GetVarReferenceList ) ;	
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  StrMsg="__FUNCT__ version versionTP=__VER_TP__, versionCA=__VER_CA__, versionGPI=__VER_GPI__" ; 
  StrMsg=${StrMsg//__FUNCT__/${__call_locality[1]}} ; 
  StrMsg=${StrMsg//__VER_CA__/${versionCA}} ; 
  StrMsg=${StrMsg//__VER_TP__/${versionTP}} ; 
  StrMsg=${StrMsg//__VER_GPI__/${versionGPI}} ; 
  VerbMsg="${StrMsg}" VerbHeader="VERSION" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
  eval $( eval VTVIsArrayStyleInsert=True \
       VTVValueEntry=${StrVarList}   \
       VTVIsValueReAssign=True       \
       VTVIsValueToConvert=False     \
       VTVIsArrayStyleInsert=True    \
       ValueToVariable ) ${StrStartMain} ; 
 fi

 }
 
 unset StreamCprEnvlTxt ; 
 function StreamCprEnvlTxt()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local __call_locality=( SCET StreamCprEnvlTxt ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]} ; 
   local StrParentApps=${__call_locality[1]} ;
   local StrStartMain=${SCETFuncStart:=__main_StartServices} ;
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=StreamCprEnvlTxt CAIsAddParent=False __Call_Argument ) :  
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=StreamCprEnvlTxt CAIsAddParent=False CallArgument ) :  
  fi   
  #local __call_locality=( StreamCET StreamCprEnvlTxt ) ;
  #local Arg0=( ${ArrayArg[0]} ) ;
  #local ArrayArg=( $* ) ; 
  #local StrPackageID=${StreamCETPackageUUID:=None} GetIdDpkgListing=${StrSnapShotUUID}
  ### Note Prefixed-Change : StreamCprEnvlTxtFile -> SCETTxtFile
  local StrFile=${SCETTxtFile:=DefaultFileName};
  local StrApps=${SCETApps:=/bin/bzip2} ; 
  local StrAppsOpt=${SCETAppsOpt:="-9z"}
  local StrFilterApps=${SCETFilterApps:=/usr/bin/base64} ; 
  local StrFilterOpt=${SCETFilterOpt:="--wrap=0"} ; 
  local StrTpl=${SCETTemplate:="__APPS__ __APPS_OPT__ __PIPE__ __FILTER__ __FILTER_OPT__ > __FILE__"} ; 
  local BoolDisplayDebug=${GIDLIsDebugDisplay:=False} ; 
  local StrVarList="StrFile,StrApps,StrAppsOpt,StrFilterApps,StrFilterOpt,BoolDisplayDebug,StrVarList" ;
   
  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local __call_locality=( Main __main_StartServices ) ;
    local ArrayArg=( $* ) ;
    local Arg0=${ArrayArg[0]} ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) :  
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) :  
   fi
   local StrDefaultVTVOpt="VTVIsArrayStyleInsert=True VTVIsValueReAssign=True VTVIsValueToConvert=False VTVIsArrayStyleInsert=True" ; 
   local StrDefaultGPIOpt="GPIIsUUIDInstance=True GPIIsGenerateCode=True GPIIsExecuteEval=False GPIIsZenityHandlerOut=False GPIIsFileHandlerOut=True GPIFuncStart=__main_StartServices GPIRepoCreatEnabled=True GPIRepositoryCreation=True"
   eval $( eval VTVValueEntry=${StrVarList} \
        ${StrDefaultVTVOpt} ValueToVariable ) $( eval      \
                          ${StrDefaultGPIOpt}              \
                          GPITpl="${StrTpl}" \
                          GPITagParserResult="StrCmdA"     \
                          GPIFileName=${StrFile}           \
                          GPIDpkgApps=${StrApps}           \
                          GPIDpkgAppsOpt=\"${StrAppsOpt}\" \
                          GPIFilterApps=${StrFilterApps}   \
                          GPIFilterOpt=\"${StrFilterOpt}\" \
                          GPIDisplayDebug=${BoolDisplayDebug} \
                          GPIParserDebug=${BoolDisplayDebug}  \
                          GnrlPrsrInfctr )  ; 
   ### __APPS__ __APPS_OPT__ __PIPE__ __FILTER__ __FILTER_OPT__ > __FILE__
   ###  bzip2   -9z          |        /usr/bin/base64     
   ###                                           --wrap=0       > ${StrFile} ;
  }
  
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GVRIsName=False     \
   GVRIsSynopsis=False \
   GVRIsSummary=False  \
   GVRIsDesc=False     \
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( __GetVarReferenceList ) ;	
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  StrMsg="__FUNCT__ version versionTP=__VER_TP__, versionCA=__VER_CA__, versionGPI=__VER_GPI__" ; 
  StrMsg=${StrMsg//__FUNCT__/${__call_locality[1]}} ; 
  StrMsg=${StrMsg//__VER_CA__/${versionCA}} ; 
  StrMsg=${StrMsg//__VER_TP__/${versionTP}} ; 
  StrMsg=${StrMsg//__VER_GPI__/${versionGPI}} ; 
  VerbMsg="${StrMsg}" VerbHeader="VERSION" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
  eval $( eval VTVIsArrayStyleInsert=True \
       VTVValueEntry=${StrVarList}   \
       VTVIsValueReAssign=True       \
       VTVIsValueToConvert=False     \
       VTVIsArrayStyleInsert=True    \
       ValueToVariable ) ${StrStartMain} ; 
 fi   
 }	
  
 unset GetDpkgListing ; 
 function GetDpkgListing()
 {
  function Verbosis()
    {
     #eval $( CAFunctName=Verbosis CAIsAddParent=False __Call_Argument ) ; 
     local -a ArrayArg=( $* ) ; 
     local -a __call_locality=( Verb Verbosis )
     local StrMsg=${VerbMsg:=__TEXT__} ; 
     local StrDevOut=${VerbDev:=/dev/stderr} ; 
     local IsVerboseState=${VerbState:=False} ;
     local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
     local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
     local IsDisplayFormatted=${VerbFormated:=True} ;
     local IsAppendMode=${VerbAppendDev:=False} ; 
     if [ "${IsVerboseState:=False}" == "True" ] ; then 
      if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
       if [ "${IsAppendMode:=False}" == "True" ] ; then 
         echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
       else  
         echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
       fi
      else
       if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
          echo "${StrMsg}" ;  
       else
        if [ "${IsAppendMode:=False}" == "True" ] ; then 
         echo "${StrMsg}" >> ${StrDevOut} ;
        else
         echo "${StrMsg}" > ${StrDevOut} ;
        fi
       fi 
      fi 
     fi
    } 
    ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
  
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local __call_locality=( GDL GetDpkgListing ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]} ; 
   local StrParentApps=${__call_locality[1]} ;
   local StrStartMain=${GDLFuncStart:=__main_StartServices} ;
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=GetDpkgListing CAIsAddParent=False __Call_Argument ) :  
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=GetDpkgListing CAIsAddParent=False CallArgument ) :  
  fi   
  ### Note 
  ### Transfert from External=>Root,StrSnapShotUUID inside GetDpkgListing, with same name. 
  #local __call_locality=( GetDpkgLst GetPackageListing ) ;
  #local ArrayArg=( $* ) ; 
  #local Arg0=( ${ArrayArg[0]} ) ;
  #local GetDpkgInstalledAwkScript=${StrScriptAwkFilter} ; 
  local StrDefaultVTVOpt=${GDLVTVOpt:="VTVIsArrayStyleInsert=True VTVIsValueReAssign=True VTVIsValueToConvert=False VTVIsArrayStyleInsert=True"} ; 
  local StrDefaultGPIOpt=${GDLGPIOpt:="GPIIsUUIDInstance=True GPIIsGenerateCode=True GPIIsExecuteEval=False GPIIsZenityHandlerOut=False GPIIsFileHandlerOut=True GPIFuncStart=__main_StartServices GPIRepoCreatEnabled=True GPIRepositoryCreation=True"} ; 
  local StrTransactionStart=${GDLPackageStartID:=DefaultStartID} ;
  local StrReposIndex=${GDLRepositoryPath:=DefaultRepositoryIndexPath} ; 
  local StrPkgLstExt=${GDLPkgLstExt:=DefaultPkgListExt} ;
  local StrFileIndex=${GDLFileIndex:=DefautlFileIndex} ;  
  local StrSnapUUID=${GDLSnapShootUUID:=DefaultSnapShootUUID} ; 
  local StrPackageID=${GDLPackageUUID:=DefaultID} ;
  local StrVarList="StrScriptAwkFilter,StrDefaultVTVOpt,StrDefaultGPIOpt,StrTransactionStart,StrFileIndex,StrPkgLstExt,StrSnapUUID,StrPackageID"
 
  function __main_StartServices()
  {
   if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
    local __call_locality=( Main __main_StartServices ) ;
    local ArrayArg=( $* ) ;
    local Arg0=${ArrayArg[0]} ; 
   elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) :  
   elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
    eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) :  
   fi  
   local StrId=$( GIDLPackageUUID=${StrPackageID}           \
                  GIDLFileIndex=${StrFileIndex}             \
                  GIDLPackageStartID=${StrTransactionStart} \
                  GetIdDpkgListing ) ; 
   local StrStreamIndexFile=${StrPathReposIndex}/${StrSnapUUID}.${StrPkgLstExt} ; 
   #GetDpkgInstalledAwkScript=${StrScriptAwkFilter} GetDpkgInstalled                                       | \
   #                          StrPkgLstExt=${StrPkgLstExt}                                                 \
   #                          StreamCprEnvlTxtFile=${StrPathReposIndex}/${StrSnapShotUUID}.${StrPkgLstExt} \
   #                          StreamCprEnvlTxt  ; 
   GetDpkgInstalledAwkScript=$( GetDpkgInstalled   | \
                             SCETApps=/bin/bzip2 SCETAppsOpt="-9z" StrPkgLstExt=${StrPkgLstExt} ) | \
                             SCETTxtFile=${StrStreamIndexFile} StreamCprEnvlTxt  ;
   local StrSHASnap=$( sha1sum --binary ${StrPathReposIndex}/${StrId}.${StrPkgLstExt} | cut -d ' ' -f 1 ) 
   echo -ne "ShaSUM of snapshot, ID:${StrId} SHA:${StrSHASnap}\n" > /dev/stderr ; 
   echo -ne "SNAPSHOT:SHA1SUM:${StrSHASnap}\nSNAPSHOT END\n" >> ${StrIndexFile} ; 
  }
  
  local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
  
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
   GVRIsName=False     \
   GVRIsSynopsis=False \
   GVRIsSummary=False  \
   GVRIsDesc=False     \
   GetVarReference ${__call_locality[1]} ; 
   echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( __GetVarReferenceList ) ;	
  elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  StrMsg="__FUNCT__ version versionTP=__VER_TP__, versionCA=__VER_CA__, versionGPI=__VER_GPI__" ; 
  StrMsg=${StrMsg//__FUNCT__/${__call_locality[1]}} ; 
  StrMsg=${StrMsg//__VER_CA__/${versionCA}} ; 
  StrMsg=${StrMsg//__VER_TP__/${versionTP}} ; 
  StrMsg=${StrMsg//__VER_GPI__/${versionGPI}} ; 
  VerbMsg="${StrMsg}" VerbHeader="VERSION" VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis ; 
  local StrScriptAwkFilter=$( PackageRepositoryMngmt --get PRMReposAwkLst ) ;
  eval $( eval VTVIsArrayStyleInsert=True \
       VTVValueEntry=${StrVarList}   \
       VTVIsValueReAssign=True       \
       VTVIsValueToConvert=False     \
       VTVIsArrayStyleInsert=True    \
       ValueToVariable ) ${StrStartMain} ; 
 fi    
 }
  
 unset GetPackageList ; 
 function GetPackageList()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local __call_locality=( GPL GetPackageList ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]} ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=TestPathIndex CAIsAddParent=False __Call_Argument ) :  
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=TestPathIndex CAIsAddParent=False CallArgument ) :  
  fi   
  
  #local __call_locality=( GetPackageList ) ;
  #local ArrayArg=( $* ) ; 
  #local Arg0=( ${ArrayArg[0]} ) ;
  local StrPathArchives=${GetPackageListPathArchives:=/var/cache/apt/archives} ; 
  local StrPackageType=${GetPackageListFormat:=deb} ;
  local StrDisplayOutput="${GetPackageListStringFormat:='%f '}" ;
  local ArrayFileList=( $( find ${StrPathArchives} -maxdepth 1 -type f -iname "*.${StrPackageType}" -printf "${StrDisplayOutput}" ) ) ; 
  local IntLenFileList=${#ArrayFileList[@]} ;
  if [ ${IntLenFileList:=0} -gt 0 ] ; then 
   echo "${ArrayFileList[@]}" ; 
   return 0 ; 
  else
   echo "None" ;
   return 1 ; 
  fi
 }
  
 ###### End of Snapshoot section 
 ######
 #########################################################################

 #########################################################################
 ###### Part of TestDriveMount section 
 ######
 unset TestPathIndex ; 
 function TestPathIndex()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local __call_locality=( TPI TestPathIndex ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]} ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=TestPathIndex CAIsAddParent=False __Call_Argument ) :  
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=TestPathIndex CAIsAddParent=False CallArgument ) :  
  fi   
  
  #local __call_locality=( TestPathIndex ) ;
  #local ArrayArg=( $* ) ; 
  #local Arg0=( ${ArrayArg[0]} ) ;
  local StrPathTest=${TestPathIndexName:=/media/COMST500GB/Linux-Debian/archives/Mint-14_x86-64/index} ; 
  local StrTestType="${TestPathIndexTest:=! -d}" ;
  local StrTestResultAction="${TestPathIndexResultAction:=mkdir -p __PATH__}" ;
  test ${StrTestType} ${StrPathReposIndex} && ${StrTestResultAction//__PATH__/${StrPathReposIndex}} ;
 }	


 unset TestDriveMount ; 
 function TestDriveMount()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local __call_locality=( TDM TestDriveMount ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]} ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=TestDriveMount CAIsAddParent=False __Call_Argument ) :  
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=TestDriveMount CAIsAddParent=False CallArgument ) :  
  fi   
  
  #local __call_locality=( TestDriveMount ) ; 
  #local ArrayArg=( $* ) ; 
  #local Arg0=( ${ArrayArg[0]} ) ;
  local IsMountDrive="True";
  local StrScopeType="${TestDriveMountScope:=local -a}";
  local StrDriveList="${TestDriveMountList}";
  local MountDriveCheck=( ${StrDriveList//,/ } ) ;
  local IsDisplayDebug=${TestDriveMountDebug:=False} ;
  local Arg0="${ArrayArg[0]}" ;
  local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n--list\t\tReturn Internal Variable List.\n" 
  if [ "${Arg0:=--startservices}" == "--help"	] ; then 
    GetVarReference ${__call_locality[0]} ; 
    echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
  elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
   eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
   echo -ne """${ArgGet}\n""" ;
  elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
   eval $( __GetVarReferenceList ) ;
  else
   for (( intx=0 ; intx <= ${#MountDriveCheck[@]}-1 ; intx++ )) ; do
    if [ "${IsDisplayDebug:=False}" == "True" ] ; then 
     echo -ne "Checking Path: ${MountDriveCheck[${intx}]}\n" > /dev/stderr ; 
    fi
    test ! -d "${MountDriveCheck[${intx}]}" && IsMountDrive="False" ;
   done 
   if [ "${IsMountDrive:=True}" == "False" ] ; then 
    echo -ne "\nCheck Variable PkgRepoMgmtRepository,PkgRepoMgmtPathArchives, some Path are inaccessible or not mounted\n" > /dev/stderr ; 
   fi 
   echo -ne "${StrScopeType} IsMountDrive=${IsMountDrive}" ; 
  fi 
 }
 ###### End of TestDriveMount section 
 ######
 #########################################################################

### End of Main Function of PackageRepositoryMgmt function
###
######################################################################



### Document : 
### 
### Note : 2224fe88-0b6f-11e3-812b-001b3875b29c 
### 
### Title : Using Alias from Bash to replace setter and 
###         permanent Assignation in Prefixed-var . 
### 
### - An efficient way to replace Setter or active method to replace
### Variable value from Prefixed-Var, using alias from shell enhance 
### and allow in a simple .bashrc changing repository of 
### PackageRepositoryMgmt, PackageRepositoryRest ... 
### 
### While not acknoledged Bug from GetVarReference to filter a function
### directly by using declare -f __FUNCTION__, the --help will display 
### original internal Value of Prefixed var, uses of Getter with --get
### will show you actual value including uses of alias. 
### 
### ex:
### simple PackageRepositoryMgmt --help will show for variable 
### PkgRepoMgmtRepository 
###     => 
###        value: /media/COMST500GB/Linux-Debian/archives/Mint-14_x86-64
### 
### - It's original design, developped under Mint-14_x86-64 realm, today
### need evolute and required another Distribution like Mint-15_x86-64
### - Also, using PackageRepositoryMgmt --get PkgRepoMgmtRepository 
### will show you similar value... 
### 
### Except: 
### - using following line imply having made another repository using 
### Mint-15_x86-64 
###   or 
### /media/COMST500GB/Linux-Debian/archives/Mint-15_x86-64/UnderscoreXDevlpt-001
### - Include possibility to use a Level Higher because Acer-One-Travel is also 
### - hook to this drive for feeding the repository of other package where this one
### depend of Radeon and OpenCL infrastructure to made simple uses of GPU during
### my leasure time... ( if it exist... )
### 
### Using Alias...
### Known to be a rubber-knife not depending from variable, but fixed informations
### alias allow rewrite call from command line and Shell execution as well. 
### 
### - To be really important to inspect alias-sanity before doing a script to 
### manage a Server, some doing extra verboses from this aliasing technique and
### generating excess of informations and sometime it reduce filtering 
### possibilities and anhilate uses of grep, sed and awk ... 
### 
### Assuming uses of alias is know, we can attach everyting to an allias.
### - simple prefixed-Var
### - test and execution on $? -eq 0 or 1 deppending how test was involved:
### ex: 
###   alias echo='test -e ${USER}/.echo_right && echo'
###     -> this powerfull thruth involve having impossibility to do an echo
###     on a terminal assuming .echo_right might be a deposed file from 
###     root-priviledge and can not be erased, it allow-you to echo on terminal.
### 
###  using alias : 
### 
###  alias PackageRepositoryMgmt='PkgRepoMgmtAddPkgLst=True \
###        PkgRepoMgmtRepository=/media/COMST500GB/Linux-Debian/archives/Mint-15_x86-64/UnderscoreXDevlpt-001 \
###        PkgRepoMgmtReposIndex=/media/COMST500GB/Linux-Debian/archives/Mint-15_x86-64/UnderscoreXDevlpt-001/index \
###        PackageRepositoryMgmt'
### 
###  - Effect on PackageRepositoryMgmt --help 
###       -> PkgRepoMgmtRepository will continue to show :
### 
###          /media/COMST500GB/Linux-Debian/archives/Mint-14_x86-64
### 
###  - effect on PackageRepositoryMgmt --get PkgRepoMgmtRepository
###   will show : 
###    
###          /media/COMST500GB/Linux-Debian/archives/Mint-15_x86-64/UnderscoreXDevlpt-001
### 
###      - Which is the correct value... 
### 
### 
### Of course a complex case of managing creation with md_cd will imply a test
### and result to a permanent verification of Repository path with :
### 
### 
### NewIndexRepository=/media/COMST500GB/Linux-Debian/archives/Mint-15_x86-64/UnderscoreXDevlpt-001/index
### NewRepository=/media/COMST500GB/Linux-Debian/archives/Mint-15_x86-64/UnderscoreXDevlpt-001
### 
### alias PackageRepositoryMgmt='test -e  $( PkgRepoMgmtReposIndex=${NewIndexRepository} PackageRepositoryMgmt --get PkgRepoMgmtReposIndex ) && /etc/init.d/Fnct.d/md_cd $( PkgRepoMgmtReposIndex=${NewIndexRepository} PackageRepositoryMgmt --get PkgRepoMgmtReposIndex ) && PkgRepoMgmtAddPkgLst=True PkgRepoMgmtRepository=${NewRepository} PkgRepoMgmtReposIndex=${NewIndexRepository} PackageRepositoryMgmt'
### 
### - This case is also exceptionnal, Attempting to use the variable without having new declaration of it thru uses of get might cumbershot the call 
### - But next uses of PackageRepositoryMgmt will not depend of 
###   PkgRepoMgmtReposIndex and PkgRepoMgmtRepository anymore .
### 

### Notice with old function name : PackageRepositoryMgmt did not return any
### Short-name aka the Prefixed-Name with function/application GetStdPrefixName
### which is an exception. Instead of adding inside the map-name PackageRepositoryMgmt:PRM
### or actual prefixed choosed PkgRepoMgm, I do change the function name for PackageRepositoryMngmt
### and stay an exception for this case... 
### 
### 
unset PackageRepositoryMngmt ; 

function PackageRepositoryMngmt()
{
  ### This is a specialized Verbosis mode :
  ###  
  ###  All condition required to set VerbState=True 
  ###  All condition required to set a message with VerbMsg=STRING
  ###  
  ###  
  ### It can be used to :
  ###  - Echo result to be passed throught Value Result .
  ###  Required :
  ###  VerbEvalForm=True VerbFormated=False 
  ###  
  ###  VerbHeader Is ineffective
  ###  
  ### -Echo result can be append to file and not overwriting the content: 
  ###  Required ;
  ###  VerbFormated=False/True VerbAppendDev=True VerbDev=[ FILENAME | UUID ]
  ###  - Appending to file also required to be unique-file were no instance of 
  ###  Verbosis may point on same-file or loss of log will be CERTAIN.
  ###  -Pointing to Same-Destination require a lock Mechanism which is 
  ###  not implemented here
  ###  
  function Verbosis()
  {
   #eval $( CAFunctName=Verbosis CAIsAddParent=False __Call_Argument ) ; 
   local -a ArrayArg=( $* ) ; 
   local -a __call_locality=( Verb Verbosis )
   local StrMsg=${VerbMsg:=__TEXT__} ; 
   local StrDevOut=${VerbDev:=/dev/stderr} ; 
   local IsVerboseState=${VerbState:=False} ;
   local StrVerboseHeader=${VerbHeader:=VERBOSE} ;
   local IsEvalRequiredForm=${VerbEvalForm:=False} ; 
   local IsDisplayFormatted=${VerbFormated:=True} ;
   local IsAppendMode=${VerbAppendDev:=False} ; 
   if [ "${IsVerboseState:=False}" == "True" ] ; then 
    if [ "${IsDisplayFormatted:=True}" == "True" ] ; then 
     if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" >> ${StrDevOut} ;
     else  
       echo -ne "${StrVerboseHeader}:[ ${StrMsg} ]\n" > ${StrDevOut} ;
     fi
    else
     if [ "${IsEvalRequiredForm:=False}" == "True" ] ; then 
        echo "${StrMsg}" ;  
     else
      if [ "${IsAppendMode:=False}" == "True" ] ; then 
       echo "${StrMsg}" >> ${StrDevOut} ;
      else
       echo "${StrMsg}" > ${StrDevOut} ;
      fi
     fi 
    fi 
   fi
  } 
  ### Model :VerbMsg=MSG VerbHeader=DEBUG VerbEvalForm=False VerbFormated=True VerbState=True VerbDev=/dev/stderr  Verbosis
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local __call_locality=( PRM PackageRepositoryMngmt ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]} ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=PackageRepositoryMngmt CAIsAddParent=False __Call_Argument ) :  
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=PackageRepositoryMngmt CAIsAddParent=False CallArgument ) :  
  fi 	
	#local __call_locality=( PkgRepoMgmt PackageRepositoryMgmt ) ;
 #local ArrayArg=( $* ) ; 
 #local Arg0="${ArrayArg[0]}"  ;

	local StrPathArchives=${PRMPathArchives:=/var/cache/apt/archives} ; 
	local StrFindStringFormat=${PRMStrFmt:="%f "} ;
	local StrPackageType=${PRMFileFormat:=deb} ;
	local StrPathRepository=${PRMRepository:=/media/COMST500GB/Linux-Debian/archives/Mint-14_x86-64} ;
	local StrPathReposIndex=${PRMReposIndex:=/media/COMST500GB/Linux-Debian/archives/Mint-14_x86-64/index} ;
	local StrIndexLatest=${PRMLatestIndexName:=latest} ;
	local StrAddPackageListing=${PRMAddPkgLst:=False} ; 
	local StrPkgLstExt=${PRMPkgExt:=bz2.base64} ;
	local StrAppsLinkerName=${PRMLinkerName:=/bin/ln} ; 
	local StrAppsLinkerOptionRecv=${PRMLinkerOption:=-s} ; 
	local StrAppsLinkerOption=( ${StrAppsLinkerOptionRecv//,/ }  ) ;
	local StrDumpingFormat=${PRMReposIndexFmt:=__ID__:__FILE__} ;
	local StrDefaultActionIndex=${PRMReposIndexAction:="/bin/mkdir -p __PATH__"} ;
	local StrTestDriveDebug=${PRMReposDriveDebug:=False} ;
	local StrIndexTest=${PRMReposIndexTest:=! -d} ;
	local StrScriptAwkFilter=${PRMReposAwkLst:=/etc/init.d/Fnct.D/awk-script/dpkg-col-display.awk} ;

	### Explained in GetOtherDate, GODReference can be negative and report yesterday date too. and not null will
  ### give n-day after today... 	
	local IntDefaultDayIndexName=${PRMReposIndexDay:=0} ;
	local StrBackupAction=${PRMReposBkpAct:=mv __SRC__/__FILE__ __DEST__ __VIRG__ ln -s __DEST__/__FILE__ __SRC__/__FILE__} ;
	
 #local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n${StrCompWordMsgSwitches}\n" ;
 local StrVarList="StrUUID,StrSnapShotUUID,StrPathArchives,StrFindStringFormat,StrPackageType,StrPathRepository,StrPathReposIndex,StrIndexLatest,StrAddPackageListing,StrPkgLstExt,StrAppsLinkerName,StrAppsLinkerOptionRecv,StrAppsLinkerOption,StrDumpingFormat,StrDefaultActionIndex,StrTestDriveDebug,StrIndexTest,StrScriptAwkFilter,IntDefaultDayIndexName,StrBackupAction,StrTransactionStart,StrToDateTransfert,StrIndexFile"


 function CheckDrive()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local __call_locality=( CD CheckDrive ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]} ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=CheckDrive CAIsAddParent=True __Call_Argument ) :  
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=CheckDrive CAIsAddParent=True CallArgument ) :  
  fi     
  #local __call_locality=( CD CheckDrive ) ;
  #local Arg0=${ArrayArg[0]} ;
  #local ArrayArg=( $* ) ;   
		test $( TestDriveMountDebug=${StrTestDriveDebug} TestDriveMountList=${StrPathRepository},${StrPathArchives} TestDriveMount ) && \
		echo -ne "Status of IsMountDrive: ${IsMountDrive}\n" > /dev/stderr ; 
 }
	
 function AddSnapShoot()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local __call_locality=( ASS AddSnapShoot ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]} ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=AddSnapShoot CAIsAddParent=True __Call_Argument ) :  
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=AddSnapShoot CAIsAddParent=True CallArgument ) :  
  fi     
  #local __call_locality=( ASS AddSnapShoot ) ;
  #local Arg0=${ArrayArg[0]} ;
  #local ArrayArg=( $* ) ;   
  echo -ne "File to store next SnapShoot: ${StrIndexFile}\n" > /dev/stderr ; 
		test $( TestDriveMountDebug=${StrTestDriveDebug} TestDriveMountList=${StrPathRepository},${StrPathArchives} TestDriveMount ) && \
  eval $( VTVValueEntry=${StrVarList} \ 
          VTVIsArrayStyleInsert=True  \
          VTVIsValueReAssign=True     \
          VTVIsValueToConvert=False   \
          ValueToVariable             )  GetDpkgListing ;
 }
 
 function __main_StartServices()
 {
  if [ ${versionCA:=0.0.0} == "0.0.0" ] ; then 
   local __call_locality=( Main __main_StartServices ) ;
   local ArrayArg=( $* ) ;
   local Arg0=${ArrayArg[0]} ; 
  elif [ ${versionCA:=0.0.0} == "0.0.1" ] ; then 
   eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True __Call_Argument ) :  
  elif [ ${versionCA:=0.0.0} == "0.0.2" ] ; then 
   eval $( eval CAFunctName=__main_StartServices CAIsAddParent=True CallArgument ) :  
  fi     
  echo -ne "Reserved ID for COMMIT:${StrUUID}\nReserved ID for Listing:${StrSnapShotUUID}\n\n" > /dev/stderr ;
  #local __call_locality=( Main __main_StartServices ${StrParentApps} ) ;
  #local ArrayArg=( $* ) ;
  #local Arg0=${ArrayArg[0]};  
    
  
  $( TestDriveMountDebug=${StrTestDriveDebug} TestDriveMountList=${StrPathRepository},${StrPathArchives} TestDriveMount ) ; 
  if [ "${IsMountDrive:=True}" == "True" ] ; then 
   TestPathIndexName=${StrPathReposIndex}   \
   TestPathIndexTest=${StrIndexTest}        \
   TestPathIndexResultAction=${StrDefaultActionIndex} TestPathIndex ;
   
   local ArrayFileList=( $( GetPackageListPathArchives=${StrPathArchives} GetPackageListFormat=${StrPackageType} GetPackageListStringFormat="${StrFindStringFormat}" GetPackageList ) )
   local ShaSum=$( echo ${ArrayFileList[@]} | sha1sum | cut -d ' ' -f 1 ) ;
     #StrPathReposIndex=${StrPathReposIndex}       \
     #StrIndexFile=${StrIndexFile}                 \
     #StrTransactionStart=${StrTransactionStart}   \
     #StrPkgLstExt=${StrPkgLstExt}                 \
     #GetDpkgInstalledAwkScript=${StrScriptAwkFilter} \
     #StrSnapShotUUID=${StrSnapShotUUID} GetDpkgListing ; 
   eval $( eval \
      BVTIsPreambule=False       \
      BVTBoolCase=True           \
      BVTIsValueToVarAssert=True \
      BVTVTVTPLA="GDLRepositoryPath=\${StrPathReposIndex} GDLFileIndex=\${StrIndexFile} GDLPackageStartID=\${StrTransactionStart} GDLPkgLstExt=\${StrPkgLstExt} GDLSnapShootUUID=\${StrSnapShotUUID} __FNCT_ASRT__ "  \
      BVTVTFnctA=GetDpkgListing  \
      BVTBoolVarName=\${StrAddPackageListing:=False} \
      BVTVTFnctA=GetDpkgListing  \
      BoolVarTest ) ; 
   #if [ ${StrAddPackageListing:=False} == "True" ] ; then 
   #  GDLRepositoryPath=${StrPathReposIndex}          \
   #  GDLFileIndex=${StrIndexFile}                        \
   #  GDLPackageStartID=${StrTransactionStart}   \
   #  GDLPkgLstExt=${StrPkgLstExt}                    \
   #  GDLSnapShootUUID=${StrSnapShotUUID} GetDpkgListing
   #fi
   local IntIsFile=0 ;
   test -e ${StrIndexFile} && IntIsFile=1 ; 
   if [ ${IntIsFile:=0} -eq 1 ] ; then 
    echo -ne "NEW TRANSACTION:${StrTransactionStart}\n" >> ${StrIndexFile} ;  
   else
    echo -ne "NEW FILE\n" > ${StrIndexFile} ; 
    echo -ne "NEW TRANSACTION:${StrTransactionStart}\n" > ${StrIndexFile} ;  
   fi 
   echo -ne "COMMIT TRANSACTION:ID:${StrUUID}:NB_FILE:${#ArrayFileList[@]}:SHA1SUM:${ShaSum}:${StrTransactionStart}\n" >> ${StrIndexFile} ; 
   
   local Result=$? ; 
   if [ ${Result:=1} -eq 0 ] ; then 
    for (( intx=0 ; intx <= ${#ArrayFileList[@]}-1 ; intx++ )) ; do 
     local strfile="${ArrayFileList[${intx}]}" ;
     echo -ne "File: ${strfile}\n" > /dev/stderr ; 
     local StrLinkAction=${StrBackupAction};
     StrLinkAction=${StrLinkAction//__FILE__/${strfile}} ; 
     StrLinkAction=${StrLinkAction//__SRC__/${StrPathArchives}} ; 
     StrLinkAction=${StrLinkAction//__DEST__/${StrPathRepository}} ;
     StrLinkAction=${StrLinkAction//__VIRG__/;} ; 
     local StrDump=${StrDumpingFormat}; 
     StrDump=${StrDump//__ID__/${StrUUID}};
     StrDump=${StrDump//__FILE__/${strfile}};
     echo -ne "${StrDump}\n" >> ${StrIndexFile} ; 
     echo -ne "Action:[ ${StrLinkAction} ]\n" > /dev/stderr ; 
     eval "${StrLinkAction}" ; 
    
    done 
    ### Adding Latest index being stored.
    eval """${StrAppsLinkerName} ${StrAppsLinkerOption[@]} ${StrIndexFile} ${StrPathReposIndex}/${StrIndexLatest} """; 
   else
    echo -ne "ArrayFileList return Empty List\n" > /dev/stderr . 
   fi
  else
   echo -ne "Exit on Path acces Problems\nStatus of IsMountDrive: ${IsMountDrive}\n" > /dev/stderr ;
   return 1 ;
  fi
 
 }
	
 
 
 ### #############################################
	### Main Body 
	### #############################################
	local StrSwitchMessages="${StrSwitchesShow}${StrStartSwitches}\n${StrGetMsgSwitches}\n${StrListMsgSwitches}\n\t--add-snapshoot\tAdd DPKG Listing inside Current Index File.\n\t\t\tOnly Store an ID in the index-file and the content into UUID-name from index path.\n\t--checkdrive\tAllow to check the Linking Destination and to mount it if it's a Device.\n${StrCompWordMsgSwitches}" ;
 local StrNameHelper="PackageRepositoryMngmt\tThe Fnct.D Application for APT/Debian installer repository Linker. ";
 local StrSummary="One of the important action This application posses is to make snapshot after you do install couple of Debian-installer and make a SNAPSHOOT of the current database to you Fnct.D Database. Allowing you to see the daily content 'Snapshooted' with tool line ZenityContentListing and Allow you to revert to you last installation status more easy. Other application are delivered with PackageRepositoryMngmt like the Filter application and Restore application putting back Installer on demand. One important Method to be held with this application is to make you AptOnCD more easy from another point avoiding corrupting the /var/cache location. It also reduce the size of your /var/cache if your setup was designed with splitting your path accross many devices." ;
 local StrSynopsis="This application is a Repository handler and File Database. It allow linking your Debian Installer file from know source (/var/cache/apt/archives) to a backup location or out of your /var/cache location. It come with handy solution to linking the file to your backup location to your installation path and does own severals other mechanism" ;
 local StrDescription="Here important information to manage your Debian Installation-File.\n\nMore to come" ;
  
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GVRIsName=True     \
   GVRIsSynopsis=True \
   GVRIsSummary=True  \
   GVRIsDesc=True     \
   GVRIOldPrefix=False  GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	elif [ "${Arg0:=--startservices}" == "--checkdrive"	] ; then 
  eval $( VTVValueEntry=${StrVarList} \ 
          VTVIsArrayStyleInsert=True  \
          VTVIsValueReAssign=True     \
          VTVIsValueToConvert=False   \
          ValueToVariable             ) CheckDrive ;
	elif [ "${Arg0:=--startservices}" == "--add-snapshoot" ] ; then 
		eval $( VTVValueEntry=${StrVarList} \ 
          VTVIsArrayStyleInsert=True  \
          VTVIsValueReAssign=True     \
          VTVIsValueToConvert=False   \
          ValueToVariable             )  AddSnapShoot ; 
	elif [ "${Arg0:=--startservices}" == "--start-services" ] ; then
   local StrTransactionStart=$( GODFormat="%Y%m%d\ %H:%M:%S" GetOtherDate ) ; 
   local StrToDateTransfert=$( GODReference=${IntDefaultDayIndexName} GetOtherDate ) ; 
	  local StrIndexFile=${StrPathReposIndex}/${StrToDateTransfert} ;
   local ArrayUUID=( $(  GetUSeq=2 GetULoop=True GetUTimeBased=True GetUAppsRegisterName=PackageRepositoryMgmt GetUIDRegister=False GetUIsHelper=False  GetUUID ) ) ; 
   local StrUUID=${ArrayUUID[0]} ; 
   local StrSnapShotUUID=${ArrayUUID[1]} ;
	 eval $( eval VTVValueEntry=${StrVarList} \ 
          VTVIsArrayStyleInsert=True  \
          VTVIsValueReAssign=True     \
          VTVIsValueToConvert=False   \
          ValueToVariable             ) ${StrStartMain} ; 
 fi 
}

######################################################################
### Main Function of PackageRepositoryRest function
###

### End of Main Function of PackageRepositoryRest function
###
######################################################################


### Here the restoring for PackageRepositoryMgmt
### Likely to use PRRIsLink=1 PRRIsResolve=0 PackageRepositoryRest
### PRRIsResolve variable is reserver to search the package following specific time
### inside an index, which is merely not working to restore whole packaging...
### lacking ID on every Package name index, which is not hard to modify.
unset PackageRepositoryRest ; 
function PackageRepositoryRest()
{
	local __call_locality=( PRR PackageRepositoryRest )	 ; 
	local ArrayArg=( $* ) ;
	local IsLink=${PRRIsLink:=0} ; 
	local IsResolve=${PRRIsResolve:=1} ; 
	local IsDebug=${PRRIsDebug:=0} ; 
	local IsDebugResult=${PRRIsDebugResult:=0} ;
	local IsRemoveResolve=${PRRRemoveOldResolved:=1} ;
	local thisdate=${PRRGetDate:=20121108} ;
	local drv=${PRRBackupPath:=/media/COMST500GB/Linux-Debian/archives/Mint-14_x86-64} ; 
	local index=${PRRBackupIndex:=__BackupPath__/index} ;
	local resolve=${PRRResolveFile:=__IndexFile__/resolve-__DATE__} ;
	local IntSleepWarning=${PRRSleepWarning:=10} ; 	
	
	local src=${PRRRepositoryPath:=/var/cache/apt/archives} ; 
	local _TA=( ) ;
	local Arg0=${ArrayArg[0]}	; 

 function __main_StartServices( )
 {
		index=${index//__BackupPath__/${drv}} ;
  local StrResolve
		resolve=${resolve//__DATE__/${thisdate}} ;
		resolve=${resolve//__IndexFile__/${index}} ;
   
		local _index=${index}/${thisdate} ; 
	
		
  if [ ${IsResolve:=0} -eq 1 ] ; then  
			echo -ne "Will resolve package into resolve file store inside index path.\n\tUsefull to get all package-name, package-file and commit level based on PRRGetDate value.\n\tFile resolver:${resolve}\n" > /dev/stderr ; 
		else
			echo -ne	"Will not perform a resolution package into resolve file store inside index path.\n" > /dev/stderr ; 
		fi ### End of test IsResolve-eq-1 
		
  if [ ${IsLink:=0} -eq 1 ] ; then 
			echo -ne "Will link package into Repository destination, based on Variable PRRRepositoryPath,\n\twill link inside path:${src}\n" > /dev/stderr ; 
		else
			echo -ne "Will not performing linking package into Repository destination\n" > /dev/stderr ;		
		fi ### End of test IsLink-eq-1 
		sleep ${IntSleepWarning} ; 

		### erasing old resolved information:
		test ${IsRemoveResolve:=1} == 1 &&	test -e ${resolve} && rm -f ${resolve} ; 

		### List of Deb File
		local _A=( $( find ${drv} -maxdepth 1 -type f -printf "%f " ) ) ;
	
		### Current Line Number and time for all commit from ${thisdate}
		### Format by Index: Line[1-...],Date[YYYYMMDD],Time[HH:MM:SS], 
		local _TI=(  $( cat ${_index} | egrep -n "COMMIT" | sed 's/\ /:/g;s/\\n//g' | cut -d ':' -f 1,4,5,6,7 | sed 's/^\([0-9]*\):\([0-9]*\):/\1,\2,/g' | tr '[:cntrl:]' ' ' ) ) ; 
		local _RA=( ) ; 

		if [ ${IsResolve:=0} -eq 1 ] ; then  
			for (( x=0 ; x<= ${#_A[@]}-1 ; x++ )) ; do 
				local file=${_A[${x}]} ; 
				### Do the resolving .
					local tfile=$( cat ${_index} | egrep -n "${file}" ) ;
					local ifile=( ${tfile//:/ } ) ; 
					ifile=${ifile[0]:=-1} ; 
					### Get The ID from which commit file was part of (... may be none if file was not installed on ${thisday} )
					local IntoldIndex=1 ;		
					local IsIndexed=0 ; 		
					test ${IsDebugResult:=0} == 1 && echo -ne "Resolving File: ${file},\n\tat line ${ifile},from commit " > /dev/stderr ; 
					local PackageName=( ${file//_/ } ) ; 
					for (( y=0 ; y<= ${#_TI[@]}-1 ; y++ )) ; do 
								local _TIA=( ${_TI[${y}]/,/ } ) ; 
								local IntLine=${_TIA[0]} ; 
								if [ ${ifile:=0} -gt 0 ] ; then 
									if [ ${ifile:=0} -gt ${IntoldIndex} ] ; then 
										if [ ${ifile:=0} -lt ${IntLine} ] ; then 
											test ${IsDebugResult:=0} == 1 && echo -ne "${IntLine}\n" > /dev/stderr ; 
											test ${IsDebug:=0} == 1 && echo -ne "File located at index: ${ifile:=0}, from commit: ${IntLine}\n" > /dev/stderr  
											_RA[${#_RA[@]}]="${IntLine},${PackageName[0]},${ifile:=0},${file}" ; 
											IsIndexed=1; 
										else
											IsIndexed=0; 
										fi ### End of test ifile-lt-IntLine
									fi ### End of test ifile-gt-IntoldIndex
								fi ### End of test ifile-gt-0
						IntoldIndex=${IntLine} ; 
					### _TI -> Action Based on Index from commit in file-index from ${thisdate}
					done 
					if [ ${IsIndexed:=0} -eq 0 ] ; then 
						test ${IsDebugResult:=0} == 1 && echo -ne "None\n" > /dev/stderr ;  
						_RA[${#_RA[@]}]="0,${PackageName[0]},${ifile:=0},${file}"
					fi ### End of test IsIndexed-eq-0 
				### _A -> File location and action based on file 
				done 
				echo -ne "Resolved information from index writed in file ${resolve}\n" ;		
				for (( x=0 ; x<= ${#_RA[@]}-1 ; x++ )) ; do 
					echo -ne "${_RA[${x}]//,/ }\n" >> ${resolve} ; 
				### _RA -> Stored informations while looping in _TI and _A to get all resolved file.
				done 
		else
			echo -ne "\n\n\tResolving Procedure was cancelled"
		fi ### End of test IsResolve-eq-1 
		### Do The link.
		if [ ${IsLink:=0} -eq 1 ] ; then 
			for (( x=0 ; x<= ${#_A[@]}-1 ; x++ )) ; do 
				local file=${_A[${x}]} ; 
				test ! -L ${src}/${file} && ln -s ${drv}/${file} ${src}/${file} ; 
			### _A -> File location and action based on file 
			done 
		fi ### End of test IsLink-eq-1 
  
 } # Calling : IntSleepWarning=${IntSleepWarning} index=${index//__BackupPath__/${drv}} _index=${index}/${thisdate} StrResolve=${resolve} src=${src} drv=${drv} IsLink=${IsLink} IsDebug=${IsDebug} IsResolve=${IsResolve} IsRemoveResolve=${IsRemoveResolve} IsDebugResult=${IsDebugResult} __main_StartServices

	local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n" ;
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	elif [ "${Arg0:=--startservices}" == "--startservices" ] ; then 
  IntSleepWarning=${IntSleepWarning}    \
  index=${index//__BackupPath__/${drv}} \
  _index=${index}/${thisdate}           \ 
  StrResolve=${resolve}                 \
  src=${src}                            \
  drv=${drv}                            \
  IsLink=${IsLink}                      \
  IsDebug=${IsDebug}                    \
  IsResolve=${IsResolve}                \
  IsRemoveResolve=${IsRemoveResolve}    \ 
  IsDebugResult=${IsDebugResult}        \
  __main_StartServices
  
	fi ### End of test Arg0==--startservices
}


######################################################################
### Main Function of PackageRepositoryFilter function
###

### End of Main Function of PackageRepositoryFilter function
###
######################################################################


unset PackageRepositoryFilter ; 
function PackageRepositoryFilter()
{
	local __call_locality=( PkgRepoFilter PackageRepositoryFilter ) ;
	local ArrayArg=( $* ) ; 
	local Arg0=${ArrayArg[0]} ;
	local StrPathRepository=${PkgRepoFilterRepository:=/media/COMST500GB/Linux-Debian/archives/Mint-14_x86-64} ;
	local StrPathReposIndex=${PkgRepoFilterReposIndex:=/media/COMST500GB/Linux-Debian/archives/Mint-14_x86-64/index} ;
 local StrPkgLstExt=${PkgRepoFilterPkgExt:=bz2.base64} ;
	local StrDateIndex=${PkgRepoFilterDateIndex:=} ;
 local IntDefaultDayIndexName=${PkgRepoFilterDayRef:=0}
 local StrTodaytDateTransfert=$( GODReference=${IntDefaultDayIndexName} GetOtherDate ) ;
 local StrSnapshootId=${PkgRepoFilterSnapID:=None} ;
 
 local StrSwitchMessages="Following switch are available:\n\n\t--startservices\tStart the application normally.\n\t--get\t\tReturn value of Internal Variable.\n\t--list\t\tList all Internal Pre-fixed Variable available to query or get.\n\n" ;
 local StrPathRef=$( PackageRepositoryMgmt --get $(  PackageRepositoryMgmt --list | cut -d ' ' -f 4 ) ) ; 
 
 function main()
 {
  local PI=() ; 
  declare -a ArrayOutput=( ) ; 
  for (( i=0 ; i<= ${#APL[@]}-1 ; i++ )) ; do 
   local APP=( ${APL[${i}]//;/ } ); 
   local pname="${APP[1]/:amd64/}" ; 
   local lpack=$( find ${PathRef} -type f -iname "${pname}*" -printf "%f\n" | tail -n 1 ) ; 
   echo -ne "Package:\t\t${pname}\nFileName:\t\t${lpack}\n\n" > /dev/stderr ; 
   if [ "${lpack:=NONE}" != "NONE" ] ; then 
    PI[${#PI[@]}]="${PathRef}/${lpack}" ; 
   fi ; 
   for (( i=0 ; i<= ${#PI[@]}-1 ; i++ )) ; do 
    ArrayOutput[${i}]="PI[${i}]" ; 
   done ;
  done ;
 }
  

 
	if [ "${Arg0:=--startservices}" == "--help"	] ; then 
			GVRIsName=False     \
   GVRIsSynopsis=False \
   GVRIsSummary=False  \
   GVRIsDesc=False     \
   GetVarReference ${__call_locality[1]} ; 
			echo -ne "${StrSwitchMessages}" > /dev/stderr ; 
	elif [ "${Arg0:=--startservices}" == "--get" ] ; then 
		eval """local ArgGet=\${${ArrayArg[1]}}""" ; 
		echo -ne """${ArgGet}\n""" ;
	elif [ "${Arg0:=--startservices}" == "--list" ] ; then 
		eval $( __GetVarReferenceList ) ;
	elif [ "${Arg0:=--startservices}" == "--startservices"	] ; then 
  StrPathRef=${StrPathRef} main ; 
 fi
}
